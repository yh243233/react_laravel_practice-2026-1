import CJS_COMPAT_NODE_URL_at6j9ae2j2t from 'node:url';
import CJS_COMPAT_NODE_PATH_at6j9ae2j2t from 'node:path';
import CJS_COMPAT_NODE_MODULE_at6j9ae2j2t from "node:module";

var __filename = CJS_COMPAT_NODE_URL_at6j9ae2j2t.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_at6j9ae2j2t.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_at6j9ae2j2t.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  require_lib,
  require_src
} from "./chunk-HF7KKBBR.js";
import {
  require_picocolors
} from "./chunk-LE232J7F.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-DRM3MJ7Y.js";

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
  "../node_modules/@babel/types/lib/utils/shallowEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = shallowEqual;
    function shallowEqual(actual, expected) {
      let keys = Object.keys(expected);
      for (let key of keys)
        if (actual[key] !== expected[key])
          return !1;
      return !0;
    }
  }
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS({
  "../node_modules/@babel/types/lib/utils/deprecationWarning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = deprecationWarning;
    var warnings = /* @__PURE__ */ new Set();
    function deprecationWarning(oldName, newName, prefix = "", cacheKey = oldName) {
      if (warnings.has(cacheKey)) return;
      warnings.add(cacheKey);
      let {
        internal,
        trace
      } = captureShortStackTrace(1, 2);
      internal || console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
    }
    function captureShortStackTrace(skip, length) {
      let {
        stackTraceLimit,
        prepareStackTrace
      } = Error, stackTrace;
      if (Error.stackTraceLimit = 1 + skip + length, Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
      }, new Error().stack, Error.stackTraceLimit = stackTraceLimit, Error.prepareStackTrace = prepareStackTrace, !stackTrace) return {
        internal: !1,
        trace: ""
      };
      let shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map((frame) => `    at ${frame}`).join(`
`)
      };
    }
  }
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
  "../node_modules/@babel/types/lib/validators/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.isAccessor = isAccessor;
    exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
    exports.isArgumentPlaceholder = isArgumentPlaceholder;
    exports.isArrayExpression = isArrayExpression;
    exports.isArrayPattern = isArrayPattern;
    exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
    exports.isArrowFunctionExpression = isArrowFunctionExpression;
    exports.isAssignmentExpression = isAssignmentExpression;
    exports.isAssignmentPattern = isAssignmentPattern;
    exports.isAwaitExpression = isAwaitExpression;
    exports.isBigIntLiteral = isBigIntLiteral;
    exports.isBinary = isBinary;
    exports.isBinaryExpression = isBinaryExpression;
    exports.isBindExpression = isBindExpression;
    exports.isBlock = isBlock;
    exports.isBlockParent = isBlockParent;
    exports.isBlockStatement = isBlockStatement;
    exports.isBooleanLiteral = isBooleanLiteral;
    exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    exports.isBreakStatement = isBreakStatement;
    exports.isCallExpression = isCallExpression;
    exports.isCatchClause = isCatchClause;
    exports.isClass = isClass;
    exports.isClassAccessorProperty = isClassAccessorProperty;
    exports.isClassBody = isClassBody;
    exports.isClassDeclaration = isClassDeclaration;
    exports.isClassExpression = isClassExpression;
    exports.isClassImplements = isClassImplements;
    exports.isClassMethod = isClassMethod;
    exports.isClassPrivateMethod = isClassPrivateMethod;
    exports.isClassPrivateProperty = isClassPrivateProperty;
    exports.isClassProperty = isClassProperty;
    exports.isCompletionStatement = isCompletionStatement;
    exports.isConditional = isConditional;
    exports.isConditionalExpression = isConditionalExpression;
    exports.isContinueStatement = isContinueStatement;
    exports.isDebuggerStatement = isDebuggerStatement;
    exports.isDecimalLiteral = isDecimalLiteral;
    exports.isDeclaration = isDeclaration;
    exports.isDeclareClass = isDeclareClass;
    exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
    exports.isDeclareFunction = isDeclareFunction;
    exports.isDeclareInterface = isDeclareInterface;
    exports.isDeclareModule = isDeclareModule;
    exports.isDeclareModuleExports = isDeclareModuleExports;
    exports.isDeclareOpaqueType = isDeclareOpaqueType;
    exports.isDeclareTypeAlias = isDeclareTypeAlias;
    exports.isDeclareVariable = isDeclareVariable;
    exports.isDeclaredPredicate = isDeclaredPredicate;
    exports.isDecorator = isDecorator;
    exports.isDirective = isDirective;
    exports.isDirectiveLiteral = isDirectiveLiteral;
    exports.isDoExpression = isDoExpression;
    exports.isDoWhileStatement = isDoWhileStatement;
    exports.isEmptyStatement = isEmptyStatement;
    exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    exports.isEnumBody = isEnumBody;
    exports.isEnumBooleanBody = isEnumBooleanBody;
    exports.isEnumBooleanMember = isEnumBooleanMember;
    exports.isEnumDeclaration = isEnumDeclaration;
    exports.isEnumDefaultedMember = isEnumDefaultedMember;
    exports.isEnumMember = isEnumMember;
    exports.isEnumNumberBody = isEnumNumberBody;
    exports.isEnumNumberMember = isEnumNumberMember;
    exports.isEnumStringBody = isEnumStringBody;
    exports.isEnumStringMember = isEnumStringMember;
    exports.isEnumSymbolBody = isEnumSymbolBody;
    exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
    exports.isExportAllDeclaration = isExportAllDeclaration;
    exports.isExportDeclaration = isExportDeclaration;
    exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
    exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
    exports.isExportNamedDeclaration = isExportNamedDeclaration;
    exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    exports.isExportSpecifier = isExportSpecifier;
    exports.isExpression = isExpression;
    exports.isExpressionStatement = isExpressionStatement;
    exports.isExpressionWrapper = isExpressionWrapper;
    exports.isFile = isFile;
    exports.isFlow = isFlow;
    exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
    exports.isFlowDeclaration = isFlowDeclaration;
    exports.isFlowPredicate = isFlowPredicate;
    exports.isFlowType = isFlowType;
    exports.isFor = isFor;
    exports.isForInStatement = isForInStatement;
    exports.isForOfStatement = isForOfStatement;
    exports.isForStatement = isForStatement;
    exports.isForXStatement = isForXStatement;
    exports.isFunction = isFunction;
    exports.isFunctionDeclaration = isFunctionDeclaration;
    exports.isFunctionExpression = isFunctionExpression;
    exports.isFunctionParameter = isFunctionParameter;
    exports.isFunctionParent = isFunctionParent;
    exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    exports.isFunctionTypeParam = isFunctionTypeParam;
    exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
    exports.isIdentifier = isIdentifier;
    exports.isIfStatement = isIfStatement;
    exports.isImmutable = isImmutable;
    exports.isImport = isImport;
    exports.isImportAttribute = isImportAttribute;
    exports.isImportDeclaration = isImportDeclaration;
    exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
    exports.isImportExpression = isImportExpression;
    exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
    exports.isImportSpecifier = isImportSpecifier;
    exports.isIndexedAccessType = isIndexedAccessType;
    exports.isInferredPredicate = isInferredPredicate;
    exports.isInterfaceDeclaration = isInterfaceDeclaration;
    exports.isInterfaceExtends = isInterfaceExtends;
    exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    exports.isInterpreterDirective = isInterpreterDirective;
    exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    exports.isJSX = isJSX;
    exports.isJSXAttribute = isJSXAttribute;
    exports.isJSXClosingElement = isJSXClosingElement;
    exports.isJSXClosingFragment = isJSXClosingFragment;
    exports.isJSXElement = isJSXElement;
    exports.isJSXEmptyExpression = isJSXEmptyExpression;
    exports.isJSXExpressionContainer = isJSXExpressionContainer;
    exports.isJSXFragment = isJSXFragment;
    exports.isJSXIdentifier = isJSXIdentifier;
    exports.isJSXMemberExpression = isJSXMemberExpression;
    exports.isJSXNamespacedName = isJSXNamespacedName;
    exports.isJSXOpeningElement = isJSXOpeningElement;
    exports.isJSXOpeningFragment = isJSXOpeningFragment;
    exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
    exports.isJSXSpreadChild = isJSXSpreadChild;
    exports.isJSXText = isJSXText;
    exports.isLVal = isLVal;
    exports.isLabeledStatement = isLabeledStatement;
    exports.isLiteral = isLiteral;
    exports.isLogicalExpression = isLogicalExpression;
    exports.isLoop = isLoop;
    exports.isMemberExpression = isMemberExpression;
    exports.isMetaProperty = isMetaProperty;
    exports.isMethod = isMethod;
    exports.isMiscellaneous = isMiscellaneous;
    exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
    exports.isModuleDeclaration = isModuleDeclaration;
    exports.isModuleExpression = isModuleExpression;
    exports.isModuleSpecifier = isModuleSpecifier;
    exports.isNewExpression = isNewExpression;
    exports.isNoop = isNoop;
    exports.isNullLiteral = isNullLiteral;
    exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
    exports.isNumberLiteral = isNumberLiteral;
    exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
    exports.isNumericLiteral = isNumericLiteral;
    exports.isObjectExpression = isObjectExpression;
    exports.isObjectMember = isObjectMember;
    exports.isObjectMethod = isObjectMethod;
    exports.isObjectPattern = isObjectPattern;
    exports.isObjectProperty = isObjectProperty;
    exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
    exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
    exports.isObjectTypeIndexer = isObjectTypeIndexer;
    exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    exports.isObjectTypeProperty = isObjectTypeProperty;
    exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    exports.isOpaqueType = isOpaqueType;
    exports.isOptionalCallExpression = isOptionalCallExpression;
    exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    exports.isOptionalMemberExpression = isOptionalMemberExpression;
    exports.isParenthesizedExpression = isParenthesizedExpression;
    exports.isPattern = isPattern;
    exports.isPatternLike = isPatternLike;
    exports.isPipelineBareFunction = isPipelineBareFunction;
    exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    exports.isPipelineTopicExpression = isPipelineTopicExpression;
    exports.isPlaceholder = isPlaceholder;
    exports.isPrivate = isPrivate;
    exports.isPrivateName = isPrivateName;
    exports.isProgram = isProgram;
    exports.isProperty = isProperty;
    exports.isPureish = isPureish;
    exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    exports.isRecordExpression = isRecordExpression;
    exports.isRegExpLiteral = isRegExpLiteral;
    exports.isRegexLiteral = isRegexLiteral;
    exports.isRestElement = isRestElement;
    exports.isRestProperty = isRestProperty;
    exports.isReturnStatement = isReturnStatement;
    exports.isScopable = isScopable;
    exports.isSequenceExpression = isSequenceExpression;
    exports.isSpreadElement = isSpreadElement;
    exports.isSpreadProperty = isSpreadProperty;
    exports.isStandardized = isStandardized;
    exports.isStatement = isStatement;
    exports.isStaticBlock = isStaticBlock;
    exports.isStringLiteral = isStringLiteral;
    exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    exports.isStringTypeAnnotation = isStringTypeAnnotation;
    exports.isSuper = isSuper;
    exports.isSwitchCase = isSwitchCase;
    exports.isSwitchStatement = isSwitchStatement;
    exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    exports.isTSAnyKeyword = isTSAnyKeyword;
    exports.isTSArrayType = isTSArrayType;
    exports.isTSAsExpression = isTSAsExpression;
    exports.isTSBaseType = isTSBaseType;
    exports.isTSBigIntKeyword = isTSBigIntKeyword;
    exports.isTSBooleanKeyword = isTSBooleanKeyword;
    exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    exports.isTSConditionalType = isTSConditionalType;
    exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    exports.isTSConstructorType = isTSConstructorType;
    exports.isTSDeclareFunction = isTSDeclareFunction;
    exports.isTSDeclareMethod = isTSDeclareMethod;
    exports.isTSEntityName = isTSEntityName;
    exports.isTSEnumBody = isTSEnumBody;
    exports.isTSEnumDeclaration = isTSEnumDeclaration;
    exports.isTSEnumMember = isTSEnumMember;
    exports.isTSExportAssignment = isTSExportAssignment;
    exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    exports.isTSExternalModuleReference = isTSExternalModuleReference;
    exports.isTSFunctionType = isTSFunctionType;
    exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    exports.isTSImportType = isTSImportType;
    exports.isTSIndexSignature = isTSIndexSignature;
    exports.isTSIndexedAccessType = isTSIndexedAccessType;
    exports.isTSInferType = isTSInferType;
    exports.isTSInstantiationExpression = isTSInstantiationExpression;
    exports.isTSInterfaceBody = isTSInterfaceBody;
    exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    exports.isTSIntersectionType = isTSIntersectionType;
    exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    exports.isTSLiteralType = isTSLiteralType;
    exports.isTSMappedType = isTSMappedType;
    exports.isTSMethodSignature = isTSMethodSignature;
    exports.isTSModuleBlock = isTSModuleBlock;
    exports.isTSModuleDeclaration = isTSModuleDeclaration;
    exports.isTSNamedTupleMember = isTSNamedTupleMember;
    exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    exports.isTSNeverKeyword = isTSNeverKeyword;
    exports.isTSNonNullExpression = isTSNonNullExpression;
    exports.isTSNullKeyword = isTSNullKeyword;
    exports.isTSNumberKeyword = isTSNumberKeyword;
    exports.isTSObjectKeyword = isTSObjectKeyword;
    exports.isTSOptionalType = isTSOptionalType;
    exports.isTSParameterProperty = isTSParameterProperty;
    exports.isTSParenthesizedType = isTSParenthesizedType;
    exports.isTSPropertySignature = isTSPropertySignature;
    exports.isTSQualifiedName = isTSQualifiedName;
    exports.isTSRestType = isTSRestType;
    exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
    exports.isTSStringKeyword = isTSStringKeyword;
    exports.isTSSymbolKeyword = isTSSymbolKeyword;
    exports.isTSTemplateLiteralType = isTSTemplateLiteralType;
    exports.isTSThisType = isTSThisType;
    exports.isTSTupleType = isTSTupleType;
    exports.isTSType = isTSType;
    exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    exports.isTSTypeAnnotation = isTSTypeAnnotation;
    exports.isTSTypeAssertion = isTSTypeAssertion;
    exports.isTSTypeElement = isTSTypeElement;
    exports.isTSTypeLiteral = isTSTypeLiteral;
    exports.isTSTypeOperator = isTSTypeOperator;
    exports.isTSTypeParameter = isTSTypeParameter;
    exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    exports.isTSTypePredicate = isTSTypePredicate;
    exports.isTSTypeQuery = isTSTypeQuery;
    exports.isTSTypeReference = isTSTypeReference;
    exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
    exports.isTSUnionType = isTSUnionType;
    exports.isTSUnknownKeyword = isTSUnknownKeyword;
    exports.isTSVoidKeyword = isTSVoidKeyword;
    exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
    exports.isTemplateElement = isTemplateElement;
    exports.isTemplateLiteral = isTemplateLiteral;
    exports.isTerminatorless = isTerminatorless;
    exports.isThisExpression = isThisExpression;
    exports.isThisTypeAnnotation = isThisTypeAnnotation;
    exports.isThrowStatement = isThrowStatement;
    exports.isTopicReference = isTopicReference;
    exports.isTryStatement = isTryStatement;
    exports.isTupleExpression = isTupleExpression;
    exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
    exports.isTypeAlias = isTypeAlias;
    exports.isTypeAnnotation = isTypeAnnotation;
    exports.isTypeCastExpression = isTypeCastExpression;
    exports.isTypeParameter = isTypeParameter;
    exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
    exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
    exports.isTypeScript = isTypeScript;
    exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    exports.isUnaryExpression = isUnaryExpression;
    exports.isUnaryLike = isUnaryLike;
    exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
    exports.isUpdateExpression = isUpdateExpression;
    exports.isUserWhitespacable = isUserWhitespacable;
    exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    exports.isVariableDeclaration = isVariableDeclaration;
    exports.isVariableDeclarator = isVariableDeclarator;
    exports.isVariance = isVariance;
    exports.isVoidPattern = isVoidPattern;
    exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
    exports.isWhile = isWhile;
    exports.isWhileStatement = isWhileStatement;
    exports.isWithStatement = isWithStatement;
    exports.isYieldExpression = isYieldExpression;
    var _shallowEqual = require_shallowEqual(), _deprecationWarning = require_deprecationWarning();
    function isArrayExpression(node, opts) {
      return !node || node.type !== "ArrayExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentExpression(node, opts) {
      return !node || node.type !== "AssignmentExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinaryExpression(node, opts) {
      return !node || node.type !== "BinaryExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterpreterDirective(node, opts) {
      return !node || node.type !== "InterpreterDirective" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirective(node, opts) {
      return !node || node.type !== "Directive" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDirectiveLiteral(node, opts) {
      return !node || node.type !== "DirectiveLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockStatement(node, opts) {
      return !node || node.type !== "BlockStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBreakStatement(node, opts) {
      return !node || node.type !== "BreakStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCallExpression(node, opts) {
      return !node || node.type !== "CallExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCatchClause(node, opts) {
      return !node || node.type !== "CatchClause" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditionalExpression(node, opts) {
      return !node || node.type !== "ConditionalExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isContinueStatement(node, opts) {
      return !node || node.type !== "ContinueStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDebuggerStatement(node, opts) {
      return !node || node.type !== "DebuggerStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoWhileStatement(node, opts) {
      return !node || node.type !== "DoWhileStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyStatement(node, opts) {
      return !node || node.type !== "EmptyStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionStatement(node, opts) {
      return !node || node.type !== "ExpressionStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFile(node, opts) {
      return !node || node.type !== "File" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForInStatement(node, opts) {
      return !node || node.type !== "ForInStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForStatement(node, opts) {
      return !node || node.type !== "ForStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionDeclaration(node, opts) {
      return !node || node.type !== "FunctionDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionExpression(node, opts) {
      return !node || node.type !== "FunctionExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIdentifier(node, opts) {
      return !node || node.type !== "Identifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIfStatement(node, opts) {
      return !node || node.type !== "IfStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLabeledStatement(node, opts) {
      return !node || node.type !== "LabeledStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteral(node, opts) {
      return !node || node.type !== "StringLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumericLiteral(node, opts) {
      return !node || node.type !== "NumericLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteral(node, opts) {
      return !node || node.type !== "NullLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteral(node, opts) {
      return !node || node.type !== "BooleanLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegExpLiteral(node, opts) {
      return !node || node.type !== "RegExpLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLogicalExpression(node, opts) {
      return !node || node.type !== "LogicalExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMemberExpression(node, opts) {
      return !node || node.type !== "MemberExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNewExpression(node, opts) {
      return !node || node.type !== "NewExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProgram(node, opts) {
      return !node || node.type !== "Program" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectExpression(node, opts) {
      return !node || node.type !== "ObjectExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMethod(node, opts) {
      return !node || node.type !== "ObjectMethod" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectProperty(node, opts) {
      return !node || node.type !== "ObjectProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestElement(node, opts) {
      return !node || node.type !== "RestElement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isReturnStatement(node, opts) {
      return !node || node.type !== "ReturnStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSequenceExpression(node, opts) {
      return !node || node.type !== "SequenceExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isParenthesizedExpression(node, opts) {
      return !node || node.type !== "ParenthesizedExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchCase(node, opts) {
      return !node || node.type !== "SwitchCase" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSwitchStatement(node, opts) {
      return !node || node.type !== "SwitchStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisExpression(node, opts) {
      return !node || node.type !== "ThisExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThrowStatement(node, opts) {
      return !node || node.type !== "ThrowStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTryStatement(node, opts) {
      return !node || node.type !== "TryStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryExpression(node, opts) {
      return !node || node.type !== "UnaryExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUpdateExpression(node, opts) {
      return !node || node.type !== "UpdateExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclaration(node, opts) {
      return !node || node.type !== "VariableDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariableDeclarator(node, opts) {
      return !node || node.type !== "VariableDeclarator" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhileStatement(node, opts) {
      return !node || node.type !== "WhileStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWithStatement(node, opts) {
      return !node || node.type !== "WithStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAssignmentPattern(node, opts) {
      return !node || node.type !== "AssignmentPattern" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayPattern(node, opts) {
      return !node || node.type !== "ArrayPattern" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrowFunctionExpression(node, opts) {
      return !node || node.type !== "ArrowFunctionExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassBody(node, opts) {
      return !node || node.type !== "ClassBody" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassExpression(node, opts) {
      return !node || node.type !== "ClassExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassDeclaration(node, opts) {
      return !node || node.type !== "ClassDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportAllDeclaration(node, opts) {
      return !node || node.type !== "ExportAllDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultDeclaration(node, opts) {
      return !node || node.type !== "ExportDefaultDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamedDeclaration(node, opts) {
      return !node || node.type !== "ExportNamedDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportSpecifier(node, opts) {
      return !node || node.type !== "ExportSpecifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForOfStatement(node, opts) {
      return !node || node.type !== "ForOfStatement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDeclaration(node, opts) {
      return !node || node.type !== "ImportDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportDefaultSpecifier(node, opts) {
      return !node || node.type !== "ImportDefaultSpecifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportNamespaceSpecifier(node, opts) {
      return !node || node.type !== "ImportNamespaceSpecifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportSpecifier(node, opts) {
      return !node || node.type !== "ImportSpecifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportExpression(node, opts) {
      return !node || node.type !== "ImportExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMetaProperty(node, opts) {
      return !node || node.type !== "MetaProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassMethod(node, opts) {
      return !node || node.type !== "ClassMethod" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectPattern(node, opts) {
      return !node || node.type !== "ObjectPattern" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadElement(node, opts) {
      return !node || node.type !== "SpreadElement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSuper(node, opts) {
      return !node || node.type !== "Super" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTaggedTemplateExpression(node, opts) {
      return !node || node.type !== "TaggedTemplateExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateElement(node, opts) {
      return !node || node.type !== "TemplateElement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTemplateLiteral(node, opts) {
      return !node || node.type !== "TemplateLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isYieldExpression(node, opts) {
      return !node || node.type !== "YieldExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAwaitExpression(node, opts) {
      return !node || node.type !== "AwaitExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImport(node, opts) {
      return !node || node.type !== "Import" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBigIntLiteral(node, opts) {
      return !node || node.type !== "BigIntLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportNamespaceSpecifier(node, opts) {
      return !node || node.type !== "ExportNamespaceSpecifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalMemberExpression(node, opts) {
      return !node || node.type !== "OptionalMemberExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalCallExpression(node, opts) {
      return !node || node.type !== "OptionalCallExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassProperty(node, opts) {
      return !node || node.type !== "ClassProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassAccessorProperty(node, opts) {
      return !node || node.type !== "ClassAccessorProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateProperty(node, opts) {
      return !node || node.type !== "ClassPrivateProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassPrivateMethod(node, opts) {
      return !node || node.type !== "ClassPrivateMethod" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivateName(node, opts) {
      return !node || node.type !== "PrivateName" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStaticBlock(node, opts) {
      return !node || node.type !== "StaticBlock" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportAttribute(node, opts) {
      return !node || node.type !== "ImportAttribute" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAnyTypeAnnotation(node, opts) {
      return !node || node.type !== "AnyTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArrayTypeAnnotation(node, opts) {
      return !node || node.type !== "ArrayTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanTypeAnnotation(node, opts) {
      return !node || node.type !== "BooleanTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBooleanLiteralTypeAnnotation(node, opts) {
      return !node || node.type !== "BooleanLiteralTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullLiteralTypeAnnotation(node, opts) {
      return !node || node.type !== "NullLiteralTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClassImplements(node, opts) {
      return !node || node.type !== "ClassImplements" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareClass(node, opts) {
      return !node || node.type !== "DeclareClass" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareFunction(node, opts) {
      return !node || node.type !== "DeclareFunction" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareInterface(node, opts) {
      return !node || node.type !== "DeclareInterface" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModule(node, opts) {
      return !node || node.type !== "DeclareModule" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareModuleExports(node, opts) {
      return !node || node.type !== "DeclareModuleExports" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareTypeAlias(node, opts) {
      return !node || node.type !== "DeclareTypeAlias" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareOpaqueType(node, opts) {
      return !node || node.type !== "DeclareOpaqueType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareVariable(node, opts) {
      return !node || node.type !== "DeclareVariable" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportDeclaration(node, opts) {
      return !node || node.type !== "DeclareExportDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclareExportAllDeclaration(node, opts) {
      return !node || node.type !== "DeclareExportAllDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaredPredicate(node, opts) {
      return !node || node.type !== "DeclaredPredicate" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExistsTypeAnnotation(node, opts) {
      return !node || node.type !== "ExistsTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeAnnotation(node, opts) {
      return !node || node.type !== "FunctionTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionTypeParam(node, opts) {
      return !node || node.type !== "FunctionTypeParam" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isGenericTypeAnnotation(node, opts) {
      return !node || node.type !== "GenericTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInferredPredicate(node, opts) {
      return !node || node.type !== "InferredPredicate" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceExtends(node, opts) {
      return !node || node.type !== "InterfaceExtends" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceDeclaration(node, opts) {
      return !node || node.type !== "InterfaceDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isInterfaceTypeAnnotation(node, opts) {
      return !node || node.type !== "InterfaceTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIntersectionTypeAnnotation(node, opts) {
      return !node || node.type !== "IntersectionTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMixedTypeAnnotation(node, opts) {
      return !node || node.type !== "MixedTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEmptyTypeAnnotation(node, opts) {
      return !node || node.type !== "EmptyTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNullableTypeAnnotation(node, opts) {
      return !node || node.type !== "NullableTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteralTypeAnnotation(node, opts) {
      return !node || node.type !== "NumberLiteralTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberTypeAnnotation(node, opts) {
      return !node || node.type !== "NumberTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeAnnotation(node, opts) {
      return !node || node.type !== "ObjectTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeInternalSlot(node, opts) {
      return !node || node.type !== "ObjectTypeInternalSlot" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeCallProperty(node, opts) {
      return !node || node.type !== "ObjectTypeCallProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeIndexer(node, opts) {
      return !node || node.type !== "ObjectTypeIndexer" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeProperty(node, opts) {
      return !node || node.type !== "ObjectTypeProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectTypeSpreadProperty(node, opts) {
      return !node || node.type !== "ObjectTypeSpreadProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOpaqueType(node, opts) {
      return !node || node.type !== "OpaqueType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isQualifiedTypeIdentifier(node, opts) {
      return !node || node.type !== "QualifiedTypeIdentifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringLiteralTypeAnnotation(node, opts) {
      return !node || node.type !== "StringLiteralTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStringTypeAnnotation(node, opts) {
      return !node || node.type !== "StringTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSymbolTypeAnnotation(node, opts) {
      return !node || node.type !== "SymbolTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isThisTypeAnnotation(node, opts) {
      return !node || node.type !== "ThisTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleTypeAnnotation(node, opts) {
      return !node || node.type !== "TupleTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeofTypeAnnotation(node, opts) {
      return !node || node.type !== "TypeofTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAlias(node, opts) {
      return !node || node.type !== "TypeAlias" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeAnnotation(node, opts) {
      return !node || node.type !== "TypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeCastExpression(node, opts) {
      return !node || node.type !== "TypeCastExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameter(node, opts) {
      return !node || node.type !== "TypeParameter" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterDeclaration(node, opts) {
      return !node || node.type !== "TypeParameterDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeParameterInstantiation(node, opts) {
      return !node || node.type !== "TypeParameterInstantiation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnionTypeAnnotation(node, opts) {
      return !node || node.type !== "UnionTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVariance(node, opts) {
      return !node || node.type !== "Variance" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVoidTypeAnnotation(node, opts) {
      return !node || node.type !== "VoidTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDeclaration(node, opts) {
      return !node || node.type !== "EnumDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanBody(node, opts) {
      return !node || node.type !== "EnumBooleanBody" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberBody(node, opts) {
      return !node || node.type !== "EnumNumberBody" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringBody(node, opts) {
      return !node || node.type !== "EnumStringBody" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumSymbolBody(node, opts) {
      return !node || node.type !== "EnumSymbolBody" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBooleanMember(node, opts) {
      return !node || node.type !== "EnumBooleanMember" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumNumberMember(node, opts) {
      return !node || node.type !== "EnumNumberMember" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumStringMember(node, opts) {
      return !node || node.type !== "EnumStringMember" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumDefaultedMember(node, opts) {
      return !node || node.type !== "EnumDefaultedMember" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isIndexedAccessType(node, opts) {
      return !node || node.type !== "IndexedAccessType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isOptionalIndexedAccessType(node, opts) {
      return !node || node.type !== "OptionalIndexedAccessType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXAttribute(node, opts) {
      return !node || node.type !== "JSXAttribute" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingElement(node, opts) {
      return !node || node.type !== "JSXClosingElement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXElement(node, opts) {
      return !node || node.type !== "JSXElement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXEmptyExpression(node, opts) {
      return !node || node.type !== "JSXEmptyExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXExpressionContainer(node, opts) {
      return !node || node.type !== "JSXExpressionContainer" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadChild(node, opts) {
      return !node || node.type !== "JSXSpreadChild" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXIdentifier(node, opts) {
      return !node || node.type !== "JSXIdentifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXMemberExpression(node, opts) {
      return !node || node.type !== "JSXMemberExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXNamespacedName(node, opts) {
      return !node || node.type !== "JSXNamespacedName" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningElement(node, opts) {
      return !node || node.type !== "JSXOpeningElement" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXSpreadAttribute(node, opts) {
      return !node || node.type !== "JSXSpreadAttribute" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXText(node, opts) {
      return !node || node.type !== "JSXText" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXFragment(node, opts) {
      return !node || node.type !== "JSXFragment" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXOpeningFragment(node, opts) {
      return !node || node.type !== "JSXOpeningFragment" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSXClosingFragment(node, opts) {
      return !node || node.type !== "JSXClosingFragment" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNoop(node, opts) {
      return !node || node.type !== "Noop" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPlaceholder(node, opts) {
      return !node || node.type !== "Placeholder" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isV8IntrinsicIdentifier(node, opts) {
      return !node || node.type !== "V8IntrinsicIdentifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isArgumentPlaceholder(node, opts) {
      return !node || node.type !== "ArgumentPlaceholder" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBindExpression(node, opts) {
      return !node || node.type !== "BindExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecorator(node, opts) {
      return !node || node.type !== "Decorator" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDoExpression(node, opts) {
      return !node || node.type !== "DoExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDefaultSpecifier(node, opts) {
      return !node || node.type !== "ExportDefaultSpecifier" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRecordExpression(node, opts) {
      return !node || node.type !== "RecordExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTupleExpression(node, opts) {
      return !node || node.type !== "TupleExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDecimalLiteral(node, opts) {
      return !node || node.type !== "DecimalLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleExpression(node, opts) {
      return !node || node.type !== "ModuleExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTopicReference(node, opts) {
      return !node || node.type !== "TopicReference" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineTopicExpression(node, opts) {
      return !node || node.type !== "PipelineTopicExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelineBareFunction(node, opts) {
      return !node || node.type !== "PipelineBareFunction" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPipelinePrimaryTopicReference(node, opts) {
      return !node || node.type !== "PipelinePrimaryTopicReference" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isVoidPattern(node, opts) {
      return !node || node.type !== "VoidPattern" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParameterProperty(node, opts) {
      return !node || node.type !== "TSParameterProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareFunction(node, opts) {
      return !node || node.type !== "TSDeclareFunction" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSDeclareMethod(node, opts) {
      return !node || node.type !== "TSDeclareMethod" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSQualifiedName(node, opts) {
      return !node || node.type !== "TSQualifiedName" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSCallSignatureDeclaration(node, opts) {
      return !node || node.type !== "TSCallSignatureDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructSignatureDeclaration(node, opts) {
      return !node || node.type !== "TSConstructSignatureDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSPropertySignature(node, opts) {
      return !node || node.type !== "TSPropertySignature" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMethodSignature(node, opts) {
      return !node || node.type !== "TSMethodSignature" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexSignature(node, opts) {
      return !node || node.type !== "TSIndexSignature" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAnyKeyword(node, opts) {
      return !node || node.type !== "TSAnyKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBooleanKeyword(node, opts) {
      return !node || node.type !== "TSBooleanKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBigIntKeyword(node, opts) {
      return !node || node.type !== "TSBigIntKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntrinsicKeyword(node, opts) {
      return !node || node.type !== "TSIntrinsicKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNeverKeyword(node, opts) {
      return !node || node.type !== "TSNeverKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNullKeyword(node, opts) {
      return !node || node.type !== "TSNullKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNumberKeyword(node, opts) {
      return !node || node.type !== "TSNumberKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSObjectKeyword(node, opts) {
      return !node || node.type !== "TSObjectKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSStringKeyword(node, opts) {
      return !node || node.type !== "TSStringKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSymbolKeyword(node, opts) {
      return !node || node.type !== "TSSymbolKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUndefinedKeyword(node, opts) {
      return !node || node.type !== "TSUndefinedKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnknownKeyword(node, opts) {
      return !node || node.type !== "TSUnknownKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSVoidKeyword(node, opts) {
      return !node || node.type !== "TSVoidKeyword" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSThisType(node, opts) {
      return !node || node.type !== "TSThisType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSFunctionType(node, opts) {
      return !node || node.type !== "TSFunctionType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConstructorType(node, opts) {
      return !node || node.type !== "TSConstructorType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeReference(node, opts) {
      return !node || node.type !== "TSTypeReference" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypePredicate(node, opts) {
      return !node || node.type !== "TSTypePredicate" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeQuery(node, opts) {
      return !node || node.type !== "TSTypeQuery" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeLiteral(node, opts) {
      return !node || node.type !== "TSTypeLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSArrayType(node, opts) {
      return !node || node.type !== "TSArrayType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTupleType(node, opts) {
      return !node || node.type !== "TSTupleType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSOptionalType(node, opts) {
      return !node || node.type !== "TSOptionalType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSRestType(node, opts) {
      return !node || node.type !== "TSRestType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamedTupleMember(node, opts) {
      return !node || node.type !== "TSNamedTupleMember" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSUnionType(node, opts) {
      return !node || node.type !== "TSUnionType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIntersectionType(node, opts) {
      return !node || node.type !== "TSIntersectionType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSConditionalType(node, opts) {
      return !node || node.type !== "TSConditionalType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInferType(node, opts) {
      return !node || node.type !== "TSInferType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSParenthesizedType(node, opts) {
      return !node || node.type !== "TSParenthesizedType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeOperator(node, opts) {
      return !node || node.type !== "TSTypeOperator" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSIndexedAccessType(node, opts) {
      return !node || node.type !== "TSIndexedAccessType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSMappedType(node, opts) {
      return !node || node.type !== "TSMappedType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTemplateLiteralType(node, opts) {
      return !node || node.type !== "TSTemplateLiteralType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSLiteralType(node, opts) {
      return !node || node.type !== "TSLiteralType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExpressionWithTypeArguments(node, opts) {
      return !node || node.type !== "TSExpressionWithTypeArguments" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceDeclaration(node, opts) {
      return !node || node.type !== "TSInterfaceDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInterfaceBody(node, opts) {
      return !node || node.type !== "TSInterfaceBody" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAliasDeclaration(node, opts) {
      return !node || node.type !== "TSTypeAliasDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSInstantiationExpression(node, opts) {
      return !node || node.type !== "TSInstantiationExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSAsExpression(node, opts) {
      return !node || node.type !== "TSAsExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSSatisfiesExpression(node, opts) {
      return !node || node.type !== "TSSatisfiesExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAssertion(node, opts) {
      return !node || node.type !== "TSTypeAssertion" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumBody(node, opts) {
      return !node || node.type !== "TSEnumBody" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumDeclaration(node, opts) {
      return !node || node.type !== "TSEnumDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEnumMember(node, opts) {
      return !node || node.type !== "TSEnumMember" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleDeclaration(node, opts) {
      return !node || node.type !== "TSModuleDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSModuleBlock(node, opts) {
      return !node || node.type !== "TSModuleBlock" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportType(node, opts) {
      return !node || node.type !== "TSImportType" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSImportEqualsDeclaration(node, opts) {
      return !node || node.type !== "TSImportEqualsDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExternalModuleReference(node, opts) {
      return !node || node.type !== "TSExternalModuleReference" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNonNullExpression(node, opts) {
      return !node || node.type !== "TSNonNullExpression" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSExportAssignment(node, opts) {
      return !node || node.type !== "TSExportAssignment" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSNamespaceExportDeclaration(node, opts) {
      return !node || node.type !== "TSNamespaceExportDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeAnnotation(node, opts) {
      return !node || node.type !== "TSTypeAnnotation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterInstantiation(node, opts) {
      return !node || node.type !== "TSTypeParameterInstantiation" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameterDeclaration(node, opts) {
      return !node || node.type !== "TSTypeParameterDeclaration" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeParameter(node, opts) {
      return !node || node.type !== "TSTypeParameter" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStandardized(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportExpression":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
        case "ImportAttribute":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Identifier":
            case "StringLiteral":
            case "BlockStatement":
            case "ClassBody":
              break;
            default:
              return !1;
          }
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpression(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ImportExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Expression":
            case "Identifier":
            case "StringLiteral":
              break;
            default:
              return !1;
          }
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBinary(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "BinaryExpression":
        case "LogicalExpression":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isScopable(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlockParent(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isBlock(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node.expectedNode === "BlockStatement") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isStatement(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Statement":
            case "Declaration":
            case "BlockStatement":
              break;
            default:
              return !1;
          }
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTerminatorless(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isCompletionStatement(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isConditional(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ConditionalExpression":
        case "IfStatement":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLoop(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isWhile(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "DoWhileStatement":
        case "WhileStatement":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExpressionWrapper(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFor(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isForXStatement(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ForInStatement":
        case "ForOfStatement":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunction(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionParent(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPureish(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isDeclaration(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
          break;
        case "Placeholder":
          if (node.expectedNode === "Declaration") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFunctionParameter(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "VoidPattern":
          break;
        case "Placeholder":
          if (node.expectedNode === "Identifier") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPatternLike(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "VoidPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return !1;
          }
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLVal(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return !1;
          }
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSEntityName(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "Identifier":
        case "TSQualifiedName":
          break;
        case "Placeholder":
          if (node.expectedNode === "Identifier") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isLiteral(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImmutable(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node.expectedNode === "StringLiteral") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUserWhitespacable(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMethod(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isObjectMember(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isProperty(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isUnaryLike(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPattern(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "VoidPattern":
          break;
        case "Placeholder":
          if (node.expectedNode === "Pattern") break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isClass(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ClassExpression":
        case "ClassDeclaration":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isImportOrExportDeclaration(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isExportDeclaration(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleSpecifier(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isAccessor(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ClassAccessorProperty":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isPrivate(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlow(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowType(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowBaseAnnotation(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowDeclaration(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isFlowPredicate(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumBody(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isEnumMember(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isJSX(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isMiscellaneous(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTypeScript(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumBody":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSTypeElement(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSType(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isTSBaseType(node, opts) {
      if (!node) return !1;
      switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
          break;
        default:
          return !1;
      }
      return opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isNumberLiteral(node, opts) {
      return (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral"), !node || node.type !== "NumberLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRegexLiteral(node, opts) {
      return (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral"), !node || node.type !== "RegexLiteral" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isRestProperty(node, opts) {
      return (0, _deprecationWarning.default)("isRestProperty", "isRestElement"), !node || node.type !== "RestProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isSpreadProperty(node, opts) {
      return (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement"), !node || node.type !== "SpreadProperty" ? !1 : opts == null || (0, _shallowEqual.default)(node, opts);
    }
    function isModuleDeclaration(node, opts) {
      return (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration"), isImportOrExportDeclaration(node, opts);
    }
  }
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
  "../node_modules/@babel/types/lib/validators/matchesPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = matchesPattern;
    var _index = require_generated();
    function isMemberExpressionLike(node) {
      return (0, _index.isMemberExpression)(node) || (0, _index.isMetaProperty)(node);
    }
    function matchesPattern(member, match, allowPartial) {
      if (!isMemberExpressionLike(member)) return !1;
      let parts = Array.isArray(match) ? match : match.split("."), nodes = [], node;
      for (node = member; isMemberExpressionLike(node); node = (_object = node.object) != null ? _object : node.meta) {
        var _object;
        nodes.push(node.property);
      }
      if (nodes.push(node), nodes.length < parts.length || !allowPartial && nodes.length > parts.length) return !1;
      for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        let node2 = nodes[j], value2;
        if ((0, _index.isIdentifier)(node2))
          value2 = node2.name;
        else if ((0, _index.isStringLiteral)(node2))
          value2 = node2.value;
        else if ((0, _index.isThisExpression)(node2))
          value2 = "this";
        else if ((0, _index.isSuper)(node2))
          value2 = "super";
        else if ((0, _index.isPrivateName)(node2))
          value2 = "#" + node2.id.name;
        else
          return !1;
        if (parts[i] !== value2) return !1;
      }
      return !0;
    }
  }
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
  "../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = buildMatchMemberExpression;
    var _matchesPattern = require_matchesPattern();
    function buildMatchMemberExpression(match, allowPartial) {
      let parts = match.split(".");
      return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
    }
  }
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
  "../node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _buildMatchMemberExpression = require_buildMatchMemberExpression(), isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component"), _default = exports.default = isReactComponent;
  }
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
  "../node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
  "../node_modules/@babel/types/lib/validators/isType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isType;
    var _index = require_definitions();
    function isType(nodeType, targetType) {
      if (nodeType === targetType) return !0;
      if (nodeType == null || _index.ALIAS_KEYS[targetType]) return !1;
      let aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
      return !!(aliases != null && aliases.includes(nodeType));
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
  "../node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isPlaceholderType;
    var _index = require_definitions();
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType) return !0;
      let aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
      return !!(aliases != null && aliases.includes(targetType));
    }
  }
});

// ../node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
  "../node_modules/@babel/types/lib/validators/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = is;
    var _shallowEqual = require_shallowEqual(), _isType = require_isType(), _isPlaceholderType = require_isPlaceholderType(), _index = require_definitions();
    function is(type, node, opts) {
      return node ? (0, _isType.default)(node.type, type) ? opts === void 0 ? !0 : (0, _shallowEqual.default)(node, opts) : !opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS ? (0, _isPlaceholderType.default)(node.expectedNode, type) : !1 : !1;
    }
  }
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "../node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierName = isIdentifierName;
    exports.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        if (pos += set[i], pos > code) return !1;
        if (pos += set[i + 1], pos >= code) return !0;
      }
      return !1;
    }
    function isIdentifierStart(code) {
      return code < 65 ? code === 36 : code <= 90 ? !0 : code < 97 ? code === 95 : code <= 122 ? !0 : code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      return code < 48 ? code === 36 : code < 58 ? !0 : code < 65 ? !1 : code <= 90 ? !0 : code < 97 ? code === 95 : code <= 122 ? !0 : code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = !0;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          let trail = name.charCodeAt(++i);
          (trail & 64512) === 56320 && (cp = 65536 + ((cp & 1023) << 10) + (trail & 1023));
        }
        if (isFirst) {
          if (isFirst = !1, !isIdentifierStart(cp))
            return !1;
        } else if (!isIdentifierChar(cp))
          return !1;
      }
      return !isFirst;
    }
  }
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "../node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.isKeyword = isKeyword;
    exports.isReservedWord = isReservedWord;
    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports.isStrictBindReservedWord = isStrictBindReservedWord;
    exports.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    }, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict), reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib2 = __commonJS({
  "../node_modules/@babel/helper-validator-identifier/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: !0,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier(), _keyword = require_keyword();
  }
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
  "../node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isValidIdentifier;
    var _helperValidatorIdentifier = require_lib2();
    function isValidIdentifier(name, reserved = !0) {
      return typeof name != "string" || reserved && ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, !0)) ? !1 : (0, _helperValidatorIdentifier.isIdentifierName)(name);
    }
  }
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var require_lib3 = __commonJS({
  "../node_modules/@babel/helper-string-parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.readCodePoint = readCodePoint;
    exports.readInt = readInt;
    exports.readStringContents = readStringContents;
    var _isDigit = function(code) {
      return code >= 48 && code <= 57;
    }, forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    }, isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      let initialPos = pos, initialLineStart = lineStart, initialCurLine = curLine, out = "", firstInvalidLoc = null, chunkStart = pos, {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine), out += input.slice(chunkStart, pos);
          break;
        }
        let ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          let res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          res.ch === null && !firstInvalidLoc ? firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          } : out += res.ch, {
            pos,
            lineStart,
            curLine
          } = res, chunkStart = pos;
        } else ch === 8232 || ch === 8233 ? (++pos, ++curLine, lineStart = pos) : ch === 10 || ch === 13 ? type === "template" ? (out += input.slice(chunkStart, pos) + `
`, ++pos, ch === 13 && input.charCodeAt(pos) === 10 && ++pos, ++curLine, chunkStart = lineStart = pos) : errors.unterminated(initialPos, initialLineStart, initialCurLine) : ++pos;
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      return type === "template" ? ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123 : ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      let throwOnInvalid = !inTemplate;
      pos++;
      let res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      }), ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res(`
`);
        case 114:
          return res("\r");
        case 120: {
          let code;
          return {
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, !1, throwOnInvalid, errors), res(code === null ? null : String.fromCharCode(code));
        }
        case 117: {
          let code;
          return {
            code,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors), res(code === null ? null : String.fromCodePoint(code));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          input.charCodeAt(pos) === 10 && ++pos;
        case 10:
          lineStart = pos, ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate)
            return res(null);
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        default:
          if (ch >= 48 && ch <= 55) {
            let startPos = pos - 1, octalStr = /^[0-7]+/.exec(input.slice(startPos, pos + 2))[0], octal = parseInt(octalStr, 8);
            octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), pos += octalStr.length - 1;
            let next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate)
                return res(null);
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      let initialPos = pos, n;
      return {
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, !1, errors, !throwOnInvalid), n === null && (throwOnInvalid ? errors.invalidEscapeSequence(initialPos, lineStart, curLine) : pos = initialPos - 1), {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      let start = pos, forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin, invalid = !1, total = 0;
      for (let i = 0, e = len ?? 1 / 0; i < e; ++i) {
        let code = input.charCodeAt(pos), val;
        if (code === 95 && allowNumSeparator !== "bail") {
          let prev = input.charCodeAt(pos - 1), next = input.charCodeAt(pos + 1);
          if (allowNumSeparator) {
            if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
              if (bailOnError) return {
                n: null,
                pos
              };
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
          } else {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code >= 97 ? val = code - 97 + 10 : code >= 65 ? val = code - 65 + 10 : _isDigit(code) ? val = code - 48 : val = 1 / 0, val >= radix) {
          if (val <= 9 && bailOnError)
            return {
              n: null,
              pos
            };
          if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix))
            val = 0;
          else if (forceLen)
            val = 0, invalid = !0;
          else
            break;
        }
        ++pos, total = total * radix + val;
      }
      return pos === start || len != null && pos - start !== len || invalid ? {
        n: null,
        pos
      } : {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      let ch = input.charCodeAt(pos), code;
      if (ch === 123) {
        if (++pos, {
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, !0, throwOnInvalid, errors), ++pos, code !== null && code > 1114111)
          if (throwOnInvalid)
            errors.invalidCodePoint(pos, lineStart, curLine);
          else
            return {
              code: null,
              pos
            };
      } else
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, !1, throwOnInvalid, errors));
      return {
        code,
        pos
      };
    }
  }
});

// ../node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS({
  "../node_modules/@babel/types/lib/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
    var STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = ["body", "expressions"], FOR_INIT_KEYS = exports.FOR_INIT_KEYS = ["left", "init"], COMMENT_KEYS = exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&", "??"], UPDATE_OPERATORS = exports.UPDATE_OPERATORS = ["++", "--"], BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"], BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS], NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], BINARY_OPERATORS = exports.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"], ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")], BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"], NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = ["typeof"], UNARY_OPERATORS = exports.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS], INHERIT_KEYS = exports.INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    exports.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), exports.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  }
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var require_utils = __commonJS({
  "../node_modules/@babel/types/lib/definitions/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.allExpandedTypes = exports.VISITOR_KEYS = exports.NODE_UNION_SHAPES__PRIVATE = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
    exports.arrayOf = arrayOf;
    exports.arrayOfType = arrayOfType;
    exports.assertEach = assertEach;
    exports.assertNodeOrValueType = assertNodeOrValueType;
    exports.assertNodeType = assertNodeType;
    exports.assertOneOf = assertOneOf;
    exports.assertOptionalChainStart = assertOptionalChainStart;
    exports.assertShape = assertShape;
    exports.assertValueType = assertValueType;
    exports.chain = chain;
    exports.default = defineType;
    exports.defineAliasedType = defineAliasedType;
    exports.validate = validate;
    exports.validateArrayOfType = validateArrayOfType;
    exports.validateOptional = validateOptional;
    exports.validateOptionalType = validateOptionalType;
    exports.validateType = validateType;
    var _is = require_is(), _validate = require_validate(), VISITOR_KEYS = exports.VISITOR_KEYS = {}, ALIAS_KEYS = exports.ALIAS_KEYS = {}, FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {}, NODE_FIELDS = exports.NODE_FIELDS = {}, BUILDER_KEYS = exports.BUILDER_KEYS = {}, DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {}, NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {}, NODE_UNION_SHAPES__PRIVATE = exports.NODE_UNION_SHAPES__PRIVATE = {};
    function getType(val) {
      return Array.isArray(val) ? "array" : val === null ? "null" : typeof val;
    }
    function validate(validate2) {
      return {
        validate: validate2
      };
    }
    function validateType(...typeNames) {
      return validate(assertNodeType(...typeNames));
    }
    function validateOptional(validate2) {
      return {
        validate: validate2,
        optional: !0
      };
    }
    function validateOptionalType(...typeNames) {
      return {
        validate: assertNodeType(...typeNames),
        optional: !0
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(...typeNames) {
      return arrayOf(assertNodeType(...typeNames));
    }
    function validateArrayOfType(...typeNames) {
      return validate(arrayOfType(...typeNames));
    }
    function assertEach(callback) {
      let childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {
      };
      function validator(node, key, val) {
        if (!Array.isArray(val)) return;
        let i = 0, subKey = {
          toString() {
            return `${key}[${i}]`;
          }
        };
        for (; i < val.length; i++) {
          let v = val[i];
          callback(node, subKey, v), childValidator(node, subKey, v);
        }
      }
      return validator.each = callback, validator;
    }
    function assertOneOf(...values) {
      function validate2(node, key, val) {
        if (!values.includes(val))
          throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
      }
      return validate2.oneOf = values, validate2;
    }
    var allExpandedTypes = exports.allExpandedTypes = [];
    function assertNodeType(...types2) {
      let expandedTypes = /* @__PURE__ */ new Set();
      allExpandedTypes.push({
        types: types2,
        set: expandedTypes
      });
      function validate2(node, key, val) {
        let valType = val?.type;
        if (valType != null) {
          if (expandedTypes.has(valType)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
          if (valType === "Placeholder") {
            for (let type of types2)
              if ((0, _is.default)(type, val)) {
                (0, _validate.validateChild)(node, key, val);
                return;
              }
          }
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(valType)}`);
      }
      return validate2.oneOfNodeTypes = types2, validate2;
    }
    function assertNodeOrValueType(...types2) {
      function validate2(node, key, val) {
        let primitiveType = getType(val);
        for (let type of types2)
          if (primitiveType === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types2)} but instead got ${JSON.stringify(val?.type)}`);
      }
      return validate2.oneOfNodeOrValueTypes = types2, validate2;
    }
    function assertValueType(type) {
      function validate2(node, key, val) {
        if (getType(val) !== type)
          throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
      }
      return validate2.type = type, validate2;
    }
    function assertShape(shape) {
      let keys = Object.keys(shape);
      function validate2(node, key, val) {
        let errors = [];
        for (let property of keys)
          try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
        if (errors.length)
          throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join(`
`)}`);
      }
      return validate2.shapeOf = shape, validate2;
    }
    function assertOptionalChainStart() {
      function validate2(node) {
        var _current;
        let current = node;
        for (; node; ) {
          let {
            type
          } = current;
          if (type === "OptionalCallExpression") {
            if (current.optional) return;
            current = current.callee;
            continue;
          }
          if (type === "OptionalMemberExpression") {
            if (current.optional) return;
            current = current.object;
            continue;
          }
          break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
      }
      return validate2;
    }
    function chain(...fns) {
      function validate2(...args) {
        for (let fn of fns)
          fn(...args);
      }
      if (validate2.chainOf = fns, fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1]))
        throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
      return validate2;
    }
    var validTypeOpts = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate", "unionShape"]), validFieldKeys = /* @__PURE__ */ new Set(["default", "optional", "deprecated", "validate"]), store = {};
    function defineAliasedType(...aliases) {
      return (type, opts = {}) => {
        let defined = opts.aliases;
        if (!defined) {
          var _store$opts$inherits$;
          opts.inherits && (defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice()), defined ?? (defined = []), opts.aliases = defined;
        }
        let additional = aliases.filter((a) => !defined.includes(a));
        defined.unshift(...additional), defineType(type, opts);
      };
    }
    function defineType(type, opts = {}) {
      let inherits = opts.inherits && store[opts.inherits] || {}, fields = opts.fields;
      if (!fields && (fields = {}, inherits.fields)) {
        let keys = Object.getOwnPropertyNames(inherits.fields);
        for (let key of keys) {
          let field = inherits.fields[key], def = field.default;
          if (Array.isArray(def) ? def.length > 0 : def && typeof def == "object")
            throw new Error("field defaults can only be primitives or empty arrays currently");
          fields[key] = {
            default: Array.isArray(def) ? [] : def,
            optional: field.optional,
            deprecated: field.deprecated,
            validate: field.validate
          };
        }
      }
      let visitor = opts.visitor || inherits.visitor || [], aliases = opts.aliases || inherits.aliases || [], builder = opts.builder || inherits.builder || opts.visitor || [];
      for (let k of Object.keys(opts))
        if (!validTypeOpts.has(k))
          throw new Error(`Unknown type option "${k}" on ${type}`);
      opts.deprecatedAlias && (DEPRECATED_KEYS[opts.deprecatedAlias] = type);
      for (let key of visitor.concat(builder))
        fields[key] = fields[key] || {};
      for (let key of Object.keys(fields)) {
        let field = fields[key];
        field.default !== void 0 && !builder.includes(key) && (field.optional = !0), field.default === void 0 ? field.default = null : !field.validate && field.default != null && (field.validate = assertValueType(getType(field.default)));
        for (let k of Object.keys(field))
          if (!validFieldKeys.has(k))
            throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
      }
      VISITOR_KEYS[type] = opts.visitor = visitor, BUILDER_KEYS[type] = opts.builder = builder, NODE_FIELDS[type] = opts.fields = fields, ALIAS_KEYS[type] = opts.aliases = aliases, aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [], FLIPPED_ALIAS_KEYS[alias].push(type);
      }), opts.validate && (NODE_PARENT_VALIDATIONS[type] = opts.validate), opts.unionShape && (NODE_UNION_SHAPES__PRIVATE[type] = opts.unionShape), store[type] = opts;
    }
  }
});

// ../node_modules/@babel/types/lib/definitions/core.js
var require_core = __commonJS({
  "../node_modules/@babel/types/lib/definitions/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.patternLikeCommon = exports.importAttributes = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyUnionShapeCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
    var _is = require_is(), _isValidIdentifier = require_isValidIdentifier(), _helperValidatorIdentifier = require_lib2(), _helperStringParser = require_lib3(), _index = require_constants(), _utils = require_utils(), classMethodOrPropertyUnionShapeCommon = (allowPrivateName = !1) => ({
      unionShape: {
        discriminator: "computed",
        shapes: [{
          name: "computed",
          value: [!0],
          properties: {
            key: {
              validate: (0, _utils.assertNodeType)("Expression")
            }
          }
        }, {
          name: "nonComputed",
          value: [!1],
          properties: {
            key: {
              validate: allowPrivateName ? (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName") : (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral")
            }
          }
        }]
      }
    });
    exports.classMethodOrPropertyUnionShapeCommon = classMethodOrPropertyUnionShapeCommon;
    var defineType = (0, _utils.defineAliasedType)("Standardized");
    defineType("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
          default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    defineType("AssignmentExpression", {
      fields: {
        operator: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign((function() {
            let identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS), pattern = (0, _utils.assertOneOf)("=");
            return function(node, key, val) {
              ((0, _is.default)("Pattern", node.left) ? pattern : identifier)(node, key, val);
            };
          })(), {
            oneOf: _index.ASSIGNMENT_OPERATORS
          }) : (0, _utils.assertValueType)("string")
        },
        left: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    defineType("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
        },
        left: {
          validate: (function() {
            let expression = (0, _utils.assertNodeType)("Expression"), inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
            return Object.assign(function(node, key, val) {
              (node.operator === "in" ? inOp : expression)(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "PrivateName"]
            });
          })()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    defineType("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    defineType("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _utils.arrayOfType)("Directive"),
          default: []
        },
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    defineType("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: !0
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("CallExpression", {
      visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: !0
        }
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: !0
        }
      })
    });
    defineType("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: !0
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    defineType("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    defineType("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: !0
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("DebuggerStatement", {
      aliases: ["Statement"]
    });
    defineType("DoWhileStatement", {
      builder: ["test", "body"],
      visitor: ["body", "test"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    defineType("EmptyStatement", {
      aliases: ["Statement"]
    });
    defineType("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    defineType("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
          }, {
            each: {
              oneOfNodeTypes: ["CommentBlock", "CommentLine"]
            }
          }),
          optional: !0
        },
        tokens: {
          validate: (0, _utils.assertEach)(Object.assign(() => {
          }, {
            type: "any"
          })),
          optional: !0
        }
      }
    });
    defineType("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
          optional: !0
        },
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: !0
        },
        update: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: !0
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    var functionCommon = () => ({
      params: (0, _utils.validateArrayOfType)("FunctionParameter"),
      generator: {
        default: !1
      },
      async: {
        default: !1
      }
    });
    exports.functionCommon = functionCommon;
    var functionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      }
    });
    exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: !0
      }
    });
    exports.functionDeclarationCommon = functionDeclarationCommon;
    defineType("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
      fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: !0
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: process.env.BABEL_TYPES_8_BREAKING ? (function() {
        let identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          (0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id);
        };
      })() : void 0
    });
    defineType("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: !0
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: !0
        }
      })
    });
    var patternLikeCommon = () => ({
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: !0
      }
    });
    exports.patternLikeCommon = patternLikeCommon;
    defineType("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "FunctionParameter", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon(), {
        name: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            if (!(0, _isValidIdentifier.default)(val, !1))
              throw new TypeError(`"${val}" is not a valid identifier name`);
          }, {
            type: "string"
          })) : (0, _utils.assertValueType)("string")
        }
      }),
      validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key, node) {
        let match = /\.(\w+)$/.exec(key.toString());
        if (!match) return;
        let [, parentKey] = match, nonComp = {
          computed: !1
        };
        if (parentKey === "property") {
          if ((0, _is.default)("MemberExpression", parent, nonComp) || (0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
        } else if (parentKey === "key") {
          if ((0, _is.default)("Property", parent, nonComp) || (0, _is.default)("Method", parent, nonComp)) return;
        } else if (parentKey === "exported") {
          if ((0, _is.default)("ExportSpecifier", parent)) return;
        } else if (parentKey === "imported") {
          if ((0, _is.default)("ImportSpecifier", parent, {
            imported: node
          })) return;
        } else if (parentKey === "meta" && (0, _is.default)("MetaProperty", parent, {
          meta: node
        }))
          return;
        if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, !1)) && node.name !== "this")
          throw new TypeError(`"${node.name}" is not a valid identifier`);
      } : void 0
    });
    defineType("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
          optional: !0,
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node, key, val) {
            if (1 / val < 0 || !Number.isFinite(val)) {
              let error = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${val}) instead.`);
            }
          }, {
            type: "number"
          }))
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)("string")
        },
        flags: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
            let invalid = /[^dgimsuvy]/.exec(val);
            if (invalid)
              throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
          }, {
            type: "string"
          })) : (0, _utils.assertValueType)("string"),
          default: ""
        }
      }
    });
    defineType("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("MemberExpression", {
      builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal", "PatternLike"],
      unionShape: {
        discriminator: "computed",
        shapes: [{
          name: "computed",
          value: [!0],
          properties: {
            property: {
              validate: (0, _utils.assertNodeType)("Expression")
            }
          }
        }, {
          name: "nonComputed",
          value: [!1],
          properties: {
            property: {
              validate: (0, _utils.assertNodeType)("Identifier", "PrivateName")
            }
          }
        }]
      },
      fields: Object.assign({
        object: {
          validate: (0, _utils.assertNodeType)("Expression", "Super")
        },
        property: {
          validate: (function() {
            let normal = (0, _utils.assertNodeType)("Identifier", "PrivateName"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
              (node.computed ? computed : normal)(node, key, val);
            };
            return validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], validator;
          })()
        },
        computed: {
          default: !1
        }
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        }
      })
    });
    defineType("NewExpression", {
      inherits: "CallExpression"
    });
    defineType("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceType: {
          validate: (0, _utils.assertOneOf)("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: !0
        },
        directives: {
          validate: (0, _utils.arrayOfType)("Directive"),
          default: []
        },
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    defineType("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
      }
    });
    defineType("ObjectMethod", Object.assign({
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
    }, classMethodOrPropertyUnionShapeCommon(), {
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
          default: "method"
        }),
        computed: {
          default: !1
        },
        key: {
          validate: (function() {
            let normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
              (node.computed ? computed : normal)(node, key, val);
            };
            return validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], validator;
          })()
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: !0
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    }));
    defineType("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
      unionShape: {
        discriminator: "computed",
        shapes: [{
          name: "computed",
          value: [!0],
          properties: {
            key: {
              validate: (0, _utils.assertNodeType)("Expression")
            }
          }
        }, {
          name: "nonComputed",
          value: [!1],
          properties: {
            key: {
              validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName")
            }
          }
        }]
      },
      fields: {
        computed: {
          default: !1
        },
        key: {
          validate: (function() {
            let normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), computed = (0, _utils.assertNodeType)("Expression");
            return Object.assign(function(node, key, val) {
              (node.computed ? computed : normal)(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
            });
          })()
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, shorthand) {
            if (shorthand) {
              if (node.computed)
                throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
              if (!(0, _is.default)("Identifier", node.key))
                throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }, {
            type: "boolean"
          })) : (0, _utils.assertValueType)("boolean"),
          default: !1
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: !0
        }
      },
      visitor: ["decorators", "key", "value"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: process.env.BABEL_TYPES_8_BREAKING ? (function() {
        let pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
          ((0, _is.default)("ObjectPattern", parent) ? pattern : expression)(node, "value", node.value);
        };
      })() : void 0
    });
    defineType("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["FunctionParameter", "PatternLike", "LVal"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon(), {
        argument: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression", "RestElement", "AssignmentPattern")
        }
      }),
      validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key) {
        let match = /(\w+)\[(\d+)\]/.exec(key.toString());
        if (!match) throw new Error("Internal Babel error: malformed key.");
        let [, listKey, index] = match;
        if (parent[listKey].length > +index + 1)
          throw new TypeError(`RestElement must be last element of ${listKey}`);
      } : void 0
    });
    defineType("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: !0
        }
      }
    });
    defineType("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: (0, _utils.validateArrayOfType)("Expression")
      },
      aliases: ["Expression"]
    });
    defineType("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: !0
        },
        consequent: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: (0, _utils.validateArrayOfType)("SwitchCase")
      }
    });
    defineType("ThisExpression", {
      aliases: ["Expression"]
    });
    defineType("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
            if (!node.handler && !node.finalizer)
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }, {
            oneOfNodeTypes: ["BlockStatement"]
          })) : (0, _utils.assertNodeType)("BlockStatement")
        },
        handler: {
          optional: !0,
          validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
          optional: !0,
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }
    });
    defineType("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: !0
        },
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    defineType("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: !1
        },
        argument: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression") : (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    defineType("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        kind: {
          validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
        },
        declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
      },
      validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
        let withoutInit = (0, _utils.assertNodeType)("Identifier", "Placeholder"), constOrLetOrVar = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "Placeholder"), usingOrAwaitUsing = (0, _utils.assertNodeType)("Identifier", "VoidPattern", "Placeholder");
        return function(parent, key, node) {
          let {
            kind,
            declarations
          } = node, parentIsForX = (0, _is.default)("ForXStatement", parent, {
            left: node
          });
          if (parentIsForX && declarations.length !== 1)
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
          for (let decl of declarations)
            kind === "const" || kind === "let" || kind === "var" ? !parentIsForX && !decl.init ? withoutInit(decl, "id", decl.id) : constOrLetOrVar(decl, "id", decl.id) : usingOrAwaitUsing(decl, "id", decl.id);
        };
      })() : void 0
    });
    defineType("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "VoidPattern") : (0, _utils.assertNodeType)("LVal", "VoidPattern")
        },
        definite: {
          optional: !0,
          validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
          optional: !0,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        left: {
          validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: !0
        }
      })
    });
    defineType("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
        }
      })
    });
    defineType("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
          validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: !0
        }
      })
    });
    defineType("ClassBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
      }
    });
    defineType("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: !0
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: !0
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: !0,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: !0
        },
        implements: {
          validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
          optional: !0
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: !0
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: !0
        }
      }
    });
    defineType("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: !0
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: !0
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: !0,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: !0
        },
        implements: {
          validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
          optional: !0
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: !0
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: !0
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        }
      },
      validate: process.env.BABEL_TYPES_8_BREAKING ? (function() {
        let identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
          (0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id);
        };
      })() : void 0
    });
    var importAttributes = exports.importAttributes = {
      attributes: {
        optional: !0,
        validate: (0, _utils.arrayOfType)("ImportAttribute")
      },
      assertions: {
        deprecated: !0,
        optional: !0,
        validate: (0, _utils.arrayOfType)("ImportAttribute")
      }
    };
    defineType("ExportAllDeclaration", {
      builder: ["source"],
      visitor: ["source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: Object.assign({
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }, importAttributes)
    });
    defineType("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
      }
    });
    defineType("ExportNamedDeclaration", {
      builder: ["declaration", "specifiers", "source"],
      visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: Object.assign({
        declaration: {
          optional: !0,
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
            if (val && node.specifiers.length)
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            if (val && node.source)
              throw new TypeError("Cannot export a declaration from a source");
          }, {
            oneOfNodeTypes: ["Declaration"]
          })) : (0, _utils.assertNodeType)("Declaration")
        }
      }, importAttributes, {
        specifiers: {
          default: [],
          validate: (0, _utils.arrayOf)((function() {
            let sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
            return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function(node, key, val) {
              (node.source ? sourced : sourceless)(node, key, val);
            }, {
              oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
            }) : sourced;
          })())
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral"),
          optional: !0
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      })
    });
    defineType("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: !0
        }
      }
    });
    defineType("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: (function() {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            let declaration = (0, _utils.assertNodeType)("VariableDeclaration"), lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
            return Object.assign(function(node, key, val) {
              (0, _is.default)("VariableDeclaration", val) ? declaration(node, key, val) : lval(node, key, val);
            }, {
              oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
            });
          })()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
          default: !1
        }
      }
    });
    defineType("ImportDeclaration", {
      builder: ["specifiers", "source"],
      visitor: ["specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
      fields: Object.assign({}, importAttributes, {
        module: {
          optional: !0,
          validate: (0, _utils.assertValueType)("boolean")
        },
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: !0
        }
      })
    });
    defineType("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportSpecifier", {
      visitor: ["imported", "local"],
      builder: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: !0
        }
      }
    });
    defineType("ImportExpression", {
      visitor: ["source", "options"],
      aliases: ["Expression"],
      fields: {
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        source: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        options: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: !0
        }
      }
    });
    defineType("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
            let property;
            switch (val.name) {
              case "function":
                property = "sent";
                break;
              case "new":
                property = "target";
                break;
              case "import":
                property = "meta";
                break;
            }
            if (!(0, _is.default)("Identifier", node.property, {
              name: property
            }))
              throw new TypeError("Unrecognised MetaProperty");
          }, {
            oneOfNodeTypes: ["Identifier"]
          })) : (0, _utils.assertNodeType)("Identifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = () => ({
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      static: {
        default: !1
      },
      override: {
        default: !1
      },
      computed: {
        default: !1
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      },
      key: {
        validate: (0, _utils.chain)((function() {
          let normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
        })(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    });
    exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: (0, _utils.validateArrayOfType)("FunctionParameter", "TSParameterProperty"),
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: !0
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: !0
      }
    });
    exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    defineType("ClassMethod", Object.assign({
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
    }, classMethodOrPropertyUnionShapeCommon(), {
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    }));
    defineType("ObjectPattern", {
      visitor: ["decorators", "properties", "typeAnnotation"],
      builder: ["properties"],
      aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
      })
    });
    defineType("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Super", {
      aliases: ["Expression"]
    });
    defineType("TaggedTemplateExpression", {
      visitor: ["tag", "typeParameters", "quasi"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: !0
        }
      }
    });
    defineType("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)("string")
            },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: !0
            }
          }), function(node) {
            let raw = node.value.raw, unterminatedCalled = !1, error = () => {
              throw new Error("Internal @babel/types error.");
            }, {
              str,
              firstInvalidLoc
            } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
              unterminated() {
                unterminatedCalled = !0;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            });
            if (!unterminatedCalled) throw new Error("Invalid raw");
            node.value.cooked = firstInvalidLoc ? null : str;
          })
        },
        tail: {
          default: !1
        }
      }
    });
    defineType("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1)
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
          })
        }
      }
    });
    defineType("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
            if (val && !node.argument)
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }, {
            type: "boolean"
          })) : (0, _utils.assertValueType)("boolean"),
          default: !1
        },
        argument: {
          optional: !0,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Import", {
      aliases: ["Expression"]
    });
    defineType("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: (function() {
            let normal = (0, _utils.assertNodeType)("Identifier"), computed = (0, _utils.assertNodeType)("Expression");
            return Object.assign(function(node, key, val) {
              (node.computed ? computed : normal)(node, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier"]
            });
          })()
        },
        computed: {
          default: !1
        },
        optional: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean")
        }
      }
    });
    defineType("OptionalCallExpression", {
      visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
        optional: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean")
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: !0
        }
      }, {
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: !0
        }
      })
    });
    defineType("ClassProperty", Object.assign({
      visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"]
    }, classMethodOrPropertyUnionShapeCommon(), {
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: !0
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: !0
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: !0
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: !0
        }
      })
    }));
    defineType("ClassAccessorProperty", Object.assign({
      visitor: ["decorators", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property", "Accessor"]
    }, classMethodOrPropertyUnionShapeCommon(!0), {
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
          validate: (0, _utils.chain)((function() {
            let normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
              (node.computed ? computed : normal)(node, key, val);
            };
          })(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: !0
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: !0
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: !0
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: !0
        }
      })
    }));
    defineType("ClassPrivateProperty", {
      visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: !0
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: !0
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: !0
        },
        static: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: !1
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: !0
        }
      }
    });
    defineType("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method"
        },
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "FunctionParent"]
    });
    defineType("ImportAttribute", {
      visitor: ["key", "value"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        }
      }
    });
  }
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS({
  "../node_modules/@babel/types/lib/definitions/flow.js"() {
    "use strict";
    var _core = require_core(), _utils = require_utils(), defineType = (0, _utils.defineAliasedType)("Flow"), defineInterfaceishType = (name) => {
      let isDeclareClass = name === "DeclareClass";
      defineType(name, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign({
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
        }, isDeclareClass ? {
          mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
        } : {}, {
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        })
      });
    };
    defineType("AnyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["FlowType"],
      fields: {
        elementType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("BooleanTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("NullLiteralTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ClassImplements", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType("DeclareFunction", {
      builder: ["id"],
      visitor: ["id", "predicate"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
      }
    });
    defineType("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
      }
    });
    defineType("DeclareVariable", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source", "attributes"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }, _core.importAttributes)
    });
    defineType("DeclareExportAllDeclaration", {
      visitor: ["source", "attributes"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }, _core.importAttributes)
    });
    defineType("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["FlowPredicate"],
      fields: {
        value: (0, _utils.validateType)("Flow")
      }
    });
    defineType("ExistsTypeAnnotation", {
      aliases: ["FlowType"]
    });
    defineType("FunctionTypeAnnotation", {
      builder: ["typeParameters", "params", "rest", "returnType"],
      visitor: ["typeParameters", "this", "params", "rest", "returnType"],
      aliases: ["FlowType"],
      fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["FlowType"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineType("InferredPredicate", {
      aliases: ["FlowPredicate"]
    });
    defineType("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["FlowType"],
      fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
    defineType("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("MixedTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EmptyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowType"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
      }
    });
    defineType("NumberTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
        indexers: {
          validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
          optional: !0,
          default: []
        },
        callProperties: {
          validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
          optional: !0,
          default: []
        },
        internalSlots: {
          validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
          optional: !0,
          default: []
        },
        exact: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: !1
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeInternalSlot", {
      visitor: ["id", "value"],
      builder: ["id", "value", "optional", "static", "method"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["UserWhitespacable"],
      fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeIndexer", {
      visitor: ["variance", "id", "key", "value"],
      builder: ["id", "key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        key: (0, _utils.validateType)("Identifier", "StringLiteral"),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["UserWhitespacable"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("QualifiedTypeIdentifier", {
      visitor: ["qualification", "id"],
      builder: ["id", "qualification"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
      }
    });
    defineType("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
      }
    });
    defineType("StringTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("SymbolTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ThisTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["FlowType"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["ExpressionWrapper", "Expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("TypeParameter", {
      visitor: ["bound", "default", "variance"],
      fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("TypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
      }
    });
    defineType("TypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("Variance", {
      builder: ["kind"],
      fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
      }
    });
    defineType("VoidTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
      }
    });
    defineType("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumBooleanMember", {
      aliases: ["EnumMember"],
      builder: ["id"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
      }
    });
    defineType("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
      }
    });
    defineType("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("IndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OptionalIndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
  }
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS({
  "../node_modules/@babel/types/lib/definitions/jsx.js"() {
    "use strict";
    var _utils = require_utils(), defineType = (0, _utils.defineAliasedType)("JSX");
    defineType("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: !0,
          validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["Immutable", "Expression"],
      fields: Object.assign({
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: !0,
          validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
      }, {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        }
      })
    });
    defineType("JSXEmptyExpression", {});
    defineType("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXMemberExpression", {
      visitor: ["object", "property"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      fields: {
        namespace: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "typeParameters", "typeArguments", "attributes"],
      aliases: ["Immutable"],
      fields: Object.assign({
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: !1
        },
        attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: !0
        }
      }, {
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: !0
        }
      })
    });
    defineType("JSXSpreadAttribute", {
      visitor: ["argument"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXText", {
      aliases: ["Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
          validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
      }
    });
    defineType("JSXOpeningFragment", {
      aliases: ["Immutable"]
    });
    defineType("JSXClosingFragment", {
      aliases: ["Immutable"]
    });
  }
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
  "../node_modules/@babel/types/lib/definitions/placeholders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
    var _utils = require_utils(), PLACEHOLDERS = exports.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };
    for (let type of PLACEHOLDERS) {
      let alias = _utils.ALIAS_KEYS[type];
      alias != null && alias.length && (PLACEHOLDERS_ALIAS[type] = alias);
    }
    var PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
      PLACEHOLDERS_ALIAS[type].forEach((alias) => {
        hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias) || (PLACEHOLDERS_FLIPPED_ALIAS[alias] = []), PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });
  }
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
  "../node_modules/@babel/types/lib/definitions/misc.js"() {
    "use strict";
    var _utils = require_utils(), _placeholders = require_placeholders(), _core = require_core(), defineType = (0, _utils.defineAliasedType)("Miscellaneous");
    defineType("Noop", {
      visitor: []
    });
    defineType("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: Object.assign({
        name: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
          validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
      }, (0, _core.patternLikeCommon)())
    });
    defineType("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
  }
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "../node_modules/@babel/types/lib/definitions/experimental.js"() {
    "use strict";
    var _utils = require_utils();
    (0, _utils.default)("ArgumentPlaceholder", {});
    (0, _utils.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      } : {
        object: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        },
        callee: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        }
      }
    });
    (0, _utils.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("DoExpression", {
      visitor: ["body"],
      builder: ["body", "async"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: !1
        }
      }
    });
    (0, _utils.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
      }
    });
    (0, _utils.default)("TupleExpression", {
      fields: {
        elements: {
          validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    (0, _utils.default)("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _utils.default)("ModuleExpression", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("Program")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("TopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("VoidPattern", {
      aliases: ["Pattern", "PatternLike", "FunctionParameter"]
    });
  }
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS({
  "../node_modules/@babel/types/lib/definitions/typescript.js"() {
    "use strict";
    var _utils = require_utils(), _core = require_core(), _is = require_is(), defineType = (0, _utils.defineAliasedType)("TypeScript"), bool = (0, _utils.assertValueType)("boolean"), tSFunctionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: !0
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: !0
      }
    });
    defineType("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: !0
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        parameter: {
          validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: !0
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSDeclareMethod", Object.assign({
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"]
    }, (0, _core.classMethodOrPropertyUnionShapeCommon)(), {
      fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
    }));
    defineType("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
      }
    });
    var signatureDeclarationCommon = () => ({
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      parameters: (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }), callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon()
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = () => ({
      key: (0, _utils.validateType)("Expression"),
      computed: {
        default: !1
      },
      optional: (0, _utils.validateOptional)(bool)
    });
    defineType("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation"],
      fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        kind: {
          optional: !0,
          validate: (0, _utils.assertOneOf)("get", "set")
        }
      })
    });
    defineType("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
      })
    });
    defineType("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (let type of tsKeywordTypes)
      defineType(type, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    defineType("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"]
    };
    defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon()
    }));
    defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool)
      })
    }));
    defineType("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName", "typeParameters"],
      fields: {
        exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
      }
    });
    defineType("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSNamedTupleMember", {
      visitor: ["label", "elementType"],
      builder: ["label", "elementType", "optional"],
      fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
          validate: bool,
          default: !1
        },
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      builder: ["typeAnnotation", "operator"],
      fields: {
        operator: {
          validate: (0, _utils.assertValueType)("string"),
          default: "keyof"
        },
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "nameType", "typeAnnotation"],
      builder: ["typeParameter", "typeAnnotation", "nameType"],
      fields: Object.assign({}, {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }, {
        readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(!0, !1, "+", "-")),
        optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(!0, !1, "+", "-")),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
      })
    });
    defineType("TSTemplateLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["quasis", "types"],
      fields: {
        quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
        types: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")), function(node, key, val) {
            if (node.quasis.length !== val.length + 1)
              throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of types.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
          })
        }
      }
    });
    defineType("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: {
          validate: (function() {
            let unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral"), unaryOperator = (0, _utils.assertOneOf)("-"), literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral"), validator = function(parent, key, node) {
              (0, _is.default)("UnaryExpression", node) ? (unaryOperator(node, "operator", node.operator), unaryExpression(node, "argument", node.argument)) : literal(parent, key, node);
            };
            return validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], validator;
          })()
        }
      }
    });
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInstantiationExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    var TSTypeExpression = {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    };
    defineType("TSAsExpression", TSTypeExpression);
    defineType("TSSatisfiesExpression", TSTypeExpression);
    defineType("TSTypeAssertion", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSEnumBody", {
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSEnumMember")
      }
    });
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        body: (0, _utils.validateOptionalType)("TSEnumBody")
      }
    });
    defineType("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: Object.assign({
        kind: {
          validate: (0, _utils.assertOneOf)("global", "module", "namespace")
        },
        declare: (0, _utils.validateOptional)(bool)
      }, {
        global: (0, _utils.validateOptional)(bool)
      }, {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
      })
    });
    defineType("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: ["TSType"],
      builder: ["argument", "qualifier", "typeParameters"],
      visitor: ["argument", "options", "qualifier", "typeParameters"],
      fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),
        options: {
          validate: (0, _utils.assertNodeType)("ObjectExpression"),
          optional: !0
        }
      }
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "moduleReference"],
      fields: Object.assign({}, {
        isExport: (0, _utils.validate)(bool)
      }, {
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: !0
        }
      })
    });
    defineType("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validateArrayOfType)("TSType")
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validateArrayOfType)("TSTypeParameter")
      }
    });
    defineType("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        },
        in: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        out: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        const: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        constraint: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: !0
        },
        default: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: !0
        }
      }
    });
  }
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS({
  "../node_modules/@babel/types/lib/definitions/deprecated-aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.DEPRECATED_ALIASES = void 0;
    var DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
  }
});

// ../node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
  "../node_modules/@babel/types/lib/definitions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "BUILDER_KEYS", {
      enumerable: !0,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_ALIASES", {
      enumerable: !0,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_KEYS", {
      enumerable: !0,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "NODE_FIELDS", {
      enumerable: !0,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
      enumerable: !0,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports, "NODE_UNION_SHAPES__PRIVATE", {
      enumerable: !0,
      get: function() {
        return _utils.NODE_UNION_SHAPES__PRIVATE;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS", {
      enumerable: !0,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
      enumerable: !0,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: !0,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports.TYPES = void 0;
    Object.defineProperty(exports, "VISITOR_KEYS", {
      enumerable: !0,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    require_core();
    require_flow();
    require_jsx();
    require_misc();
    require_experimental();
    require_typescript();
    var _utils = require_utils(), _placeholders = require_placeholders(), _deprecatedAliases = require_deprecated_aliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    for (let {
      types: types2,
      set
    } of _utils.allExpandedTypes)
      for (let type of types2) {
        let aliases = _utils.FLIPPED_ALIAS_KEYS[type];
        aliases ? aliases.forEach(set.add, set) : set.add(type);
      }
    var TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
  }
});

// ../node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS({
  "../node_modules/@babel/types/lib/validators/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = validate;
    exports.validateChild = validateChild;
    exports.validateField = validateField;
    exports.validateInternal = validateInternal;
    var _index = require_definitions();
    function validate(node, key, val) {
      if (!node) return;
      let fields = _index.NODE_FIELDS[node.type];
      if (!fields) return;
      let field = fields[key];
      validateField(node, key, val, field), validateChild(node, key, val);
    }
    function validateInternal(field, node, key, val, maybeNode) {
      if (field != null && field.validate && !(field.optional && val == null) && (field.validate(node, key, val), maybeNode)) {
        var _NODE_PARENT_VALIDATI;
        let type = val.type;
        if (type == null) return;
        (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
      }
    }
    function validateField(node, key, val, field) {
      field != null && field.validate && (field.optional && val == null || field.validate(node, key, val));
    }
    function validateChild(node, key, val) {
      var _NODE_PARENT_VALIDATI2;
      let type = val?.type;
      type != null && ((_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key, val));
    }
  }
});

// ../node_modules/@babel/types/lib/builders/generated/lowercase.js
var require_lowercase = __commonJS({
  "../node_modules/@babel/types/lib/builders/generated/lowercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.anyTypeAnnotation = anyTypeAnnotation;
    exports.argumentPlaceholder = argumentPlaceholder;
    exports.arrayExpression = arrayExpression;
    exports.arrayPattern = arrayPattern;
    exports.arrayTypeAnnotation = arrayTypeAnnotation;
    exports.arrowFunctionExpression = arrowFunctionExpression;
    exports.assignmentExpression = assignmentExpression;
    exports.assignmentPattern = assignmentPattern;
    exports.awaitExpression = awaitExpression;
    exports.bigIntLiteral = bigIntLiteral;
    exports.binaryExpression = binaryExpression;
    exports.bindExpression = bindExpression;
    exports.blockStatement = blockStatement;
    exports.booleanLiteral = booleanLiteral;
    exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports.booleanTypeAnnotation = booleanTypeAnnotation;
    exports.breakStatement = breakStatement;
    exports.callExpression = callExpression;
    exports.catchClause = catchClause;
    exports.classAccessorProperty = classAccessorProperty;
    exports.classBody = classBody;
    exports.classDeclaration = classDeclaration;
    exports.classExpression = classExpression;
    exports.classImplements = classImplements;
    exports.classMethod = classMethod;
    exports.classPrivateMethod = classPrivateMethod;
    exports.classPrivateProperty = classPrivateProperty;
    exports.classProperty = classProperty;
    exports.conditionalExpression = conditionalExpression;
    exports.continueStatement = continueStatement;
    exports.debuggerStatement = debuggerStatement;
    exports.decimalLiteral = decimalLiteral;
    exports.declareClass = declareClass;
    exports.declareExportAllDeclaration = declareExportAllDeclaration;
    exports.declareExportDeclaration = declareExportDeclaration;
    exports.declareFunction = declareFunction;
    exports.declareInterface = declareInterface;
    exports.declareModule = declareModule;
    exports.declareModuleExports = declareModuleExports;
    exports.declareOpaqueType = declareOpaqueType;
    exports.declareTypeAlias = declareTypeAlias;
    exports.declareVariable = declareVariable;
    exports.declaredPredicate = declaredPredicate;
    exports.decorator = decorator;
    exports.directive = directive;
    exports.directiveLiteral = directiveLiteral;
    exports.doExpression = doExpression;
    exports.doWhileStatement = doWhileStatement;
    exports.emptyStatement = emptyStatement;
    exports.emptyTypeAnnotation = emptyTypeAnnotation;
    exports.enumBooleanBody = enumBooleanBody;
    exports.enumBooleanMember = enumBooleanMember;
    exports.enumDeclaration = enumDeclaration;
    exports.enumDefaultedMember = enumDefaultedMember;
    exports.enumNumberBody = enumNumberBody;
    exports.enumNumberMember = enumNumberMember;
    exports.enumStringBody = enumStringBody;
    exports.enumStringMember = enumStringMember;
    exports.enumSymbolBody = enumSymbolBody;
    exports.existsTypeAnnotation = existsTypeAnnotation;
    exports.exportAllDeclaration = exportAllDeclaration;
    exports.exportDefaultDeclaration = exportDefaultDeclaration;
    exports.exportDefaultSpecifier = exportDefaultSpecifier;
    exports.exportNamedDeclaration = exportNamedDeclaration;
    exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports.exportSpecifier = exportSpecifier;
    exports.expressionStatement = expressionStatement;
    exports.file = file;
    exports.forInStatement = forInStatement;
    exports.forOfStatement = forOfStatement;
    exports.forStatement = forStatement;
    exports.functionDeclaration = functionDeclaration;
    exports.functionExpression = functionExpression;
    exports.functionTypeAnnotation = functionTypeAnnotation;
    exports.functionTypeParam = functionTypeParam;
    exports.genericTypeAnnotation = genericTypeAnnotation;
    exports.identifier = identifier;
    exports.ifStatement = ifStatement;
    exports.import = _import;
    exports.importAttribute = importAttribute;
    exports.importDeclaration = importDeclaration;
    exports.importDefaultSpecifier = importDefaultSpecifier;
    exports.importExpression = importExpression;
    exports.importNamespaceSpecifier = importNamespaceSpecifier;
    exports.importSpecifier = importSpecifier;
    exports.indexedAccessType = indexedAccessType;
    exports.inferredPredicate = inferredPredicate;
    exports.interfaceDeclaration = interfaceDeclaration;
    exports.interfaceExtends = interfaceExtends;
    exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports.interpreterDirective = interpreterDirective;
    exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
    exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
    exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
    exports.jSXElement = exports.jsxElement = jsxElement;
    exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
    exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
    exports.jSXFragment = exports.jsxFragment = jsxFragment;
    exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
    exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
    exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
    exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
    exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
    exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
    exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
    exports.jSXText = exports.jsxText = jsxText;
    exports.labeledStatement = labeledStatement;
    exports.logicalExpression = logicalExpression;
    exports.memberExpression = memberExpression;
    exports.metaProperty = metaProperty;
    exports.mixedTypeAnnotation = mixedTypeAnnotation;
    exports.moduleExpression = moduleExpression;
    exports.newExpression = newExpression;
    exports.noop = noop;
    exports.nullLiteral = nullLiteral;
    exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports.nullableTypeAnnotation = nullableTypeAnnotation;
    exports.numberLiteral = NumberLiteral;
    exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports.numberTypeAnnotation = numberTypeAnnotation;
    exports.numericLiteral = numericLiteral;
    exports.objectExpression = objectExpression;
    exports.objectMethod = objectMethod;
    exports.objectPattern = objectPattern;
    exports.objectProperty = objectProperty;
    exports.objectTypeAnnotation = objectTypeAnnotation;
    exports.objectTypeCallProperty = objectTypeCallProperty;
    exports.objectTypeIndexer = objectTypeIndexer;
    exports.objectTypeInternalSlot = objectTypeInternalSlot;
    exports.objectTypeProperty = objectTypeProperty;
    exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports.opaqueType = opaqueType;
    exports.optionalCallExpression = optionalCallExpression;
    exports.optionalIndexedAccessType = optionalIndexedAccessType;
    exports.optionalMemberExpression = optionalMemberExpression;
    exports.parenthesizedExpression = parenthesizedExpression;
    exports.pipelineBareFunction = pipelineBareFunction;
    exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports.pipelineTopicExpression = pipelineTopicExpression;
    exports.placeholder = placeholder;
    exports.privateName = privateName;
    exports.program = program;
    exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports.recordExpression = recordExpression;
    exports.regExpLiteral = regExpLiteral;
    exports.regexLiteral = RegexLiteral;
    exports.restElement = restElement;
    exports.restProperty = RestProperty;
    exports.returnStatement = returnStatement;
    exports.sequenceExpression = sequenceExpression;
    exports.spreadElement = spreadElement;
    exports.spreadProperty = SpreadProperty;
    exports.staticBlock = staticBlock;
    exports.stringLiteral = stringLiteral;
    exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports.stringTypeAnnotation = stringTypeAnnotation;
    exports.super = _super;
    exports.switchCase = switchCase;
    exports.switchStatement = switchStatement;
    exports.symbolTypeAnnotation = symbolTypeAnnotation;
    exports.taggedTemplateExpression = taggedTemplateExpression;
    exports.templateElement = templateElement;
    exports.templateLiteral = templateLiteral;
    exports.thisExpression = thisExpression;
    exports.thisTypeAnnotation = thisTypeAnnotation;
    exports.throwStatement = throwStatement;
    exports.topicReference = topicReference;
    exports.tryStatement = tryStatement;
    exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
    exports.tSArrayType = exports.tsArrayType = tsArrayType;
    exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
    exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
    exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
    exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
    exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
    exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
    exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
    exports.tSEnumBody = exports.tsEnumBody = tsEnumBody;
    exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
    exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
    exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
    exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
    exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
    exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports.tSImportType = exports.tsImportType = tsImportType;
    exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
    exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
    exports.tSInferType = exports.tsInferType = tsInferType;
    exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
    exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
    exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
    exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
    exports.tSMappedType = exports.tsMappedType = tsMappedType;
    exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
    exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
    exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
    exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
    exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
    exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
    exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
    exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
    exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
    exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
    exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
    exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
    exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
    exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
    exports.tSRestType = exports.tsRestType = tsRestType;
    exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
    exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
    exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
    exports.tSTemplateLiteralType = exports.tsTemplateLiteralType = tsTemplateLiteralType;
    exports.tSThisType = exports.tsThisType = tsThisType;
    exports.tSTupleType = exports.tsTupleType = tsTupleType;
    exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
    exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
    exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
    exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
    exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
    exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
    exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
    exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
    exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
    exports.tSUnionType = exports.tsUnionType = tsUnionType;
    exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
    exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
    exports.tupleExpression = tupleExpression;
    exports.tupleTypeAnnotation = tupleTypeAnnotation;
    exports.typeAlias = typeAlias;
    exports.typeAnnotation = typeAnnotation;
    exports.typeCastExpression = typeCastExpression;
    exports.typeParameter = typeParameter;
    exports.typeParameterDeclaration = typeParameterDeclaration;
    exports.typeParameterInstantiation = typeParameterInstantiation;
    exports.typeofTypeAnnotation = typeofTypeAnnotation;
    exports.unaryExpression = unaryExpression;
    exports.unionTypeAnnotation = unionTypeAnnotation;
    exports.updateExpression = updateExpression;
    exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports.variableDeclaration = variableDeclaration;
    exports.variableDeclarator = variableDeclarator;
    exports.variance = variance;
    exports.voidPattern = voidPattern;
    exports.voidTypeAnnotation = voidTypeAnnotation;
    exports.whileStatement = whileStatement;
    exports.withStatement = withStatement;
    exports.yieldExpression = yieldExpression;
    var _validate = require_validate(), _deprecationWarning = require_deprecationWarning(), utils = require_utils(), {
      validateInternal: validate
    } = _validate, {
      NODE_FIELDS
    } = utils;
    function bigIntLiteral(value2) {
      typeof value2 == "bigint" && (value2 = value2.toString());
      let node = {
        type: "BigIntLiteral",
        value: value2
      }, defs = NODE_FIELDS.BigIntLiteral;
      return validate(defs.value, node, "value", value2), node;
    }
    function arrayExpression(elements = []) {
      let node = {
        type: "ArrayExpression",
        elements
      }, defs = NODE_FIELDS.ArrayExpression;
      return validate(defs.elements, node, "elements", elements, 1), node;
    }
    function assignmentExpression(operator, left, right) {
      let node = {
        type: "AssignmentExpression",
        operator,
        left,
        right
      }, defs = NODE_FIELDS.AssignmentExpression;
      return validate(defs.operator, node, "operator", operator), validate(defs.left, node, "left", left, 1), validate(defs.right, node, "right", right, 1), node;
    }
    function binaryExpression(operator, left, right) {
      let node = {
        type: "BinaryExpression",
        operator,
        left,
        right
      }, defs = NODE_FIELDS.BinaryExpression;
      return validate(defs.operator, node, "operator", operator), validate(defs.left, node, "left", left, 1), validate(defs.right, node, "right", right, 1), node;
    }
    function interpreterDirective(value2) {
      let node = {
        type: "InterpreterDirective",
        value: value2
      }, defs = NODE_FIELDS.InterpreterDirective;
      return validate(defs.value, node, "value", value2), node;
    }
    function directive(value2) {
      let node = {
        type: "Directive",
        value: value2
      }, defs = NODE_FIELDS.Directive;
      return validate(defs.value, node, "value", value2, 1), node;
    }
    function directiveLiteral(value2) {
      let node = {
        type: "DirectiveLiteral",
        value: value2
      }, defs = NODE_FIELDS.DirectiveLiteral;
      return validate(defs.value, node, "value", value2), node;
    }
    function blockStatement(body, directives = []) {
      let node = {
        type: "BlockStatement",
        body,
        directives
      }, defs = NODE_FIELDS.BlockStatement;
      return validate(defs.body, node, "body", body, 1), validate(defs.directives, node, "directives", directives, 1), node;
    }
    function breakStatement(label = null) {
      let node = {
        type: "BreakStatement",
        label
      }, defs = NODE_FIELDS.BreakStatement;
      return validate(defs.label, node, "label", label, 1), node;
    }
    function callExpression(callee, _arguments) {
      let node = {
        type: "CallExpression",
        callee,
        arguments: _arguments
      }, defs = NODE_FIELDS.CallExpression;
      return validate(defs.callee, node, "callee", callee, 1), validate(defs.arguments, node, "arguments", _arguments, 1), node;
    }
    function catchClause(param = null, body) {
      let node = {
        type: "CatchClause",
        param,
        body
      }, defs = NODE_FIELDS.CatchClause;
      return validate(defs.param, node, "param", param, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function conditionalExpression(test, consequent, alternate) {
      let node = {
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      }, defs = NODE_FIELDS.ConditionalExpression;
      return validate(defs.test, node, "test", test, 1), validate(defs.consequent, node, "consequent", consequent, 1), validate(defs.alternate, node, "alternate", alternate, 1), node;
    }
    function continueStatement(label = null) {
      let node = {
        type: "ContinueStatement",
        label
      }, defs = NODE_FIELDS.ContinueStatement;
      return validate(defs.label, node, "label", label, 1), node;
    }
    function debuggerStatement() {
      return {
        type: "DebuggerStatement"
      };
    }
    function doWhileStatement(test, body) {
      let node = {
        type: "DoWhileStatement",
        test,
        body
      }, defs = NODE_FIELDS.DoWhileStatement;
      return validate(defs.test, node, "test", test, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function emptyStatement() {
      return {
        type: "EmptyStatement"
      };
    }
    function expressionStatement(expression) {
      let node = {
        type: "ExpressionStatement",
        expression
      }, defs = NODE_FIELDS.ExpressionStatement;
      return validate(defs.expression, node, "expression", expression, 1), node;
    }
    function file(program2, comments = null, tokens = null) {
      let node = {
        type: "File",
        program: program2,
        comments,
        tokens
      }, defs = NODE_FIELDS.File;
      return validate(defs.program, node, "program", program2, 1), validate(defs.comments, node, "comments", comments, 1), validate(defs.tokens, node, "tokens", tokens), node;
    }
    function forInStatement(left, right, body) {
      let node = {
        type: "ForInStatement",
        left,
        right,
        body
      }, defs = NODE_FIELDS.ForInStatement;
      return validate(defs.left, node, "left", left, 1), validate(defs.right, node, "right", right, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function forStatement(init = null, test = null, update = null, body) {
      let node = {
        type: "ForStatement",
        init,
        test,
        update,
        body
      }, defs = NODE_FIELDS.ForStatement;
      return validate(defs.init, node, "init", init, 1), validate(defs.test, node, "test", test, 1), validate(defs.update, node, "update", update, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function functionDeclaration(id = null, params, body, generator = !1, async = !1) {
      let node = {
        type: "FunctionDeclaration",
        id,
        params,
        body,
        generator,
        async
      }, defs = NODE_FIELDS.FunctionDeclaration;
      return validate(defs.id, node, "id", id, 1), validate(defs.params, node, "params", params, 1), validate(defs.body, node, "body", body, 1), validate(defs.generator, node, "generator", generator), validate(defs.async, node, "async", async), node;
    }
    function functionExpression(id = null, params, body, generator = !1, async = !1) {
      let node = {
        type: "FunctionExpression",
        id,
        params,
        body,
        generator,
        async
      }, defs = NODE_FIELDS.FunctionExpression;
      return validate(defs.id, node, "id", id, 1), validate(defs.params, node, "params", params, 1), validate(defs.body, node, "body", body, 1), validate(defs.generator, node, "generator", generator), validate(defs.async, node, "async", async), node;
    }
    function identifier(name) {
      let node = {
        type: "Identifier",
        name
      }, defs = NODE_FIELDS.Identifier;
      return validate(defs.name, node, "name", name), node;
    }
    function ifStatement(test, consequent, alternate = null) {
      let node = {
        type: "IfStatement",
        test,
        consequent,
        alternate
      }, defs = NODE_FIELDS.IfStatement;
      return validate(defs.test, node, "test", test, 1), validate(defs.consequent, node, "consequent", consequent, 1), validate(defs.alternate, node, "alternate", alternate, 1), node;
    }
    function labeledStatement(label, body) {
      let node = {
        type: "LabeledStatement",
        label,
        body
      }, defs = NODE_FIELDS.LabeledStatement;
      return validate(defs.label, node, "label", label, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function stringLiteral(value2) {
      let node = {
        type: "StringLiteral",
        value: value2
      }, defs = NODE_FIELDS.StringLiteral;
      return validate(defs.value, node, "value", value2), node;
    }
    function numericLiteral(value2) {
      let node = {
        type: "NumericLiteral",
        value: value2
      }, defs = NODE_FIELDS.NumericLiteral;
      return validate(defs.value, node, "value", value2), node;
    }
    function nullLiteral() {
      return {
        type: "NullLiteral"
      };
    }
    function booleanLiteral(value2) {
      let node = {
        type: "BooleanLiteral",
        value: value2
      }, defs = NODE_FIELDS.BooleanLiteral;
      return validate(defs.value, node, "value", value2), node;
    }
    function regExpLiteral(pattern, flags = "") {
      let node = {
        type: "RegExpLiteral",
        pattern,
        flags
      }, defs = NODE_FIELDS.RegExpLiteral;
      return validate(defs.pattern, node, "pattern", pattern), validate(defs.flags, node, "flags", flags), node;
    }
    function logicalExpression(operator, left, right) {
      let node = {
        type: "LogicalExpression",
        operator,
        left,
        right
      }, defs = NODE_FIELDS.LogicalExpression;
      return validate(defs.operator, node, "operator", operator), validate(defs.left, node, "left", left, 1), validate(defs.right, node, "right", right, 1), node;
    }
    function memberExpression(object, property, computed = !1, optional = null) {
      let node = {
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
      }, defs = NODE_FIELDS.MemberExpression;
      return validate(defs.object, node, "object", object, 1), validate(defs.property, node, "property", property, 1), validate(defs.computed, node, "computed", computed), validate(defs.optional, node, "optional", optional), node;
    }
    function newExpression(callee, _arguments) {
      let node = {
        type: "NewExpression",
        callee,
        arguments: _arguments
      }, defs = NODE_FIELDS.NewExpression;
      return validate(defs.callee, node, "callee", callee, 1), validate(defs.arguments, node, "arguments", _arguments, 1), node;
    }
    function program(body, directives = [], sourceType = "script", interpreter = null) {
      let node = {
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter
      }, defs = NODE_FIELDS.Program;
      return validate(defs.body, node, "body", body, 1), validate(defs.directives, node, "directives", directives, 1), validate(defs.sourceType, node, "sourceType", sourceType), validate(defs.interpreter, node, "interpreter", interpreter, 1), node;
    }
    function objectExpression(properties) {
      let node = {
        type: "ObjectExpression",
        properties
      }, defs = NODE_FIELDS.ObjectExpression;
      return validate(defs.properties, node, "properties", properties, 1), node;
    }
    function objectMethod(kind = "method", key, params, body, computed = !1, generator = !1, async = !1) {
      let node = {
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async
      }, defs = NODE_FIELDS.ObjectMethod;
      return validate(defs.kind, node, "kind", kind), validate(defs.key, node, "key", key, 1), validate(defs.params, node, "params", params, 1), validate(defs.body, node, "body", body, 1), validate(defs.computed, node, "computed", computed), validate(defs.generator, node, "generator", generator), validate(defs.async, node, "async", async), node;
    }
    function objectProperty(key, value2, computed = !1, shorthand = !1, decorators = null) {
      let node = {
        type: "ObjectProperty",
        key,
        value: value2,
        computed,
        shorthand,
        decorators
      }, defs = NODE_FIELDS.ObjectProperty;
      return validate(defs.key, node, "key", key, 1), validate(defs.value, node, "value", value2, 1), validate(defs.computed, node, "computed", computed), validate(defs.shorthand, node, "shorthand", shorthand), validate(defs.decorators, node, "decorators", decorators, 1), node;
    }
    function restElement(argument) {
      let node = {
        type: "RestElement",
        argument
      }, defs = NODE_FIELDS.RestElement;
      return validate(defs.argument, node, "argument", argument, 1), node;
    }
    function returnStatement(argument = null) {
      let node = {
        type: "ReturnStatement",
        argument
      }, defs = NODE_FIELDS.ReturnStatement;
      return validate(defs.argument, node, "argument", argument, 1), node;
    }
    function sequenceExpression(expressions) {
      let node = {
        type: "SequenceExpression",
        expressions
      }, defs = NODE_FIELDS.SequenceExpression;
      return validate(defs.expressions, node, "expressions", expressions, 1), node;
    }
    function parenthesizedExpression(expression) {
      let node = {
        type: "ParenthesizedExpression",
        expression
      }, defs = NODE_FIELDS.ParenthesizedExpression;
      return validate(defs.expression, node, "expression", expression, 1), node;
    }
    function switchCase(test = null, consequent) {
      let node = {
        type: "SwitchCase",
        test,
        consequent
      }, defs = NODE_FIELDS.SwitchCase;
      return validate(defs.test, node, "test", test, 1), validate(defs.consequent, node, "consequent", consequent, 1), node;
    }
    function switchStatement(discriminant, cases) {
      let node = {
        type: "SwitchStatement",
        discriminant,
        cases
      }, defs = NODE_FIELDS.SwitchStatement;
      return validate(defs.discriminant, node, "discriminant", discriminant, 1), validate(defs.cases, node, "cases", cases, 1), node;
    }
    function thisExpression() {
      return {
        type: "ThisExpression"
      };
    }
    function throwStatement(argument) {
      let node = {
        type: "ThrowStatement",
        argument
      }, defs = NODE_FIELDS.ThrowStatement;
      return validate(defs.argument, node, "argument", argument, 1), node;
    }
    function tryStatement(block, handler = null, finalizer = null) {
      let node = {
        type: "TryStatement",
        block,
        handler,
        finalizer
      }, defs = NODE_FIELDS.TryStatement;
      return validate(defs.block, node, "block", block, 1), validate(defs.handler, node, "handler", handler, 1), validate(defs.finalizer, node, "finalizer", finalizer, 1), node;
    }
    function unaryExpression(operator, argument, prefix = !0) {
      let node = {
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      }, defs = NODE_FIELDS.UnaryExpression;
      return validate(defs.operator, node, "operator", operator), validate(defs.argument, node, "argument", argument, 1), validate(defs.prefix, node, "prefix", prefix), node;
    }
    function updateExpression(operator, argument, prefix = !1) {
      let node = {
        type: "UpdateExpression",
        operator,
        argument,
        prefix
      }, defs = NODE_FIELDS.UpdateExpression;
      return validate(defs.operator, node, "operator", operator), validate(defs.argument, node, "argument", argument, 1), validate(defs.prefix, node, "prefix", prefix), node;
    }
    function variableDeclaration(kind, declarations) {
      let node = {
        type: "VariableDeclaration",
        kind,
        declarations
      }, defs = NODE_FIELDS.VariableDeclaration;
      return validate(defs.kind, node, "kind", kind), validate(defs.declarations, node, "declarations", declarations, 1), node;
    }
    function variableDeclarator(id, init = null) {
      let node = {
        type: "VariableDeclarator",
        id,
        init
      }, defs = NODE_FIELDS.VariableDeclarator;
      return validate(defs.id, node, "id", id, 1), validate(defs.init, node, "init", init, 1), node;
    }
    function whileStatement(test, body) {
      let node = {
        type: "WhileStatement",
        test,
        body
      }, defs = NODE_FIELDS.WhileStatement;
      return validate(defs.test, node, "test", test, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function withStatement(object, body) {
      let node = {
        type: "WithStatement",
        object,
        body
      }, defs = NODE_FIELDS.WithStatement;
      return validate(defs.object, node, "object", object, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function assignmentPattern(left, right) {
      let node = {
        type: "AssignmentPattern",
        left,
        right
      }, defs = NODE_FIELDS.AssignmentPattern;
      return validate(defs.left, node, "left", left, 1), validate(defs.right, node, "right", right, 1), node;
    }
    function arrayPattern(elements) {
      let node = {
        type: "ArrayPattern",
        elements
      }, defs = NODE_FIELDS.ArrayPattern;
      return validate(defs.elements, node, "elements", elements, 1), node;
    }
    function arrowFunctionExpression(params, body, async = !1) {
      let node = {
        type: "ArrowFunctionExpression",
        params,
        body,
        async,
        expression: null
      }, defs = NODE_FIELDS.ArrowFunctionExpression;
      return validate(defs.params, node, "params", params, 1), validate(defs.body, node, "body", body, 1), validate(defs.async, node, "async", async), node;
    }
    function classBody(body) {
      let node = {
        type: "ClassBody",
        body
      }, defs = NODE_FIELDS.ClassBody;
      return validate(defs.body, node, "body", body, 1), node;
    }
    function classExpression(id = null, superClass = null, body, decorators = null) {
      let node = {
        type: "ClassExpression",
        id,
        superClass,
        body,
        decorators
      }, defs = NODE_FIELDS.ClassExpression;
      return validate(defs.id, node, "id", id, 1), validate(defs.superClass, node, "superClass", superClass, 1), validate(defs.body, node, "body", body, 1), validate(defs.decorators, node, "decorators", decorators, 1), node;
    }
    function classDeclaration(id = null, superClass = null, body, decorators = null) {
      let node = {
        type: "ClassDeclaration",
        id,
        superClass,
        body,
        decorators
      }, defs = NODE_FIELDS.ClassDeclaration;
      return validate(defs.id, node, "id", id, 1), validate(defs.superClass, node, "superClass", superClass, 1), validate(defs.body, node, "body", body, 1), validate(defs.decorators, node, "decorators", decorators, 1), node;
    }
    function exportAllDeclaration(source) {
      let node = {
        type: "ExportAllDeclaration",
        source
      }, defs = NODE_FIELDS.ExportAllDeclaration;
      return validate(defs.source, node, "source", source, 1), node;
    }
    function exportDefaultDeclaration(declaration) {
      let node = {
        type: "ExportDefaultDeclaration",
        declaration
      }, defs = NODE_FIELDS.ExportDefaultDeclaration;
      return validate(defs.declaration, node, "declaration", declaration, 1), node;
    }
    function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
      let node = {
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
      }, defs = NODE_FIELDS.ExportNamedDeclaration;
      return validate(defs.declaration, node, "declaration", declaration, 1), validate(defs.specifiers, node, "specifiers", specifiers, 1), validate(defs.source, node, "source", source, 1), node;
    }
    function exportSpecifier(local, exported) {
      let node = {
        type: "ExportSpecifier",
        local,
        exported
      }, defs = NODE_FIELDS.ExportSpecifier;
      return validate(defs.local, node, "local", local, 1), validate(defs.exported, node, "exported", exported, 1), node;
    }
    function forOfStatement(left, right, body, _await = !1) {
      let node = {
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      }, defs = NODE_FIELDS.ForOfStatement;
      return validate(defs.left, node, "left", left, 1), validate(defs.right, node, "right", right, 1), validate(defs.body, node, "body", body, 1), validate(defs.await, node, "await", _await), node;
    }
    function importDeclaration(specifiers, source) {
      let node = {
        type: "ImportDeclaration",
        specifiers,
        source
      }, defs = NODE_FIELDS.ImportDeclaration;
      return validate(defs.specifiers, node, "specifiers", specifiers, 1), validate(defs.source, node, "source", source, 1), node;
    }
    function importDefaultSpecifier(local) {
      let node = {
        type: "ImportDefaultSpecifier",
        local
      }, defs = NODE_FIELDS.ImportDefaultSpecifier;
      return validate(defs.local, node, "local", local, 1), node;
    }
    function importNamespaceSpecifier(local) {
      let node = {
        type: "ImportNamespaceSpecifier",
        local
      }, defs = NODE_FIELDS.ImportNamespaceSpecifier;
      return validate(defs.local, node, "local", local, 1), node;
    }
    function importSpecifier(local, imported) {
      let node = {
        type: "ImportSpecifier",
        local,
        imported
      }, defs = NODE_FIELDS.ImportSpecifier;
      return validate(defs.local, node, "local", local, 1), validate(defs.imported, node, "imported", imported, 1), node;
    }
    function importExpression(source, options = null) {
      let node = {
        type: "ImportExpression",
        source,
        options
      }, defs = NODE_FIELDS.ImportExpression;
      return validate(defs.source, node, "source", source, 1), validate(defs.options, node, "options", options, 1), node;
    }
    function metaProperty(meta, property) {
      let node = {
        type: "MetaProperty",
        meta,
        property
      }, defs = NODE_FIELDS.MetaProperty;
      return validate(defs.meta, node, "meta", meta, 1), validate(defs.property, node, "property", property, 1), node;
    }
    function classMethod(kind = "method", key, params, body, computed = !1, _static = !1, generator = !1, async = !1) {
      let node = {
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async
      }, defs = NODE_FIELDS.ClassMethod;
      return validate(defs.kind, node, "kind", kind), validate(defs.key, node, "key", key, 1), validate(defs.params, node, "params", params, 1), validate(defs.body, node, "body", body, 1), validate(defs.computed, node, "computed", computed), validate(defs.static, node, "static", _static), validate(defs.generator, node, "generator", generator), validate(defs.async, node, "async", async), node;
    }
    function objectPattern(properties) {
      let node = {
        type: "ObjectPattern",
        properties
      }, defs = NODE_FIELDS.ObjectPattern;
      return validate(defs.properties, node, "properties", properties, 1), node;
    }
    function spreadElement(argument) {
      let node = {
        type: "SpreadElement",
        argument
      }, defs = NODE_FIELDS.SpreadElement;
      return validate(defs.argument, node, "argument", argument, 1), node;
    }
    function _super() {
      return {
        type: "Super"
      };
    }
    function taggedTemplateExpression(tag, quasi) {
      let node = {
        type: "TaggedTemplateExpression",
        tag,
        quasi
      }, defs = NODE_FIELDS.TaggedTemplateExpression;
      return validate(defs.tag, node, "tag", tag, 1), validate(defs.quasi, node, "quasi", quasi, 1), node;
    }
    function templateElement(value2, tail = !1) {
      let node = {
        type: "TemplateElement",
        value: value2,
        tail
      }, defs = NODE_FIELDS.TemplateElement;
      return validate(defs.value, node, "value", value2), validate(defs.tail, node, "tail", tail), node;
    }
    function templateLiteral(quasis, expressions) {
      let node = {
        type: "TemplateLiteral",
        quasis,
        expressions
      }, defs = NODE_FIELDS.TemplateLiteral;
      return validate(defs.quasis, node, "quasis", quasis, 1), validate(defs.expressions, node, "expressions", expressions, 1), node;
    }
    function yieldExpression(argument = null, delegate = !1) {
      let node = {
        type: "YieldExpression",
        argument,
        delegate
      }, defs = NODE_FIELDS.YieldExpression;
      return validate(defs.argument, node, "argument", argument, 1), validate(defs.delegate, node, "delegate", delegate), node;
    }
    function awaitExpression(argument) {
      let node = {
        type: "AwaitExpression",
        argument
      }, defs = NODE_FIELDS.AwaitExpression;
      return validate(defs.argument, node, "argument", argument, 1), node;
    }
    function _import() {
      return {
        type: "Import"
      };
    }
    function exportNamespaceSpecifier(exported) {
      let node = {
        type: "ExportNamespaceSpecifier",
        exported
      }, defs = NODE_FIELDS.ExportNamespaceSpecifier;
      return validate(defs.exported, node, "exported", exported, 1), node;
    }
    function optionalMemberExpression(object, property, computed = !1, optional) {
      let node = {
        type: "OptionalMemberExpression",
        object,
        property,
        computed,
        optional
      }, defs = NODE_FIELDS.OptionalMemberExpression;
      return validate(defs.object, node, "object", object, 1), validate(defs.property, node, "property", property, 1), validate(defs.computed, node, "computed", computed), validate(defs.optional, node, "optional", optional), node;
    }
    function optionalCallExpression(callee, _arguments, optional) {
      let node = {
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
      }, defs = NODE_FIELDS.OptionalCallExpression;
      return validate(defs.callee, node, "callee", callee, 1), validate(defs.arguments, node, "arguments", _arguments, 1), validate(defs.optional, node, "optional", optional), node;
    }
    function classProperty(key, value2 = null, typeAnnotation2 = null, decorators = null, computed = !1, _static = !1) {
      let node = {
        type: "ClassProperty",
        key,
        value: value2,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      }, defs = NODE_FIELDS.ClassProperty;
      return validate(defs.key, node, "key", key, 1), validate(defs.value, node, "value", value2, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), validate(defs.decorators, node, "decorators", decorators, 1), validate(defs.computed, node, "computed", computed), validate(defs.static, node, "static", _static), node;
    }
    function classAccessorProperty(key, value2 = null, typeAnnotation2 = null, decorators = null, computed = !1, _static = !1) {
      let node = {
        type: "ClassAccessorProperty",
        key,
        value: value2,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      }, defs = NODE_FIELDS.ClassAccessorProperty;
      return validate(defs.key, node, "key", key, 1), validate(defs.value, node, "value", value2, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), validate(defs.decorators, node, "decorators", decorators, 1), validate(defs.computed, node, "computed", computed), validate(defs.static, node, "static", _static), node;
    }
    function classPrivateProperty(key, value2 = null, decorators = null, _static = !1) {
      let node = {
        type: "ClassPrivateProperty",
        key,
        value: value2,
        decorators,
        static: _static
      }, defs = NODE_FIELDS.ClassPrivateProperty;
      return validate(defs.key, node, "key", key, 1), validate(defs.value, node, "value", value2, 1), validate(defs.decorators, node, "decorators", decorators, 1), validate(defs.static, node, "static", _static), node;
    }
    function classPrivateMethod(kind = "method", key, params, body, _static = !1) {
      let node = {
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
      }, defs = NODE_FIELDS.ClassPrivateMethod;
      return validate(defs.kind, node, "kind", kind), validate(defs.key, node, "key", key, 1), validate(defs.params, node, "params", params, 1), validate(defs.body, node, "body", body, 1), validate(defs.static, node, "static", _static), node;
    }
    function privateName(id) {
      let node = {
        type: "PrivateName",
        id
      }, defs = NODE_FIELDS.PrivateName;
      return validate(defs.id, node, "id", id, 1), node;
    }
    function staticBlock(body) {
      let node = {
        type: "StaticBlock",
        body
      }, defs = NODE_FIELDS.StaticBlock;
      return validate(defs.body, node, "body", body, 1), node;
    }
    function importAttribute(key, value2) {
      let node = {
        type: "ImportAttribute",
        key,
        value: value2
      }, defs = NODE_FIELDS.ImportAttribute;
      return validate(defs.key, node, "key", key, 1), validate(defs.value, node, "value", value2, 1), node;
    }
    function anyTypeAnnotation() {
      return {
        type: "AnyTypeAnnotation"
      };
    }
    function arrayTypeAnnotation(elementType) {
      let node = {
        type: "ArrayTypeAnnotation",
        elementType
      }, defs = NODE_FIELDS.ArrayTypeAnnotation;
      return validate(defs.elementType, node, "elementType", elementType, 1), node;
    }
    function booleanTypeAnnotation() {
      return {
        type: "BooleanTypeAnnotation"
      };
    }
    function booleanLiteralTypeAnnotation(value2) {
      let node = {
        type: "BooleanLiteralTypeAnnotation",
        value: value2
      }, defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
      return validate(defs.value, node, "value", value2), node;
    }
    function nullLiteralTypeAnnotation() {
      return {
        type: "NullLiteralTypeAnnotation"
      };
    }
    function classImplements(id, typeParameters = null) {
      let node = {
        type: "ClassImplements",
        id,
        typeParameters
      }, defs = NODE_FIELDS.ClassImplements;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), node;
    }
    function declareClass(id, typeParameters = null, _extends = null, body) {
      let node = {
        type: "DeclareClass",
        id,
        typeParameters,
        extends: _extends,
        body
      }, defs = NODE_FIELDS.DeclareClass;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.extends, node, "extends", _extends, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function declareFunction(id) {
      let node = {
        type: "DeclareFunction",
        id
      }, defs = NODE_FIELDS.DeclareFunction;
      return validate(defs.id, node, "id", id, 1), node;
    }
    function declareInterface(id, typeParameters = null, _extends = null, body) {
      let node = {
        type: "DeclareInterface",
        id,
        typeParameters,
        extends: _extends,
        body
      }, defs = NODE_FIELDS.DeclareInterface;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.extends, node, "extends", _extends, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function declareModule(id, body, kind = null) {
      let node = {
        type: "DeclareModule",
        id,
        body,
        kind
      }, defs = NODE_FIELDS.DeclareModule;
      return validate(defs.id, node, "id", id, 1), validate(defs.body, node, "body", body, 1), validate(defs.kind, node, "kind", kind), node;
    }
    function declareModuleExports(typeAnnotation2) {
      let node = {
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.DeclareModuleExports;
      return validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function declareTypeAlias(id, typeParameters = null, right) {
      let node = {
        type: "DeclareTypeAlias",
        id,
        typeParameters,
        right
      }, defs = NODE_FIELDS.DeclareTypeAlias;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.right, node, "right", right, 1), node;
    }
    function declareOpaqueType(id, typeParameters = null, supertype = null) {
      let node = {
        type: "DeclareOpaqueType",
        id,
        typeParameters,
        supertype
      }, defs = NODE_FIELDS.DeclareOpaqueType;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.supertype, node, "supertype", supertype, 1), node;
    }
    function declareVariable(id) {
      let node = {
        type: "DeclareVariable",
        id
      }, defs = NODE_FIELDS.DeclareVariable;
      return validate(defs.id, node, "id", id, 1), node;
    }
    function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
      let node = {
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source,
        attributes
      }, defs = NODE_FIELDS.DeclareExportDeclaration;
      return validate(defs.declaration, node, "declaration", declaration, 1), validate(defs.specifiers, node, "specifiers", specifiers, 1), validate(defs.source, node, "source", source, 1), validate(defs.attributes, node, "attributes", attributes, 1), node;
    }
    function declareExportAllDeclaration(source, attributes = null) {
      let node = {
        type: "DeclareExportAllDeclaration",
        source,
        attributes
      }, defs = NODE_FIELDS.DeclareExportAllDeclaration;
      return validate(defs.source, node, "source", source, 1), validate(defs.attributes, node, "attributes", attributes, 1), node;
    }
    function declaredPredicate(value2) {
      let node = {
        type: "DeclaredPredicate",
        value: value2
      }, defs = NODE_FIELDS.DeclaredPredicate;
      return validate(defs.value, node, "value", value2, 1), node;
    }
    function existsTypeAnnotation() {
      return {
        type: "ExistsTypeAnnotation"
      };
    }
    function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
      let node = {
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
      }, defs = NODE_FIELDS.FunctionTypeAnnotation;
      return validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.params, node, "params", params, 1), validate(defs.rest, node, "rest", rest, 1), validate(defs.returnType, node, "returnType", returnType, 1), node;
    }
    function functionTypeParam(name = null, typeAnnotation2) {
      let node = {
        type: "FunctionTypeParam",
        name,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.FunctionTypeParam;
      return validate(defs.name, node, "name", name, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function genericTypeAnnotation(id, typeParameters = null) {
      let node = {
        type: "GenericTypeAnnotation",
        id,
        typeParameters
      }, defs = NODE_FIELDS.GenericTypeAnnotation;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), node;
    }
    function inferredPredicate() {
      return {
        type: "InferredPredicate"
      };
    }
    function interfaceExtends(id, typeParameters = null) {
      let node = {
        type: "InterfaceExtends",
        id,
        typeParameters
      }, defs = NODE_FIELDS.InterfaceExtends;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), node;
    }
    function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      let node = {
        type: "InterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      }, defs = NODE_FIELDS.InterfaceDeclaration;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.extends, node, "extends", _extends, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function interfaceTypeAnnotation(_extends = null, body) {
      let node = {
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
      }, defs = NODE_FIELDS.InterfaceTypeAnnotation;
      return validate(defs.extends, node, "extends", _extends, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function intersectionTypeAnnotation(types2) {
      let node = {
        type: "IntersectionTypeAnnotation",
        types: types2
      }, defs = NODE_FIELDS.IntersectionTypeAnnotation;
      return validate(defs.types, node, "types", types2, 1), node;
    }
    function mixedTypeAnnotation() {
      return {
        type: "MixedTypeAnnotation"
      };
    }
    function emptyTypeAnnotation() {
      return {
        type: "EmptyTypeAnnotation"
      };
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      let node = {
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.NullableTypeAnnotation;
      return validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function numberLiteralTypeAnnotation(value2) {
      let node = {
        type: "NumberLiteralTypeAnnotation",
        value: value2
      }, defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
      return validate(defs.value, node, "value", value2), node;
    }
    function numberTypeAnnotation() {
      return {
        type: "NumberTypeAnnotation"
      };
    }
    function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = !1) {
      let node = {
        type: "ObjectTypeAnnotation",
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact
      }, defs = NODE_FIELDS.ObjectTypeAnnotation;
      return validate(defs.properties, node, "properties", properties, 1), validate(defs.indexers, node, "indexers", indexers, 1), validate(defs.callProperties, node, "callProperties", callProperties, 1), validate(defs.internalSlots, node, "internalSlots", internalSlots, 1), validate(defs.exact, node, "exact", exact), node;
    }
    function objectTypeInternalSlot(id, value2, optional, _static, method) {
      let node = {
        type: "ObjectTypeInternalSlot",
        id,
        value: value2,
        optional,
        static: _static,
        method
      }, defs = NODE_FIELDS.ObjectTypeInternalSlot;
      return validate(defs.id, node, "id", id, 1), validate(defs.value, node, "value", value2, 1), validate(defs.optional, node, "optional", optional), validate(defs.static, node, "static", _static), validate(defs.method, node, "method", method), node;
    }
    function objectTypeCallProperty(value2) {
      let node = {
        type: "ObjectTypeCallProperty",
        value: value2,
        static: null
      }, defs = NODE_FIELDS.ObjectTypeCallProperty;
      return validate(defs.value, node, "value", value2, 1), node;
    }
    function objectTypeIndexer(id = null, key, value2, variance2 = null) {
      let node = {
        type: "ObjectTypeIndexer",
        id,
        key,
        value: value2,
        variance: variance2,
        static: null
      }, defs = NODE_FIELDS.ObjectTypeIndexer;
      return validate(defs.id, node, "id", id, 1), validate(defs.key, node, "key", key, 1), validate(defs.value, node, "value", value2, 1), validate(defs.variance, node, "variance", variance2, 1), node;
    }
    function objectTypeProperty(key, value2, variance2 = null) {
      let node = {
        type: "ObjectTypeProperty",
        key,
        value: value2,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      }, defs = NODE_FIELDS.ObjectTypeProperty;
      return validate(defs.key, node, "key", key, 1), validate(defs.value, node, "value", value2, 1), validate(defs.variance, node, "variance", variance2, 1), node;
    }
    function objectTypeSpreadProperty(argument) {
      let node = {
        type: "ObjectTypeSpreadProperty",
        argument
      }, defs = NODE_FIELDS.ObjectTypeSpreadProperty;
      return validate(defs.argument, node, "argument", argument, 1), node;
    }
    function opaqueType(id, typeParameters = null, supertype = null, impltype) {
      let node = {
        type: "OpaqueType",
        id,
        typeParameters,
        supertype,
        impltype
      }, defs = NODE_FIELDS.OpaqueType;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.supertype, node, "supertype", supertype, 1), validate(defs.impltype, node, "impltype", impltype, 1), node;
    }
    function qualifiedTypeIdentifier(id, qualification) {
      let node = {
        type: "QualifiedTypeIdentifier",
        id,
        qualification
      }, defs = NODE_FIELDS.QualifiedTypeIdentifier;
      return validate(defs.id, node, "id", id, 1), validate(defs.qualification, node, "qualification", qualification, 1), node;
    }
    function stringLiteralTypeAnnotation(value2) {
      let node = {
        type: "StringLiteralTypeAnnotation",
        value: value2
      }, defs = NODE_FIELDS.StringLiteralTypeAnnotation;
      return validate(defs.value, node, "value", value2), node;
    }
    function stringTypeAnnotation() {
      return {
        type: "StringTypeAnnotation"
      };
    }
    function symbolTypeAnnotation() {
      return {
        type: "SymbolTypeAnnotation"
      };
    }
    function thisTypeAnnotation() {
      return {
        type: "ThisTypeAnnotation"
      };
    }
    function tupleTypeAnnotation(types2) {
      let node = {
        type: "TupleTypeAnnotation",
        types: types2
      }, defs = NODE_FIELDS.TupleTypeAnnotation;
      return validate(defs.types, node, "types", types2, 1), node;
    }
    function typeofTypeAnnotation(argument) {
      let node = {
        type: "TypeofTypeAnnotation",
        argument
      }, defs = NODE_FIELDS.TypeofTypeAnnotation;
      return validate(defs.argument, node, "argument", argument, 1), node;
    }
    function typeAlias(id, typeParameters = null, right) {
      let node = {
        type: "TypeAlias",
        id,
        typeParameters,
        right
      }, defs = NODE_FIELDS.TypeAlias;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.right, node, "right", right, 1), node;
    }
    function typeAnnotation(typeAnnotation2) {
      let node = {
        type: "TypeAnnotation",
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TypeAnnotation;
      return validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function typeCastExpression(expression, typeAnnotation2) {
      let node = {
        type: "TypeCastExpression",
        expression,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TypeCastExpression;
      return validate(defs.expression, node, "expression", expression, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function typeParameter(bound = null, _default = null, variance2 = null) {
      let node = {
        type: "TypeParameter",
        bound,
        default: _default,
        variance: variance2,
        name: null
      }, defs = NODE_FIELDS.TypeParameter;
      return validate(defs.bound, node, "bound", bound, 1), validate(defs.default, node, "default", _default, 1), validate(defs.variance, node, "variance", variance2, 1), node;
    }
    function typeParameterDeclaration(params) {
      let node = {
        type: "TypeParameterDeclaration",
        params
      }, defs = NODE_FIELDS.TypeParameterDeclaration;
      return validate(defs.params, node, "params", params, 1), node;
    }
    function typeParameterInstantiation(params) {
      let node = {
        type: "TypeParameterInstantiation",
        params
      }, defs = NODE_FIELDS.TypeParameterInstantiation;
      return validate(defs.params, node, "params", params, 1), node;
    }
    function unionTypeAnnotation(types2) {
      let node = {
        type: "UnionTypeAnnotation",
        types: types2
      }, defs = NODE_FIELDS.UnionTypeAnnotation;
      return validate(defs.types, node, "types", types2, 1), node;
    }
    function variance(kind) {
      let node = {
        type: "Variance",
        kind
      }, defs = NODE_FIELDS.Variance;
      return validate(defs.kind, node, "kind", kind), node;
    }
    function voidTypeAnnotation() {
      return {
        type: "VoidTypeAnnotation"
      };
    }
    function enumDeclaration(id, body) {
      let node = {
        type: "EnumDeclaration",
        id,
        body
      }, defs = NODE_FIELDS.EnumDeclaration;
      return validate(defs.id, node, "id", id, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function enumBooleanBody(members) {
      let node = {
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      }, defs = NODE_FIELDS.EnumBooleanBody;
      return validate(defs.members, node, "members", members, 1), node;
    }
    function enumNumberBody(members) {
      let node = {
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      }, defs = NODE_FIELDS.EnumNumberBody;
      return validate(defs.members, node, "members", members, 1), node;
    }
    function enumStringBody(members) {
      let node = {
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      }, defs = NODE_FIELDS.EnumStringBody;
      return validate(defs.members, node, "members", members, 1), node;
    }
    function enumSymbolBody(members) {
      let node = {
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
      }, defs = NODE_FIELDS.EnumSymbolBody;
      return validate(defs.members, node, "members", members, 1), node;
    }
    function enumBooleanMember(id) {
      let node = {
        type: "EnumBooleanMember",
        id,
        init: null
      }, defs = NODE_FIELDS.EnumBooleanMember;
      return validate(defs.id, node, "id", id, 1), node;
    }
    function enumNumberMember(id, init) {
      let node = {
        type: "EnumNumberMember",
        id,
        init
      }, defs = NODE_FIELDS.EnumNumberMember;
      return validate(defs.id, node, "id", id, 1), validate(defs.init, node, "init", init, 1), node;
    }
    function enumStringMember(id, init) {
      let node = {
        type: "EnumStringMember",
        id,
        init
      }, defs = NODE_FIELDS.EnumStringMember;
      return validate(defs.id, node, "id", id, 1), validate(defs.init, node, "init", init, 1), node;
    }
    function enumDefaultedMember(id) {
      let node = {
        type: "EnumDefaultedMember",
        id
      }, defs = NODE_FIELDS.EnumDefaultedMember;
      return validate(defs.id, node, "id", id, 1), node;
    }
    function indexedAccessType(objectType, indexType) {
      let node = {
        type: "IndexedAccessType",
        objectType,
        indexType
      }, defs = NODE_FIELDS.IndexedAccessType;
      return validate(defs.objectType, node, "objectType", objectType, 1), validate(defs.indexType, node, "indexType", indexType, 1), node;
    }
    function optionalIndexedAccessType(objectType, indexType) {
      let node = {
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
      }, defs = NODE_FIELDS.OptionalIndexedAccessType;
      return validate(defs.objectType, node, "objectType", objectType, 1), validate(defs.indexType, node, "indexType", indexType, 1), node;
    }
    function jsxAttribute(name, value2 = null) {
      let node = {
        type: "JSXAttribute",
        name,
        value: value2
      }, defs = NODE_FIELDS.JSXAttribute;
      return validate(defs.name, node, "name", name, 1), validate(defs.value, node, "value", value2, 1), node;
    }
    function jsxClosingElement(name) {
      let node = {
        type: "JSXClosingElement",
        name
      }, defs = NODE_FIELDS.JSXClosingElement;
      return validate(defs.name, node, "name", name, 1), node;
    }
    function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
      let node = {
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
      }, defs = NODE_FIELDS.JSXElement;
      return validate(defs.openingElement, node, "openingElement", openingElement, 1), validate(defs.closingElement, node, "closingElement", closingElement, 1), validate(defs.children, node, "children", children, 1), validate(defs.selfClosing, node, "selfClosing", selfClosing), node;
    }
    function jsxEmptyExpression() {
      return {
        type: "JSXEmptyExpression"
      };
    }
    function jsxExpressionContainer(expression) {
      let node = {
        type: "JSXExpressionContainer",
        expression
      }, defs = NODE_FIELDS.JSXExpressionContainer;
      return validate(defs.expression, node, "expression", expression, 1), node;
    }
    function jsxSpreadChild(expression) {
      let node = {
        type: "JSXSpreadChild",
        expression
      }, defs = NODE_FIELDS.JSXSpreadChild;
      return validate(defs.expression, node, "expression", expression, 1), node;
    }
    function jsxIdentifier(name) {
      let node = {
        type: "JSXIdentifier",
        name
      }, defs = NODE_FIELDS.JSXIdentifier;
      return validate(defs.name, node, "name", name), node;
    }
    function jsxMemberExpression(object, property) {
      let node = {
        type: "JSXMemberExpression",
        object,
        property
      }, defs = NODE_FIELDS.JSXMemberExpression;
      return validate(defs.object, node, "object", object, 1), validate(defs.property, node, "property", property, 1), node;
    }
    function jsxNamespacedName(namespace, name) {
      let node = {
        type: "JSXNamespacedName",
        namespace,
        name
      }, defs = NODE_FIELDS.JSXNamespacedName;
      return validate(defs.namespace, node, "namespace", namespace, 1), validate(defs.name, node, "name", name, 1), node;
    }
    function jsxOpeningElement(name, attributes, selfClosing = !1) {
      let node = {
        type: "JSXOpeningElement",
        name,
        attributes,
        selfClosing
      }, defs = NODE_FIELDS.JSXOpeningElement;
      return validate(defs.name, node, "name", name, 1), validate(defs.attributes, node, "attributes", attributes, 1), validate(defs.selfClosing, node, "selfClosing", selfClosing), node;
    }
    function jsxSpreadAttribute(argument) {
      let node = {
        type: "JSXSpreadAttribute",
        argument
      }, defs = NODE_FIELDS.JSXSpreadAttribute;
      return validate(defs.argument, node, "argument", argument, 1), node;
    }
    function jsxText(value2) {
      let node = {
        type: "JSXText",
        value: value2
      }, defs = NODE_FIELDS.JSXText;
      return validate(defs.value, node, "value", value2), node;
    }
    function jsxFragment(openingFragment, closingFragment, children) {
      let node = {
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
      }, defs = NODE_FIELDS.JSXFragment;
      return validate(defs.openingFragment, node, "openingFragment", openingFragment, 1), validate(defs.closingFragment, node, "closingFragment", closingFragment, 1), validate(defs.children, node, "children", children, 1), node;
    }
    function jsxOpeningFragment() {
      return {
        type: "JSXOpeningFragment"
      };
    }
    function jsxClosingFragment() {
      return {
        type: "JSXClosingFragment"
      };
    }
    function noop() {
      return {
        type: "Noop"
      };
    }
    function placeholder(expectedNode, name) {
      let node = {
        type: "Placeholder",
        expectedNode,
        name
      }, defs = NODE_FIELDS.Placeholder;
      return validate(defs.expectedNode, node, "expectedNode", expectedNode), validate(defs.name, node, "name", name, 1), node;
    }
    function v8IntrinsicIdentifier(name) {
      let node = {
        type: "V8IntrinsicIdentifier",
        name
      }, defs = NODE_FIELDS.V8IntrinsicIdentifier;
      return validate(defs.name, node, "name", name), node;
    }
    function argumentPlaceholder() {
      return {
        type: "ArgumentPlaceholder"
      };
    }
    function bindExpression(object, callee) {
      let node = {
        type: "BindExpression",
        object,
        callee
      }, defs = NODE_FIELDS.BindExpression;
      return validate(defs.object, node, "object", object, 1), validate(defs.callee, node, "callee", callee, 1), node;
    }
    function decorator(expression) {
      let node = {
        type: "Decorator",
        expression
      }, defs = NODE_FIELDS.Decorator;
      return validate(defs.expression, node, "expression", expression, 1), node;
    }
    function doExpression(body, async = !1) {
      let node = {
        type: "DoExpression",
        body,
        async
      }, defs = NODE_FIELDS.DoExpression;
      return validate(defs.body, node, "body", body, 1), validate(defs.async, node, "async", async), node;
    }
    function exportDefaultSpecifier(exported) {
      let node = {
        type: "ExportDefaultSpecifier",
        exported
      }, defs = NODE_FIELDS.ExportDefaultSpecifier;
      return validate(defs.exported, node, "exported", exported, 1), node;
    }
    function recordExpression(properties) {
      let node = {
        type: "RecordExpression",
        properties
      }, defs = NODE_FIELDS.RecordExpression;
      return validate(defs.properties, node, "properties", properties, 1), node;
    }
    function tupleExpression(elements = []) {
      let node = {
        type: "TupleExpression",
        elements
      }, defs = NODE_FIELDS.TupleExpression;
      return validate(defs.elements, node, "elements", elements, 1), node;
    }
    function decimalLiteral(value2) {
      let node = {
        type: "DecimalLiteral",
        value: value2
      }, defs = NODE_FIELDS.DecimalLiteral;
      return validate(defs.value, node, "value", value2), node;
    }
    function moduleExpression(body) {
      let node = {
        type: "ModuleExpression",
        body
      }, defs = NODE_FIELDS.ModuleExpression;
      return validate(defs.body, node, "body", body, 1), node;
    }
    function topicReference() {
      return {
        type: "TopicReference"
      };
    }
    function pipelineTopicExpression(expression) {
      let node = {
        type: "PipelineTopicExpression",
        expression
      }, defs = NODE_FIELDS.PipelineTopicExpression;
      return validate(defs.expression, node, "expression", expression, 1), node;
    }
    function pipelineBareFunction(callee) {
      let node = {
        type: "PipelineBareFunction",
        callee
      }, defs = NODE_FIELDS.PipelineBareFunction;
      return validate(defs.callee, node, "callee", callee, 1), node;
    }
    function pipelinePrimaryTopicReference() {
      return {
        type: "PipelinePrimaryTopicReference"
      };
    }
    function voidPattern() {
      return {
        type: "VoidPattern"
      };
    }
    function tsParameterProperty(parameter) {
      let node = {
        type: "TSParameterProperty",
        parameter
      }, defs = NODE_FIELDS.TSParameterProperty;
      return validate(defs.parameter, node, "parameter", parameter, 1), node;
    }
    function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
      let node = {
        type: "TSDeclareFunction",
        id,
        typeParameters,
        params,
        returnType
      }, defs = NODE_FIELDS.TSDeclareFunction;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.params, node, "params", params, 1), validate(defs.returnType, node, "returnType", returnType, 1), node;
    }
    function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
      let node = {
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
      }, defs = NODE_FIELDS.TSDeclareMethod;
      return validate(defs.decorators, node, "decorators", decorators, 1), validate(defs.key, node, "key", key, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.params, node, "params", params, 1), validate(defs.returnType, node, "returnType", returnType, 1), node;
    }
    function tsQualifiedName(left, right) {
      let node = {
        type: "TSQualifiedName",
        left,
        right
      }, defs = NODE_FIELDS.TSQualifiedName;
      return validate(defs.left, node, "left", left, 1), validate(defs.right, node, "right", right, 1), node;
    }
    function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      let node = {
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSCallSignatureDeclaration;
      return validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.parameters, node, "parameters", parameters, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      let node = {
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSConstructSignatureDeclaration;
      return validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.parameters, node, "parameters", parameters, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsPropertySignature(key, typeAnnotation2 = null) {
      let node = {
        type: "TSPropertySignature",
        key,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSPropertySignature;
      return validate(defs.key, node, "key", key, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
      let node = {
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2,
        kind: null
      }, defs = NODE_FIELDS.TSMethodSignature;
      return validate(defs.key, node, "key", key, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.parameters, node, "parameters", parameters, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsIndexSignature(parameters, typeAnnotation2 = null) {
      let node = {
        type: "TSIndexSignature",
        parameters,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSIndexSignature;
      return validate(defs.parameters, node, "parameters", parameters, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsAnyKeyword() {
      return {
        type: "TSAnyKeyword"
      };
    }
    function tsBooleanKeyword() {
      return {
        type: "TSBooleanKeyword"
      };
    }
    function tsBigIntKeyword() {
      return {
        type: "TSBigIntKeyword"
      };
    }
    function tsIntrinsicKeyword() {
      return {
        type: "TSIntrinsicKeyword"
      };
    }
    function tsNeverKeyword() {
      return {
        type: "TSNeverKeyword"
      };
    }
    function tsNullKeyword() {
      return {
        type: "TSNullKeyword"
      };
    }
    function tsNumberKeyword() {
      return {
        type: "TSNumberKeyword"
      };
    }
    function tsObjectKeyword() {
      return {
        type: "TSObjectKeyword"
      };
    }
    function tsStringKeyword() {
      return {
        type: "TSStringKeyword"
      };
    }
    function tsSymbolKeyword() {
      return {
        type: "TSSymbolKeyword"
      };
    }
    function tsUndefinedKeyword() {
      return {
        type: "TSUndefinedKeyword"
      };
    }
    function tsUnknownKeyword() {
      return {
        type: "TSUnknownKeyword"
      };
    }
    function tsVoidKeyword() {
      return {
        type: "TSVoidKeyword"
      };
    }
    function tsThisType() {
      return {
        type: "TSThisType"
      };
    }
    function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
      let node = {
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSFunctionType;
      return validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.parameters, node, "parameters", parameters, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
      let node = {
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSConstructorType;
      return validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.parameters, node, "parameters", parameters, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsTypeReference(typeName, typeParameters = null) {
      let node = {
        type: "TSTypeReference",
        typeName,
        typeParameters
      }, defs = NODE_FIELDS.TSTypeReference;
      return validate(defs.typeName, node, "typeName", typeName, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), node;
    }
    function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
      let node = {
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts
      }, defs = NODE_FIELDS.TSTypePredicate;
      return validate(defs.parameterName, node, "parameterName", parameterName, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), validate(defs.asserts, node, "asserts", asserts), node;
    }
    function tsTypeQuery(exprName, typeParameters = null) {
      let node = {
        type: "TSTypeQuery",
        exprName,
        typeParameters
      }, defs = NODE_FIELDS.TSTypeQuery;
      return validate(defs.exprName, node, "exprName", exprName, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), node;
    }
    function tsTypeLiteral(members) {
      let node = {
        type: "TSTypeLiteral",
        members
      }, defs = NODE_FIELDS.TSTypeLiteral;
      return validate(defs.members, node, "members", members, 1), node;
    }
    function tsArrayType(elementType) {
      let node = {
        type: "TSArrayType",
        elementType
      }, defs = NODE_FIELDS.TSArrayType;
      return validate(defs.elementType, node, "elementType", elementType, 1), node;
    }
    function tsTupleType(elementTypes) {
      let node = {
        type: "TSTupleType",
        elementTypes
      }, defs = NODE_FIELDS.TSTupleType;
      return validate(defs.elementTypes, node, "elementTypes", elementTypes, 1), node;
    }
    function tsOptionalType(typeAnnotation2) {
      let node = {
        type: "TSOptionalType",
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSOptionalType;
      return validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsRestType(typeAnnotation2) {
      let node = {
        type: "TSRestType",
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSRestType;
      return validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsNamedTupleMember(label, elementType, optional = !1) {
      let node = {
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
      }, defs = NODE_FIELDS.TSNamedTupleMember;
      return validate(defs.label, node, "label", label, 1), validate(defs.elementType, node, "elementType", elementType, 1), validate(defs.optional, node, "optional", optional), node;
    }
    function tsUnionType(types2) {
      let node = {
        type: "TSUnionType",
        types: types2
      }, defs = NODE_FIELDS.TSUnionType;
      return validate(defs.types, node, "types", types2, 1), node;
    }
    function tsIntersectionType(types2) {
      let node = {
        type: "TSIntersectionType",
        types: types2
      }, defs = NODE_FIELDS.TSIntersectionType;
      return validate(defs.types, node, "types", types2, 1), node;
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      let node = {
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
      }, defs = NODE_FIELDS.TSConditionalType;
      return validate(defs.checkType, node, "checkType", checkType, 1), validate(defs.extendsType, node, "extendsType", extendsType, 1), validate(defs.trueType, node, "trueType", trueType, 1), validate(defs.falseType, node, "falseType", falseType, 1), node;
    }
    function tsInferType(typeParameter2) {
      let node = {
        type: "TSInferType",
        typeParameter: typeParameter2
      }, defs = NODE_FIELDS.TSInferType;
      return validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1), node;
    }
    function tsParenthesizedType(typeAnnotation2) {
      let node = {
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSParenthesizedType;
      return validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsTypeOperator(typeAnnotation2, operator = "keyof") {
      let node = {
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation2,
        operator
      }, defs = NODE_FIELDS.TSTypeOperator;
      return validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), validate(defs.operator, node, "operator", operator), node;
    }
    function tsIndexedAccessType(objectType, indexType) {
      let node = {
        type: "TSIndexedAccessType",
        objectType,
        indexType
      }, defs = NODE_FIELDS.TSIndexedAccessType;
      return validate(defs.objectType, node, "objectType", objectType, 1), validate(defs.indexType, node, "indexType", indexType, 1), node;
    }
    function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
      let node = {
        type: "TSMappedType",
        typeParameter: typeParameter2,
        typeAnnotation: typeAnnotation2,
        nameType
      }, defs = NODE_FIELDS.TSMappedType;
      return validate(defs.typeParameter, node, "typeParameter", typeParameter2, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), validate(defs.nameType, node, "nameType", nameType, 1), node;
    }
    function tsTemplateLiteralType(quasis, types2) {
      let node = {
        type: "TSTemplateLiteralType",
        quasis,
        types: types2
      }, defs = NODE_FIELDS.TSTemplateLiteralType;
      return validate(defs.quasis, node, "quasis", quasis, 1), validate(defs.types, node, "types", types2, 1), node;
    }
    function tsLiteralType(literal) {
      let node = {
        type: "TSLiteralType",
        literal
      }, defs = NODE_FIELDS.TSLiteralType;
      return validate(defs.literal, node, "literal", literal, 1), node;
    }
    function tsExpressionWithTypeArguments(expression, typeParameters = null) {
      let node = {
        type: "TSExpressionWithTypeArguments",
        expression,
        typeParameters
      }, defs = NODE_FIELDS.TSExpressionWithTypeArguments;
      return validate(defs.expression, node, "expression", expression, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), node;
    }
    function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
      let node = {
        type: "TSInterfaceDeclaration",
        id,
        typeParameters,
        extends: _extends,
        body
      }, defs = NODE_FIELDS.TSInterfaceDeclaration;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.extends, node, "extends", _extends, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function tsInterfaceBody(body) {
      let node = {
        type: "TSInterfaceBody",
        body
      }, defs = NODE_FIELDS.TSInterfaceBody;
      return validate(defs.body, node, "body", body, 1), node;
    }
    function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation2) {
      let node = {
        type: "TSTypeAliasDeclaration",
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSTypeAliasDeclaration;
      return validate(defs.id, node, "id", id, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsInstantiationExpression(expression, typeParameters = null) {
      let node = {
        type: "TSInstantiationExpression",
        expression,
        typeParameters
      }, defs = NODE_FIELDS.TSInstantiationExpression;
      return validate(defs.expression, node, "expression", expression, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), node;
    }
    function tsAsExpression(expression, typeAnnotation2) {
      let node = {
        type: "TSAsExpression",
        expression,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSAsExpression;
      return validate(defs.expression, node, "expression", expression, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsSatisfiesExpression(expression, typeAnnotation2) {
      let node = {
        type: "TSSatisfiesExpression",
        expression,
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSSatisfiesExpression;
      return validate(defs.expression, node, "expression", expression, 1), validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsTypeAssertion(typeAnnotation2, expression) {
      let node = {
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation2,
        expression
      }, defs = NODE_FIELDS.TSTypeAssertion;
      return validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), validate(defs.expression, node, "expression", expression, 1), node;
    }
    function tsEnumBody(members) {
      let node = {
        type: "TSEnumBody",
        members
      }, defs = NODE_FIELDS.TSEnumBody;
      return validate(defs.members, node, "members", members, 1), node;
    }
    function tsEnumDeclaration(id, members) {
      let node = {
        type: "TSEnumDeclaration",
        id,
        members
      }, defs = NODE_FIELDS.TSEnumDeclaration;
      return validate(defs.id, node, "id", id, 1), validate(defs.members, node, "members", members, 1), node;
    }
    function tsEnumMember(id, initializer = null) {
      let node = {
        type: "TSEnumMember",
        id,
        initializer
      }, defs = NODE_FIELDS.TSEnumMember;
      return validate(defs.id, node, "id", id, 1), validate(defs.initializer, node, "initializer", initializer, 1), node;
    }
    function tsModuleDeclaration(id, body) {
      let node = {
        type: "TSModuleDeclaration",
        id,
        body,
        kind: null
      }, defs = NODE_FIELDS.TSModuleDeclaration;
      return validate(defs.id, node, "id", id, 1), validate(defs.body, node, "body", body, 1), node;
    }
    function tsModuleBlock(body) {
      let node = {
        type: "TSModuleBlock",
        body
      }, defs = NODE_FIELDS.TSModuleBlock;
      return validate(defs.body, node, "body", body, 1), node;
    }
    function tsImportType(argument, qualifier = null, typeParameters = null) {
      let node = {
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
      }, defs = NODE_FIELDS.TSImportType;
      return validate(defs.argument, node, "argument", argument, 1), validate(defs.qualifier, node, "qualifier", qualifier, 1), validate(defs.typeParameters, node, "typeParameters", typeParameters, 1), node;
    }
    function tsImportEqualsDeclaration(id, moduleReference) {
      let node = {
        type: "TSImportEqualsDeclaration",
        id,
        moduleReference,
        isExport: null
      }, defs = NODE_FIELDS.TSImportEqualsDeclaration;
      return validate(defs.id, node, "id", id, 1), validate(defs.moduleReference, node, "moduleReference", moduleReference, 1), node;
    }
    function tsExternalModuleReference(expression) {
      let node = {
        type: "TSExternalModuleReference",
        expression
      }, defs = NODE_FIELDS.TSExternalModuleReference;
      return validate(defs.expression, node, "expression", expression, 1), node;
    }
    function tsNonNullExpression(expression) {
      let node = {
        type: "TSNonNullExpression",
        expression
      }, defs = NODE_FIELDS.TSNonNullExpression;
      return validate(defs.expression, node, "expression", expression, 1), node;
    }
    function tsExportAssignment(expression) {
      let node = {
        type: "TSExportAssignment",
        expression
      }, defs = NODE_FIELDS.TSExportAssignment;
      return validate(defs.expression, node, "expression", expression, 1), node;
    }
    function tsNamespaceExportDeclaration(id) {
      let node = {
        type: "TSNamespaceExportDeclaration",
        id
      }, defs = NODE_FIELDS.TSNamespaceExportDeclaration;
      return validate(defs.id, node, "id", id, 1), node;
    }
    function tsTypeAnnotation(typeAnnotation2) {
      let node = {
        type: "TSTypeAnnotation",
        typeAnnotation: typeAnnotation2
      }, defs = NODE_FIELDS.TSTypeAnnotation;
      return validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation2, 1), node;
    }
    function tsTypeParameterInstantiation(params) {
      let node = {
        type: "TSTypeParameterInstantiation",
        params
      }, defs = NODE_FIELDS.TSTypeParameterInstantiation;
      return validate(defs.params, node, "params", params, 1), node;
    }
    function tsTypeParameterDeclaration(params) {
      let node = {
        type: "TSTypeParameterDeclaration",
        params
      }, defs = NODE_FIELDS.TSTypeParameterDeclaration;
      return validate(defs.params, node, "params", params, 1), node;
    }
    function tsTypeParameter(constraint = null, _default = null, name) {
      let node = {
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name
      }, defs = NODE_FIELDS.TSTypeParameter;
      return validate(defs.constraint, node, "constraint", constraint, 1), validate(defs.default, node, "default", _default, 1), validate(defs.name, node, "name", name), node;
    }
    function NumberLiteral(value2) {
      return (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type "), numericLiteral(value2);
    }
    function RegexLiteral(pattern, flags = "") {
      return (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type "), regExpLiteral(pattern, flags);
    }
    function RestProperty(argument) {
      return (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type "), restElement(argument);
    }
    function SpreadProperty(argument) {
      return (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type "), spreadElement(argument);
    }
  }
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
  "../node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.JSXIdentifier = exports.JSXFragment = exports.JSXExpressionContainer = exports.JSXEmptyExpression = exports.JSXElement = exports.JSXClosingFragment = exports.JSXClosingElement = exports.JSXAttribute = exports.IntersectionTypeAnnotation = exports.InterpreterDirective = exports.InterfaceTypeAnnotation = exports.InterfaceExtends = exports.InterfaceDeclaration = exports.InferredPredicate = exports.IndexedAccessType = exports.ImportSpecifier = exports.ImportNamespaceSpecifier = exports.ImportExpression = exports.ImportDefaultSpecifier = exports.ImportDeclaration = exports.ImportAttribute = exports.Import = exports.IfStatement = exports.Identifier = exports.GenericTypeAnnotation = exports.FunctionTypeParam = exports.FunctionTypeAnnotation = exports.FunctionExpression = exports.FunctionDeclaration = exports.ForStatement = exports.ForOfStatement = exports.ForInStatement = exports.File = exports.ExpressionStatement = exports.ExportSpecifier = exports.ExportNamespaceSpecifier = exports.ExportNamedDeclaration = exports.ExportDefaultSpecifier = exports.ExportDefaultDeclaration = exports.ExportAllDeclaration = exports.ExistsTypeAnnotation = exports.EnumSymbolBody = exports.EnumStringMember = exports.EnumStringBody = exports.EnumNumberMember = exports.EnumNumberBody = exports.EnumDefaultedMember = exports.EnumDeclaration = exports.EnumBooleanMember = exports.EnumBooleanBody = exports.EmptyTypeAnnotation = exports.EmptyStatement = exports.DoWhileStatement = exports.DoExpression = exports.DirectiveLiteral = exports.Directive = exports.Decorator = exports.DeclaredPredicate = exports.DeclareVariable = exports.DeclareTypeAlias = exports.DeclareOpaqueType = exports.DeclareModuleExports = exports.DeclareModule = exports.DeclareInterface = exports.DeclareFunction = exports.DeclareExportDeclaration = exports.DeclareExportAllDeclaration = exports.DeclareClass = exports.DecimalLiteral = exports.DebuggerStatement = exports.ContinueStatement = exports.ConditionalExpression = exports.ClassProperty = exports.ClassPrivateProperty = exports.ClassPrivateMethod = exports.ClassMethod = exports.ClassImplements = exports.ClassExpression = exports.ClassDeclaration = exports.ClassBody = exports.ClassAccessorProperty = exports.CatchClause = exports.CallExpression = exports.BreakStatement = exports.BooleanTypeAnnotation = exports.BooleanLiteralTypeAnnotation = exports.BooleanLiteral = exports.BlockStatement = exports.BindExpression = exports.BinaryExpression = exports.BigIntLiteral = exports.AwaitExpression = exports.AssignmentPattern = exports.AssignmentExpression = exports.ArrowFunctionExpression = exports.ArrayTypeAnnotation = exports.ArrayPattern = exports.ArrayExpression = exports.ArgumentPlaceholder = exports.AnyTypeAnnotation = void 0;
    exports.TSNumberKeyword = exports.TSNullKeyword = exports.TSNonNullExpression = exports.TSNeverKeyword = exports.TSNamespaceExportDeclaration = exports.TSNamedTupleMember = exports.TSModuleDeclaration = exports.TSModuleBlock = exports.TSMethodSignature = exports.TSMappedType = exports.TSLiteralType = exports.TSIntrinsicKeyword = exports.TSIntersectionType = exports.TSInterfaceDeclaration = exports.TSInterfaceBody = exports.TSInstantiationExpression = exports.TSInferType = exports.TSIndexedAccessType = exports.TSIndexSignature = exports.TSImportType = exports.TSImportEqualsDeclaration = exports.TSFunctionType = exports.TSExternalModuleReference = exports.TSExpressionWithTypeArguments = exports.TSExportAssignment = exports.TSEnumMember = exports.TSEnumDeclaration = exports.TSEnumBody = exports.TSDeclareMethod = exports.TSDeclareFunction = exports.TSConstructorType = exports.TSConstructSignatureDeclaration = exports.TSConditionalType = exports.TSCallSignatureDeclaration = exports.TSBooleanKeyword = exports.TSBigIntKeyword = exports.TSAsExpression = exports.TSArrayType = exports.TSAnyKeyword = exports.SymbolTypeAnnotation = exports.SwitchStatement = exports.SwitchCase = exports.Super = exports.StringTypeAnnotation = exports.StringLiteralTypeAnnotation = exports.StringLiteral = exports.StaticBlock = exports.SpreadProperty = exports.SpreadElement = exports.SequenceExpression = exports.ReturnStatement = exports.RestProperty = exports.RestElement = exports.RegexLiteral = exports.RegExpLiteral = exports.RecordExpression = exports.QualifiedTypeIdentifier = exports.Program = exports.PrivateName = exports.Placeholder = exports.PipelineTopicExpression = exports.PipelinePrimaryTopicReference = exports.PipelineBareFunction = exports.ParenthesizedExpression = exports.OptionalMemberExpression = exports.OptionalIndexedAccessType = exports.OptionalCallExpression = exports.OpaqueType = exports.ObjectTypeSpreadProperty = exports.ObjectTypeProperty = exports.ObjectTypeInternalSlot = exports.ObjectTypeIndexer = exports.ObjectTypeCallProperty = exports.ObjectTypeAnnotation = exports.ObjectProperty = exports.ObjectPattern = exports.ObjectMethod = exports.ObjectExpression = exports.NumericLiteral = exports.NumberTypeAnnotation = exports.NumberLiteralTypeAnnotation = exports.NumberLiteral = exports.NullableTypeAnnotation = exports.NullLiteralTypeAnnotation = exports.NullLiteral = exports.Noop = exports.NewExpression = exports.ModuleExpression = exports.MixedTypeAnnotation = exports.MetaProperty = exports.MemberExpression = exports.LogicalExpression = exports.LabeledStatement = exports.JSXText = exports.JSXSpreadChild = exports.JSXSpreadAttribute = exports.JSXOpeningFragment = exports.JSXOpeningElement = exports.JSXNamespacedName = exports.JSXMemberExpression = void 0;
    exports.YieldExpression = exports.WithStatement = exports.WhileStatement = exports.VoidTypeAnnotation = exports.VoidPattern = exports.Variance = exports.VariableDeclarator = exports.VariableDeclaration = exports.V8IntrinsicIdentifier = exports.UpdateExpression = exports.UnionTypeAnnotation = exports.UnaryExpression = exports.TypeofTypeAnnotation = exports.TypeParameterInstantiation = exports.TypeParameterDeclaration = exports.TypeParameter = exports.TypeCastExpression = exports.TypeAnnotation = exports.TypeAlias = exports.TupleTypeAnnotation = exports.TupleExpression = exports.TryStatement = exports.TopicReference = exports.ThrowStatement = exports.ThisTypeAnnotation = exports.ThisExpression = exports.TemplateLiteral = exports.TemplateElement = exports.TaggedTemplateExpression = exports.TSVoidKeyword = exports.TSUnknownKeyword = exports.TSUnionType = exports.TSUndefinedKeyword = exports.TSTypeReference = exports.TSTypeQuery = exports.TSTypePredicate = exports.TSTypeParameterInstantiation = exports.TSTypeParameterDeclaration = exports.TSTypeParameter = exports.TSTypeOperator = exports.TSTypeLiteral = exports.TSTypeAssertion = exports.TSTypeAnnotation = exports.TSTypeAliasDeclaration = exports.TSTupleType = exports.TSThisType = exports.TSTemplateLiteralType = exports.TSSymbolKeyword = exports.TSStringKeyword = exports.TSSatisfiesExpression = exports.TSRestType = exports.TSQualifiedName = exports.TSPropertySignature = exports.TSParenthesizedType = exports.TSParameterProperty = exports.TSOptionalType = exports.TSObjectKeyword = void 0;
    var b = require_lowercase(), _deprecationWarning = require_deprecationWarning();
    function alias(lowercase) {
      return b[lowercase];
    }
    var ArrayExpression = exports.ArrayExpression = alias("arrayExpression"), AssignmentExpression = exports.AssignmentExpression = alias("assignmentExpression"), BinaryExpression = exports.BinaryExpression = alias("binaryExpression"), InterpreterDirective = exports.InterpreterDirective = alias("interpreterDirective"), Directive = exports.Directive = alias("directive"), DirectiveLiteral = exports.DirectiveLiteral = alias("directiveLiteral"), BlockStatement = exports.BlockStatement = alias("blockStatement"), BreakStatement = exports.BreakStatement = alias("breakStatement"), CallExpression = exports.CallExpression = alias("callExpression"), CatchClause = exports.CatchClause = alias("catchClause"), ConditionalExpression = exports.ConditionalExpression = alias("conditionalExpression"), ContinueStatement = exports.ContinueStatement = alias("continueStatement"), DebuggerStatement = exports.DebuggerStatement = alias("debuggerStatement"), DoWhileStatement = exports.DoWhileStatement = alias("doWhileStatement"), EmptyStatement = exports.EmptyStatement = alias("emptyStatement"), ExpressionStatement = exports.ExpressionStatement = alias("expressionStatement"), File2 = exports.File = alias("file"), ForInStatement = exports.ForInStatement = alias("forInStatement"), ForStatement = exports.ForStatement = alias("forStatement"), FunctionDeclaration = exports.FunctionDeclaration = alias("functionDeclaration"), FunctionExpression = exports.FunctionExpression = alias("functionExpression"), Identifier = exports.Identifier = alias("identifier"), IfStatement = exports.IfStatement = alias("ifStatement"), LabeledStatement = exports.LabeledStatement = alias("labeledStatement"), StringLiteral = exports.StringLiteral = alias("stringLiteral"), NumericLiteral = exports.NumericLiteral = alias("numericLiteral"), NullLiteral = exports.NullLiteral = alias("nullLiteral"), BooleanLiteral = exports.BooleanLiteral = alias("booleanLiteral"), RegExpLiteral = exports.RegExpLiteral = alias("regExpLiteral"), LogicalExpression = exports.LogicalExpression = alias("logicalExpression"), MemberExpression = exports.MemberExpression = alias("memberExpression"), NewExpression = exports.NewExpression = alias("newExpression"), Program = exports.Program = alias("program"), ObjectExpression = exports.ObjectExpression = alias("objectExpression"), ObjectMethod = exports.ObjectMethod = alias("objectMethod"), ObjectProperty = exports.ObjectProperty = alias("objectProperty"), RestElement = exports.RestElement = alias("restElement"), ReturnStatement = exports.ReturnStatement = alias("returnStatement"), SequenceExpression = exports.SequenceExpression = alias("sequenceExpression"), ParenthesizedExpression = exports.ParenthesizedExpression = alias("parenthesizedExpression"), SwitchCase = exports.SwitchCase = alias("switchCase"), SwitchStatement = exports.SwitchStatement = alias("switchStatement"), ThisExpression = exports.ThisExpression = alias("thisExpression"), ThrowStatement = exports.ThrowStatement = alias("throwStatement"), TryStatement = exports.TryStatement = alias("tryStatement"), UnaryExpression = exports.UnaryExpression = alias("unaryExpression"), UpdateExpression = exports.UpdateExpression = alias("updateExpression"), VariableDeclaration = exports.VariableDeclaration = alias("variableDeclaration"), VariableDeclarator = exports.VariableDeclarator = alias("variableDeclarator"), WhileStatement = exports.WhileStatement = alias("whileStatement"), WithStatement = exports.WithStatement = alias("withStatement"), AssignmentPattern = exports.AssignmentPattern = alias("assignmentPattern"), ArrayPattern = exports.ArrayPattern = alias("arrayPattern"), ArrowFunctionExpression = exports.ArrowFunctionExpression = alias("arrowFunctionExpression"), ClassBody = exports.ClassBody = alias("classBody"), ClassExpression = exports.ClassExpression = alias("classExpression"), ClassDeclaration = exports.ClassDeclaration = alias("classDeclaration"), ExportAllDeclaration = exports.ExportAllDeclaration = alias("exportAllDeclaration"), ExportDefaultDeclaration = exports.ExportDefaultDeclaration = alias("exportDefaultDeclaration"), ExportNamedDeclaration = exports.ExportNamedDeclaration = alias("exportNamedDeclaration"), ExportSpecifier = exports.ExportSpecifier = alias("exportSpecifier"), ForOfStatement = exports.ForOfStatement = alias("forOfStatement"), ImportDeclaration = exports.ImportDeclaration = alias("importDeclaration"), ImportDefaultSpecifier = exports.ImportDefaultSpecifier = alias("importDefaultSpecifier"), ImportNamespaceSpecifier = exports.ImportNamespaceSpecifier = alias("importNamespaceSpecifier"), ImportSpecifier = exports.ImportSpecifier = alias("importSpecifier"), ImportExpression = exports.ImportExpression = alias("importExpression"), MetaProperty = exports.MetaProperty = alias("metaProperty"), ClassMethod = exports.ClassMethod = alias("classMethod"), ObjectPattern = exports.ObjectPattern = alias("objectPattern"), SpreadElement = exports.SpreadElement = alias("spreadElement"), Super = exports.Super = alias("super"), TaggedTemplateExpression = exports.TaggedTemplateExpression = alias("taggedTemplateExpression"), TemplateElement = exports.TemplateElement = alias("templateElement"), TemplateLiteral = exports.TemplateLiteral = alias("templateLiteral"), YieldExpression = exports.YieldExpression = alias("yieldExpression"), AwaitExpression = exports.AwaitExpression = alias("awaitExpression"), Import = exports.Import = alias("import"), BigIntLiteral = exports.BigIntLiteral = alias("bigIntLiteral"), ExportNamespaceSpecifier = exports.ExportNamespaceSpecifier = alias("exportNamespaceSpecifier"), OptionalMemberExpression = exports.OptionalMemberExpression = alias("optionalMemberExpression"), OptionalCallExpression = exports.OptionalCallExpression = alias("optionalCallExpression"), ClassProperty = exports.ClassProperty = alias("classProperty"), ClassAccessorProperty = exports.ClassAccessorProperty = alias("classAccessorProperty"), ClassPrivateProperty = exports.ClassPrivateProperty = alias("classPrivateProperty"), ClassPrivateMethod = exports.ClassPrivateMethod = alias("classPrivateMethod"), PrivateName = exports.PrivateName = alias("privateName"), StaticBlock = exports.StaticBlock = alias("staticBlock"), ImportAttribute = exports.ImportAttribute = alias("importAttribute"), AnyTypeAnnotation = exports.AnyTypeAnnotation = alias("anyTypeAnnotation"), ArrayTypeAnnotation = exports.ArrayTypeAnnotation = alias("arrayTypeAnnotation"), BooleanTypeAnnotation = exports.BooleanTypeAnnotation = alias("booleanTypeAnnotation"), BooleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = alias("booleanLiteralTypeAnnotation"), NullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = alias("nullLiteralTypeAnnotation"), ClassImplements = exports.ClassImplements = alias("classImplements"), DeclareClass = exports.DeclareClass = alias("declareClass"), DeclareFunction = exports.DeclareFunction = alias("declareFunction"), DeclareInterface = exports.DeclareInterface = alias("declareInterface"), DeclareModule = exports.DeclareModule = alias("declareModule"), DeclareModuleExports = exports.DeclareModuleExports = alias("declareModuleExports"), DeclareTypeAlias = exports.DeclareTypeAlias = alias("declareTypeAlias"), DeclareOpaqueType = exports.DeclareOpaqueType = alias("declareOpaqueType"), DeclareVariable = exports.DeclareVariable = alias("declareVariable"), DeclareExportDeclaration = exports.DeclareExportDeclaration = alias("declareExportDeclaration"), DeclareExportAllDeclaration = exports.DeclareExportAllDeclaration = alias("declareExportAllDeclaration"), DeclaredPredicate = exports.DeclaredPredicate = alias("declaredPredicate"), ExistsTypeAnnotation = exports.ExistsTypeAnnotation = alias("existsTypeAnnotation"), FunctionTypeAnnotation = exports.FunctionTypeAnnotation = alias("functionTypeAnnotation"), FunctionTypeParam = exports.FunctionTypeParam = alias("functionTypeParam"), GenericTypeAnnotation = exports.GenericTypeAnnotation = alias("genericTypeAnnotation"), InferredPredicate = exports.InferredPredicate = alias("inferredPredicate"), InterfaceExtends = exports.InterfaceExtends = alias("interfaceExtends"), InterfaceDeclaration = exports.InterfaceDeclaration = alias("interfaceDeclaration"), InterfaceTypeAnnotation = exports.InterfaceTypeAnnotation = alias("interfaceTypeAnnotation"), IntersectionTypeAnnotation = exports.IntersectionTypeAnnotation = alias("intersectionTypeAnnotation"), MixedTypeAnnotation = exports.MixedTypeAnnotation = alias("mixedTypeAnnotation"), EmptyTypeAnnotation = exports.EmptyTypeAnnotation = alias("emptyTypeAnnotation"), NullableTypeAnnotation = exports.NullableTypeAnnotation = alias("nullableTypeAnnotation"), NumberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = alias("numberLiteralTypeAnnotation"), NumberTypeAnnotation = exports.NumberTypeAnnotation = alias("numberTypeAnnotation"), ObjectTypeAnnotation = exports.ObjectTypeAnnotation = alias("objectTypeAnnotation"), ObjectTypeInternalSlot = exports.ObjectTypeInternalSlot = alias("objectTypeInternalSlot"), ObjectTypeCallProperty = exports.ObjectTypeCallProperty = alias("objectTypeCallProperty"), ObjectTypeIndexer = exports.ObjectTypeIndexer = alias("objectTypeIndexer"), ObjectTypeProperty = exports.ObjectTypeProperty = alias("objectTypeProperty"), ObjectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = alias("objectTypeSpreadProperty"), OpaqueType = exports.OpaqueType = alias("opaqueType"), QualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = alias("qualifiedTypeIdentifier"), StringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = alias("stringLiteralTypeAnnotation"), StringTypeAnnotation = exports.StringTypeAnnotation = alias("stringTypeAnnotation"), SymbolTypeAnnotation = exports.SymbolTypeAnnotation = alias("symbolTypeAnnotation"), ThisTypeAnnotation = exports.ThisTypeAnnotation = alias("thisTypeAnnotation"), TupleTypeAnnotation = exports.TupleTypeAnnotation = alias("tupleTypeAnnotation"), TypeofTypeAnnotation = exports.TypeofTypeAnnotation = alias("typeofTypeAnnotation"), TypeAlias = exports.TypeAlias = alias("typeAlias"), TypeAnnotation = exports.TypeAnnotation = alias("typeAnnotation"), TypeCastExpression = exports.TypeCastExpression = alias("typeCastExpression"), TypeParameter = exports.TypeParameter = alias("typeParameter"), TypeParameterDeclaration = exports.TypeParameterDeclaration = alias("typeParameterDeclaration"), TypeParameterInstantiation = exports.TypeParameterInstantiation = alias("typeParameterInstantiation"), UnionTypeAnnotation = exports.UnionTypeAnnotation = alias("unionTypeAnnotation"), Variance = exports.Variance = alias("variance"), VoidTypeAnnotation = exports.VoidTypeAnnotation = alias("voidTypeAnnotation"), EnumDeclaration = exports.EnumDeclaration = alias("enumDeclaration"), EnumBooleanBody = exports.EnumBooleanBody = alias("enumBooleanBody"), EnumNumberBody = exports.EnumNumberBody = alias("enumNumberBody"), EnumStringBody = exports.EnumStringBody = alias("enumStringBody"), EnumSymbolBody = exports.EnumSymbolBody = alias("enumSymbolBody"), EnumBooleanMember = exports.EnumBooleanMember = alias("enumBooleanMember"), EnumNumberMember = exports.EnumNumberMember = alias("enumNumberMember"), EnumStringMember = exports.EnumStringMember = alias("enumStringMember"), EnumDefaultedMember = exports.EnumDefaultedMember = alias("enumDefaultedMember"), IndexedAccessType = exports.IndexedAccessType = alias("indexedAccessType"), OptionalIndexedAccessType = exports.OptionalIndexedAccessType = alias("optionalIndexedAccessType"), JSXAttribute = exports.JSXAttribute = alias("jsxAttribute"), JSXClosingElement = exports.JSXClosingElement = alias("jsxClosingElement"), JSXElement = exports.JSXElement = alias("jsxElement"), JSXEmptyExpression = exports.JSXEmptyExpression = alias("jsxEmptyExpression"), JSXExpressionContainer = exports.JSXExpressionContainer = alias("jsxExpressionContainer"), JSXSpreadChild = exports.JSXSpreadChild = alias("jsxSpreadChild"), JSXIdentifier = exports.JSXIdentifier = alias("jsxIdentifier"), JSXMemberExpression = exports.JSXMemberExpression = alias("jsxMemberExpression"), JSXNamespacedName = exports.JSXNamespacedName = alias("jsxNamespacedName"), JSXOpeningElement = exports.JSXOpeningElement = alias("jsxOpeningElement"), JSXSpreadAttribute = exports.JSXSpreadAttribute = alias("jsxSpreadAttribute"), JSXText = exports.JSXText = alias("jsxText"), JSXFragment = exports.JSXFragment = alias("jsxFragment"), JSXOpeningFragment = exports.JSXOpeningFragment = alias("jsxOpeningFragment"), JSXClosingFragment = exports.JSXClosingFragment = alias("jsxClosingFragment"), Noop = exports.Noop = alias("noop"), Placeholder = exports.Placeholder = alias("placeholder"), V8IntrinsicIdentifier = exports.V8IntrinsicIdentifier = alias("v8IntrinsicIdentifier"), ArgumentPlaceholder = exports.ArgumentPlaceholder = alias("argumentPlaceholder"), BindExpression = exports.BindExpression = alias("bindExpression"), Decorator = exports.Decorator = alias("decorator"), DoExpression = exports.DoExpression = alias("doExpression"), ExportDefaultSpecifier = exports.ExportDefaultSpecifier = alias("exportDefaultSpecifier"), RecordExpression = exports.RecordExpression = alias("recordExpression"), TupleExpression = exports.TupleExpression = alias("tupleExpression"), DecimalLiteral = exports.DecimalLiteral = alias("decimalLiteral"), ModuleExpression = exports.ModuleExpression = alias("moduleExpression"), TopicReference = exports.TopicReference = alias("topicReference"), PipelineTopicExpression = exports.PipelineTopicExpression = alias("pipelineTopicExpression"), PipelineBareFunction = exports.PipelineBareFunction = alias("pipelineBareFunction"), PipelinePrimaryTopicReference = exports.PipelinePrimaryTopicReference = alias("pipelinePrimaryTopicReference"), VoidPattern = exports.VoidPattern = alias("voidPattern"), TSParameterProperty = exports.TSParameterProperty = alias("tsParameterProperty"), TSDeclareFunction = exports.TSDeclareFunction = alias("tsDeclareFunction"), TSDeclareMethod = exports.TSDeclareMethod = alias("tsDeclareMethod"), TSQualifiedName = exports.TSQualifiedName = alias("tsQualifiedName"), TSCallSignatureDeclaration = exports.TSCallSignatureDeclaration = alias("tsCallSignatureDeclaration"), TSConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = alias("tsConstructSignatureDeclaration"), TSPropertySignature = exports.TSPropertySignature = alias("tsPropertySignature"), TSMethodSignature = exports.TSMethodSignature = alias("tsMethodSignature"), TSIndexSignature = exports.TSIndexSignature = alias("tsIndexSignature"), TSAnyKeyword = exports.TSAnyKeyword = alias("tsAnyKeyword"), TSBooleanKeyword = exports.TSBooleanKeyword = alias("tsBooleanKeyword"), TSBigIntKeyword = exports.TSBigIntKeyword = alias("tsBigIntKeyword"), TSIntrinsicKeyword = exports.TSIntrinsicKeyword = alias("tsIntrinsicKeyword"), TSNeverKeyword = exports.TSNeverKeyword = alias("tsNeverKeyword"), TSNullKeyword = exports.TSNullKeyword = alias("tsNullKeyword"), TSNumberKeyword = exports.TSNumberKeyword = alias("tsNumberKeyword"), TSObjectKeyword = exports.TSObjectKeyword = alias("tsObjectKeyword"), TSStringKeyword = exports.TSStringKeyword = alias("tsStringKeyword"), TSSymbolKeyword = exports.TSSymbolKeyword = alias("tsSymbolKeyword"), TSUndefinedKeyword = exports.TSUndefinedKeyword = alias("tsUndefinedKeyword"), TSUnknownKeyword = exports.TSUnknownKeyword = alias("tsUnknownKeyword"), TSVoidKeyword = exports.TSVoidKeyword = alias("tsVoidKeyword"), TSThisType = exports.TSThisType = alias("tsThisType"), TSFunctionType = exports.TSFunctionType = alias("tsFunctionType"), TSConstructorType = exports.TSConstructorType = alias("tsConstructorType"), TSTypeReference = exports.TSTypeReference = alias("tsTypeReference"), TSTypePredicate = exports.TSTypePredicate = alias("tsTypePredicate"), TSTypeQuery = exports.TSTypeQuery = alias("tsTypeQuery"), TSTypeLiteral = exports.TSTypeLiteral = alias("tsTypeLiteral"), TSArrayType = exports.TSArrayType = alias("tsArrayType"), TSTupleType = exports.TSTupleType = alias("tsTupleType"), TSOptionalType = exports.TSOptionalType = alias("tsOptionalType"), TSRestType = exports.TSRestType = alias("tsRestType"), TSNamedTupleMember = exports.TSNamedTupleMember = alias("tsNamedTupleMember"), TSUnionType = exports.TSUnionType = alias("tsUnionType"), TSIntersectionType = exports.TSIntersectionType = alias("tsIntersectionType"), TSConditionalType = exports.TSConditionalType = alias("tsConditionalType"), TSInferType = exports.TSInferType = alias("tsInferType"), TSParenthesizedType = exports.TSParenthesizedType = alias("tsParenthesizedType"), TSTypeOperator = exports.TSTypeOperator = alias("tsTypeOperator"), TSIndexedAccessType = exports.TSIndexedAccessType = alias("tsIndexedAccessType"), TSMappedType = exports.TSMappedType = alias("tsMappedType"), TSTemplateLiteralType = exports.TSTemplateLiteralType = alias("tsTemplateLiteralType"), TSLiteralType = exports.TSLiteralType = alias("tsLiteralType"), TSExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = alias("tsExpressionWithTypeArguments"), TSInterfaceDeclaration = exports.TSInterfaceDeclaration = alias("tsInterfaceDeclaration"), TSInterfaceBody = exports.TSInterfaceBody = alias("tsInterfaceBody"), TSTypeAliasDeclaration = exports.TSTypeAliasDeclaration = alias("tsTypeAliasDeclaration"), TSInstantiationExpression = exports.TSInstantiationExpression = alias("tsInstantiationExpression"), TSAsExpression = exports.TSAsExpression = alias("tsAsExpression"), TSSatisfiesExpression = exports.TSSatisfiesExpression = alias("tsSatisfiesExpression"), TSTypeAssertion = exports.TSTypeAssertion = alias("tsTypeAssertion"), TSEnumBody = exports.TSEnumBody = alias("tsEnumBody"), TSEnumDeclaration = exports.TSEnumDeclaration = alias("tsEnumDeclaration"), TSEnumMember = exports.TSEnumMember = alias("tsEnumMember"), TSModuleDeclaration = exports.TSModuleDeclaration = alias("tsModuleDeclaration"), TSModuleBlock = exports.TSModuleBlock = alias("tsModuleBlock"), TSImportType = exports.TSImportType = alias("tsImportType"), TSImportEqualsDeclaration = exports.TSImportEqualsDeclaration = alias("tsImportEqualsDeclaration"), TSExternalModuleReference = exports.TSExternalModuleReference = alias("tsExternalModuleReference"), TSNonNullExpression = exports.TSNonNullExpression = alias("tsNonNullExpression"), TSExportAssignment = exports.TSExportAssignment = alias("tsExportAssignment"), TSNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = alias("tsNamespaceExportDeclaration"), TSTypeAnnotation = exports.TSTypeAnnotation = alias("tsTypeAnnotation"), TSTypeParameterInstantiation = exports.TSTypeParameterInstantiation = alias("tsTypeParameterInstantiation"), TSTypeParameterDeclaration = exports.TSTypeParameterDeclaration = alias("tsTypeParameterDeclaration"), TSTypeParameter = exports.TSTypeParameter = alias("tsTypeParameter"), NumberLiteral = exports.NumberLiteral = b.numberLiteral, RegexLiteral = exports.RegexLiteral = b.regexLiteral, RestProperty = exports.RestProperty = b.restProperty, SpreadProperty = exports.SpreadProperty = b.spreadProperty;
  }
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
  "../node_modules/@babel/types/lib/builders/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var _lowercase = require_lowercase();
    Object.keys(_lowercase).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _lowercase[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _lowercase[key];
        }
      });
    });
    var _uppercase = require_uppercase();
    Object.keys(_uppercase).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _uppercase[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _uppercase[key];
        }
      });
    });
  }
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
  "../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = cleanJSXElementLiteralChild;
    var _index = require_generated2(), _index2 = require_lib4();
    function cleanJSXElementLiteralChild(child, args) {
      let lines = child.value.split(/\r\n|\n|\r/), lastNonEmptyLine = 0;
      for (let i = 0; i < lines.length; i++)
        /[^ \t]/.exec(lines[i]) && (lastNonEmptyLine = i);
      let str = "";
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i], isFirstLine = i === 0, isLastLine = i === lines.length - 1, isLastNonEmptyLine = i === lastNonEmptyLine, trimmedLine = line.replace(/\t/g, " ");
        isFirstLine || (trimmedLine = trimmedLine.replace(/^ +/, "")), isLastLine || (trimmedLine = trimmedLine.replace(/ +$/, "")), trimmedLine && (isLastNonEmptyLine || (trimmedLine += " "), str += trimmedLine);
      }
      str && args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
    }
  }
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
  "../node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = buildChildren;
    var _index = require_generated(), _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
    function buildChildren(node) {
      let elements = [];
      for (let i = 0; i < node.children.length; i++) {
        let child = node.children[i];
        if ((0, _index.isJSXText)(child)) {
          (0, _cleanJSXElementLiteralChild.default)(child, elements);
          continue;
        }
        (0, _index.isJSXExpressionContainer)(child) && (child = child.expression), !(0, _index.isJSXEmptyExpression)(child) && elements.push(child);
      }
      return elements;
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
  "../node_modules/@babel/types/lib/validators/isNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isNode;
    var _index = require_definitions();
    function isNode(node) {
      return !!(node && _index.VISITOR_KEYS[node.type]);
    }
  }
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
  "../node_modules/@babel/types/lib/asserts/assertNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = assertNode;
    var _isNode = require_isNode();
    function assertNode(node) {
      if (!(0, _isNode.default)(node)) {
        var _node$type;
        let type = (_node$type = node?.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
      }
    }
  }
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
  "../node_modules/@babel/types/lib/asserts/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.assertAccessor = assertAccessor;
    exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
    exports.assertArrayExpression = assertArrayExpression;
    exports.assertArrayPattern = assertArrayPattern;
    exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
    exports.assertAssignmentExpression = assertAssignmentExpression;
    exports.assertAssignmentPattern = assertAssignmentPattern;
    exports.assertAwaitExpression = assertAwaitExpression;
    exports.assertBigIntLiteral = assertBigIntLiteral;
    exports.assertBinary = assertBinary;
    exports.assertBinaryExpression = assertBinaryExpression;
    exports.assertBindExpression = assertBindExpression;
    exports.assertBlock = assertBlock;
    exports.assertBlockParent = assertBlockParent;
    exports.assertBlockStatement = assertBlockStatement;
    exports.assertBooleanLiteral = assertBooleanLiteral;
    exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    exports.assertBreakStatement = assertBreakStatement;
    exports.assertCallExpression = assertCallExpression;
    exports.assertCatchClause = assertCatchClause;
    exports.assertClass = assertClass;
    exports.assertClassAccessorProperty = assertClassAccessorProperty;
    exports.assertClassBody = assertClassBody;
    exports.assertClassDeclaration = assertClassDeclaration;
    exports.assertClassExpression = assertClassExpression;
    exports.assertClassImplements = assertClassImplements;
    exports.assertClassMethod = assertClassMethod;
    exports.assertClassPrivateMethod = assertClassPrivateMethod;
    exports.assertClassPrivateProperty = assertClassPrivateProperty;
    exports.assertClassProperty = assertClassProperty;
    exports.assertCompletionStatement = assertCompletionStatement;
    exports.assertConditional = assertConditional;
    exports.assertConditionalExpression = assertConditionalExpression;
    exports.assertContinueStatement = assertContinueStatement;
    exports.assertDebuggerStatement = assertDebuggerStatement;
    exports.assertDecimalLiteral = assertDecimalLiteral;
    exports.assertDeclaration = assertDeclaration;
    exports.assertDeclareClass = assertDeclareClass;
    exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    exports.assertDeclareFunction = assertDeclareFunction;
    exports.assertDeclareInterface = assertDeclareInterface;
    exports.assertDeclareModule = assertDeclareModule;
    exports.assertDeclareModuleExports = assertDeclareModuleExports;
    exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
    exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
    exports.assertDeclareVariable = assertDeclareVariable;
    exports.assertDeclaredPredicate = assertDeclaredPredicate;
    exports.assertDecorator = assertDecorator;
    exports.assertDirective = assertDirective;
    exports.assertDirectiveLiteral = assertDirectiveLiteral;
    exports.assertDoExpression = assertDoExpression;
    exports.assertDoWhileStatement = assertDoWhileStatement;
    exports.assertEmptyStatement = assertEmptyStatement;
    exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    exports.assertEnumBody = assertEnumBody;
    exports.assertEnumBooleanBody = assertEnumBooleanBody;
    exports.assertEnumBooleanMember = assertEnumBooleanMember;
    exports.assertEnumDeclaration = assertEnumDeclaration;
    exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
    exports.assertEnumMember = assertEnumMember;
    exports.assertEnumNumberBody = assertEnumNumberBody;
    exports.assertEnumNumberMember = assertEnumNumberMember;
    exports.assertEnumStringBody = assertEnumStringBody;
    exports.assertEnumStringMember = assertEnumStringMember;
    exports.assertEnumSymbolBody = assertEnumSymbolBody;
    exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    exports.assertExportAllDeclaration = assertExportAllDeclaration;
    exports.assertExportDeclaration = assertExportDeclaration;
    exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
    exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    exports.assertExportSpecifier = assertExportSpecifier;
    exports.assertExpression = assertExpression;
    exports.assertExpressionStatement = assertExpressionStatement;
    exports.assertExpressionWrapper = assertExpressionWrapper;
    exports.assertFile = assertFile;
    exports.assertFlow = assertFlow;
    exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    exports.assertFlowDeclaration = assertFlowDeclaration;
    exports.assertFlowPredicate = assertFlowPredicate;
    exports.assertFlowType = assertFlowType;
    exports.assertFor = assertFor;
    exports.assertForInStatement = assertForInStatement;
    exports.assertForOfStatement = assertForOfStatement;
    exports.assertForStatement = assertForStatement;
    exports.assertForXStatement = assertForXStatement;
    exports.assertFunction = assertFunction;
    exports.assertFunctionDeclaration = assertFunctionDeclaration;
    exports.assertFunctionExpression = assertFunctionExpression;
    exports.assertFunctionParameter = assertFunctionParameter;
    exports.assertFunctionParent = assertFunctionParent;
    exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    exports.assertFunctionTypeParam = assertFunctionTypeParam;
    exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    exports.assertIdentifier = assertIdentifier;
    exports.assertIfStatement = assertIfStatement;
    exports.assertImmutable = assertImmutable;
    exports.assertImport = assertImport;
    exports.assertImportAttribute = assertImportAttribute;
    exports.assertImportDeclaration = assertImportDeclaration;
    exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    exports.assertImportExpression = assertImportExpression;
    exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    exports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
    exports.assertImportSpecifier = assertImportSpecifier;
    exports.assertIndexedAccessType = assertIndexedAccessType;
    exports.assertInferredPredicate = assertInferredPredicate;
    exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
    exports.assertInterfaceExtends = assertInterfaceExtends;
    exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    exports.assertInterpreterDirective = assertInterpreterDirective;
    exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    exports.assertJSX = assertJSX;
    exports.assertJSXAttribute = assertJSXAttribute;
    exports.assertJSXClosingElement = assertJSXClosingElement;
    exports.assertJSXClosingFragment = assertJSXClosingFragment;
    exports.assertJSXElement = assertJSXElement;
    exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
    exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
    exports.assertJSXFragment = assertJSXFragment;
    exports.assertJSXIdentifier = assertJSXIdentifier;
    exports.assertJSXMemberExpression = assertJSXMemberExpression;
    exports.assertJSXNamespacedName = assertJSXNamespacedName;
    exports.assertJSXOpeningElement = assertJSXOpeningElement;
    exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
    exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    exports.assertJSXSpreadChild = assertJSXSpreadChild;
    exports.assertJSXText = assertJSXText;
    exports.assertLVal = assertLVal;
    exports.assertLabeledStatement = assertLabeledStatement;
    exports.assertLiteral = assertLiteral;
    exports.assertLogicalExpression = assertLogicalExpression;
    exports.assertLoop = assertLoop;
    exports.assertMemberExpression = assertMemberExpression;
    exports.assertMetaProperty = assertMetaProperty;
    exports.assertMethod = assertMethod;
    exports.assertMiscellaneous = assertMiscellaneous;
    exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    exports.assertModuleDeclaration = assertModuleDeclaration;
    exports.assertModuleExpression = assertModuleExpression;
    exports.assertModuleSpecifier = assertModuleSpecifier;
    exports.assertNewExpression = assertNewExpression;
    exports.assertNoop = assertNoop;
    exports.assertNullLiteral = assertNullLiteral;
    exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    exports.assertNumberLiteral = assertNumberLiteral;
    exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    exports.assertNumericLiteral = assertNumericLiteral;
    exports.assertObjectExpression = assertObjectExpression;
    exports.assertObjectMember = assertObjectMember;
    exports.assertObjectMethod = assertObjectMethod;
    exports.assertObjectPattern = assertObjectPattern;
    exports.assertObjectProperty = assertObjectProperty;
    exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
    exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    exports.assertObjectTypeProperty = assertObjectTypeProperty;
    exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    exports.assertOpaqueType = assertOpaqueType;
    exports.assertOptionalCallExpression = assertOptionalCallExpression;
    exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
    exports.assertParenthesizedExpression = assertParenthesizedExpression;
    exports.assertPattern = assertPattern;
    exports.assertPatternLike = assertPatternLike;
    exports.assertPipelineBareFunction = assertPipelineBareFunction;
    exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
    exports.assertPlaceholder = assertPlaceholder;
    exports.assertPrivate = assertPrivate;
    exports.assertPrivateName = assertPrivateName;
    exports.assertProgram = assertProgram;
    exports.assertProperty = assertProperty;
    exports.assertPureish = assertPureish;
    exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    exports.assertRecordExpression = assertRecordExpression;
    exports.assertRegExpLiteral = assertRegExpLiteral;
    exports.assertRegexLiteral = assertRegexLiteral;
    exports.assertRestElement = assertRestElement;
    exports.assertRestProperty = assertRestProperty;
    exports.assertReturnStatement = assertReturnStatement;
    exports.assertScopable = assertScopable;
    exports.assertSequenceExpression = assertSequenceExpression;
    exports.assertSpreadElement = assertSpreadElement;
    exports.assertSpreadProperty = assertSpreadProperty;
    exports.assertStandardized = assertStandardized;
    exports.assertStatement = assertStatement;
    exports.assertStaticBlock = assertStaticBlock;
    exports.assertStringLiteral = assertStringLiteral;
    exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
    exports.assertSuper = assertSuper;
    exports.assertSwitchCase = assertSwitchCase;
    exports.assertSwitchStatement = assertSwitchStatement;
    exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    exports.assertTSAnyKeyword = assertTSAnyKeyword;
    exports.assertTSArrayType = assertTSArrayType;
    exports.assertTSAsExpression = assertTSAsExpression;
    exports.assertTSBaseType = assertTSBaseType;
    exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
    exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
    exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    exports.assertTSConditionalType = assertTSConditionalType;
    exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    exports.assertTSConstructorType = assertTSConstructorType;
    exports.assertTSDeclareFunction = assertTSDeclareFunction;
    exports.assertTSDeclareMethod = assertTSDeclareMethod;
    exports.assertTSEntityName = assertTSEntityName;
    exports.assertTSEnumBody = assertTSEnumBody;
    exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
    exports.assertTSEnumMember = assertTSEnumMember;
    exports.assertTSExportAssignment = assertTSExportAssignment;
    exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
    exports.assertTSFunctionType = assertTSFunctionType;
    exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    exports.assertTSImportType = assertTSImportType;
    exports.assertTSIndexSignature = assertTSIndexSignature;
    exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
    exports.assertTSInferType = assertTSInferType;
    exports.assertTSInstantiationExpression = assertTSInstantiationExpression;
    exports.assertTSInterfaceBody = assertTSInterfaceBody;
    exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    exports.assertTSIntersectionType = assertTSIntersectionType;
    exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    exports.assertTSLiteralType = assertTSLiteralType;
    exports.assertTSMappedType = assertTSMappedType;
    exports.assertTSMethodSignature = assertTSMethodSignature;
    exports.assertTSModuleBlock = assertTSModuleBlock;
    exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
    exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
    exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    exports.assertTSNeverKeyword = assertTSNeverKeyword;
    exports.assertTSNonNullExpression = assertTSNonNullExpression;
    exports.assertTSNullKeyword = assertTSNullKeyword;
    exports.assertTSNumberKeyword = assertTSNumberKeyword;
    exports.assertTSObjectKeyword = assertTSObjectKeyword;
    exports.assertTSOptionalType = assertTSOptionalType;
    exports.assertTSParameterProperty = assertTSParameterProperty;
    exports.assertTSParenthesizedType = assertTSParenthesizedType;
    exports.assertTSPropertySignature = assertTSPropertySignature;
    exports.assertTSQualifiedName = assertTSQualifiedName;
    exports.assertTSRestType = assertTSRestType;
    exports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    exports.assertTSStringKeyword = assertTSStringKeyword;
    exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
    exports.assertTSTemplateLiteralType = assertTSTemplateLiteralType;
    exports.assertTSThisType = assertTSThisType;
    exports.assertTSTupleType = assertTSTupleType;
    exports.assertTSType = assertTSType;
    exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
    exports.assertTSTypeAssertion = assertTSTypeAssertion;
    exports.assertTSTypeElement = assertTSTypeElement;
    exports.assertTSTypeLiteral = assertTSTypeLiteral;
    exports.assertTSTypeOperator = assertTSTypeOperator;
    exports.assertTSTypeParameter = assertTSTypeParameter;
    exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    exports.assertTSTypePredicate = assertTSTypePredicate;
    exports.assertTSTypeQuery = assertTSTypeQuery;
    exports.assertTSTypeReference = assertTSTypeReference;
    exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    exports.assertTSUnionType = assertTSUnionType;
    exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
    exports.assertTSVoidKeyword = assertTSVoidKeyword;
    exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    exports.assertTemplateElement = assertTemplateElement;
    exports.assertTemplateLiteral = assertTemplateLiteral;
    exports.assertTerminatorless = assertTerminatorless;
    exports.assertThisExpression = assertThisExpression;
    exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
    exports.assertThrowStatement = assertThrowStatement;
    exports.assertTopicReference = assertTopicReference;
    exports.assertTryStatement = assertTryStatement;
    exports.assertTupleExpression = assertTupleExpression;
    exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    exports.assertTypeAlias = assertTypeAlias;
    exports.assertTypeAnnotation = assertTypeAnnotation;
    exports.assertTypeCastExpression = assertTypeCastExpression;
    exports.assertTypeParameter = assertTypeParameter;
    exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    exports.assertTypeScript = assertTypeScript;
    exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    exports.assertUnaryExpression = assertUnaryExpression;
    exports.assertUnaryLike = assertUnaryLike;
    exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    exports.assertUpdateExpression = assertUpdateExpression;
    exports.assertUserWhitespacable = assertUserWhitespacable;
    exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    exports.assertVariableDeclaration = assertVariableDeclaration;
    exports.assertVariableDeclarator = assertVariableDeclarator;
    exports.assertVariance = assertVariance;
    exports.assertVoidPattern = assertVoidPattern;
    exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    exports.assertWhile = assertWhile;
    exports.assertWhileStatement = assertWhileStatement;
    exports.assertWithStatement = assertWithStatement;
    exports.assertYieldExpression = assertYieldExpression;
    var _is = require_is(), _deprecationWarning = require_deprecationWarning();
    function assert(type, node, opts) {
      if (!(0, _is.default)(type, node, opts))
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
    }
    function assertArrayExpression(node, opts) {
      assert("ArrayExpression", node, opts);
    }
    function assertAssignmentExpression(node, opts) {
      assert("AssignmentExpression", node, opts);
    }
    function assertBinaryExpression(node, opts) {
      assert("BinaryExpression", node, opts);
    }
    function assertInterpreterDirective(node, opts) {
      assert("InterpreterDirective", node, opts);
    }
    function assertDirective(node, opts) {
      assert("Directive", node, opts);
    }
    function assertDirectiveLiteral(node, opts) {
      assert("DirectiveLiteral", node, opts);
    }
    function assertBlockStatement(node, opts) {
      assert("BlockStatement", node, opts);
    }
    function assertBreakStatement(node, opts) {
      assert("BreakStatement", node, opts);
    }
    function assertCallExpression(node, opts) {
      assert("CallExpression", node, opts);
    }
    function assertCatchClause(node, opts) {
      assert("CatchClause", node, opts);
    }
    function assertConditionalExpression(node, opts) {
      assert("ConditionalExpression", node, opts);
    }
    function assertContinueStatement(node, opts) {
      assert("ContinueStatement", node, opts);
    }
    function assertDebuggerStatement(node, opts) {
      assert("DebuggerStatement", node, opts);
    }
    function assertDoWhileStatement(node, opts) {
      assert("DoWhileStatement", node, opts);
    }
    function assertEmptyStatement(node, opts) {
      assert("EmptyStatement", node, opts);
    }
    function assertExpressionStatement(node, opts) {
      assert("ExpressionStatement", node, opts);
    }
    function assertFile(node, opts) {
      assert("File", node, opts);
    }
    function assertForInStatement(node, opts) {
      assert("ForInStatement", node, opts);
    }
    function assertForStatement(node, opts) {
      assert("ForStatement", node, opts);
    }
    function assertFunctionDeclaration(node, opts) {
      assert("FunctionDeclaration", node, opts);
    }
    function assertFunctionExpression(node, opts) {
      assert("FunctionExpression", node, opts);
    }
    function assertIdentifier(node, opts) {
      assert("Identifier", node, opts);
    }
    function assertIfStatement(node, opts) {
      assert("IfStatement", node, opts);
    }
    function assertLabeledStatement(node, opts) {
      assert("LabeledStatement", node, opts);
    }
    function assertStringLiteral(node, opts) {
      assert("StringLiteral", node, opts);
    }
    function assertNumericLiteral(node, opts) {
      assert("NumericLiteral", node, opts);
    }
    function assertNullLiteral(node, opts) {
      assert("NullLiteral", node, opts);
    }
    function assertBooleanLiteral(node, opts) {
      assert("BooleanLiteral", node, opts);
    }
    function assertRegExpLiteral(node, opts) {
      assert("RegExpLiteral", node, opts);
    }
    function assertLogicalExpression(node, opts) {
      assert("LogicalExpression", node, opts);
    }
    function assertMemberExpression(node, opts) {
      assert("MemberExpression", node, opts);
    }
    function assertNewExpression(node, opts) {
      assert("NewExpression", node, opts);
    }
    function assertProgram(node, opts) {
      assert("Program", node, opts);
    }
    function assertObjectExpression(node, opts) {
      assert("ObjectExpression", node, opts);
    }
    function assertObjectMethod(node, opts) {
      assert("ObjectMethod", node, opts);
    }
    function assertObjectProperty(node, opts) {
      assert("ObjectProperty", node, opts);
    }
    function assertRestElement(node, opts) {
      assert("RestElement", node, opts);
    }
    function assertReturnStatement(node, opts) {
      assert("ReturnStatement", node, opts);
    }
    function assertSequenceExpression(node, opts) {
      assert("SequenceExpression", node, opts);
    }
    function assertParenthesizedExpression(node, opts) {
      assert("ParenthesizedExpression", node, opts);
    }
    function assertSwitchCase(node, opts) {
      assert("SwitchCase", node, opts);
    }
    function assertSwitchStatement(node, opts) {
      assert("SwitchStatement", node, opts);
    }
    function assertThisExpression(node, opts) {
      assert("ThisExpression", node, opts);
    }
    function assertThrowStatement(node, opts) {
      assert("ThrowStatement", node, opts);
    }
    function assertTryStatement(node, opts) {
      assert("TryStatement", node, opts);
    }
    function assertUnaryExpression(node, opts) {
      assert("UnaryExpression", node, opts);
    }
    function assertUpdateExpression(node, opts) {
      assert("UpdateExpression", node, opts);
    }
    function assertVariableDeclaration(node, opts) {
      assert("VariableDeclaration", node, opts);
    }
    function assertVariableDeclarator(node, opts) {
      assert("VariableDeclarator", node, opts);
    }
    function assertWhileStatement(node, opts) {
      assert("WhileStatement", node, opts);
    }
    function assertWithStatement(node, opts) {
      assert("WithStatement", node, opts);
    }
    function assertAssignmentPattern(node, opts) {
      assert("AssignmentPattern", node, opts);
    }
    function assertArrayPattern(node, opts) {
      assert("ArrayPattern", node, opts);
    }
    function assertArrowFunctionExpression(node, opts) {
      assert("ArrowFunctionExpression", node, opts);
    }
    function assertClassBody(node, opts) {
      assert("ClassBody", node, opts);
    }
    function assertClassExpression(node, opts) {
      assert("ClassExpression", node, opts);
    }
    function assertClassDeclaration(node, opts) {
      assert("ClassDeclaration", node, opts);
    }
    function assertExportAllDeclaration(node, opts) {
      assert("ExportAllDeclaration", node, opts);
    }
    function assertExportDefaultDeclaration(node, opts) {
      assert("ExportDefaultDeclaration", node, opts);
    }
    function assertExportNamedDeclaration(node, opts) {
      assert("ExportNamedDeclaration", node, opts);
    }
    function assertExportSpecifier(node, opts) {
      assert("ExportSpecifier", node, opts);
    }
    function assertForOfStatement(node, opts) {
      assert("ForOfStatement", node, opts);
    }
    function assertImportDeclaration(node, opts) {
      assert("ImportDeclaration", node, opts);
    }
    function assertImportDefaultSpecifier(node, opts) {
      assert("ImportDefaultSpecifier", node, opts);
    }
    function assertImportNamespaceSpecifier(node, opts) {
      assert("ImportNamespaceSpecifier", node, opts);
    }
    function assertImportSpecifier(node, opts) {
      assert("ImportSpecifier", node, opts);
    }
    function assertImportExpression(node, opts) {
      assert("ImportExpression", node, opts);
    }
    function assertMetaProperty(node, opts) {
      assert("MetaProperty", node, opts);
    }
    function assertClassMethod(node, opts) {
      assert("ClassMethod", node, opts);
    }
    function assertObjectPattern(node, opts) {
      assert("ObjectPattern", node, opts);
    }
    function assertSpreadElement(node, opts) {
      assert("SpreadElement", node, opts);
    }
    function assertSuper(node, opts) {
      assert("Super", node, opts);
    }
    function assertTaggedTemplateExpression(node, opts) {
      assert("TaggedTemplateExpression", node, opts);
    }
    function assertTemplateElement(node, opts) {
      assert("TemplateElement", node, opts);
    }
    function assertTemplateLiteral(node, opts) {
      assert("TemplateLiteral", node, opts);
    }
    function assertYieldExpression(node, opts) {
      assert("YieldExpression", node, opts);
    }
    function assertAwaitExpression(node, opts) {
      assert("AwaitExpression", node, opts);
    }
    function assertImport(node, opts) {
      assert("Import", node, opts);
    }
    function assertBigIntLiteral(node, opts) {
      assert("BigIntLiteral", node, opts);
    }
    function assertExportNamespaceSpecifier(node, opts) {
      assert("ExportNamespaceSpecifier", node, opts);
    }
    function assertOptionalMemberExpression(node, opts) {
      assert("OptionalMemberExpression", node, opts);
    }
    function assertOptionalCallExpression(node, opts) {
      assert("OptionalCallExpression", node, opts);
    }
    function assertClassProperty(node, opts) {
      assert("ClassProperty", node, opts);
    }
    function assertClassAccessorProperty(node, opts) {
      assert("ClassAccessorProperty", node, opts);
    }
    function assertClassPrivateProperty(node, opts) {
      assert("ClassPrivateProperty", node, opts);
    }
    function assertClassPrivateMethod(node, opts) {
      assert("ClassPrivateMethod", node, opts);
    }
    function assertPrivateName(node, opts) {
      assert("PrivateName", node, opts);
    }
    function assertStaticBlock(node, opts) {
      assert("StaticBlock", node, opts);
    }
    function assertImportAttribute(node, opts) {
      assert("ImportAttribute", node, opts);
    }
    function assertAnyTypeAnnotation(node, opts) {
      assert("AnyTypeAnnotation", node, opts);
    }
    function assertArrayTypeAnnotation(node, opts) {
      assert("ArrayTypeAnnotation", node, opts);
    }
    function assertBooleanTypeAnnotation(node, opts) {
      assert("BooleanTypeAnnotation", node, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node, opts) {
      assert("BooleanLiteralTypeAnnotation", node, opts);
    }
    function assertNullLiteralTypeAnnotation(node, opts) {
      assert("NullLiteralTypeAnnotation", node, opts);
    }
    function assertClassImplements(node, opts) {
      assert("ClassImplements", node, opts);
    }
    function assertDeclareClass(node, opts) {
      assert("DeclareClass", node, opts);
    }
    function assertDeclareFunction(node, opts) {
      assert("DeclareFunction", node, opts);
    }
    function assertDeclareInterface(node, opts) {
      assert("DeclareInterface", node, opts);
    }
    function assertDeclareModule(node, opts) {
      assert("DeclareModule", node, opts);
    }
    function assertDeclareModuleExports(node, opts) {
      assert("DeclareModuleExports", node, opts);
    }
    function assertDeclareTypeAlias(node, opts) {
      assert("DeclareTypeAlias", node, opts);
    }
    function assertDeclareOpaqueType(node, opts) {
      assert("DeclareOpaqueType", node, opts);
    }
    function assertDeclareVariable(node, opts) {
      assert("DeclareVariable", node, opts);
    }
    function assertDeclareExportDeclaration(node, opts) {
      assert("DeclareExportDeclaration", node, opts);
    }
    function assertDeclareExportAllDeclaration(node, opts) {
      assert("DeclareExportAllDeclaration", node, opts);
    }
    function assertDeclaredPredicate(node, opts) {
      assert("DeclaredPredicate", node, opts);
    }
    function assertExistsTypeAnnotation(node, opts) {
      assert("ExistsTypeAnnotation", node, opts);
    }
    function assertFunctionTypeAnnotation(node, opts) {
      assert("FunctionTypeAnnotation", node, opts);
    }
    function assertFunctionTypeParam(node, opts) {
      assert("FunctionTypeParam", node, opts);
    }
    function assertGenericTypeAnnotation(node, opts) {
      assert("GenericTypeAnnotation", node, opts);
    }
    function assertInferredPredicate(node, opts) {
      assert("InferredPredicate", node, opts);
    }
    function assertInterfaceExtends(node, opts) {
      assert("InterfaceExtends", node, opts);
    }
    function assertInterfaceDeclaration(node, opts) {
      assert("InterfaceDeclaration", node, opts);
    }
    function assertInterfaceTypeAnnotation(node, opts) {
      assert("InterfaceTypeAnnotation", node, opts);
    }
    function assertIntersectionTypeAnnotation(node, opts) {
      assert("IntersectionTypeAnnotation", node, opts);
    }
    function assertMixedTypeAnnotation(node, opts) {
      assert("MixedTypeAnnotation", node, opts);
    }
    function assertEmptyTypeAnnotation(node, opts) {
      assert("EmptyTypeAnnotation", node, opts);
    }
    function assertNullableTypeAnnotation(node, opts) {
      assert("NullableTypeAnnotation", node, opts);
    }
    function assertNumberLiteralTypeAnnotation(node, opts) {
      assert("NumberLiteralTypeAnnotation", node, opts);
    }
    function assertNumberTypeAnnotation(node, opts) {
      assert("NumberTypeAnnotation", node, opts);
    }
    function assertObjectTypeAnnotation(node, opts) {
      assert("ObjectTypeAnnotation", node, opts);
    }
    function assertObjectTypeInternalSlot(node, opts) {
      assert("ObjectTypeInternalSlot", node, opts);
    }
    function assertObjectTypeCallProperty(node, opts) {
      assert("ObjectTypeCallProperty", node, opts);
    }
    function assertObjectTypeIndexer(node, opts) {
      assert("ObjectTypeIndexer", node, opts);
    }
    function assertObjectTypeProperty(node, opts) {
      assert("ObjectTypeProperty", node, opts);
    }
    function assertObjectTypeSpreadProperty(node, opts) {
      assert("ObjectTypeSpreadProperty", node, opts);
    }
    function assertOpaqueType(node, opts) {
      assert("OpaqueType", node, opts);
    }
    function assertQualifiedTypeIdentifier(node, opts) {
      assert("QualifiedTypeIdentifier", node, opts);
    }
    function assertStringLiteralTypeAnnotation(node, opts) {
      assert("StringLiteralTypeAnnotation", node, opts);
    }
    function assertStringTypeAnnotation(node, opts) {
      assert("StringTypeAnnotation", node, opts);
    }
    function assertSymbolTypeAnnotation(node, opts) {
      assert("SymbolTypeAnnotation", node, opts);
    }
    function assertThisTypeAnnotation(node, opts) {
      assert("ThisTypeAnnotation", node, opts);
    }
    function assertTupleTypeAnnotation(node, opts) {
      assert("TupleTypeAnnotation", node, opts);
    }
    function assertTypeofTypeAnnotation(node, opts) {
      assert("TypeofTypeAnnotation", node, opts);
    }
    function assertTypeAlias(node, opts) {
      assert("TypeAlias", node, opts);
    }
    function assertTypeAnnotation(node, opts) {
      assert("TypeAnnotation", node, opts);
    }
    function assertTypeCastExpression(node, opts) {
      assert("TypeCastExpression", node, opts);
    }
    function assertTypeParameter(node, opts) {
      assert("TypeParameter", node, opts);
    }
    function assertTypeParameterDeclaration(node, opts) {
      assert("TypeParameterDeclaration", node, opts);
    }
    function assertTypeParameterInstantiation(node, opts) {
      assert("TypeParameterInstantiation", node, opts);
    }
    function assertUnionTypeAnnotation(node, opts) {
      assert("UnionTypeAnnotation", node, opts);
    }
    function assertVariance(node, opts) {
      assert("Variance", node, opts);
    }
    function assertVoidTypeAnnotation(node, opts) {
      assert("VoidTypeAnnotation", node, opts);
    }
    function assertEnumDeclaration(node, opts) {
      assert("EnumDeclaration", node, opts);
    }
    function assertEnumBooleanBody(node, opts) {
      assert("EnumBooleanBody", node, opts);
    }
    function assertEnumNumberBody(node, opts) {
      assert("EnumNumberBody", node, opts);
    }
    function assertEnumStringBody(node, opts) {
      assert("EnumStringBody", node, opts);
    }
    function assertEnumSymbolBody(node, opts) {
      assert("EnumSymbolBody", node, opts);
    }
    function assertEnumBooleanMember(node, opts) {
      assert("EnumBooleanMember", node, opts);
    }
    function assertEnumNumberMember(node, opts) {
      assert("EnumNumberMember", node, opts);
    }
    function assertEnumStringMember(node, opts) {
      assert("EnumStringMember", node, opts);
    }
    function assertEnumDefaultedMember(node, opts) {
      assert("EnumDefaultedMember", node, opts);
    }
    function assertIndexedAccessType(node, opts) {
      assert("IndexedAccessType", node, opts);
    }
    function assertOptionalIndexedAccessType(node, opts) {
      assert("OptionalIndexedAccessType", node, opts);
    }
    function assertJSXAttribute(node, opts) {
      assert("JSXAttribute", node, opts);
    }
    function assertJSXClosingElement(node, opts) {
      assert("JSXClosingElement", node, opts);
    }
    function assertJSXElement(node, opts) {
      assert("JSXElement", node, opts);
    }
    function assertJSXEmptyExpression(node, opts) {
      assert("JSXEmptyExpression", node, opts);
    }
    function assertJSXExpressionContainer(node, opts) {
      assert("JSXExpressionContainer", node, opts);
    }
    function assertJSXSpreadChild(node, opts) {
      assert("JSXSpreadChild", node, opts);
    }
    function assertJSXIdentifier(node, opts) {
      assert("JSXIdentifier", node, opts);
    }
    function assertJSXMemberExpression(node, opts) {
      assert("JSXMemberExpression", node, opts);
    }
    function assertJSXNamespacedName(node, opts) {
      assert("JSXNamespacedName", node, opts);
    }
    function assertJSXOpeningElement(node, opts) {
      assert("JSXOpeningElement", node, opts);
    }
    function assertJSXSpreadAttribute(node, opts) {
      assert("JSXSpreadAttribute", node, opts);
    }
    function assertJSXText(node, opts) {
      assert("JSXText", node, opts);
    }
    function assertJSXFragment(node, opts) {
      assert("JSXFragment", node, opts);
    }
    function assertJSXOpeningFragment(node, opts) {
      assert("JSXOpeningFragment", node, opts);
    }
    function assertJSXClosingFragment(node, opts) {
      assert("JSXClosingFragment", node, opts);
    }
    function assertNoop(node, opts) {
      assert("Noop", node, opts);
    }
    function assertPlaceholder(node, opts) {
      assert("Placeholder", node, opts);
    }
    function assertV8IntrinsicIdentifier(node, opts) {
      assert("V8IntrinsicIdentifier", node, opts);
    }
    function assertArgumentPlaceholder(node, opts) {
      assert("ArgumentPlaceholder", node, opts);
    }
    function assertBindExpression(node, opts) {
      assert("BindExpression", node, opts);
    }
    function assertDecorator(node, opts) {
      assert("Decorator", node, opts);
    }
    function assertDoExpression(node, opts) {
      assert("DoExpression", node, opts);
    }
    function assertExportDefaultSpecifier(node, opts) {
      assert("ExportDefaultSpecifier", node, opts);
    }
    function assertRecordExpression(node, opts) {
      assert("RecordExpression", node, opts);
    }
    function assertTupleExpression(node, opts) {
      assert("TupleExpression", node, opts);
    }
    function assertDecimalLiteral(node, opts) {
      assert("DecimalLiteral", node, opts);
    }
    function assertModuleExpression(node, opts) {
      assert("ModuleExpression", node, opts);
    }
    function assertTopicReference(node, opts) {
      assert("TopicReference", node, opts);
    }
    function assertPipelineTopicExpression(node, opts) {
      assert("PipelineTopicExpression", node, opts);
    }
    function assertPipelineBareFunction(node, opts) {
      assert("PipelineBareFunction", node, opts);
    }
    function assertPipelinePrimaryTopicReference(node, opts) {
      assert("PipelinePrimaryTopicReference", node, opts);
    }
    function assertVoidPattern(node, opts) {
      assert("VoidPattern", node, opts);
    }
    function assertTSParameterProperty(node, opts) {
      assert("TSParameterProperty", node, opts);
    }
    function assertTSDeclareFunction(node, opts) {
      assert("TSDeclareFunction", node, opts);
    }
    function assertTSDeclareMethod(node, opts) {
      assert("TSDeclareMethod", node, opts);
    }
    function assertTSQualifiedName(node, opts) {
      assert("TSQualifiedName", node, opts);
    }
    function assertTSCallSignatureDeclaration(node, opts) {
      assert("TSCallSignatureDeclaration", node, opts);
    }
    function assertTSConstructSignatureDeclaration(node, opts) {
      assert("TSConstructSignatureDeclaration", node, opts);
    }
    function assertTSPropertySignature(node, opts) {
      assert("TSPropertySignature", node, opts);
    }
    function assertTSMethodSignature(node, opts) {
      assert("TSMethodSignature", node, opts);
    }
    function assertTSIndexSignature(node, opts) {
      assert("TSIndexSignature", node, opts);
    }
    function assertTSAnyKeyword(node, opts) {
      assert("TSAnyKeyword", node, opts);
    }
    function assertTSBooleanKeyword(node, opts) {
      assert("TSBooleanKeyword", node, opts);
    }
    function assertTSBigIntKeyword(node, opts) {
      assert("TSBigIntKeyword", node, opts);
    }
    function assertTSIntrinsicKeyword(node, opts) {
      assert("TSIntrinsicKeyword", node, opts);
    }
    function assertTSNeverKeyword(node, opts) {
      assert("TSNeverKeyword", node, opts);
    }
    function assertTSNullKeyword(node, opts) {
      assert("TSNullKeyword", node, opts);
    }
    function assertTSNumberKeyword(node, opts) {
      assert("TSNumberKeyword", node, opts);
    }
    function assertTSObjectKeyword(node, opts) {
      assert("TSObjectKeyword", node, opts);
    }
    function assertTSStringKeyword(node, opts) {
      assert("TSStringKeyword", node, opts);
    }
    function assertTSSymbolKeyword(node, opts) {
      assert("TSSymbolKeyword", node, opts);
    }
    function assertTSUndefinedKeyword(node, opts) {
      assert("TSUndefinedKeyword", node, opts);
    }
    function assertTSUnknownKeyword(node, opts) {
      assert("TSUnknownKeyword", node, opts);
    }
    function assertTSVoidKeyword(node, opts) {
      assert("TSVoidKeyword", node, opts);
    }
    function assertTSThisType(node, opts) {
      assert("TSThisType", node, opts);
    }
    function assertTSFunctionType(node, opts) {
      assert("TSFunctionType", node, opts);
    }
    function assertTSConstructorType(node, opts) {
      assert("TSConstructorType", node, opts);
    }
    function assertTSTypeReference(node, opts) {
      assert("TSTypeReference", node, opts);
    }
    function assertTSTypePredicate(node, opts) {
      assert("TSTypePredicate", node, opts);
    }
    function assertTSTypeQuery(node, opts) {
      assert("TSTypeQuery", node, opts);
    }
    function assertTSTypeLiteral(node, opts) {
      assert("TSTypeLiteral", node, opts);
    }
    function assertTSArrayType(node, opts) {
      assert("TSArrayType", node, opts);
    }
    function assertTSTupleType(node, opts) {
      assert("TSTupleType", node, opts);
    }
    function assertTSOptionalType(node, opts) {
      assert("TSOptionalType", node, opts);
    }
    function assertTSRestType(node, opts) {
      assert("TSRestType", node, opts);
    }
    function assertTSNamedTupleMember(node, opts) {
      assert("TSNamedTupleMember", node, opts);
    }
    function assertTSUnionType(node, opts) {
      assert("TSUnionType", node, opts);
    }
    function assertTSIntersectionType(node, opts) {
      assert("TSIntersectionType", node, opts);
    }
    function assertTSConditionalType(node, opts) {
      assert("TSConditionalType", node, opts);
    }
    function assertTSInferType(node, opts) {
      assert("TSInferType", node, opts);
    }
    function assertTSParenthesizedType(node, opts) {
      assert("TSParenthesizedType", node, opts);
    }
    function assertTSTypeOperator(node, opts) {
      assert("TSTypeOperator", node, opts);
    }
    function assertTSIndexedAccessType(node, opts) {
      assert("TSIndexedAccessType", node, opts);
    }
    function assertTSMappedType(node, opts) {
      assert("TSMappedType", node, opts);
    }
    function assertTSTemplateLiteralType(node, opts) {
      assert("TSTemplateLiteralType", node, opts);
    }
    function assertTSLiteralType(node, opts) {
      assert("TSLiteralType", node, opts);
    }
    function assertTSExpressionWithTypeArguments(node, opts) {
      assert("TSExpressionWithTypeArguments", node, opts);
    }
    function assertTSInterfaceDeclaration(node, opts) {
      assert("TSInterfaceDeclaration", node, opts);
    }
    function assertTSInterfaceBody(node, opts) {
      assert("TSInterfaceBody", node, opts);
    }
    function assertTSTypeAliasDeclaration(node, opts) {
      assert("TSTypeAliasDeclaration", node, opts);
    }
    function assertTSInstantiationExpression(node, opts) {
      assert("TSInstantiationExpression", node, opts);
    }
    function assertTSAsExpression(node, opts) {
      assert("TSAsExpression", node, opts);
    }
    function assertTSSatisfiesExpression(node, opts) {
      assert("TSSatisfiesExpression", node, opts);
    }
    function assertTSTypeAssertion(node, opts) {
      assert("TSTypeAssertion", node, opts);
    }
    function assertTSEnumBody(node, opts) {
      assert("TSEnumBody", node, opts);
    }
    function assertTSEnumDeclaration(node, opts) {
      assert("TSEnumDeclaration", node, opts);
    }
    function assertTSEnumMember(node, opts) {
      assert("TSEnumMember", node, opts);
    }
    function assertTSModuleDeclaration(node, opts) {
      assert("TSModuleDeclaration", node, opts);
    }
    function assertTSModuleBlock(node, opts) {
      assert("TSModuleBlock", node, opts);
    }
    function assertTSImportType(node, opts) {
      assert("TSImportType", node, opts);
    }
    function assertTSImportEqualsDeclaration(node, opts) {
      assert("TSImportEqualsDeclaration", node, opts);
    }
    function assertTSExternalModuleReference(node, opts) {
      assert("TSExternalModuleReference", node, opts);
    }
    function assertTSNonNullExpression(node, opts) {
      assert("TSNonNullExpression", node, opts);
    }
    function assertTSExportAssignment(node, opts) {
      assert("TSExportAssignment", node, opts);
    }
    function assertTSNamespaceExportDeclaration(node, opts) {
      assert("TSNamespaceExportDeclaration", node, opts);
    }
    function assertTSTypeAnnotation(node, opts) {
      assert("TSTypeAnnotation", node, opts);
    }
    function assertTSTypeParameterInstantiation(node, opts) {
      assert("TSTypeParameterInstantiation", node, opts);
    }
    function assertTSTypeParameterDeclaration(node, opts) {
      assert("TSTypeParameterDeclaration", node, opts);
    }
    function assertTSTypeParameter(node, opts) {
      assert("TSTypeParameter", node, opts);
    }
    function assertStandardized(node, opts) {
      assert("Standardized", node, opts);
    }
    function assertExpression(node, opts) {
      assert("Expression", node, opts);
    }
    function assertBinary(node, opts) {
      assert("Binary", node, opts);
    }
    function assertScopable(node, opts) {
      assert("Scopable", node, opts);
    }
    function assertBlockParent(node, opts) {
      assert("BlockParent", node, opts);
    }
    function assertBlock(node, opts) {
      assert("Block", node, opts);
    }
    function assertStatement(node, opts) {
      assert("Statement", node, opts);
    }
    function assertTerminatorless(node, opts) {
      assert("Terminatorless", node, opts);
    }
    function assertCompletionStatement(node, opts) {
      assert("CompletionStatement", node, opts);
    }
    function assertConditional(node, opts) {
      assert("Conditional", node, opts);
    }
    function assertLoop(node, opts) {
      assert("Loop", node, opts);
    }
    function assertWhile(node, opts) {
      assert("While", node, opts);
    }
    function assertExpressionWrapper(node, opts) {
      assert("ExpressionWrapper", node, opts);
    }
    function assertFor(node, opts) {
      assert("For", node, opts);
    }
    function assertForXStatement(node, opts) {
      assert("ForXStatement", node, opts);
    }
    function assertFunction(node, opts) {
      assert("Function", node, opts);
    }
    function assertFunctionParent(node, opts) {
      assert("FunctionParent", node, opts);
    }
    function assertPureish(node, opts) {
      assert("Pureish", node, opts);
    }
    function assertDeclaration(node, opts) {
      assert("Declaration", node, opts);
    }
    function assertFunctionParameter(node, opts) {
      assert("FunctionParameter", node, opts);
    }
    function assertPatternLike(node, opts) {
      assert("PatternLike", node, opts);
    }
    function assertLVal(node, opts) {
      assert("LVal", node, opts);
    }
    function assertTSEntityName(node, opts) {
      assert("TSEntityName", node, opts);
    }
    function assertLiteral(node, opts) {
      assert("Literal", node, opts);
    }
    function assertImmutable(node, opts) {
      assert("Immutable", node, opts);
    }
    function assertUserWhitespacable(node, opts) {
      assert("UserWhitespacable", node, opts);
    }
    function assertMethod(node, opts) {
      assert("Method", node, opts);
    }
    function assertObjectMember(node, opts) {
      assert("ObjectMember", node, opts);
    }
    function assertProperty(node, opts) {
      assert("Property", node, opts);
    }
    function assertUnaryLike(node, opts) {
      assert("UnaryLike", node, opts);
    }
    function assertPattern(node, opts) {
      assert("Pattern", node, opts);
    }
    function assertClass(node, opts) {
      assert("Class", node, opts);
    }
    function assertImportOrExportDeclaration(node, opts) {
      assert("ImportOrExportDeclaration", node, opts);
    }
    function assertExportDeclaration(node, opts) {
      assert("ExportDeclaration", node, opts);
    }
    function assertModuleSpecifier(node, opts) {
      assert("ModuleSpecifier", node, opts);
    }
    function assertAccessor(node, opts) {
      assert("Accessor", node, opts);
    }
    function assertPrivate(node, opts) {
      assert("Private", node, opts);
    }
    function assertFlow(node, opts) {
      assert("Flow", node, opts);
    }
    function assertFlowType(node, opts) {
      assert("FlowType", node, opts);
    }
    function assertFlowBaseAnnotation(node, opts) {
      assert("FlowBaseAnnotation", node, opts);
    }
    function assertFlowDeclaration(node, opts) {
      assert("FlowDeclaration", node, opts);
    }
    function assertFlowPredicate(node, opts) {
      assert("FlowPredicate", node, opts);
    }
    function assertEnumBody(node, opts) {
      assert("EnumBody", node, opts);
    }
    function assertEnumMember(node, opts) {
      assert("EnumMember", node, opts);
    }
    function assertJSX(node, opts) {
      assert("JSX", node, opts);
    }
    function assertMiscellaneous(node, opts) {
      assert("Miscellaneous", node, opts);
    }
    function assertTypeScript(node, opts) {
      assert("TypeScript", node, opts);
    }
    function assertTSTypeElement(node, opts) {
      assert("TSTypeElement", node, opts);
    }
    function assertTSType(node, opts) {
      assert("TSType", node, opts);
    }
    function assertTSBaseType(node, opts) {
      assert("TSBaseType", node, opts);
    }
    function assertNumberLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral"), assert("NumberLiteral", node, opts);
    }
    function assertRegexLiteral(node, opts) {
      (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral"), assert("RegexLiteral", node, opts);
    }
    function assertRestProperty(node, opts) {
      (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement"), assert("RestProperty", node, opts);
    }
    function assertSpreadProperty(node, opts) {
      (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement"), assert("SpreadProperty", node, opts);
    }
    function assertModuleDeclaration(node, opts) {
      (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), assert("ModuleDeclaration", node, opts);
    }
  }
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
  "../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _index = require_generated2(), _default = exports.default = createTypeAnnotationBasedOnTypeof;
    function createTypeAnnotationBasedOnTypeof(type) {
      switch (type) {
        case "string":
          return (0, _index.stringTypeAnnotation)();
        case "number":
          return (0, _index.numberTypeAnnotation)();
        case "undefined":
          return (0, _index.voidTypeAnnotation)();
        case "boolean":
          return (0, _index.booleanTypeAnnotation)();
        case "function":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
        case "object":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
        case "symbol":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
        case "bigint":
          return (0, _index.anyTypeAnnotation)();
      }
      throw new Error("Invalid typeof value: " + type);
    }
  }
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
  "../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node) {
      return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      let nodes = Array.from(nodesIn), generics = /* @__PURE__ */ new Map(), bases = /* @__PURE__ */ new Map(), typeGroups = /* @__PURE__ */ new Set(), types2 = [];
      for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        if (node && !types2.includes(node)) {
          if ((0, _index.isAnyTypeAnnotation)(node))
            return [node];
          if ((0, _index.isFlowBaseAnnotation)(node)) {
            bases.set(node.type, node);
            continue;
          }
          if ((0, _index.isUnionTypeAnnotation)(node)) {
            typeGroups.has(node.types) || (nodes.push(...node.types), typeGroups.add(node.types));
            continue;
          }
          if ((0, _index.isGenericTypeAnnotation)(node)) {
            let name = getQualifiedName(node.id);
            if (generics.has(name)) {
              let existing = generics.get(name);
              existing.typeParameters ? node.typeParameters && (existing.typeParameters.params.push(...node.typeParameters.params), existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params)) : existing = node.typeParameters;
            } else
              generics.set(name, node);
            continue;
          }
          types2.push(node);
        }
      }
      for (let [, baseType] of bases)
        types2.push(baseType);
      for (let [, genericName] of generics)
        types2.push(genericName);
      return types2;
    }
  }
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
  "../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = createFlowUnionType;
    var _index = require_generated2(), _removeTypeDuplicates = require_removeTypeDuplicates();
    function createFlowUnionType(types2) {
      let flattened = (0, _removeTypeDuplicates.default)(types2);
      return flattened.length === 1 ? flattened[0] : (0, _index.unionTypeAnnotation)(flattened);
    }
  }
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
  "../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node) {
      return (0, _index.isIdentifier)(node) ? node.name : (0, _index.isThisExpression)(node) ? "this" : `${node.right.name}.${getQualifiedName(node.left)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      let nodes = Array.from(nodesIn), generics = /* @__PURE__ */ new Map(), bases = /* @__PURE__ */ new Map(), typeGroups = /* @__PURE__ */ new Set(), types2 = [];
      for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        if (!node || types2.includes(node))
          continue;
        if ((0, _index.isTSAnyKeyword)(node))
          return [node];
        if ((0, _index.isTSBaseType)(node)) {
          bases.set(node.type, node);
          continue;
        }
        if ((0, _index.isTSUnionType)(node)) {
          typeGroups.has(node.types) || (nodes.push(...node.types), typeGroups.add(node.types));
          continue;
        }
        let typeArgumentsKey = "typeParameters";
        if ((0, _index.isTSTypeReference)(node) && node[typeArgumentsKey]) {
          let typeArguments = node[typeArgumentsKey], name = getQualifiedName(node.typeName);
          if (generics.has(name)) {
            let existing = generics.get(name), existingTypeArguments = existing[typeArgumentsKey];
            existingTypeArguments ? (existingTypeArguments.params.push(...typeArguments.params), existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params)) : existing = typeArguments;
          } else
            generics.set(name, node);
          continue;
        }
        types2.push(node);
      }
      for (let [, baseType] of bases)
        types2.push(baseType);
      for (let [, genericName] of generics)
        types2.push(genericName);
      return types2;
    }
  }
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
  "../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = createTSUnionType;
    var _index = require_generated2(), _removeTypeDuplicates = require_removeTypeDuplicates2(), _index2 = require_generated();
    function createTSUnionType(typeAnnotations) {
      let types2 = typeAnnotations.map((type) => (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type), flattened = (0, _removeTypeDuplicates.default)(types2);
      return flattened.length === 1 ? flattened[0] : (0, _index.tsUnionType)(flattened);
    }
  }
});

// ../node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS({
  "../node_modules/@babel/types/lib/builders/productions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.buildUndefinedNode = buildUndefinedNode;
    var _index = require_generated2();
    function buildUndefinedNode() {
      return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), !0);
    }
  }
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
  "../node_modules/@babel/types/lib/clone/cloneNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = cloneNode;
    var _index = require_definitions(), _index2 = require_generated(), {
      hasOwn
    } = {
      hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
    };
    function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
      return obj && typeof obj.type == "string" ? cloneNodeInternal(obj, deep, withoutLoc, commentsCache) : obj;
    }
    function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
      return Array.isArray(obj) ? obj.map((node) => cloneIfNode(node, deep, withoutLoc, commentsCache)) : cloneIfNode(obj, deep, withoutLoc, commentsCache);
    }
    function cloneNode(node, deep = !0, withoutLoc = !1) {
      return cloneNodeInternal(node, deep, withoutLoc, /* @__PURE__ */ new Map());
    }
    function cloneNodeInternal(node, deep = !0, withoutLoc = !1, commentsCache) {
      if (!node) return node;
      let {
        type
      } = node, newNode = {
        type: node.type
      };
      if ((0, _index2.isIdentifier)(node))
        newNode.name = node.name, hasOwn(node, "optional") && typeof node.optional == "boolean" && (newNode.optional = node.optional), hasOwn(node, "typeAnnotation") && (newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, !0, withoutLoc, commentsCache) : node.typeAnnotation), hasOwn(node, "decorators") && (newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, !0, withoutLoc, commentsCache) : node.decorators);
      else if (hasOwn(_index.NODE_FIELDS, type))
        for (let field of Object.keys(_index.NODE_FIELDS[type]))
          hasOwn(node, field) && (deep ? newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], !0, withoutLoc, commentsCache) : newNode[field] = node[field]);
      else
        throw new Error(`Unknown node type: "${type}"`);
      return hasOwn(node, "loc") && (withoutLoc ? newNode.loc = null : newNode.loc = node.loc), hasOwn(node, "leadingComments") && (newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache)), hasOwn(node, "innerComments") && (newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache)), hasOwn(node, "trailingComments") && (newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache)), hasOwn(node, "extra") && (newNode.extra = Object.assign({}, node.extra)), newNode;
    }
    function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
      return !comments || !deep ? comments : comments.map((comment) => {
        let cache = commentsCache.get(comment);
        if (cache) return cache;
        let {
          type,
          value: value2,
          loc
        } = comment, ret = {
          type,
          value: value2,
          loc
        };
        return withoutLoc && (ret.loc = null), commentsCache.set(comment, ret), ret;
      });
    }
  }
});

// ../node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS({
  "../node_modules/@babel/types/lib/clone/clone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = clone;
    var _cloneNode = require_cloneNode();
    function clone(node) {
      return (0, _cloneNode.default)(node, !1);
    }
  }
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
  "../node_modules/@babel/types/lib/clone/cloneDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = cloneDeep;
    var _cloneNode = require_cloneNode();
    function cloneDeep(node) {
      return (0, _cloneNode.default)(node);
    }
  }
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
  "../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = cloneDeepWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneDeepWithoutLoc(node) {
      return (0, _cloneNode.default)(node, !0, !0);
    }
  }
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
  "../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = cloneWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneWithoutLoc(node) {
      return (0, _cloneNode.default)(node, !1, !0);
    }
  }
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
  "../node_modules/@babel/types/lib/comments/addComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = addComments;
    function addComments(node, type, comments) {
      if (!comments || !node) return node;
      let key = `${type}Comments`;
      return node[key] ? type === "leading" ? node[key] = comments.concat(node[key]) : node[key].push(...comments) : node[key] = comments, node;
    }
  }
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
  "../node_modules/@babel/types/lib/comments/addComment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = addComment;
    var _addComments = require_addComments();
    function addComment(node, type, content, line) {
      return (0, _addComments.default)(node, type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }
  }
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
  "../node_modules/@babel/types/lib/utils/inherit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = inherit;
    function inherit(key, child, parent) {
      child && parent && (child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean))));
    }
  }
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
  "../node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = inheritInnerComments;
    var _inherit = require_inherit();
    function inheritInnerComments(child, parent) {
      (0, _inherit.default)("innerComments", child, parent);
    }
  }
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
  "../node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = inheritLeadingComments;
    var _inherit = require_inherit();
    function inheritLeadingComments(child, parent) {
      (0, _inherit.default)("leadingComments", child, parent);
    }
  }
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
  "../node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = inheritTrailingComments;
    var _inherit = require_inherit();
    function inheritTrailingComments(child, parent) {
      (0, _inherit.default)("trailingComments", child, parent);
    }
  }
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
  "../node_modules/@babel/types/lib/comments/inheritsComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = inheritsComments;
    var _inheritTrailingComments = require_inheritTrailingComments(), _inheritLeadingComments = require_inheritLeadingComments(), _inheritInnerComments = require_inheritInnerComments();
    function inheritsComments(child, parent) {
      return (0, _inheritTrailingComments.default)(child, parent), (0, _inheritLeadingComments.default)(child, parent), (0, _inheritInnerComments.default)(child, parent), child;
    }
  }
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
  "../node_modules/@babel/types/lib/comments/removeComments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = removeComments;
    var _index = require_constants();
    function removeComments(node) {
      return _index.COMMENT_KEYS.forEach((key) => {
        node[key] = null;
      }), node;
    }
  }
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
  "../node_modules/@babel/types/lib/constants/generated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTIONPARAMETER_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
    var _index = require_definitions(), STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS.Standardized, EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS.Expression, BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS.Binary, SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS.Scopable, BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS.BlockParent, BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS.Block, STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS.Statement, TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS.Terminatorless, COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS.CompletionStatement, CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS.Conditional, LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS.Loop, WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS.While, EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS.ExpressionWrapper, FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS.For, FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS.ForXStatement, FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS.Function, FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS.FunctionParent, PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS.Pureish, DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS.Declaration, FUNCTIONPARAMETER_TYPES = exports.FUNCTIONPARAMETER_TYPES = _index.FLIPPED_ALIAS_KEYS.FunctionParameter, PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS.PatternLike, LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS.LVal, TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS.TSEntityName, LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS.Literal, IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS.Immutable, USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS.UserWhitespacable, METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS.Method, OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS.ObjectMember, PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS.Property, UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS.UnaryLike, PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS.Pattern, CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS.Class, IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS.ExportDeclaration, MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS.ModuleSpecifier, ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS.Accessor, PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS.Private, FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS.Flow, FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS.FlowType, FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS.FlowDeclaration, FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS.FlowPredicate, ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS.EnumBody, ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS.EnumMember, JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS.JSX, MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS.Miscellaneous, TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS.TypeScript, TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS.TSTypeElement, TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS.TSType, TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS.TSBaseType, MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
  }
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
  "../node_modules/@babel/types/lib/converters/toBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = toBlock;
    var _index = require_generated(), _index2 = require_generated2();
    function toBlock(node, parent) {
      if ((0, _index.isBlockStatement)(node))
        return node;
      let blockNodes = [];
      return (0, _index.isEmptyStatement)(node) ? blockNodes = [] : ((0, _index.isStatement)(node) || ((0, _index.isFunction)(parent) ? node = (0, _index2.returnStatement)(node) : node = (0, _index2.expressionStatement)(node)), blockNodes = [node]), (0, _index2.blockStatement)(blockNodes);
    }
  }
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
  "../node_modules/@babel/types/lib/converters/ensureBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = ensureBlock;
    var _toBlock = require_toBlock();
    function ensureBlock(node, key = "body") {
      let result = (0, _toBlock.default)(node[key], node);
      return node[key] = result, result;
    }
  }
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
  "../node_modules/@babel/types/lib/converters/toIdentifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = toIdentifier;
    var _isValidIdentifier = require_isValidIdentifier(), _helperValidatorIdentifier = require_lib2();
    function toIdentifier(input) {
      input = input + "";
      let name = "";
      for (let c of input)
        name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
      return name = name.replace(/^[-0-9]+/, ""), name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
      }), (0, _isValidIdentifier.default)(name) || (name = `_${name}`), name || "_";
    }
  }
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
  "../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = toBindingIdentifierName;
    var _toIdentifier = require_toIdentifier();
    function toBindingIdentifierName(name) {
      return name = (0, _toIdentifier.default)(name), (name === "eval" || name === "arguments") && (name = "_" + name), name;
    }
  }
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
  "../node_modules/@babel/types/lib/converters/toComputedKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = toComputedKey;
    var _index = require_generated(), _index2 = require_generated2();
    function toComputedKey(node, key = node.key || node.property) {
      return !node.computed && (0, _index.isIdentifier)(key) && (key = (0, _index2.stringLiteral)(key.name)), key;
    }
  }
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
  "../node_modules/@babel/types/lib/converters/toExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _index = require_generated(), _default = exports.default = toExpression;
    function toExpression(node) {
      if ((0, _index.isExpressionStatement)(node) && (node = node.expression), (0, _index.isExpression)(node))
        return node;
      if ((0, _index.isClass)(node) ? (node.type = "ClassExpression", node.abstract = !1) : (0, _index.isFunction)(node) && (node.type = "FunctionExpression"), !(0, _index.isExpression)(node))
        throw new Error(`cannot turn ${node.type} to an expression`);
      return node;
    }
  }
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
  "../node_modules/@babel/types/lib/traverse/traverseFast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = traverseFast;
    var _index = require_definitions(), _skip = Symbol(), _stop = Symbol();
    function traverseFast(node, enter, opts) {
      if (!node) return !1;
      let keys = _index.VISITOR_KEYS[node.type];
      if (!keys) return !1;
      opts = opts || {};
      let ret = enter(node, opts);
      if (ret !== void 0)
        switch (ret) {
          case _skip:
            return !1;
          case _stop:
            return !0;
        }
      for (let key of keys) {
        let subNode = node[key];
        if (subNode) {
          if (Array.isArray(subNode)) {
            for (let node2 of subNode)
              if (traverseFast(node2, enter, opts)) return !0;
          } else if (traverseFast(subNode, enter, opts)) return !0;
        }
      }
      return !1;
    }
    traverseFast.skip = _skip;
    traverseFast.stop = _stop;
  }
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
  "../node_modules/@babel/types/lib/modifications/removeProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = removeProperties;
    var _index = require_constants(), CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"], CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
    function removeProperties(node, opts = {}) {
      let map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (let key of map)
        node[key] != null && (node[key] = void 0);
      for (let key of Object.keys(node))
        key[0] === "_" && node[key] != null && (node[key] = void 0);
      let symbols = Object.getOwnPropertySymbols(node);
      for (let sym of symbols)
        node[sym] = null;
    }
  }
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
  "../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = removePropertiesDeep;
    var _traverseFast = require_traverseFast(), _removeProperties = require_removeProperties();
    function removePropertiesDeep(tree, opts) {
      return (0, _traverseFast.default)(tree, _removeProperties.default, opts), tree;
    }
  }
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
  "../node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = toKeyAlias;
    var _index = require_generated(), _cloneNode = require_cloneNode(), _removePropertiesDeep = require_removePropertiesDeep();
    function toKeyAlias(node, key = node.key) {
      let alias;
      return node.kind === "method" ? toKeyAlias.increment() + "" : ((0, _index.isIdentifier)(key) ? alias = key.name : (0, _index.isStringLiteral)(key) ? alias = JSON.stringify(key.value) : alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key))), node.computed && (alias = `[${alias}]`), node.static && (alias = `static:${alias}`), alias);
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++;
    };
  }
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
  "../node_modules/@babel/types/lib/converters/toStatement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _index = require_generated(), _index2 = require_generated2(), _default = exports.default = toStatement;
    function toStatement(node, ignore) {
      if ((0, _index.isStatement)(node))
        return node;
      let mustHaveId = !1, newType;
      if ((0, _index.isClass)(node))
        mustHaveId = !0, newType = "ClassDeclaration";
      else if ((0, _index.isFunction)(node))
        mustHaveId = !0, newType = "FunctionDeclaration";
      else if ((0, _index.isAssignmentExpression)(node))
        return (0, _index2.expressionStatement)(node);
      if (mustHaveId && !node.id && (newType = !1), !newType) {
        if (ignore)
          return !1;
        throw new Error(`cannot turn ${node.type} to a statement`);
      }
      return node.type = newType, node;
    }
  }
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
  "../node_modules/@babel/types/lib/converters/valueToNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _isValidIdentifier = require_isValidIdentifier(), _index = require_generated2(), _default = exports.default = valueToNode, objectToString = Function.call.bind(Object.prototype.toString);
    function isRegExp(value2) {
      return objectToString(value2) === "[object RegExp]";
    }
    function isPlainObject(value2) {
      if (typeof value2 != "object" || value2 === null || Object.prototype.toString.call(value2) !== "[object Object]")
        return !1;
      let proto = Object.getPrototypeOf(value2);
      return proto === null || Object.getPrototypeOf(proto) === null;
    }
    function valueToNode(value2) {
      if (value2 === void 0)
        return (0, _index.identifier)("undefined");
      if (value2 === !0 || value2 === !1)
        return (0, _index.booleanLiteral)(value2);
      if (value2 === null)
        return (0, _index.nullLiteral)();
      if (typeof value2 == "string")
        return (0, _index.stringLiteral)(value2);
      if (typeof value2 == "number") {
        let result;
        if (Number.isFinite(value2))
          result = (0, _index.numericLiteral)(Math.abs(value2));
        else {
          let numerator;
          Number.isNaN(value2) ? numerator = (0, _index.numericLiteral)(0) : numerator = (0, _index.numericLiteral)(1), result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
        }
        return (value2 < 0 || Object.is(value2, -0)) && (result = (0, _index.unaryExpression)("-", result)), result;
      }
      if (typeof value2 == "bigint")
        return value2 < 0 ? (0, _index.unaryExpression)("-", (0, _index.bigIntLiteral)(-value2)) : (0, _index.bigIntLiteral)(value2);
      if (isRegExp(value2)) {
        let pattern = value2.source, flags = /\/([a-z]*)$/.exec(value2.toString())[1];
        return (0, _index.regExpLiteral)(pattern, flags);
      }
      if (Array.isArray(value2))
        return (0, _index.arrayExpression)(value2.map(valueToNode));
      if (isPlainObject(value2)) {
        let props = [];
        for (let key of Object.keys(value2)) {
          let nodeKey, computed = !1;
          (0, _isValidIdentifier.default)(key) ? key === "__proto__" ? (computed = !0, nodeKey = (0, _index.stringLiteral)(key)) : nodeKey = (0, _index.identifier)(key) : nodeKey = (0, _index.stringLiteral)(key), props.push((0, _index.objectProperty)(nodeKey, valueToNode(value2[key]), computed));
        }
        return (0, _index.objectExpression)(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
  }
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
  "../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = appendToMemberExpression;
    var _index = require_generated2();
    function appendToMemberExpression(member, append, computed = !1) {
      return member.object = (0, _index.memberExpression)(member.object, member.property, member.computed), member.property = append, member.computed = !!computed, member;
    }
  }
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS({
  "../node_modules/@babel/types/lib/modifications/inherits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = inherits;
    var _index = require_constants(), _inheritsComments = require_inheritsComments();
    function inherits(child, parent) {
      if (!child || !parent) return child;
      for (let key of _index.INHERIT_KEYS.optional)
        child[key] == null && (child[key] = parent[key]);
      for (let key of Object.keys(parent))
        key[0] === "_" && key !== "__clone" && (child[key] = parent[key]);
      for (let key of _index.INHERIT_KEYS.force)
        child[key] = parent[key];
      return (0, _inheritsComments.default)(child, parent), child;
    }
  }
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
  "../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = prependToMemberExpression;
    var _index = require_generated2(), _index2 = require_lib4();
    function prependToMemberExpression(member, prepend) {
      if ((0, _index2.isSuper)(member.object))
        throw new Error("Cannot prepend node to super property access (`super.foo`).");
      return member.object = (0, _index.memberExpression)(prepend, member.object), member;
    }
  }
});

// ../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var require_getAssignmentIdentifiers = __commonJS({
  "../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = getAssignmentIdentifiers;
    function getAssignmentIdentifiers(node) {
      let search = [].concat(node), ids = /* @__PURE__ */ Object.create(null);
      for (; search.length; ) {
        let id = search.pop();
        if (id)
          switch (id.type) {
            case "ArrayPattern":
              search.push(...id.elements);
              break;
            case "AssignmentExpression":
            case "AssignmentPattern":
            case "ForInStatement":
            case "ForOfStatement":
              search.push(id.left);
              break;
            case "ObjectPattern":
              search.push(...id.properties);
              break;
            case "ObjectProperty":
              search.push(id.value);
              break;
            case "RestElement":
            case "UpdateExpression":
              search.push(id.argument);
              break;
            case "UnaryExpression":
              id.operator === "delete" && search.push(id.argument);
              break;
            case "Identifier":
              ids[id.name] = id;
              break;
            default:
              break;
          }
      }
      return ids;
    }
  }
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
  "../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = getBindingIdentifiers;
    var _index = require_generated();
    function getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {
      let search = [].concat(node), ids = /* @__PURE__ */ Object.create(null);
      for (; search.length; ) {
        let id = search.shift();
        if (!id || newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id)))
          continue;
        if ((0, _index.isIdentifier)(id)) {
          duplicates ? (ids[id.name] = ids[id.name] || []).push(id) : ids[id.name] = id;
          continue;
        }
        if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
          (0, _index.isDeclaration)(id.declaration) && search.push(id.declaration);
          continue;
        }
        if (outerOnly) {
          if ((0, _index.isFunctionDeclaration)(id)) {
            search.push(id.id);
            continue;
          }
          if ((0, _index.isFunctionExpression)(id))
            continue;
        }
        let keys2 = getBindingIdentifiers.keys[id.type];
        if (keys2)
          for (let i = 0; i < keys2.length; i++) {
            let key = keys2[i], nodes = id[key];
            nodes && (Array.isArray(nodes) ? search.push(...nodes) : search.push(nodes));
          }
      }
      return ids;
    }
    var keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      TSImportEqualsDeclaration: ["id"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ClassPrivateMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
    getBindingIdentifiers.keys = keys;
  }
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
  "../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _getBindingIdentifiers = require_getBindingIdentifiers(), _default = exports.default = getOuterBindingIdentifiers;
    function getOuterBindingIdentifiers(node, duplicates) {
      return (0, _getBindingIdentifiers.default)(node, duplicates, !0);
    }
  }
});

// ../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var require_getFunctionName = __commonJS({
  "../node_modules/@babel/types/lib/retrievers/getFunctionName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = getFunctionName;
    var _index = require_generated();
    function getNameFromLiteralId(id) {
      return (0, _index.isNullLiteral)(id) ? "null" : (0, _index.isRegExpLiteral)(id) ? `/${id.pattern}/${id.flags}` : (0, _index.isTemplateLiteral)(id) ? id.quasis.map((quasi) => quasi.value.raw).join("") : id.value !== void 0 ? String(id.value) : null;
    }
    function getObjectMemberKey(node) {
      if (!node.computed || (0, _index.isLiteral)(node.key))
        return node.key;
    }
    function getFunctionName(node, parent) {
      if ("id" in node && node.id)
        return {
          name: node.id.name,
          originalNode: node.id
        };
      let prefix = "", id;
      if ((0, _index.isObjectProperty)(parent, {
        value: node
      }) ? id = getObjectMemberKey(parent) : (0, _index.isObjectMethod)(node) || (0, _index.isClassMethod)(node) ? (id = getObjectMemberKey(node), node.kind === "get" ? prefix = "get " : node.kind === "set" && (prefix = "set ")) : (0, _index.isVariableDeclarator)(parent, {
        init: node
      }) ? id = parent.id : (0, _index.isAssignmentExpression)(parent, {
        operator: "=",
        right: node
      }) && (id = parent.left), !id) return null;
      let name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;
      return name == null ? null : {
        name: prefix + name,
        originalNode: id
      };
    }
  }
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
  "../node_modules/@babel/types/lib/traverse/traverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = traverse2;
    var _index = require_definitions();
    function traverse2(node, handlers, state) {
      typeof handlers == "function" && (handlers = {
        enter: handlers
      });
      let {
        enter,
        exit
      } = handlers;
      traverseSimpleImpl(node, enter, exit, state, []);
    }
    function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      let keys = _index.VISITOR_KEYS[node.type];
      if (keys) {
        enter && enter(node, ancestors, state);
        for (let key of keys) {
          let subNode = node[key];
          if (Array.isArray(subNode))
            for (let i = 0; i < subNode.length; i++) {
              let child = subNode[i];
              child && (ancestors.push({
                node,
                key,
                index: i
              }), traverseSimpleImpl(child, enter, exit, state, ancestors), ancestors.pop());
            }
          else subNode && (ancestors.push({
            node,
            key
          }), traverseSimpleImpl(subNode, enter, exit, state, ancestors), ancestors.pop());
        }
        exit && exit(node, ancestors, state);
      }
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
  "../node_modules/@babel/types/lib/validators/isBinding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isBinding;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    function isBinding(node, parent, grandparent) {
      if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression")
        return !1;
      let keys = _getBindingIdentifiers.default.keys[parent.type];
      if (keys)
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i], val = parent[key];
          if (Array.isArray(val)) {
            if (val.includes(node)) return !0;
          } else if (val === node) return !0;
        }
      return !1;
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
  "../node_modules/@babel/types/lib/validators/isLet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isLet;
    var _index = require_generated();
    BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    var BLOCK_SCOPED_SYMBOL;
    function isLet(node) {
      return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
  "../node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isBlockScoped;
    var _index = require_generated(), _isLet = require_isLet();
    function isBlockScoped(node) {
      return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
  "../node_modules/@babel/types/lib/validators/isImmutable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isImmutable;
    var _isType = require_isType(), _index = require_generated();
    function isImmutable(node) {
      return (0, _isType.default)(node.type, "Immutable") ? !0 : (0, _index.isIdentifier)(node) ? node.name === "undefined" : !1;
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
  "../node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isNodesEquivalent;
    var _index = require_definitions();
    function isNodesEquivalent(a, b) {
      if (typeof a != "object" || typeof b != "object" || a == null || b == null)
        return a === b;
      if (a.type !== b.type)
        return !1;
      let fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type), visitorKeys = _index.VISITOR_KEYS[a.type];
      for (let field of fields) {
        let val_a = a[field], val_b = b[field];
        if (typeof val_a != typeof val_b)
          return !1;
        if (!(val_a == null && val_b == null)) {
          if (val_a == null || val_b == null)
            return !1;
          if (Array.isArray(val_a)) {
            if (!Array.isArray(val_b) || val_a.length !== val_b.length)
              return !1;
            for (let i = 0; i < val_a.length; i++)
              if (!isNodesEquivalent(val_a[i], val_b[i]))
                return !1;
            continue;
          }
          if (typeof val_a == "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
            for (let key of Object.keys(val_a))
              if (val_a[key] !== val_b[key])
                return !1;
            continue;
          }
          if (!isNodesEquivalent(val_a, val_b))
            return !1;
        }
      }
      return !0;
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
  "../node_modules/@babel/types/lib/validators/isReferenced.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isReferenced;
    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          return parent.property === node ? !!parent.computed : parent.object === node;
        case "JSXMemberExpression":
          return parent.object === node;
        case "VariableDeclarator":
          return parent.init === node;
        case "ArrowFunctionExpression":
          return parent.body === node;
        case "PrivateName":
          return !1;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          return parent.key === node ? !!parent.computed : !1;
        case "ObjectProperty":
          return parent.key === node ? !!parent.computed : !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          return parent.key === node ? !!parent.computed : !0;
        case "ClassPrivateProperty":
          return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "LabeledStatement":
          return !1;
        case "CatchClause":
          return !1;
        case "RestElement":
          return !1;
        case "BreakStatement":
        case "ContinueStatement":
          return !1;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return !1;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return !1;
        case "ExportSpecifier":
          return grandparent != null && grandparent.source ? !1 : parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return !1;
        case "ImportAttribute":
          return !1;
        case "JSXAttribute":
          return !1;
        case "ObjectPattern":
        case "ArrayPattern":
          return !1;
        case "MetaProperty":
          return !1;
        case "ObjectTypeProperty":
          return parent.key !== node;
        case "TSEnumMember":
          return parent.id !== node;
        case "TSPropertySignature":
          return parent.key === node ? !!parent.computed : !0;
      }
      return !0;
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
  "../node_modules/@babel/types/lib/validators/isScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isScope;
    var _index = require_generated();
    function isScope(node, parent) {
      return (0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent)) ? !1 : (0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent)) ? !0 : (0, _index.isScopable)(node);
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
  "../node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isSpecifierDefault;
    var _index = require_generated();
    function isSpecifierDefault(specifier) {
      return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
  "../node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isValidES3Identifier;
    var _isValidIdentifier = require_isValidIdentifier(), RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name) {
      return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
    }
  }
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
  "../node_modules/@babel/types/lib/validators/isVar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isVar;
    var _index = require_generated();
    BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    var BLOCK_SCOPED_SYMBOL;
    function isVar(node) {
      return (0, _index.isVariableDeclaration)(node, {
        kind: "var"
      }) && !node[BLOCK_SCOPED_SYMBOL];
    }
  }
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
  "../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = gatherSequenceExpressions;
    var _getBindingIdentifiers = require_getBindingIdentifiers(), _index = require_generated(), _index2 = require_generated2(), _productions = require_productions(), _cloneNode = require_cloneNode();
    function gatherSequenceExpressions(nodes, declars) {
      let exprs = [], ensureLastUndefined = !0;
      for (let node of nodes)
        if ((0, _index.isEmptyStatement)(node) || (ensureLastUndefined = !1), (0, _index.isExpression)(node))
          exprs.push(node);
        else if ((0, _index.isExpressionStatement)(node))
          exprs.push(node.expression);
        else if ((0, _index.isVariableDeclaration)(node)) {
          if (node.kind !== "var") return;
          for (let declar of node.declarations) {
            let bindings = (0, _getBindingIdentifiers.default)(declar);
            for (let key of Object.keys(bindings))
              declars.push({
                kind: node.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            declar.init && exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
          }
          ensureLastUndefined = !0;
        } else if ((0, _index.isIfStatement)(node)) {
          let consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : (0, _productions.buildUndefinedNode)(), alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : (0, _productions.buildUndefinedNode)();
          if (!consequent || !alternate) return;
          exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _index.isBlockStatement)(node)) {
          let body = gatherSequenceExpressions(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if ((0, _index.isEmptyStatement)(node))
          nodes.indexOf(node) === 0 && (ensureLastUndefined = !0);
        else
          return;
      return ensureLastUndefined && exprs.push((0, _productions.buildUndefinedNode)()), exprs.length === 1 ? exprs[0] : (0, _index2.sequenceExpression)(exprs);
    }
  }
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
  "../node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = toSequenceExpression;
    var _gatherSequenceExpressions = require_gatherSequenceExpressions();
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length)) return;
      let declars = [], result = (0, _gatherSequenceExpressions.default)(nodes, declars);
      if (result) {
        for (let declar of declars)
          scope.push(declar);
        return result;
      }
    }
  }
});

// ../node_modules/@babel/types/lib/index.js
var require_lib4 = __commonJS({
  "../node_modules/@babel/types/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var _exportNames = {
      react: !0,
      assertNode: !0,
      createTypeAnnotationBasedOnTypeof: !0,
      createUnionTypeAnnotation: !0,
      createFlowUnionType: !0,
      createTSUnionType: !0,
      cloneNode: !0,
      clone: !0,
      cloneDeep: !0,
      cloneDeepWithoutLoc: !0,
      cloneWithoutLoc: !0,
      addComment: !0,
      addComments: !0,
      inheritInnerComments: !0,
      inheritLeadingComments: !0,
      inheritsComments: !0,
      inheritTrailingComments: !0,
      removeComments: !0,
      ensureBlock: !0,
      toBindingIdentifierName: !0,
      toBlock: !0,
      toComputedKey: !0,
      toExpression: !0,
      toIdentifier: !0,
      toKeyAlias: !0,
      toStatement: !0,
      valueToNode: !0,
      appendToMemberExpression: !0,
      inherits: !0,
      prependToMemberExpression: !0,
      removeProperties: !0,
      removePropertiesDeep: !0,
      removeTypeDuplicates: !0,
      getAssignmentIdentifiers: !0,
      getBindingIdentifiers: !0,
      getOuterBindingIdentifiers: !0,
      getFunctionName: !0,
      traverse: !0,
      traverseFast: !0,
      shallowEqual: !0,
      is: !0,
      isBinding: !0,
      isBlockScoped: !0,
      isImmutable: !0,
      isLet: !0,
      isNode: !0,
      isNodesEquivalent: !0,
      isPlaceholderType: !0,
      isReferenced: !0,
      isScope: !0,
      isSpecifierDefault: !0,
      isType: !0,
      isValidES3Identifier: !0,
      isValidIdentifier: !0,
      isVar: !0,
      matchesPattern: !0,
      validate: !0,
      buildMatchMemberExpression: !0,
      __internal__deprecationWarning: !0
    };
    Object.defineProperty(exports, "__internal__deprecationWarning", {
      enumerable: !0,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports, "addComment", {
      enumerable: !0,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports, "addComments", {
      enumerable: !0,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports, "appendToMemberExpression", {
      enumerable: !0,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "assertNode", {
      enumerable: !0,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports, "buildMatchMemberExpression", {
      enumerable: !0,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports, "clone", {
      enumerable: !0,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: !0,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports, "cloneDeepWithoutLoc", {
      enumerable: !0,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "cloneNode", {
      enumerable: !0,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports, "cloneWithoutLoc", {
      enumerable: !0,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports, "createFlowUnionType", {
      enumerable: !0,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTSUnionType", {
      enumerable: !0,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: !0,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports, "ensureBlock", {
      enumerable: !0,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports, "getAssignmentIdentifiers", {
      enumerable: !0,
      get: function() {
        return _getAssignmentIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "getFunctionName", {
      enumerable: !0,
      get: function() {
        return _getFunctionName.default;
      }
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports, "inheritInnerComments", {
      enumerable: !0,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports, "inheritLeadingComments", {
      enumerable: !0,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports, "inheritTrailingComments", {
      enumerable: !0,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports, "inherits", {
      enumerable: !0,
      get: function() {
        return _inherits.default;
      }
    });
    Object.defineProperty(exports, "inheritsComments", {
      enumerable: !0,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports, "is", {
      enumerable: !0,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports, "isBinding", {
      enumerable: !0,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: !0,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: !0,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: !0,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: !0,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: !0,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports, "isPlaceholderType", {
      enumerable: !0,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: !0,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: !0,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: !0,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: !0,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports, "isValidES3Identifier", {
      enumerable: !0,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: !0,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: !0,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports, "matchesPattern", {
      enumerable: !0,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports, "prependToMemberExpression", {
      enumerable: !0,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports.react = void 0;
    Object.defineProperty(exports, "removeComments", {
      enumerable: !0,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports, "removeProperties", {
      enumerable: !0,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports, "removePropertiesDeep", {
      enumerable: !0,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: !0,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports, "shallowEqual", {
      enumerable: !0,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: !0,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: !0,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: !0,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: !0,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: !0,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: !0,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: !0,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: !0,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports, "traverseFast", {
      enumerable: !0,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: !0,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: !0,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = require_isReactComponent(), _isCompatTag = require_isCompatTag(), _buildChildren = require_buildChildren(), _assertNode = require_assertNode(), _index = require_generated3();
    Object.keys(_index).forEach(function(key) {
      key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _index[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _index[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof(), _createFlowUnionType = require_createFlowUnionType(), _createTSUnionType = require_createTSUnionType(), _productions = require_productions();
    Object.keys(_productions).forEach(function(key) {
      key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _productions[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _productions[key];
        }
      });
    });
    var _index2 = require_generated2();
    Object.keys(_index2).forEach(function(key) {
      key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _index2[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _index2[key];
        }
      });
    });
    var _cloneNode = require_cloneNode(), _clone = require_clone(), _cloneDeep = require_cloneDeep(), _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc(), _cloneWithoutLoc = require_cloneWithoutLoc(), _addComment = require_addComment(), _addComments = require_addComments(), _inheritInnerComments = require_inheritInnerComments(), _inheritLeadingComments = require_inheritLeadingComments(), _inheritsComments = require_inheritsComments(), _inheritTrailingComments = require_inheritTrailingComments(), _removeComments = require_removeComments(), _index3 = require_generated4();
    Object.keys(_index3).forEach(function(key) {
      key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _index3[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _index3[key];
        }
      });
    });
    var _index4 = require_constants();
    Object.keys(_index4).forEach(function(key) {
      key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _index4[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _index4[key];
        }
      });
    });
    var _ensureBlock = require_ensureBlock(), _toBindingIdentifierName = require_toBindingIdentifierName(), _toBlock = require_toBlock(), _toComputedKey = require_toComputedKey(), _toExpression = require_toExpression(), _toIdentifier = require_toIdentifier(), _toKeyAlias = require_toKeyAlias(), _toStatement = require_toStatement(), _valueToNode = require_valueToNode(), _index5 = require_definitions();
    Object.keys(_index5).forEach(function(key) {
      key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _index5[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _index5[key];
        }
      });
    });
    var _appendToMemberExpression = require_appendToMemberExpression(), _inherits = require_inherits(), _prependToMemberExpression = require_prependToMemberExpression(), _removeProperties = require_removeProperties(), _removePropertiesDeep = require_removePropertiesDeep(), _removeTypeDuplicates = require_removeTypeDuplicates(), _getAssignmentIdentifiers = require_getAssignmentIdentifiers(), _getBindingIdentifiers = require_getBindingIdentifiers(), _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers(), _getFunctionName = require_getFunctionName(), _traverse = require_traverse();
    Object.keys(_traverse).forEach(function(key) {
      key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _traverse[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = require_traverseFast(), _shallowEqual = require_shallowEqual(), _is = require_is(), _isBinding = require_isBinding(), _isBlockScoped = require_isBlockScoped(), _isImmutable = require_isImmutable(), _isLet = require_isLet(), _isNode = require_isNode(), _isNodesEquivalent = require_isNodesEquivalent(), _isPlaceholderType = require_isPlaceholderType(), _isReferenced = require_isReferenced(), _isScope = require_isScope(), _isSpecifierDefault = require_isSpecifierDefault(), _isType = require_isType(), _isValidES3Identifier = require_isValidES3Identifier(), _isValidIdentifier = require_isValidIdentifier(), _isVar = require_isVar(), _matchesPattern = require_matchesPattern(), _validate = require_validate(), _buildMatchMemberExpression = require_buildMatchMemberExpression(), _index6 = require_generated();
    Object.keys(_index6).forEach(function(key) {
      key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _index6[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _index6[key];
        }
      });
    });
    var _deprecationWarning = require_deprecationWarning(), _toSequenceExpression = require_toSequenceExpression(), react = exports.react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    exports.toSequenceExpression = _toSequenceExpression.default;
    process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
  }
});

// ../node_modules/@babel/template/lib/formatters.js
var require_formatters = __commonJS({
  "../node_modules/@babel/template/lib/formatters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;
    var _t = require_lib4(), {
      assertExpressionStatement
    } = _t;
    function makeStatementFormatter(fn) {
      return {
        code: (str) => `/* @babel/template */;
${str}`,
        validate: () => {
        },
        unwrap: (ast) => fn(ast.program.body.slice(1))
      };
    }
    var smart = exports.smart = makeStatementFormatter((body) => body.length > 1 ? body : body[0]), statements = exports.statements = makeStatementFormatter((body) => body), statement = exports.statement = makeStatementFormatter((body) => {
      if (body.length === 0)
        throw new Error("Found nothing to return.");
      if (body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      return body[0];
    }), expression = exports.expression = {
      code: (str) => `(
${str}
)`,
      validate: (ast) => {
        if (ast.program.body.length > 1)
          throw new Error("Found multiple statements but wanted one");
        if (expression.unwrap(ast).start === 0)
          throw new Error("Parse result included parens.");
      },
      unwrap: ({
        program: program2
      }) => {
        let [stmt] = program2.body;
        return assertExpressionStatement(stmt), stmt.expression;
      }
    }, program = exports.program = {
      code: (str) => str,
      validate: () => {
      },
      unwrap: (ast) => ast.program
    };
  }
});

// ../node_modules/@babel/template/lib/options.js
var require_options = __commonJS({
  "../node_modules/@babel/template/lib/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.merge = merge;
    exports.normalizeReplacements = normalizeReplacements;
    exports.validate = validate;
    var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
    function _objectWithoutPropertiesLoose(r, e) {
      if (r == null) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.indexOf(n) !== -1) continue;
        t[n] = r[n];
      }
      return t;
    }
    function merge(a, b) {
      let {
        placeholderWhitelist = a.placeholderWhitelist,
        placeholderPattern = a.placeholderPattern,
        preserveComments = a.preserveComments,
        syntacticPlaceholders = a.syntacticPlaceholders
      } = b;
      return {
        parser: Object.assign({}, a.parser, b.parser),
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      };
    }
    function validate(opts) {
      if (opts != null && typeof opts != "object")
        throw new Error("Unknown template options.");
      let _ref = opts || {}, {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = _ref, parser3 = _objectWithoutPropertiesLoose(_ref, _excluded);
      if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set))
        throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
      if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== !1)
        throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
      if (preserveComments != null && typeof preserveComments != "boolean")
        throw new Error("'.preserveComments' must be a boolean, null, or undefined");
      if (syntacticPlaceholders != null && typeof syntacticPlaceholders != "boolean")
        throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
      if (syntacticPlaceholders === !0 && (placeholderWhitelist != null || placeholderPattern != null))
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      return {
        parser: parser3,
        placeholderWhitelist: placeholderWhitelist || void 0,
        placeholderPattern: placeholderPattern ?? void 0,
        preserveComments: preserveComments ?? void 0,
        syntacticPlaceholders: syntacticPlaceholders ?? void 0
      };
    }
    function normalizeReplacements(replacements) {
      if (Array.isArray(replacements))
        return replacements.reduce((acc, replacement, i) => (acc["$" + i] = replacement, acc), {});
      if (typeof replacements == "object" || replacements == null)
        return replacements || void 0;
      throw new Error("Template replacements must be an array, object, null, or undefined");
    }
  }
});

// ../node_modules/@babel/parser/lib/index.js
var require_lib5 = __commonJS({
  "../node_modules/@babel/parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    function _objectWithoutPropertiesLoose(r, e) {
      if (r == null) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.indexOf(n) !== -1) continue;
        t[n] = r[n];
      }
      return t;
    }
    var Position = class {
      constructor(line, col, index) {
        this.line = void 0, this.column = void 0, this.index = void 0, this.line = line, this.column = col, this.index = index;
      }
    }, SourceLocation = class {
      constructor(start, end) {
        this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = start, this.end = end;
      }
    };
    function createPositionWithColumnOffset(position, columnOffset) {
      let {
        line,
        column,
        index
      } = position;
      return new Position(line, column + columnOffset, index + columnOffset);
    }
    var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code
      }
    }, NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    }, toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type], StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArity: "`import()` requires exactly one or two arguments.",
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsOptionalChaining: ({
        ancestor
      }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key
      }) => `Duplicate key "${key}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword
      }) => `Unexpected keyword '${keyword}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.",
      UnexpectedVoidPattern: "Unexpected void binding.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationExport: "Using declaration cannot be exported.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.",
      VoidPatternInitializer: "A void binding may not have an initializer.",
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    }, StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    }, ParseExpressionErrors = {
      ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
      ParseExpressionExpectsEOF: ({
        unexpected
      }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(unexpected)}\`.`
    }, UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), PipelineOperatorErrors = Object.assign({
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token
      }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`
    }, {
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    }), _excluded = ["message"];
    function defineHidden(obj, key, value2) {
      Object.defineProperty(obj, key, {
        enumerable: !1,
        configurable: !0,
        value: value2
      });
    }
    function toParseErrorConstructor({
      toMessage,
      code: code2,
      reasonCode,
      syntaxPlugin
    }) {
      let hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
      {
        let oldReasonCodes = {
          AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
          AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
          ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
          SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
          SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
          SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
        };
        oldReasonCodes[reasonCode] && (reasonCode = oldReasonCodes[reasonCode]);
      }
      return function constructor(loc, details) {
        let error = new SyntaxError();
        return error.code = code2, error.reasonCode = reasonCode, error.loc = loc, error.pos = loc.index, error.syntaxPlugin = syntaxPlugin, hasMissingPlugin && (error.missingPlugin = details.missingPlugin), defineHidden(error, "clone", function(overrides = {}) {
          var _overrides$loc;
          let {
            line,
            column,
            index
          } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
          return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
        }), defineHidden(error, "details", details), Object.defineProperty(error, "message", {
          configurable: !0,
          get() {
            let message = `${toMessage(details)} (${loc.line}:${loc.column})`;
            return this.message = message, message;
          },
          set(value2) {
            Object.defineProperty(this, "message", {
              value: value2,
              writable: !0
            });
          }
        }), error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument))
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      let ParseErrorConstructors = {};
      for (let reasonCode of Object.keys(argument)) {
        let template = argument[reasonCode], _ref = typeof template == "string" ? {
          message: () => template
        } : typeof template == "function" ? {
          message: template
        } : template, {
          message
        } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded), toMessage = typeof message == "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: "BABEL_PARSER_SYNTAX_ERROR",
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    function createDefaultOptions() {
      return {
        sourceType: "script",
        sourceFilename: void 0,
        startIndex: 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: !1,
        allowReturnOutsideFunction: !1,
        allowNewTargetOutsideFunction: !1,
        allowImportExportEverywhere: !1,
        allowSuperOutsideMethod: !1,
        allowUndeclaredExports: !1,
        allowYieldOutsideFunction: !1,
        plugins: [],
        strictMode: void 0,
        ranges: !1,
        tokens: !1,
        createImportExpressions: !1,
        createParenthesizedExpressions: !1,
        errorRecovery: !1,
        attachComment: !0,
        annexB: !0
      };
    }
    function getOptions(opts) {
      let options = createDefaultOptions();
      if (opts == null)
        return options;
      if (opts.annexB != null && opts.annexB !== !1)
        throw new Error("The `annexB` option can only be set to `false`.");
      for (let key of Object.keys(options))
        opts[key] != null && (options[key] = opts[key]);
      if (options.startLine === 1)
        opts.startIndex == null && options.startColumn > 0 ? options.startIndex = options.startColumn : opts.startColumn == null && options.startIndex > 0 && (options.startColumn = options.startIndex);
      else if ((opts.startColumn == null || opts.startIndex == null) && opts.startIndex != null)
        throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
      if (options.sourceType === "commonjs") {
        if (opts.allowAwaitOutsideFunction != null)
          throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
        if (opts.allowReturnOutsideFunction != null)
          throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
        if (opts.allowNewTargetOutsideFunction != null)
          throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
      }
      return options;
    }
    var {
      defineProperty
    } = Object, toUnenumerable = (object, key) => {
      object && defineProperty(object, key, {
        enumerable: !1,
        value: object[key]
      });
    };
    function toESTreeLocation(node) {
      return toUnenumerable(node.loc.start, "index"), toUnenumerable(node.loc.end, "index"), node;
    }
    var estree = (superClass) => class extends superClass {
      parse() {
        let file = toESTreeLocation(super.parse());
        return this.optionFlags & 256 && (file.tokens = file.tokens.map(toESTreeLocation)), file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch {
        }
        let node = this.estreeParseLiteral(regex);
        return node.regex = {
          pattern,
          flags
        }, node;
      }
      parseBigIntLiteral(value2) {
        let bigInt;
        try {
          bigInt = BigInt(value2);
        } catch {
          bigInt = null;
        }
        let node = this.estreeParseLiteral(bigInt);
        return node.bigint = String(node.value || value2), node;
      }
      parseDecimalLiteral(value2) {
        let node = this.estreeParseLiteral(null);
        return node.decimal = String(node.value || value2), node;
      }
      estreeParseLiteral(value2) {
        return this.parseLiteral(value2, "Literal");
      }
      parseStringLiteral(value2) {
        return this.estreeParseLiteral(value2);
      }
      parseNumericLiteral(value2) {
        return this.estreeParseLiteral(value2);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value2) {
        return this.estreeParseLiteral(value2);
      }
      estreeParseChainExpression(node, endLoc) {
        let chain = this.startNodeAtNode(node);
        return chain.expression = node, this.finishNodeAt(chain, "ChainExpression", endLoc);
      }
      directiveToStmt(directive) {
        let expression = directive.value;
        delete directive.value, this.castNodeTo(expression, "Literal"), expression.raw = expression.extra.raw, expression.value = expression.extra.expressionValue;
        let stmt = this.castNodeTo(directive, "ExpressionStatement");
        return stmt.expression = expression, stmt.directive = expression.extra.rawValue, delete expression.extra, stmt;
      }
      fillOptionalPropertiesForTSESLint(node) {
      }
      cloneEstreeStringLiteral(node) {
        let {
          start,
          end,
          loc,
          range,
          raw,
          value: value2
        } = node, cloned = Object.create(node.constructor.prototype);
        return cloned.type = "Literal", cloned.start = start, cloned.end = end, cloned.loc = loc, cloned.range = range, cloned.raw = raw, cloned.value = value2, cloned;
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync), node.expression = !1;
      }
      checkDeclaration(node) {
        node != null && this.isObjectProperty(node) ? this.checkDeclaration(node.value) : super.checkDeclaration(node);
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value == "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        let directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body), delete node.directives;
      }
      parsePrivateName() {
        let node = super.parsePrivateName();
        return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(node) : node;
      }
      convertPrivateNameToPrivateIdentifier(node) {
        let name = super.getPrivateNameSV(node);
        return delete node.id, node.name = name, this.castNodeTo(node, "PrivateIdentifier");
      }
      isPrivateName(node) {
        return this.getPluginOption("estree", "classFeatures") ? node.type === "PrivateIdentifier" : super.isPrivateName(node);
      }
      getPrivateNameSV(node) {
        return this.getPluginOption("estree", "classFeatures") ? node.name : super.getPrivateNameSV(node);
      }
      parseLiteral(value2, type) {
        let node = super.parseLiteral(value2, type);
        return node.raw = node.extra.raw, delete node.extra, node;
      }
      parseFunctionBody(node, allowExpression, isMethod = !1) {
        super.parseFunctionBody(node, allowExpression, isMethod), node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = !1) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind, funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope), delete funcNode.kind;
        let {
          typeParameters
        } = node;
        typeParameters && (delete node.typeParameters, funcNode.typeParameters = typeParameters, this.resetStartLocationFromNode(funcNode, typeParameters));
        let valueNode = this.castNodeTo(funcNode, "FunctionExpression");
        return node.value = valueNode, type === "ClassPrivateMethod" && (node.computed = !1), type === "ObjectMethod" ? (node.kind === "method" && (node.kind = "init"), node.shorthand = !1, this.finishNode(node, "Property")) : this.finishNode(node, "MethodDefinition");
      }
      nameIsConstructor(key) {
        return key.type === "Literal" ? key.value === "constructor" : super.nameIsConstructor(key);
      }
      parseClassProperty(...args) {
        let propertyNode = super.parseClassProperty(...args);
        return this.getPluginOption("estree", "classFeatures") && this.castNodeTo(propertyNode, "PropertyDefinition"), propertyNode;
      }
      parseClassPrivateProperty(...args) {
        let propertyNode = super.parseClassPrivateProperty(...args);
        return this.getPluginOption("estree", "classFeatures") && (this.castNodeTo(propertyNode, "PropertyDefinition"), propertyNode.computed = !1), propertyNode;
      }
      parseClassAccessorProperty(node) {
        let accessorPropertyNode = super.parseClassAccessorProperty(node);
        return this.getPluginOption("estree", "classFeatures") && (accessorPropertyNode.abstract && this.hasPlugin("typescript") ? (delete accessorPropertyNode.abstract, this.castNodeTo(accessorPropertyNode, "TSAbstractAccessorProperty")) : this.castNodeTo(accessorPropertyNode, "AccessorProperty")), accessorPropertyNode;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        let node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        return node && (node.kind = "init", this.castNodeTo(node, "Property")), node;
      }
      finishObjectProperty(node) {
        return node.kind = "init", this.finishNode(node, "Property");
      }
      isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node, isBinding) {
        return node != null && this.isObjectProperty(node) ? this.isAssignable(node.value, isBinding) : super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = !1) {
        if (node != null && this.isObjectProperty(node)) {
          let {
            key,
            value: value2
          } = node;
          this.isPrivateName(key) && this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start), this.toAssignable(value2, isLHS);
        } else
          super.toAssignable(node, isLHS);
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        prop.type === "Property" && (prop.kind === "get" || prop.kind === "set") ? this.raise(Errors.PatternHasAccessor, prop.key) : prop.type === "Property" && prop.method ? this.raise(Errors.PatternHasMethod, prop.key) : super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
      }
      finishCallExpression(unfinished, optional) {
        let node = super.finishCallExpression(unfinished, optional);
        if (node.callee.type === "Import") {
          var _ref;
          this.castNodeTo(node, "ImportExpression"), node.source = node.arguments[0], node.options = (_ref = node.arguments[1]) != null ? _ref : null;
          {
            var _ref2;
            node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
          }
          delete node.arguments, delete node.callee;
        } else node.type === "OptionalCallExpression" ? this.castNodeTo(node, "CallExpression") : node.optional = !1;
        return node;
      }
      toReferencedArguments(node) {
        node.type !== "ImportExpression" && super.toReferencedArguments(node);
      }
      parseExport(unfinished, decorators) {
        let exportStartLoc = this.state.lastTokStartLoc, node = super.parseExport(unfinished, decorators);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier" && (this.castNodeTo(node, "ExportAllDeclaration"), node.exported = node.specifiers[0].exported, delete node.specifiers);
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              let {
                declaration
              } = node;
              declaration?.type === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start && this.resetStartLocation(node, exportStartLoc);
            }
            break;
        }
        return node;
      }
      stopParseSubscript(base, state) {
        let node = super.stopParseSubscript(base, state);
        return state.optionalChainMember ? this.estreeParseChainExpression(node, base.loc.end) : node;
      }
      parseMember(base, startLoc, state, computed, optional) {
        let node = super.parseMember(base, startLoc, state, computed, optional);
        return node.type === "OptionalMemberExpression" ? this.castNodeTo(node, "MemberExpression") : node.optional = !1, node;
      }
      isOptionalMemberExpression(node) {
        return node.type === "ChainExpression" ? node.expression.type === "MemberExpression" : super.isOptionalMemberExpression(node);
      }
      hasPropertyAsPrivateName(node) {
        return node.type === "ChainExpression" && (node = node.expression), super.hasPropertyAsPrivateName(node);
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
      }
      castNodeTo(node, type) {
        let result = super.castNodeTo(node, type);
        return this.fillOptionalPropertiesForTSESLint(result), result;
      }
      cloneIdentifier(node) {
        let cloned = super.cloneIdentifier(node);
        return this.fillOptionalPropertiesForTSESLint(cloned), cloned;
      }
      cloneStringLiteral(node) {
        return node.type === "Literal" ? this.cloneEstreeStringLiteral(node) : super.cloneStringLiteral(node);
      }
      finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
      }
      finishNode(node, type) {
        let result = super.finishNode(node, type);
        return this.fillOptionalPropertiesForTSESLint(result), result;
      }
      resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc), toESTreeLocation(node);
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc), toESTreeLocation(node);
      }
    }, TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0, this.preserveSpace = void 0, this.token = token, this.preserveSpace = !!preserveSpace;
      }
    }, types2 = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", !0)
    };
    types2.template = new TokContext("`", !0);
    var beforeExpr = !0, startsExpr = !0, isLoop = !0, isAssign = !0, prefix = !0, postfix = !0, ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = label, this.keyword = conf.keyword, this.beforeExpr = !!conf.beforeExpr, this.startsExpr = !!conf.startsExpr, this.rightAssociative = !!conf.rightAssociative, this.isLoop = !!conf.isLoop, this.isAssign = !!conf.isAssign, this.prefix = !!conf.prefix, this.postfix = !!conf.postfix, this.binop = conf.binop != null ? conf.binop : null, this.updateContext = null;
      }
    }, keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name, options = {}) {
      options.keyword = name;
      let token = createToken(name, options);
      return keywords$1.set(name, token), token;
    }
    function createBinop(name, binop) {
      return createToken(name, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1, tokenTypes = [], tokenLabels = [], tokenBinops = [], tokenBeforeExprs = [], tokenStartsExprs = [], tokenPrefixes = [];
    function createToken(name, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      return ++tokenTypeCounter, tokenLabels.push(name), tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1), tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : !1), tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : !1), tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : !1), tokenTypes.push(new ExportedTokenType(name, options)), tokenTypeCounter;
    }
    function createKeywordLike(name, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      return ++tokenTypeCounter, keywords$1.set(name, tokenTypeCounter), tokenLabels.push(name), tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1), tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : !1), tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : !1), tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : !1), tokenTypes.push(new ExportedTokenType("name", options)), tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: !0
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _defer: createKeywordLike("defer", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _source: createKeywordLike("source", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _using: createKeywordLike("using", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      placeholder: createToken("%%", {
        startsExpr
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr
      }),
      jsxTagEnd: createToken("jsxTagEnd")
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 133;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 133;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 137;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 129 && token <= 131;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 121 && token <= 123;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 124 && token <= 130;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes[token];
    }
    tokenTypes[8].updateContext = (context) => {
      context.pop();
    }, tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
      context.push(types2.brace);
    }, tokenTypes[22].updateContext = (context) => {
      context[context.length - 1] === types2.template ? context.pop() : context.push(types2.template);
    }, tokenTypes[143].updateContext = (context) => {
      context.push(types2.j_expr, types2.j_oTag);
    };
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code2, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        if (pos += set[i], pos > code2) return !1;
        if (pos += set[i + 1], pos >= code2) return !0;
      }
      return !1;
    }
    function isIdentifierStart(code2) {
      return code2 < 65 ? code2 === 36 : code2 <= 90 ? !0 : code2 < 97 ? code2 === 95 : code2 <= 122 ? !0 : code2 <= 65535 ? code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2)) : isInAstralSet(code2, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code2) {
      return code2 < 48 ? code2 === 36 : code2 < 58 ? !0 : code2 < 65 ? !1 : code2 <= 90 ? !0 : code2 < 97 ? code2 === 95 : code2 <= 122 ? !0 : code2 <= 65535 ? code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2)) : isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    }, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict), reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var Scope = class {
      constructor(flags) {
        this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = flags;
      }
    }, ScopeHandler = class {
      constructor(parser3, inModule) {
        this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = parser3, this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
      }
      get allowNewTarget() {
        return (this.currentThisScopeFlags() & 512) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        let flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          let {
            flags
          } = this.scopeStack[i];
          if (flags & 128)
            return !0;
          if (flags & 1731)
            return !1;
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
      }
      get inBareCaseStatement() {
        return (this.currentScope().flags & 256) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        return this.scopeStack.pop().flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & 130 || !this.parser.inModule && scope.flags & 1);
      }
      declareName(name, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 8 || bindingType & 16) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          let type = scope.names.get(name) || 0;
          bindingType & 16 ? type = type | 4 : (scope.firstLexicalName || (scope.firstLexicalName = name), type = type | 2), scope.names.set(name, type), bindingType & 8 && this.maybeExportDefined(scope, name);
        } else if (bindingType & 4)
          for (let i = this.scopeStack.length - 1; i >= 0 && (scope = this.scopeStack[i], this.checkRedeclarationInScope(scope, name, bindingType, loc), scope.names.set(name, (scope.names.get(name) || 0) | 1), this.maybeExportDefined(scope, name), !(scope.flags & 1667)); --i)
            ;
        this.parser.inModule && scope.flags & 1 && this.undefinedExports.delete(name);
      }
      maybeExportDefined(scope, name) {
        this.parser.inModule && scope.flags & 1 && this.undefinedExports.delete(name);
      }
      checkRedeclarationInScope(scope, name, bindingType, loc) {
        this.isRedeclaredInScope(scope, name, bindingType) && this.parser.raise(Errors.VarRedeclaration, loc, {
          identifierName: name
        });
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & 1)) return !1;
        if (bindingType & 8)
          return scope.names.has(name);
        let type = scope.names.get(name) || 0;
        return bindingType & 16 ? (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0 : (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
      }
      checkLocalExport(id) {
        let {
          name
        } = id;
        this.scopeStack[0].names.has(name) || this.undefinedExports.set(name, id.loc.start);
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          let {
            flags
          } = this.scopeStack[i];
          if (flags & 1667)
            return flags;
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          let {
            flags
          } = this.scopeStack[i];
          if (flags & 1731 && !(flags & 4))
            return flags;
        }
      }
    }, FlowScope = class extends Scope {
      constructor(...args) {
        super(...args), this.declareFunctions = /* @__PURE__ */ new Set();
      }
    }, FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 2048) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc), this.maybeExportDefined(scope, name), scope.declareFunctions.add(name);
          return;
        }
        super.declareName(name, bindingType, loc);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (super.isRedeclaredInScope(scope, name, bindingType)) return !0;
        if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
          let type = scope.names.get(name);
          return (type & 4) > 0 || (type & 2) > 0;
        }
        return !1;
      }
      checkLocalExport(id) {
        this.scopeStack[0].declareFunctions.has(id.name) || super.checkLocalExport(id);
      }
    }, reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitialized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      let list1 = [], list2 = [];
      for (let i = 0; i < list.length; i++)
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/, flow = (superClass) => class extends superClass {
      constructor(...args) {
        super(...args), this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      finishToken(type, val) {
        type !== 134 && type !== 13 && type !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          let matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (matches) if (matches[1] === "flow")
            this.flowPragma = "flow";
          else if (matches[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
        }
        super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        let oldInType = this.state.inType;
        this.state.inType = !0, this.expect(tok || 14);
        let type = this.flowParseType();
        return this.state.inType = oldInType, type;
      }
      flowParsePredicate() {
        let node = this.startNode(), moduloLoc = this.state.startLoc;
        return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > moduloLoc.index + 1 && this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc), this.eat(10) ? (node.value = super.parseExpression(), this.expect(11), this.finishNode(node, "DeclaredPredicate")) : this.finishNode(node, "InferredPredicate");
      }
      flowParseTypeAndPredicateInitialiser() {
        let oldInType = this.state.inType;
        this.state.inType = !0, this.expect(14);
        let type = null, predicate = null;
        return this.match(54) ? (this.state.inType = oldInType, predicate = this.flowParsePredicate()) : (type = this.flowParseType(), this.state.inType = oldInType, this.match(54) && (predicate = this.flowParsePredicate())), [type, predicate];
      }
      flowParseDeclareClass(node) {
        return this.next(), this.flowParseInterfaceish(node, !0), this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        let id = node.id = this.parseIdentifier(), typeNode = this.startNode(), typeContainer = this.startNode();
        this.match(47) ? typeNode.typeParameters = this.flowParseTypeParameterDeclaration() : typeNode.typeParameters = null, this.expect(10);
        let tmp = this.flowParseFunctionTypeParams();
        return typeNode.params = tmp.params, typeNode.rest = tmp.rest, typeNode.this = tmp._this, this.expect(11), [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation"), id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation"), this.resetEndLocation(id), this.semicolon(), this.scope.declareName(node.id.name, 2048, node.id.loc.start), this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(80))
          return this.flowParseDeclareClass(node);
        if (this.match(68))
          return this.flowParseDeclareFunction(node);
        if (this.match(74))
          return this.flowParseDeclareVariable(node);
        if (this.eatContextual(127))
          return this.match(16) ? this.flowParseDeclareModuleExports(node) : (insideModule && this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(node));
        if (this.isContextual(130))
          return this.flowParseDeclareTypeAlias(node);
        if (this.isContextual(131))
          return this.flowParseDeclareOpaqueType(node);
        if (this.isContextual(129))
          return this.flowParseDeclareInterface(node);
        if (this.match(82))
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        throw this.unexpected();
      }
      flowParseDeclareVariable(node) {
        return this.next(), node.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(node.id.name, 5, node.id.loc.start), this.semicolon(), this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(0), this.match(134) ? node.id = super.parseExprAtom() : node.id = this.parseIdentifier();
        let bodyNode = node.body = this.startNode(), body = bodyNode.body = [];
        for (this.expect(5); !this.match(8); ) {
          let bodyNode2 = this.startNode();
          this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), body.push(super.parseImport(bodyNode2))) : (this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule), body.push(this.flowParseDeclare(bodyNode2, !0)));
        }
        this.scope.exit(), this.expect(8), this.finishNode(bodyNode, "BlockStatement");
        let kind = null, hasModuleExport = !1;
        return body.forEach((bodyElement) => {
          isEsModuleType(bodyElement) ? (kind === "CommonJS" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement), kind = "ES") : bodyElement.type === "DeclareModuleExports" && (hasModuleExport && this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement), kind === "ES" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement), kind = "CommonJS", hasModuleExport = !0);
        }), node.kind = kind || "CommonJS", this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        if (this.expect(82), this.eat(65))
          return this.match(68) || this.match(80) ? node.declaration = this.flowParseDeclare(this.startNode()) : (node.declaration = this.flowParseType(), this.semicolon()), node.default = !0, this.finishNode(node, "DeclareExportDeclaration");
        if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
          let label = this.state.value;
          throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
            unsupportedExportKind: label,
            suggestion: exportSuggestions[label]
          });
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
          return node.declaration = this.flowParseDeclare(this.startNode()), node.default = !1, this.finishNode(node, "DeclareExportDeclaration");
        if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
          return node = this.parseExport(node, null), node.type === "ExportNamedDeclaration" ? (node.default = !1, delete node.exportKind, this.castNodeTo(node, "DeclareExportDeclaration")) : this.castNodeTo(node, "DeclareExportAllDeclaration");
        throw this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        return this.next(), this.expectContextual(111), node.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        let finished = this.flowParseTypeAlias(node);
        return this.castNodeTo(finished, "DeclareTypeAlias"), finished;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        let finished = this.flowParseOpaqueType(node, !0);
        return this.castNodeTo(finished, "DeclareOpaqueType"), finished;
      }
      flowParseDeclareInterface(node) {
        return this.next(), this.flowParseInterfaceish(node, !1), this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass) {
        if (node.id = this.flowParseRestrictedIdentifier(!isClass, !0), this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.extends = [], this.eat(81))
          do
            node.extends.push(this.flowParseInterfaceExtends());
          while (!isClass && this.eat(12));
        if (isClass) {
          if (node.implements = [], node.mixins = [], this.eatContextual(117))
            do
              node.mixins.push(this.flowParseInterfaceExtends());
            while (this.eat(12));
          if (this.eatContextual(113))
            do
              node.implements.push(this.flowParseInterfaceExtends());
            while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: !1,
          allowSpread: !1,
          allowProto: isClass,
          allowInexact: !1
        });
      }
      flowParseInterfaceExtends() {
        let node = this.startNode();
        return node.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? node.typeParameters = this.flowParseTypeParameterInstantiation() : node.typeParameters = null, this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        return this.flowParseInterfaceish(node, !1), this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        word === "_" && this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
      }
      checkReservedType(word, startLoc, declaration) {
        reservedTypes.has(word) && this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
          reservedType: word
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        return this.checkReservedType(this.state.value, this.state.startLoc, declaration), this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        return node.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(node.id.name, 8201, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        return this.expectContextual(130), node.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(node.id.name, 8201, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.supertype = null, this.match(14) && (node.supertype = this.flowParseTypeInitialiser(14)), node.impltype = null, declare || (node.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = !1) {
        let nodeStartLoc = this.state.startLoc, node = this.startNode(), variance = this.flowParseVariance(), ident = this.flowParseTypeAnnotatableIdentifier();
        return node.name = ident.name, node.variance = variance, node.bound = ident.typeAnnotation, this.match(29) ? (this.eat(29), node.default = this.flowParseType()) : requireDefault && this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc), this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        let oldInType = this.state.inType, node = this.startNode();
        node.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
        let defaultRequired = !1;
        do {
          let typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter), typeParameter.default && (defaultRequired = !0), this.match(48) || this.expect(12);
        } while (!this.match(48));
        return this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterDeclaration");
      }
      flowInTopLevelContext(cb) {
        if (this.curContext() !== types2.brace) {
          let oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else
          return cb();
      }
      flowParseTypeParameterInstantiationInExpression() {
        if (this.reScan_lt() === 47)
          return this.flowParseTypeParameterInstantiation();
      }
      flowParseTypeParameterInstantiation() {
        let node = this.startNode(), oldInType = this.state.inType;
        return this.state.inType = !0, node.params = [], this.flowInTopLevelContext(() => {
          this.expect(47);
          let oldNoAnonFunctionType = this.state.noAnonFunctionType;
          for (this.state.noAnonFunctionType = !1; !this.match(48); )
            node.params.push(this.flowParseType()), this.match(48) || this.expect(12);
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }), this.state.inType = oldInType, !this.state.inType && this.curContext() === types2.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        if (this.reScan_lt() !== 47) return null;
        let node = this.startNode(), oldInType = this.state.inType;
        for (node.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
          node.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
        return this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        let node = this.startNode();
        if (this.expectContextual(129), node.extends = [], this.eat(81))
          do
            node.extends.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        return node.body = this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !1,
          allowSpread: !1,
          allowProto: !1,
          allowInexact: !1
        }), this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        return node.static = isStatic, this.lookahead().type === 14 ? (node.id = this.flowParseObjectPropertyKey(), node.key = this.flowParseTypeInitialiser()) : (node.id = null, node.key = this.flowParseType()), this.expect(3), node.value = this.flowParseTypeInitialiser(), node.variance = variance, this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        return node.static = isStatic, node.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (node.method = !0, node.optional = !1, node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start))) : (node.method = !1, this.eat(17) && (node.optional = !0), node.value = this.flowParseTypeInitialiser()), this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        for (node.params = [], node.rest = null, node.typeParameters = null, node.this = null, this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (node.this = this.flowParseFunctionTypeParam(!0), node.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
          node.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
        return this.eat(21) && (node.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), node.returnType = this.flowParseTypeInitialiser(), this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        let valueNode = this.startNode();
        return node.static = isStatic, node.value = this.flowParseObjectTypeMethodish(valueNode), this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        let oldInType = this.state.inType;
        this.state.inType = !0;
        let nodeStart = this.startNode();
        nodeStart.callProperties = [], nodeStart.properties = [], nodeStart.indexers = [], nodeStart.internalSlots = [];
        let endDelim, exact, inexact = !1;
        for (allowExact && this.match(6) ? (this.expect(6), endDelim = 9, exact = !0) : (this.expect(5), endDelim = 8, exact = !1), nodeStart.exact = exact; !this.match(endDelim); ) {
          let isStatic = !1, protoStartLoc = null, inexactStartLoc = null, node = this.startNode();
          if (allowProto && this.isContextual(118)) {
            let lookahead = this.lookahead();
            lookahead.type !== 14 && lookahead.type !== 17 && (this.next(), protoStartLoc = this.state.startLoc, allowStatic = !1);
          }
          if (allowStatic && this.isContextual(106)) {
            let lookahead = this.lookahead();
            lookahead.type !== 14 && lookahead.type !== 17 && (this.next(), isStatic = !0);
          }
          let variance = this.flowParseVariance();
          if (this.eat(0))
            protoStartLoc != null && this.unexpected(protoStartLoc), this.eat(0) ? (variance && this.unexpected(variance.loc.start), nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic))) : nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
          else if (this.match(10) || this.match(47))
            protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          else {
            let kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              let lookahead = this.lookahead();
              tokenIsLiteralPropertyName(lookahead.type) && (kind = this.state.value, this.next());
            }
            let propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact ?? !exact);
            propOrInexact === null ? (inexact = !0, inexactStartLoc = this.state.lastTokStartLoc) : nodeStart.properties.push(propOrInexact);
          }
          this.flowObjectTypeSemicolon(), inexactStartLoc && !this.match(8) && !this.match(9) && this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
        }
        this.expect(endDelim), allowSpread && (nodeStart.inexact = inexact);
        let out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        return this.state.inType = oldInType, out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21))
          return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (allowSpread ? allowInexact || this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc), variance && this.raise(FlowErrors.InexactVariance, variance), null) : (allowSpread || this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc), protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.raise(FlowErrors.SpreadVariance, variance), node.argument = this.flowParseType(), this.finishNode(node, "ObjectTypeSpreadProperty"));
        {
          node.key = this.flowParseObjectPropertyKey(), node.static = isStatic, node.proto = protoStartLoc != null, node.kind = kind;
          let optional = !1;
          return this.match(47) || this.match(10) ? (node.method = !0, protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start)), (kind === "get" || kind === "set") && this.flowCheckGetterSetterParams(node), !allowSpread && node.key.name === "constructor" && node.value.this && this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this)) : (kind !== "init" && this.unexpected(), node.method = !1, this.eat(17) && (optional = !0), node.value = this.flowParseTypeInitialiser(), node.variance = variance), node.optional = optional, this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        let paramCount = property.kind === "get" ? 0 : 1, length = property.value.params.length + (property.value.rest ? 1 : 0);
        property.value.this && this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this), length !== paramCount && this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property), property.kind === "set" && property.value.rest && this.raise(Errors.BadSetterRestParameter, property);
      }
      flowObjectTypeSemicolon() {
        !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
      }
      flowParseQualifiedTypeIdentifier(startLoc, id) {
        startLoc ?? (startLoc = this.state.startLoc);
        let node = id || this.flowParseRestrictedIdentifier(!0);
        for (; this.eat(16); ) {
          let node2 = this.startNodeAt(startLoc);
          node2.qualification = node, node2.id = this.flowParseRestrictedIdentifier(!0), node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startLoc, id) {
        let node = this.startNodeAt(startLoc);
        return node.typeParameters = null, node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id), this.match(47) && (node.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        let node = this.startNode();
        return this.expect(87), node.argument = this.flowParsePrimaryType(), this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        let node = this.startNode();
        for (node.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (node.types.push(this.flowParseType()), !this.match(3)); )
          this.expect(12);
        return this.expect(3), this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name = null, optional = !1, typeAnnotation = null, node = this.startNode(), lh = this.lookahead(), isThis = this.state.type === 78;
        return lh.type === 14 || lh.type === 17 ? (isThis && !first && this.raise(FlowErrors.ThisParamMustBeFirst, node), name = this.parseIdentifier(isThis), this.eat(17) && (optional = !0, isThis && this.raise(FlowErrors.ThisParamMayNotBeOptional, node)), typeAnnotation = this.flowParseTypeInitialiser()) : typeAnnotation = this.flowParseType(), node.name = name, node.optional = optional, node.typeAnnotation = typeAnnotation, this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        let node = this.startNodeAt(type.loc.start);
        return node.name = null, node.optional = !1, node.typeAnnotation = type, this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null, _this = null;
        for (this.match(78) && (_this = this.flowParseFunctionTypeParam(!0), _this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
          params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
        return this.eat(21) && (rest = this.flowParseFunctionTypeParam(!1)), {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            return this.checkNotUnderscore(id.name), this.flowParseGenericType(startLoc, id);
        }
      }
      flowParsePrimaryType() {
        let startLoc = this.state.startLoc, node = this.startNode(), tmp, type, isGroupedType = !1, oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: !1,
              allowExact: !1,
              allowSpread: !0,
              allowProto: !1,
              allowInexact: !0
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: !1,
              allowExact: !0,
              allowSpread: !0,
              allowProto: !1,
              allowInexact: !1
            });
          case 0:
            return this.state.noAnonFunctionType = !1, type = this.flowParseTupleType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, type;
          case 47: {
            let node2 = this.startNode();
            return node2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), tmp = this.flowParseFunctionTypeParams(), node2.params = tmp.params, node2.rest = tmp.rest, node2.this = tmp._this, this.expect(11), this.expect(19), node2.returnType = this.flowParseType(), this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 10: {
            let node2 = this.startNode();
            if (this.next(), !this.match(11) && !this.match(21))
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                let token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else
                isGroupedType = !0;
            if (isGroupedType) {
              if (this.state.noAnonFunctionType = !1, type = this.flowParseType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                return this.expect(11), type;
              this.eat(12);
            }
            return type ? tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]) : tmp = this.flowParseFunctionTypeParams(), node2.params = tmp.params, node2.rest = tmp.rest, node2.this = tmp._this, this.expect(11), this.expect(19), node2.returnType = this.flowParseType(), node2.typeParameters = null, this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 134:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            return node.value = this.match(85), this.next(), this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              if (this.next(), this.match(135))
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              if (this.match(136))
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            throw this.unexpected();
          case 135:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 136:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            return this.next(), this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            return this.next(), this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            return this.next(), this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            return this.next(), this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              let label = tokenLabelName(this.state.type);
              return this.next(), super.createIdentifier(node, label);
            } else if (tokenIsIdentifier(this.state.type))
              return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
        }
        throw this.unexpected();
      }
      flowParsePostfixType() {
        let startLoc = this.state.startLoc, type = this.flowParsePrimaryType(), seenOptionalIndexedAccess = !1;
        for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
          let node = this.startNodeAt(startLoc), optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional, this.expect(0), !optional && this.match(3) ? (node.elementType = type, this.next(), type = this.finishNode(node, "ArrayTypeAnnotation")) : (node.objectType = type, node.indexType = this.flowParseType(), this.expect(3), seenOptionalIndexedAccess ? (node.optional = optional, type = this.finishNode(node, "OptionalIndexedAccessType")) : type = this.finishNode(node, "IndexedAccessType"));
        }
        return type;
      }
      flowParsePrefixType() {
        let node = this.startNode();
        return this.eat(17) ? (node.typeAnnotation = this.flowParsePrefixType(), this.finishNode(node, "NullableTypeAnnotation")) : this.flowParsePostfixType();
      }
      flowParseAnonFunctionWithoutParens() {
        let param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          let node = this.startNodeAt(param.loc.start);
          return node.params = [this.reinterpretTypeAsFunctionTypeParam(param)], node.rest = null, node.this = null, node.returnType = this.flowParseType(), node.typeParameters = null, this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        let node = this.startNode();
        this.eat(45);
        let type = this.flowParseAnonFunctionWithoutParens();
        for (node.types = [type]; this.eat(45); )
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        let node = this.startNode();
        this.eat(43);
        let type = this.flowParseIntersectionType();
        for (node.types = [type]; this.eat(43); )
          node.types.push(this.flowParseIntersectionType());
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        let oldInType = this.state.inType;
        this.state.inType = !0;
        let type = this.flowParseUnionType();
        return this.state.inType = oldInType, type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          let startLoc = this.state.startLoc, node = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node);
        } else
          return this.flowParseType();
      }
      flowParseTypeAnnotation() {
        let node = this.startNode();
        return node.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        let ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        return this.match(14) && (ident.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(ident)), ident;
      }
      typeCastToParameter(node) {
        return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), node.expression;
      }
      flowParseVariance() {
        let variance = null;
        return this.match(53) ? (variance = this.startNode(), this.state.value === "+" ? variance.kind = "plus" : variance.kind = "minus", this.next(), this.finishNode(variance, "Variance")) : variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = !1) {
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, !0, isMethod));
          return;
        }
        super.parseFunctionBody(node, !1, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = !1) {
        if (this.match(14)) {
          let typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          let lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            let node = this.startNode();
            return this.next(), this.flowParseInterface(node);
          }
        } else if (this.isContextual(126)) {
          let node = this.startNode();
          return this.next(), this.flowParseEnumDeclaration(node);
        }
        let stmt = super.parseStatementLike(flags);
        return this.flowPragma === void 0 && !this.isValidDirective(stmt) && (this.flowPragma = null), stmt;
      }
      parseExpressionStatement(node, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82))
              return this.flowParseDeclare(node);
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface")
              return this.flowParseInterface(node);
            if (expr.name === "type")
              return this.flowParseTypeAlias(node);
            if (expr.name === "opaque")
              return this.flowParseOpaqueType(node, !1);
          }
        }
        return super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        let {
          type
        } = this.state;
        return type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        let {
          type
        } = this.state;
        return type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type) ? this.state.containsEsc : super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.isContextual(126)) {
          let node = this.startNode();
          return this.next(), this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          let nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41)
            return this.setOptionalParametersError(refExpressionErrors), expr;
        }
        this.expect(17);
        let state = this.state.clone(), originalNoArrowAt = this.state.noArrowAt, node = this.startNodeAt(startLoc), {
          consequent,
          failed
        } = this.tryParseConditionalConsequent(), [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          let noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state, this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++)
              noArrowAt.push(invalid[i].start);
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent()), [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          failed && valid.length > 1 && this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc), failed && valid.length === 1 && (this.state = state, noArrowAt.push(valid[0].start), this.state.noArrowAt = noArrowAt, {
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
        }
        return this.getArrowLikeExpressions(consequent, !0), this.state.noArrowAt = originalNoArrowAt, this.expect(14), node.test = expr, node.consequent = consequent, node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        let consequent = this.parseMaybeAssignAllowIn(), failed = !this.match(14);
        return this.state.noArrowParamsConversionAt.pop(), {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        let stack = [node], arrows = [];
        for (; stack.length !== 0; ) {
          let node2 = stack.pop();
          node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement" ? (node2.typeParameters || !node2.returnType ? this.finishArrowValidation(node2) : arrows.push(node2), stack.push(node2.body)) : node2.type === "ConditionalExpression" && (stack.push(node2.consequent), stack.push(node2.alternate));
        }
        return disallowInvalid ? (arrows.forEach((node2) => this.finishArrowValidation(node2)), [arrows, []]) : partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, !0)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, !1), this.scope.enter(518), super.checkParams(node, !1, !0), this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse4) {
        let result;
        return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), result = parse4(), this.state.noArrowParamsConversionAt.pop()) : result = parse4(), result;
      }
      parseParenItem(node, startLoc) {
        let newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17) && (newNode.optional = !0, this.resetEndLocation(node)), this.match(14)) {
          let typeCastNode = this.startNodeAt(startLoc);
          return typeCastNode.expression = newNode, typeCastNode.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return newNode;
      }
      assertModuleNodeAllowed(node) {
        node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type" || super.assertModuleNodeAllowed(node);
      }
      parseExportDeclaration(node) {
        if (this.isContextual(130)) {
          node.exportKind = "type";
          let declarationNode = this.startNode();
          return this.next(), this.match(5) ? (node.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(node), null) : this.flowParseTypeAlias(declarationNode);
        } else if (this.isContextual(131)) {
          node.exportKind = "type";
          let declarationNode = this.startNode();
          return this.next(), this.flowParseOpaqueType(declarationNode, !1);
        } else if (this.isContextual(129)) {
          node.exportKind = "type";
          let declarationNode = this.startNode();
          return this.next(), this.flowParseInterface(declarationNode);
        } else if (this.isContextual(126)) {
          node.exportKind = "value";
          let declarationNode = this.startNode();
          return this.next(), this.flowParseEnumDeclaration(declarationNode);
        } else
          return super.parseExportDeclaration(node);
      }
      eatExportStar(node) {
        return super.eatExportStar(node) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (node.exportKind = "type", this.next(), this.next(), !0) : !1;
      }
      maybeParseExportNamespaceSpecifier(node) {
        let {
          startLoc
        } = this.state, hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        return hasNamespace && node.exportKind === "type" && this.unexpected(startLoc), hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId), this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration());
      }
      parseClassMember(classBody, member, state) {
        let {
          startLoc
        } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(classBody, member))
            return;
          member.declare = !0;
        }
        super.parseClassMember(classBody, member, state), member.declare && (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition" ? this.raise(FlowErrors.DeclareClassElement, startLoc) : member.value && this.raise(FlowErrors.DeclareClassFieldInitializer, member.value));
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        let word = super.readWord1(), fullWord = "@@" + word;
        (!this.isIterator(word) || !this.state.inType) && this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
          identifierName: fullWord
        }), this.finishToken(132, fullWord);
      }
      getTokenFromCode(code2) {
        let next = this.input.charCodeAt(this.state.pos + 1);
        code2 === 123 && next === 124 ? this.finishOp(6, 2) : this.state.inType && (code2 === 62 || code2 === 60) ? this.finishOp(code2 === 62 ? 48 : 47, 1) : this.state.inType && code2 === 63 ? next === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(code2);
      }
      isAssignable(node, isBinding) {
        return node.type === "TypeCastExpression" ? this.isAssignable(node.expression, isBinding) : super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = !1) {
        !isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression" && (node.left = this.typeCastToParameter(node.left)), super.toAssignable(node, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          let expr = exprList[i];
          expr?.type === "TypeCastExpression" && (exprList[i] = this.typeCastToParameter(expr));
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          let expr = exprList[i];
          expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr) && this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
        }
        return exprList;
      }
      parseArrayLike(close, isTuple, refExpressionErrors) {
        let node = super.parseArrayLike(close, isTuple, refExpressionErrors);
        return refExpressionErrors != null && !this.state.maybeInArrowParameters && this.toReferencedList(node.elements), node;
      }
      isValidLVal(type, disallowCallExpression, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);
      }
      parseClassProperty(node) {
        return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper), method.params && isConstructor) {
          let params = method.params;
          params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, method);
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          let params = method.value.params;
          params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, method);
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        if (super.parseClassSuper(node), node.superClass && (this.match(47) || this.match(51)) && (node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113)) {
          this.next();
          let implemented = node.implements = [];
          do {
            let node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? node2.typeParameters = this.flowParseTypeParameterInstantiation() : node2.typeParameters = null, implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        let params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          let param = params[0];
          this.isThisParam(param) && method.kind === "get" ? this.raise(FlowErrors.GetterMayNotHaveThisParam, param) : this.isThisParam(param) && this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
        }
      }
      parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        prop.variance && this.unexpected(prop.variance.loc.start), delete prop.variance;
        let typeParameters;
        this.match(47) && !isAccessor && (typeParameters = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
        let result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        return typeParameters && ((result.value || result).typeParameters = typeParameters), result;
      }
      parseFunctionParamType(param) {
        return this.eat(17) && (param.type !== "Identifier" && this.raise(FlowErrors.PatternIsOptional, param), this.isThisParam(param) && this.raise(FlowErrors.ThisParamMayNotBeOptional, param), param.optional = !0), this.match(14) ? param.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(param) && this.raise(FlowErrors.ThisParamAnnotationRequired, param), this.match(29) && this.isThisParam(param) && this.raise(FlowErrors.ThisParamNoDefault, param), this.resetEndLocation(param), param;
      }
      parseMaybeDefault(startLoc, left) {
        let node = super.parseMaybeDefault(startLoc, left);
        return node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation), node;
      }
      checkImportReflection(node) {
        super.checkImportReflection(node), node.module && node.importKind !== "value" && this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return !0;
        if (this.isContextual(130)) {
          if (!isExport) return !0;
          let ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        if (super.applyImportPhase(node, isExport, phase, loc), isExport) {
          if (!phase && this.match(65))
            return;
          node.exportKind = phase === "type" ? phase : "value";
        } else
          phase === "type" && this.match(55) && this.unexpected(), node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        let firstIdent = specifier.imported, specifierTypeKind = null;
        firstIdent.type === "Identifier" && (firstIdent.name === "type" ? specifierTypeKind = "type" : firstIdent.name === "typeof" && (specifierTypeKind = "typeof"));
        let isBinding = !1;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          let as_ident = this.parseIdentifier(!0);
          specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type) ? (specifier.imported = as_ident, specifier.importKind = specifierTypeKind, specifier.local = this.cloneIdentifier(as_ident)) : (specifier.imported = firstIdent, specifier.importKind = null, specifier.local = this.parseIdentifier());
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type))
            specifier.imported = this.parseIdentifier(!0), specifier.importKind = specifierTypeKind;
          else {
            if (importedIsString)
              throw this.raise(Errors.ImportBindingIsString, specifier, {
                importName: firstIdent.value
              });
            specifier.imported = firstIdent, specifier.importKind = null;
          }
          this.eatContextual(93) ? specifier.local = this.parseIdentifier() : (isBinding = !0, specifier.local = this.cloneIdentifier(specifier.imported));
        }
        let specifierIsTypeImport = hasTypeImportKind(specifier);
        return isInTypeOnlyImport && specifierIsTypeImport && this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier), (isInTypeOnlyImport || specifierIsTypeImport) && this.checkReservedType(specifier.local.name, specifier.local.loc.start, !0), isBinding && !isInTypeOnlyImport && !specifierIsTypeImport && this.checkReservedWord(specifier.local.name, specifier.loc.start, !0, !0), this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(!0);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, isConstructor) {
        let kind = node.kind;
        kind !== "get" && kind !== "set" && this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind), this.match(14) && (decl.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(decl.id));
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          let oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0, node.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null, jsx2;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          if (state = this.state.clone(), jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !jsx2.error) return jsx2.node;
          let {
            context
          } = this.state, currentContext = context[context.length - 1];
          (currentContext === types2.j_oTag || currentContext === types2.j_expr) && context.pop();
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters, arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            let arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              let result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              return this.resetStartLocationFromNode(result, typeParameters), result;
            });
            (_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized && abort();
            let expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            return expr.type !== "ArrowFunctionExpression" && abort(), expr.typeParameters = typeParameters, this.resetStartLocationFromNode(expr, typeParameters), arrowExpression2;
          }, state), arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted)
              return arrow.node.async && this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters), arrow.node;
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node)
            return this.state = jsx2.failState, jsx2.node;
          if (arrowExpression)
            return this.state = arrow.failState, arrowExpression;
          throw (_jsx3 = jsx2) != null && _jsx3.thrown ? jsx2.error : arrow.thrown ? arrow.error : this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(14)) {
          let result = this.tryParse(() => {
            let oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = !0;
            let typeNode = this.startNode();
            return [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), typeNode;
          });
          if (result.thrown) return null;
          result.error && (this.state = result.failState), node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start)) ? node.params = params : super.setArrowFunctionParameters(node, params);
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = !0) {
        if (!(isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start)))) {
          for (let i = 0; i < node.params.length; i++)
            this.isThisParam(node.params[i]) && i > 0 && this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
          super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
        }
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
          this.next();
          let node = this.startNodeAt(startLoc);
          node.callee = base, node.arguments = super.parseCallExpressionArguments(), base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          let state = this.state.clone(), arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          let result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error) return result.node;
          if (arrow.node)
            return this.state = arrow.failState, arrow.node;
          if (result.node)
            return this.state = result.failState, result.node;
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          if (subscriptState.optionalChainMember = !0, noCalls)
            return subscriptState.stop = !0, base;
          this.next();
          let node = this.startNodeAt(startLoc);
          return node.callee = base, node.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), node.arguments = this.parseCallExpressionArguments(), node.optional = !0, this.finishCallExpression(node, !0);
        } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
          let node = this.startNodeAt(startLoc);
          node.callee = base;
          let result = this.tryParse(() => (node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), node.arguments = super.parseCallExpressionArguments(), subscriptState.optionalChainMember && (node.optional = !1), this.finishCallExpression(node, subscriptState.optionalChainMember)));
          if (result.node)
            return result.error && (this.state = result.failState), result.node;
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node) {
        super.parseNewCallee(node);
        let targs = null;
        this.shouldParseTypes() && this.match(47) && (targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), node.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        let node = this.startNodeAt(startLoc);
        if (this.parseFunctionParams(node, !1), !!this.parseArrow(node))
          return super.parseArrowExpression(node, void 0, !0);
      }
      readToken_mult_modulo(code2) {
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code2);
      }
      readToken_pipe_amp(code2) {
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code2);
      }
      parseTopLevel(file, program) {
        let fileNode = super.parseTopLevel(file, program);
        return this.state.hasFlowComment && this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition()), fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment)
            throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
          this.hasFlowCommentCompletion();
          let commentSkip = this.skipFlowComment();
          commentSkip && (this.state.pos += commentSkip, this.state.hasFlowComment = !0);
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        let {
          pos
        } = this.state, shiftToFirstNonWhiteSpace = 2;
        for (; [32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace)); )
          shiftToFirstNonWhiteSpace++;
        let ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos), ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        return ch2 === 58 && ch3 === 58 ? shiftToFirstNonWhiteSpace + 2 : this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include" ? shiftToFirstNonWhiteSpace + 12 : ch2 === 58 && ch3 !== 58 ? shiftToFirstNonWhiteSpace : !1;
      }
      hasFlowCommentCompletion() {
        if (this.input.indexOf("*/", this.state.pos) === -1)
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(enumContext.explicitType ? enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType : FlowErrors.EnumInvalidMemberInitializerUnknownType, loc, enumContext);
      }
      flowEnumErrorNumberMemberNotInitialized(loc, details) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
      }
      flowEnumMemberInit() {
        let startLoc = this.state.startLoc, endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 135: {
            let literal = this.parseNumericLiteral(this.state.value);
            return endOfInit() ? {
              type: "number",
              loc: literal.loc.start,
              value: literal
            } : {
              type: "invalid",
              loc: startLoc
            };
          }
          case 134: {
            let literal = this.parseStringLiteral(this.state.value);
            return endOfInit() ? {
              type: "string",
              loc: literal.loc.start,
              value: literal
            } : {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            let literal = this.parseBooleanLiteral(this.match(85));
            return endOfInit() ? {
              type: "boolean",
              loc: literal.loc.start,
              value: literal
            } : {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        let loc = this.state.startLoc, id = this.parseIdentifier(!0), init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        let {
          explicitType
        } = context;
        explicitType !== null && explicitType !== expectedType && this.flowEnumErrorInvalidMemberInitializer(loc, context);
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        let seenNames = /* @__PURE__ */ new Set(), members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        }, hasUnknownMembers = !1;
        for (; !this.match(8); ) {
          if (this.eat(21)) {
            hasUnknownMembers = !0;
            break;
          }
          let memberNode = this.startNode(), {
            id,
            init
          } = this.flowEnumMemberRaw(), memberName = id.name;
          if (memberName === "")
            continue;
          /^[a-z]/.test(memberName) && this.raise(FlowErrors.EnumInvalidMemberName, id, {
            memberName,
            suggestion: memberName[0].toUpperCase() + memberName.slice(1),
            enumName
          }), seenNames.has(memberName) && this.raise(FlowErrors.EnumDuplicateMemberName, id, {
            memberName,
            enumName
          }), seenNames.add(memberName);
          let context = {
            enumName,
            explicitType,
            memberName
          };
          switch (memberNode.id = id, init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean"), memberNode.init = init.value, members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number"), memberNode.init = init.value, members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string"), memberNode.init = init.value, members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid":
              throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
            case "none":
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
          }
          this.match(8) || this.expect(12);
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0)
          return defaultedMembers;
        if (defaultedMembers.length === 0)
          return initializedMembers;
        if (defaultedMembers.length > initializedMembers.length) {
          for (let member of initializedMembers)
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          return defaultedMembers;
        } else {
          for (let member of defaultedMembers)
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(102)) return null;
        if (!tokenIsIdentifier(this.state.type))
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
            enumName
          });
        let {
          value: value2
        } = this.state;
        return this.next(), value2 !== "boolean" && value2 !== "number" && value2 !== "string" && value2 !== "symbol" && this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
          enumName,
          invalidEnumType: value2
        }), value2;
      }
      flowEnumBody(node, id) {
        let enumName = id.name, nameLoc = id.loc.start, explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        let {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        switch (node.hasUnknownMembers = hasUnknownMembers, explicitType) {
          case "boolean":
            return node.explicitType = !0, node.members = members.booleanMembers, this.expect(8), this.finishNode(node, "EnumBooleanBody");
          case "number":
            return node.explicitType = !0, node.members = members.numberMembers, this.expect(8), this.finishNode(node, "EnumNumberBody");
          case "string":
            return node.explicitType = !0, node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            }), this.expect(8), this.finishNode(node, "EnumStringBody");
          case "symbol":
            return node.members = members.defaultedMembers, this.expect(8), this.finishNode(node, "EnumSymbolBody");
          default: {
            let empty = () => (node.members = [], this.expect(8), this.finishNode(node, "EnumStringBody"));
            node.explicitType = !1;
            let boolsLen = members.booleanMembers.length, numsLen = members.numberMembers.length, strsLen = members.stringMembers.length, defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen)
              return empty();
            if (!boolsLen && !numsLen)
              return node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              }), this.expect(8), this.finishNode(node, "EnumStringBody");
            if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (let member of members.defaultedMembers)
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              return node.members = members.booleanMembers, this.expect(8), this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (let member of members.defaultedMembers)
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              return node.members = members.numberMembers, this.expect(8), this.finishNode(node, "EnumNumberBody");
            } else
              return this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                enumName
              }), empty();
          }
        }
      }
      flowParseEnumDeclaration(node) {
        let id = this.parseIdentifier();
        return node.id = id, node.body = this.flowEnumBody(this.startNode(), id), this.finishNode(node, "EnumDeclaration");
      }
      jsxParseOpeningElementAfterName(node) {
        return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (node.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(node);
      }
      isLookaheadToken_lt() {
        let next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          let afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return !1;
      }
      reScan_lt_gt() {
        let {
          type
        } = this.state;
        type === 47 ? (this.state.pos -= 1, this.readToken_lt()) : type === 48 && (this.state.pos -= 1, this.readToken_gt());
      }
      reScan_lt() {
        let {
          type
        } = this.state;
        return type === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : type;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    }, entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    }, lineBreak = /\r\n|[\r\n\u2028\u2029]/, lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code2) {
      switch (code2) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return !0;
        default:
          return !1;
      }
    }
    function hasNewLine(input, start, end) {
      for (let i = start; i < end; i++)
        if (isNewLine(input.charCodeAt(i)))
          return !0;
      return !1;
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    function isWhitespace(code2) {
      switch (code2) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return !0;
        default:
          return !1;
      }
    }
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : !1;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier")
        return object.name;
      if (object.type === "JSXNamespacedName")
        return object.namespace.name + ":" + object.name.name;
      if (object.type === "JSXMemberExpression")
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class extends superClass {
      jsxReadToken() {
        let out = "", chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length)
            throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
          let ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                ch === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(ch);
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos), this.finishToken(142, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(!0), chunkStart = this.state.pos) : ++this.state.pos;
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        let ch = this.input.charCodeAt(this.state.pos), out;
        return ++this.state.pos, ch === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, out = normalizeCRLF ? `
` : `\r
`) : out = String.fromCharCode(ch), ++this.state.curLine, this.state.lineStart = this.state.pos, out;
      }
      jsxReadString(quote) {
        let out = "", chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length)
            throw this.raise(Errors.UnterminatedString, this.state.startLoc);
          let ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;
          ch === 38 ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos) : isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(!1), chunkStart = this.state.pos) : ++this.state.pos;
        }
        out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(134, out);
      }
      jsxReadEntity() {
        let startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          this.codePointAtPos(this.state.pos) === 120 && (radix = 16, ++this.state.pos);
          let codePoint = this.readInt(radix, void 0, !1, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59)
            return ++this.state.pos, String.fromCodePoint(codePoint);
        } else {
          let count = 0, semi = !1;
          for (; count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59); )
            ++this.state.pos;
          if (semi) {
            let desc = this.input.slice(startPos, this.state.pos), entity = entities[desc];
            if (++this.state.pos, entity)
              return entity;
          }
        }
        return this.state.pos = startPos, "&";
      }
      jsxReadWord() {
        let ch, start = this.state.pos;
        do
          ch = this.input.charCodeAt(++this.state.pos);
        while (isIdentifierChar(ch) || ch === 45);
        this.finishToken(141, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        let node = this.startNode();
        return this.match(141) ? node.name = this.state.value : tokenIsKeyword(this.state.type) ? node.name = tokenLabelName(this.state.type) : this.unexpected(), this.next(), this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        let startLoc = this.state.startLoc, name = this.jsxParseIdentifier();
        if (!this.eat(14)) return name;
        let node = this.startNodeAt(startLoc);
        return node.namespace = name, node.name = this.jsxParseIdentifier(), this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        let startLoc = this.state.startLoc, node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName")
          return node;
        for (; this.eat(16); ) {
          let newNode = this.startNodeAt(startLoc);
          newNode.object = node, newNode.property = this.jsxParseIdentifier(), node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case 5:
            return node = this.startNode(), this.setContext(types2.brace), this.next(), node = this.jsxParseExpressionContainer(node, types2.j_oTag), node.expression.type === "JSXEmptyExpression" && this.raise(JsxErrors.AttributeIsEmpty, node), node;
          case 143:
          case 134:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
      }
      jsxParseEmptyExpression() {
        let node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        return this.next(), node.expression = this.parseExpression(), this.setContext(types2.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8))
          node.expression = this.jsxParseEmptyExpression();
        else {
          let expression = this.parseExpression();
          node.expression = expression;
        }
        return this.setContext(previousContext), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        let node = this.startNode();
        return this.match(5) ? (this.setContext(types2.brace), this.next(), this.expect(21), node.argument = this.parseMaybeAssignAllowIn(), this.setContext(types2.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(node, "JSXSpreadAttribute")) : (node.name = this.jsxParseNamespacedName(), node.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(node, "JSXAttribute"));
      }
      jsxParseOpeningElementAt(startLoc) {
        let node = this.startNodeAt(startLoc);
        return this.eat(144) ? this.finishNode(node, "JSXOpeningFragment") : (node.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(node));
      }
      jsxParseOpeningElementAfterName(node) {
        let attributes = [];
        for (; !this.match(56) && !this.match(144); )
          attributes.push(this.jsxParseAttribute());
        return node.attributes = attributes, node.selfClosing = this.eat(56), this.expect(144), this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        let node = this.startNodeAt(startLoc);
        return this.eat(144) ? this.finishNode(node, "JSXClosingFragment") : (node.name = this.jsxParseElementName(), this.expect(144), this.finishNode(node, "JSXClosingElement"));
      }
      jsxParseElementAt(startLoc) {
        let node = this.startNodeAt(startLoc), children = [], openingElement = this.jsxParseOpeningElementAt(startLoc), closingElement = null;
        if (!openingElement.selfClosing) {
          contents: for (; ; )
            switch (this.state.type) {
              case 143:
                if (startLoc = this.state.startLoc, this.next(), this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 142:
                children.push(this.parseLiteral(this.state.value, "JSXText"));
                break;
              case 5: {
                let node2 = this.startNode();
                this.setContext(types2.brace), this.next(), this.match(21) ? children.push(this.jsxParseSpreadChild(node2)) : children.push(this.jsxParseExpressionContainer(node2, types2.j_expr));
                break;
              }
              default:
                this.unexpected();
            }
          isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null ? this.raise(JsxErrors.MissingClosingTagFragment, closingElement) : !isFragment(openingElement) && isFragment(closingElement) ? this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
            openingTagName: getQualifiedJSXName(openingElement.name)
          }) : !isFragment(openingElement) && !isFragment(closingElement) && getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name) && this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
            openingTagName: getQualifiedJSXName(openingElement.name)
          });
        }
        if (isFragment(openingElement) ? (node.openingFragment = openingElement, node.closingFragment = closingElement) : (node.openingElement = openingElement, node.closingElement = closingElement), node.children = children, this.match(47))
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        let startLoc = this.state.startLoc;
        return this.next(), this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        let {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(refExpressionErrors);
      }
      skipSpace() {
        this.curContext().preserveSpace || super.skipSpace();
      }
      getTokenFromCode(code2) {
        let context = this.curContext();
        if (context === types2.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types2.j_oTag || context === types2.j_cTag) {
          if (isIdentifierStart(code2)) {
            this.jsxReadWord();
            return;
          }
          if (code2 === 62) {
            ++this.state.pos, this.finishToken(144);
            return;
          }
          if ((code2 === 34 || code2 === 39) && context === types2.j_oTag) {
            this.jsxReadString(code2);
            return;
          }
        }
        if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        super.getTokenFromCode(code2);
      }
      updateContext(prevType) {
        let {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 143)
          context.splice(-2, 2, types2.j_cTag), this.state.canStartJSXElement = !1;
        else if (type === 143)
          context.push(types2.j_oTag);
        else if (type === 144) {
          let out = context[context.length - 1];
          out === types2.j_oTag && prevType === 56 || out === types2.j_cTag ? (context.pop(), this.state.canStartJSXElement = context[context.length - 1] === types2.j_expr) : (this.setContext(types2.j_expr), this.state.canStartJSXElement = !0);
        } else
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
      }
    }, TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args), this.tsNames = /* @__PURE__ */ new Map();
      }
    }, TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args), this.importsStack = [];
      }
      createScope(flags) {
        return this.importsStack.push(/* @__PURE__ */ new Set()), new TypeScriptScope(flags);
      }
      enter(flags) {
        flags === 1024 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(flags);
      }
      exit() {
        let flags = super.exit();
        return flags === 1024 && this.importsStack.pop(), flags;
      }
      hasImport(name, allowShadow) {
        let len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name))
          return !0;
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++)
            if (this.importsStack[i].has(name)) return !0;
        }
        return !1;
      }
      declareName(name, bindingType, loc) {
        if (bindingType & 4096) {
          this.hasImport(name, !0) && this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name
          }), this.importsStack[this.importsStack.length - 1].add(name);
          return;
        }
        let scope = this.currentScope(), type = scope.tsNames.get(name) || 0;
        if (bindingType & 1024) {
          this.maybeExportDefined(scope, name), scope.tsNames.set(name, type | 16);
          return;
        }
        super.declareName(name, bindingType, loc), bindingType & 2 && (bindingType & 1 || (this.checkRedeclarationInScope(scope, name, bindingType, loc), this.maybeExportDefined(scope, name)), type = type | 1), bindingType & 256 && (type = type | 2), bindingType & 512 && (type = type | 4), bindingType & 128 && (type = type | 8), type && scope.tsNames.set(name, type);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        let type = scope.tsNames.get(name);
        if ((type & 2) > 0) {
          if (bindingType & 256) {
            let isConst = !!(bindingType & 512), wasConst = (type & 4) > 0;
            return isConst !== wasConst;
          }
          return !0;
        }
        return bindingType & 128 && (type & 8) > 0 ? scope.names.get(name) & 2 ? !!(bindingType & 1) : !1 : bindingType & 2 && (type & 1) > 0 ? !0 : super.isRedeclaredInScope(scope, name, bindingType);
      }
      checkLocalExport(id) {
        let {
          name
        } = id;
        if (this.hasImport(name)) return;
        let len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          let type = this.scopeStack[i].tsNames.get(name);
          if ((type & 1) > 0 || (type & 16) > 0)
            return;
        }
        super.checkLocalExport(id);
      }
    }, ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
      }
      sourceToOffsetPos(sourcePos) {
        return sourcePos + this.startIndex;
      }
      offsetToSourcePos(offsetPos) {
        return offsetPos - this.startIndex;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig == "string")
          return this.plugins.has(pluginConfig);
        {
          let [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName))
            return !1;
          let actualOptions = this.plugins.get(pluginName);
          for (let key of Object.keys(pluginOptions))
            if (actualOptions?.[key] !== pluginOptions[key])
              return !1;
          return !0;
        }
      }
      getPluginOption(plugin, name) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
      }
    };
    function setTrailingComments(node, comments) {
      node.trailingComments === void 0 ? node.trailingComments = comments : node.trailingComments.unshift(...comments);
    }
    function setLeadingComments(node, comments) {
      node.leadingComments === void 0 ? node.leadingComments = comments : node.leadingComments.unshift(...comments);
    }
    function setInnerComments(node, comments) {
      node.innerComments === void 0 ? node.innerComments = comments : node.innerComments.unshift(...comments);
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null, i = elements.length;
      for (; lastElement === null && i > 0; )
        lastElement = elements[--i];
      lastElement === null || lastElement.start > commentWS.start ? setInnerComments(node, commentWS.comments) : setTrailingComments(lastElement, commentWS.comments);
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        this.filename && (comment.loc.filename = this.filename);
        let {
          commentsLen
        } = this.state;
        this.comments.length !== commentsLen && (this.comments.length = commentsLen), this.comments.push(comment), this.state.commentsLen++;
      }
      processComment(node) {
        let {
          commentStack
        } = this.state, commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1, lastCommentWS = commentStack[i];
        lastCommentWS.start === node.end && (lastCommentWS.leadingNode = node, i--);
        let {
          start: nodeStart
        } = node;
        for (; i >= 0; i--) {
          let commentWS = commentStack[i], commentEnd = commentWS.end;
          if (commentEnd > nodeStart)
            commentWS.containingNode = node, this.finalizeComment(commentWS), commentStack.splice(i, 1);
          else {
            commentEnd === nodeStart && (commentWS.trailingNode = node);
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        var _node$options;
        let {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null)
          commentWS.leadingNode !== null && setTrailingComments(commentWS.leadingNode, comments), commentWS.trailingNode !== null && setLeadingComments(commentWS.trailingNode, comments);
        else {
          let node = commentWS.containingNode, commentStart = commentWS.start;
          if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44)
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "ImportExpression":
                adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              case "TSEnumDeclaration":
                adjustInnerComments(node, node.members, commentWS);
                break;
              case "TSEnumBody":
                adjustInnerComments(node, node.members, commentWS);
                break;
              default:
                setInnerComments(node, comments);
            }
          else
            setInnerComments(node, comments);
        }
      }
      finalizeRemainingComments() {
        let {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--)
          this.finalizeComment(commentStack[i]);
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        let {
          commentStack
        } = this.state, {
          length
        } = commentStack;
        if (length === 0) return;
        let commentWS = commentStack[length - 1];
        commentWS.leadingNode === node && (commentWS.leadingNode = null);
      }
      takeSurroundingComments(node, start, end) {
        let {
          commentStack
        } = this.state, commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          let commentWS = commentStack[i], commentEnd = commentWS.end;
          if (commentWS.start === end)
            commentWS.leadingNode = node;
          else if (commentEnd === start)
            commentWS.trailingNode = node;
          else if (commentEnd < start)
            break;
        }
      }
    }, State = class _State {
      constructor() {
        this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [types2.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
      }
      get strict() {
        return (this.flags & 1) > 0;
      }
      set strict(v) {
        v ? this.flags |= 1 : this.flags &= -2;
      }
      init({
        strictMode,
        sourceType,
        startIndex,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === !1 ? !1 : strictMode === !0 ? !0 : sourceType === "module", this.startIndex = startIndex, this.curLine = startLine, this.lineStart = -startColumn, this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
      }
      get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
      }
      set maybeInArrowParameters(v) {
        v ? this.flags |= 2 : this.flags &= -3;
      }
      get inType() {
        return (this.flags & 4) > 0;
      }
      set inType(v) {
        v ? this.flags |= 4 : this.flags &= -5;
      }
      get noAnonFunctionType() {
        return (this.flags & 8) > 0;
      }
      set noAnonFunctionType(v) {
        v ? this.flags |= 8 : this.flags &= -9;
      }
      get hasFlowComment() {
        return (this.flags & 16) > 0;
      }
      set hasFlowComment(v) {
        v ? this.flags |= 16 : this.flags &= -17;
      }
      get isAmbientContext() {
        return (this.flags & 32) > 0;
      }
      set isAmbientContext(v) {
        v ? this.flags |= 32 : this.flags &= -33;
      }
      get inAbstractClass() {
        return (this.flags & 64) > 0;
      }
      set inAbstractClass(v) {
        v ? this.flags |= 64 : this.flags &= -65;
      }
      get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
      }
      set inDisallowConditionalTypesContext(v) {
        v ? this.flags |= 128 : this.flags &= -129;
      }
      get soloAwait() {
        return (this.flags & 256) > 0;
      }
      set soloAwait(v) {
        v ? this.flags |= 256 : this.flags &= -257;
      }
      get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
      }
      set inFSharpPipelineDirectBody(v) {
        v ? this.flags |= 512 : this.flags &= -513;
      }
      get canStartJSXElement() {
        return (this.flags & 1024) > 0;
      }
      set canStartJSXElement(v) {
        v ? this.flags |= 1024 : this.flags &= -1025;
      }
      get containsEsc() {
        return (this.flags & 2048) > 0;
      }
      set containsEsc(v) {
        v ? this.flags |= 2048 : this.flags &= -2049;
      }
      get hasTopLevelAwait() {
        return (this.flags & 4096) > 0;
      }
      set hasTopLevelAwait(v) {
        v ? this.flags |= 4096 : this.flags &= -4097;
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
      }
      clone() {
        let state = new _State();
        return state.flags = this.flags, state.startIndex = this.startIndex, state.curLine = this.curLine, state.lineStart = this.lineStart, state.startLoc = this.startLoc, state.endLoc = this.endLoc, state.errors = this.errors.slice(), state.potentialArrowAt = this.potentialArrowAt, state.noArrowAt = this.noArrowAt.slice(), state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), state.topicContext = this.topicContext, state.labels = this.labels.slice(), state.commentsLen = this.commentsLen, state.commentStack = this.commentStack.slice(), state.pos = this.pos, state.type = this.type, state.value = this.value, state.start = this.start, state.end = this.end, state.lastTokEndLoc = this.lastTokEndLoc, state.lastTokStartLoc = this.lastTokStartLoc, state.context = this.context.slice(), state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, state.strictErrors = this.strictErrors, state.tokensLength = this.tokensLength, state;
      }
    }, _isDigit = function(code2) {
      return code2 >= 48 && code2 <= 57;
    }, forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    }, isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      let initialPos = pos, initialLineStart = lineStart, initialCurLine = curLine, out = "", firstInvalidLoc = null, chunkStart = pos, {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine), out += input.slice(chunkStart, pos);
          break;
        }
        let ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          let res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          res.ch === null && !firstInvalidLoc ? firstInvalidLoc = {
            pos,
            lineStart,
            curLine
          } : out += res.ch, {
            pos,
            lineStart,
            curLine
          } = res, chunkStart = pos;
        } else ch === 8232 || ch === 8233 ? (++pos, ++curLine, lineStart = pos) : ch === 10 || ch === 13 ? type === "template" ? (out += input.slice(chunkStart, pos) + `
`, ++pos, ch === 13 && input.charCodeAt(pos) === 10 && ++pos, ++curLine, chunkStart = lineStart = pos) : errors.unterminated(initialPos, initialLineStart, initialCurLine) : ++pos;
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      return type === "template" ? ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123 : ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      let throwOnInvalid = !inTemplate;
      pos++;
      let res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      }), ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res(`
`);
        case 114:
          return res("\r");
        case 120: {
          let code2;
          return {
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, !1, throwOnInvalid, errors), res(code2 === null ? null : String.fromCharCode(code2));
        }
        case 117: {
          let code2;
          return {
            code: code2,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors), res(code2 === null ? null : String.fromCodePoint(code2));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          input.charCodeAt(pos) === 10 && ++pos;
        case 10:
          lineStart = pos, ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate)
            return res(null);
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        default:
          if (ch >= 48 && ch <= 55) {
            let startPos = pos - 1, octalStr = /^[0-7]+/.exec(input.slice(startPos, pos + 2))[0], octal = parseInt(octalStr, 8);
            octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), pos += octalStr.length - 1;
            let next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate)
                return res(null);
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      let initialPos = pos, n;
      return {
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, !1, errors, !throwOnInvalid), n === null && (throwOnInvalid ? errors.invalidEscapeSequence(initialPos, lineStart, curLine) : pos = initialPos - 1), {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      let start = pos, forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin, invalid = !1, total = 0;
      for (let i = 0, e = len ?? 1 / 0; i < e; ++i) {
        let code2 = input.charCodeAt(pos), val;
        if (code2 === 95 && allowNumSeparator !== "bail") {
          let prev = input.charCodeAt(pos - 1), next = input.charCodeAt(pos + 1);
          if (allowNumSeparator) {
            if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
              if (bailOnError) return {
                n: null,
                pos
              };
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
          } else {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code2 >= 97 ? val = code2 - 97 + 10 : code2 >= 65 ? val = code2 - 65 + 10 : _isDigit(code2) ? val = code2 - 48 : val = 1 / 0, val >= radix) {
          if (val <= 9 && bailOnError)
            return {
              n: null,
              pos
            };
          if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix))
            val = 0;
          else if (forceLen)
            val = 0, invalid = !0;
          else
            break;
        }
        ++pos, total = total * radix + val;
      }
      return pos === start || len != null && pos - start !== len || invalid ? {
        n: null,
        pos
      } : {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      let ch = input.charCodeAt(pos), code2;
      if (ch === 123) {
        if (++pos, {
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, !0, throwOnInvalid, errors), ++pos, code2 !== null && code2 > 1114111)
          if (throwOnInvalid)
            errors.invalidCodePoint(pos, lineStart, curLine);
          else
            return {
              code: null,
              pos
            };
      } else
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, !1, throwOnInvalid, errors));
      return {
        code: code2,
        pos
      };
    }
    function buildPosition(pos, lineStart, curLine) {
      return new Position(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Token = class {
      constructor(state) {
        let startIndex = state.startIndex || 0;
        this.type = state.type, this.value = state.value, this.start = startIndex + state.start, this.end = startIndex + state.end, this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    }, Tokenizer = class extends CommentsParser {
      constructor(options, input) {
        super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
          invalidDigit: (pos, lineStart, curLine, radix) => this.optionFlags & 2048 ? (this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
            radix
          }), !0) : !1,
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
          },
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
          }
        }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
          }
        }), this.state = new State(), this.state.init(options), this.input = input, this.length = input.length, this.comments = [], this.isLookahead = !1;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength, this.tokens.push(token), ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new Token(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
      }
      eat(type) {
        return this.match(type) ? (this.next(), !0) : !1;
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        let old = this.state;
        this.state = this.createLookaheadState(old), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
        let curr = this.state;
        return this.state = old, curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        return skipWhiteSpace.lastIndex = pos, skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.lookaheadCharCodeSince(this.state.pos);
      }
      lookaheadCharCodeSince(pos) {
        return this.input.charCodeAt(this.nextTokenStartSince(pos));
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(pos) {
        return skipWhiteSpaceInLine.lastIndex = pos, skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          let trail = this.input.charCodeAt(pos);
          (trail & 64512) === 56320 && (cp = 65536 + ((cp & 1023) << 10) + (trail & 1023));
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict, strict && (this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at)), this.state.strictErrors.clear());
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
          this.finishToken(140);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        this.isLookahead || (startLoc = this.state.curPosition());
        let start = this.state.pos, end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1)
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        for (this.state.pos = end + commentEnd.length, lineBreakG.lastIndex = start + 2; lineBreakG.test(this.input) && lineBreakG.lastIndex <= end; )
          ++this.state.curLine, this.state.lineStart = lineBreakG.lastIndex;
        if (this.isLookahead) return;
        let comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end + commentEnd.length),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        return this.optionFlags & 256 && this.pushToken(comment), comment;
      }
      skipLineComment(startSkip) {
        let start = this.state.pos, startLoc;
        this.isLookahead || (startLoc = this.state.curPosition());
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length)
          for (; !isNewLine(ch) && ++this.state.pos < this.length; )
            ch = this.input.charCodeAt(this.state.pos);
        if (this.isLookahead) return;
        let end = this.state.pos, comment = {
          type: "CommentLine",
          value: this.input.slice(start + startSkip, end),
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        return this.optionFlags & 256 && this.pushToken(comment), comment;
      }
      skipSpace() {
        let spaceStart = this.state.pos, comments = this.optionFlags & 4096 ? [] : null;
        loop: for (; this.state.pos < this.length; ) {
          let ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  let comment = this.skipBlockComment("*/");
                  comment !== void 0 && (this.addComment(comment), comments?.push(comment));
                  break;
                }
                case 47: {
                  let comment = this.skipLineComment(2);
                  comment !== void 0 && (this.addComment(comment), comments?.push(comment));
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch))
                ++this.state.pos;
              else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
                let pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  let comment = this.skipLineComment(3);
                  comment !== void 0 && (this.addComment(comment), comments?.push(comment));
                } else
                  break loop;
              } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
                let pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                  let comment = this.skipLineComment(4);
                  comment !== void 0 && (this.addComment(comment), comments?.push(comment));
                } else
                  break loop;
              } else
                break loop;
          }
        }
        if (comments?.length > 0) {
          let end = this.state.pos, commentWhitespace = {
            start: this.sourceToOffsetPos(spaceStart),
            end: this.sourceToOffsetPos(end),
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
        let prevType = this.state.type;
        this.state.type = type, this.state.value = val, this.isLookahead || this.updateContext(prevType);
      }
      replaceToken(type) {
        this.state.type = type, this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter())
          return;
        let nextPos = this.state.pos + 1, next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57)
          throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          this.state.pos += 2, next === 123 ? this.finishToken(7) : this.finishToken(1);
        } else isIdentifierStart(next) ? (++this.state.pos, this.finishToken(139, this.readWord1(next))) : next === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
      }
      readToken_dot() {
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(!0);
          return;
        }
        next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
      }
      readToken_slash() {
        this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return !1;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return !1;
        let start = this.state.pos;
        for (this.state.pos += 1; !isNewLine(ch) && ++this.state.pos < this.length; )
          ch = this.input.charCodeAt(this.state.pos);
        let value2 = this.input.slice(start + 2, this.state.pos);
        return this.finishToken(28, value2), !0;
      }
      readToken_mult_modulo(code2) {
        let type = code2 === 42 ? 55 : 54, width = 1, next = this.input.charCodeAt(this.state.pos + 1);
        code2 === 42 && next === 42 && (width++, next = this.input.charCodeAt(this.state.pos + 2), type = 57), next === 61 && !this.state.inType && (width++, type = code2 === 37 ? 33 : 30), this.finishOp(type, width);
      }
      readToken_pipe_amp(code2) {
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(code2 === 124 ? 41 : 42, 2);
          return;
        }
        if (code2 === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code2 === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        let next = this.input.charCodeAt(this.state.pos + 1);
        next === 61 && !this.state.inType ? this.finishOp(32, 2) : next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
      }
      readToken_atSign() {
        this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
      }
      readToken_plus_min(code2) {
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          this.finishOp(34, 2);
          return;
        }
        next === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
      }
      readToken_lt() {
        let {
          pos
        } = this.state, next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        let {
          pos
        } = this.state, next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          let size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code2) {
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code2 === 61 && next === 62) {
          this.state.pos += 2, this.finishToken(19);
          return;
        }
        this.finishOp(code2 === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        let next = this.input.charCodeAt(this.state.pos + 1), next2 = this.input.charCodeAt(this.state.pos + 2);
        next === 63 ? next2 === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : next === 46 && !(next2 >= 48 && next2 <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
      }
      getTokenFromCode(code2) {
        switch (code2) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos, this.finishToken(10);
            return;
          case 41:
            ++this.state.pos, this.finishToken(11);
            return;
          case 59:
            ++this.state.pos, this.finishToken(13);
            return;
          case 44:
            ++this.state.pos, this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              this.state.pos += 2, this.finishToken(2);
            } else
              ++this.state.pos, this.finishToken(0);
            return;
          case 93:
            ++this.state.pos, this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              this.state.pos += 2, this.finishToken(6);
            } else
              ++this.state.pos, this.finishToken(5);
            return;
          case 125:
            ++this.state.pos, this.finishToken(8);
            return;
          case 58:
            this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            let next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(!1);
            return;
          case 34:
          case 39:
            this.readString(code2);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code2);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code2);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code2);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code2);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart(code2)) {
              this.readWord(code2);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
          unexpected: String.fromCodePoint(code2)
        });
      }
      finishOp(type, size) {
        let str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size, this.finishToken(type, str);
      }
      readRegexp() {
        let startLoc = this.state.startLoc, start = this.state.start + 1, escaped, inClass, {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length)
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          let ch = this.input.charCodeAt(pos);
          if (isNewLine(ch))
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          if (escaped)
            escaped = !1;
          else {
            if (ch === 91)
              inClass = !0;
            else if (ch === 93 && inClass)
              inClass = !1;
            else if (ch === 47 && !inClass)
              break;
            escaped = ch === 92;
          }
        }
        let content = this.input.slice(start, pos);
        ++pos;
        let mods = "", nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        for (; pos < this.length; ) {
          let cp = this.codePointAtPos(pos), char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp))
            cp === 118 ? mods.includes("u") && this.raise(Errors.IncompatibleRegExpUVFlags, nextPos()) : cp === 117 && mods.includes("v") && this.raise(Errors.IncompatibleRegExpUVFlags, nextPos()), mods.includes(char) && this.raise(Errors.DuplicateRegExpFlags, nextPos());
          else if (isIdentifierChar(cp) || cp === 92)
            this.raise(Errors.MalformedRegExpFlags, nextPos());
          else
            break;
          ++pos, mods += char;
        }
        this.state.pos = pos, this.finishToken(138, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = !1, allowNumSeparator = !0) {
        let {
          n,
          pos
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, !1);
        return this.state.pos = pos, n;
      }
      readRadixNumber(radix) {
        let start = this.state.pos, startLoc = this.state.curPosition(), isBigInt = !1;
        this.state.pos += 2;
        let val = this.readInt(radix);
        val == null && this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
          radix
        });
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 110)
          ++this.state.pos, isBigInt = !0;
        else if (next === 109)
          throw this.raise(Errors.InvalidDecimal, startLoc);
        if (isIdentifierStart(this.codePointAtPos(this.state.pos)))
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        if (isBigInt) {
          let str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(136, str);
          return;
        }
        this.finishToken(135, val);
      }
      readNumber(startsWithDot) {
        let start = this.state.pos, startLoc = this.state.curPosition(), isFloat = !1, isBigInt = !1, hasExponent = !1, isOctal = !1;
        !startsWithDot && this.readInt(10) === null && this.raise(Errors.InvalidNumber, this.state.curPosition());
        let hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          let integer = this.input.slice(start, this.state.pos);
          if (this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc), !this.state.strict) {
            let underscorePos = integer.indexOf("_");
            underscorePos > 0 && this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal && (++this.state.pos, this.readInt(10), isFloat = !0, next = this.input.charCodeAt(this.state.pos)), (next === 69 || next === 101) && !isOctal && (next = this.input.charCodeAt(++this.state.pos), (next === 43 || next === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(Errors.InvalidOrMissingExponent, startLoc), isFloat = !0, hasExponent = !0, next = this.input.charCodeAt(this.state.pos)), next === 110 && ((isFloat || hasLeadingZero) && this.raise(Errors.InvalidBigIntLiteral, startLoc), ++this.state.pos, isBigInt = !0), next === 109) {
          this.expectPlugin("decimal", this.state.curPosition()), (hasExponent || hasLeadingZero) && this.raise(Errors.InvalidDecimal, startLoc), ++this.state.pos;
          var isDecimal = !0;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos)))
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        let str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(136, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(137, str);
          return;
        }
        let val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(135, val);
      }
      readCodePoint(throwOnInvalid) {
        let {
          code: code2,
          pos
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        return this.state.pos = pos, code2;
      }
      readString(quote) {
        let {
          str,
          pos,
          curLine,
          lineStart
        } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos + 1, this.state.lineStart = lineStart, this.state.curLine = curLine, this.finishToken(134, str);
      }
      readTemplateContinuation() {
        this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
      }
      readTemplateToken() {
        let opening = this.input[this.state.pos], {
          str,
          firstInvalidLoc,
          pos,
          curLine,
          lineStart
        } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos + 1, this.state.lineStart = lineStart, this.state.curLine = curLine, firstInvalidLoc && (this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos))), this.input.codePointAt(pos) === 96 ? this.finishToken(24, firstInvalidLoc ? null : opening + str + "`") : (this.state.pos++, this.finishToken(25, firstInvalidLoc ? null : opening + str + "${"));
      }
      recordStrictModeErrors(toParseError, at) {
        let index = at.index;
        this.state.strict && !this.state.strictErrors.has(index) ? this.raise(toParseError, at) : this.state.strictErrors.set(index, [toParseError, at]);
      }
      readWord1(firstCode) {
        this.state.containsEsc = !1;
        let word = "", start = this.state.pos, chunkStart = this.state.pos;
        for (firstCode !== void 0 && (this.state.pos += firstCode <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
          let ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch))
            this.state.pos += ch <= 65535 ? 1 : 2;
          else if (ch === 92) {
            this.state.containsEsc = !0, word += this.input.slice(chunkStart, this.state.pos);
            let escStart = this.state.curPosition(), identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, this.state.curPosition()), chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            let esc = this.readCodePoint(!0);
            esc !== null && (identifierCheck(esc) || this.raise(Errors.EscapedCharNotAnIdentifier, escStart), word += String.fromCodePoint(esc)), chunkStart = this.state.pos;
          } else
            break;
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        let word = this.readWord1(firstCode), type = keywords$1.get(word);
        type !== void 0 ? this.finishToken(type, tokenLabelName(type)) : this.finishToken(132, word);
      }
      checkKeywordEscapes() {
        let {
          type
        } = this.state;
        tokenIsKeyword(type) && this.state.containsEsc && this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
          reservedWord: tokenLabelName(type)
        });
      }
      raise(toParseError, at, details = {}) {
        let loc = at instanceof Position ? at : at.loc.start, error = toParseError(loc, details);
        if (!(this.optionFlags & 2048)) throw error;
        return this.isLookahead || this.state.errors.push(error), error;
      }
      raiseOverwrite(toParseError, at, details = {}) {
        let loc = at instanceof Position ? at : at.loc.start, pos = loc.index, errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          let error = errors[i];
          if (error.loc.index === pos)
            return errors[i] = toParseError(loc, details);
          if (error.loc.index < pos) break;
        }
        return this.raise(toParseError, at, details);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc ?? this.state.startLoc, {
          expected: type ? tokenLabelName(type) : null
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName))
          return !0;
        throw this.raise(Errors.MissingPlugin, loc ?? this.state.startLoc, {
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name) => this.hasPlugin(name)))
          throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
            missingPlugin: pluginNames
          });
      }
      errorBuilder(error) {
        return (pos, lineStart, curLine) => {
          this.raise(error, buildPosition(pos, lineStart, curLine));
        };
      }
    }, ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    }, ClassScopeHandler = class {
      constructor(parser3) {
        this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = parser3;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        let oldClassScope = this.stack.pop(), current = this.current();
        for (let [name, loc] of Array.from(oldClassScope.undefinedPrivateNames))
          current ? current.undefinedPrivateNames.has(name) || current.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name
          });
      }
      declarePrivateName(name, elementType, loc) {
        let {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current(), redefined = privateNames.has(name);
        if (elementType & 3) {
          let accessor = redefined && loneAccessors.get(name);
          if (accessor) {
            let oldStatic = accessor & 4, newStatic = elementType & 4, oldKind = accessor & 3, newKind = elementType & 3;
            redefined = oldKind === newKind || oldStatic !== newStatic, redefined || loneAccessors.delete(name);
          } else redefined || loneAccessors.set(name, elementType);
        }
        redefined && this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
          identifierName: name
        }), privateNames.add(name), undefinedPrivateNames.delete(name);
      }
      usePrivateName(name, loc) {
        let classScope;
        for (classScope of this.stack)
          if (classScope.privateNames.has(name)) return;
        classScope ? classScope.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
          identifierName: name
        });
      }
    }, ExpressionScope = class {
      constructor(type = 0) {
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
      }
      isCertainlyParameterDeclaration() {
        return this.type === 3;
      }
    }, ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type), this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, at) {
        let index = at.index;
        this.declarationErrors.set(index, [ParsingErrorClass, at]);
      }
      clearDeclarationError(index) {
        this.declarationErrors.delete(index);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    }, ExpressionScopeHandler = class {
      constructor(parser3) {
        this.parser = void 0, this.stack = [new ExpressionScope()], this.parser = parser3;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, node) {
        let origin = node.loc.start, {
          stack
        } = this, i = stack.length - 1, scope = stack[i];
        for (; !scope.isCertainlyParameterDeclaration(); ) {
          if (scope.canBeArrowParameterDeclaration())
            scope.recordDeclarationError(toParseError, origin);
          else
            return;
          scope = stack[--i];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, node) {
        let {
          stack
        } = this, scope = stack[stack.length - 1], origin = node.loc.start;
        if (scope.isCertainlyParameterDeclaration())
          this.parser.raise(error, origin);
        else if (scope.canBeArrowParameterDeclaration())
          scope.recordDeclarationError(error, origin);
        else
          return;
      }
      recordAsyncArrowParametersError(at) {
        let {
          stack
        } = this, i = stack.length - 1, scope = stack[i];
        for (; scope.canBeArrowParameterDeclaration(); )
          scope.type === 2 && scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at), scope = stack[--i];
      }
      validateAsPattern() {
        let {
          stack
        } = this, currentScope = stack[stack.length - 1];
        currentScope.canBeArrowParameterDeclaration() && currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, loc);
          let i = stack.length - 2, scope = stack[i];
          for (; scope.canBeArrowParameterDeclaration(); )
            scope.clearDeclarationError(loc.index), scope = stack[--i];
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key, value2, enumerable = !0) {
        if (!node) return;
        let {
          extra
        } = node;
        extra == null && (extra = {}, node.extra = extra), enumerable ? extra[key] = value2 : Object.defineProperty(extra, key, {
          enumerable,
          value: value2
        });
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name) {
        if (this.input.startsWith(name, nameStart)) {
          let nextCh = this.input.charCodeAt(nameStart + name.length);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return !1;
      }
      isLookaheadContextual(name) {
        let next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      }
      eatContextual(token) {
        return this.isContextual(token) ? (this.next(), !0) : !1;
      }
      expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
          if (toParseError != null)
            throw this.raise(toParseError, this.state.startLoc);
          this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
      }
      hasFollowingLineBreak() {
        return hasNewLine(this.input, this.state.end, this.nextTokenStart());
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = !0) {
        (allowAsi ? this.isLineTerminator() : this.eat(13)) || this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
      }
      expect(type, loc) {
        this.eat(type) || this.unexpected(loc, type);
      }
      tryParse(fn, oldState = this.state.clone()) {
        let abortSignal = {
          node: null
        };
        try {
          let node = fn((node2 = null) => {
            throw abortSignal.node = node2, abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            let failState = this.state;
            return this.state = oldState, this.state.tokensLength = failState.tokensLength, {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: !1,
              aborted: !1,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: !1,
            aborted: !1,
            failState: null
          };
        } catch (error) {
          let failState = this.state;
          if (this.state = oldState, error instanceof SyntaxError)
            return {
              node: null,
              error,
              thrown: !0,
              aborted: !1,
              failState
            };
          if (error === abortSignal)
            return {
              node: abortSignal.node,
              error: null,
              thrown: !1,
              aborted: !0,
              failState
            };
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors) return !1;
        let {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc,
          voidPatternLoc
        } = refExpressionErrors, hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc || !!voidPatternLoc;
        if (!andThrow)
          return hasErrors;
        shorthandAssignLoc != null && this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc), doubleProtoLoc != null && this.raise(Errors.DuplicateProto, doubleProtoLoc), privateKeyLoc != null && this.raise(Errors.UnexpectedPrivateField, privateKeyLoc), optionalParametersLoc != null && this.unexpected(optionalParametersLoc), voidPatternLoc != null && this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        let oldLabels = this.state.labels;
        this.state.labels = [];
        let oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        let oldInModule = this.inModule;
        this.inModule = inModule;
        let oldScope = this.scope, ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        let oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        let oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        let oldExpressionScope = this.expressionScope;
        return this.expressionScope = new ExpressionScopeHandler(this), () => {
          this.state.labels = oldLabels, this.exportedIdentifiers = oldExportedIdentifiers, this.inModule = oldInModule, this.scope = oldScope, this.prodParam = oldProdParam, this.classScope = oldClassScope, this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = 0;
        (this.inModule || this.optionFlags & 1) && (paramFlags |= 2), this.optionFlags & 32 && (paramFlags |= 1);
        let isCommonJS = !this.inModule && this.options.sourceType === "commonjs";
        (isCommonJS || this.optionFlags & 2) && (paramFlags |= 4), this.prodParam.enter(paramFlags);
        let scopeFlags = isCommonJS ? 514 : 1;
        this.optionFlags & 4 && (scopeFlags |= 512), this.scope.enter(scopeFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        let {
          privateKeyLoc
        } = refExpressionErrors;
        privateKeyLoc !== null && this.expectPlugin("destructuringPrivate", privateKeyLoc);
      }
    }, ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null, this.voidPatternLoc = null;
      }
    }, Node = class {
      constructor(parser3, pos, loc) {
        this.type = "", this.start = pos, this.end = 0, this.loc = new SourceLocation(loc), parser3?.optionFlags & 128 && (this.range = [pos, 0]), parser3 != null && parser3.filename && (this.loc.filename = parser3.filename);
      }
    }, NodePrototype = Node.prototype;
    NodePrototype.__clone = function() {
      let newNode = new Node(void 0, this.start, this.loc.start), keys = Object.keys(this);
      for (let i = 0, length = keys.length; i < length; i++) {
        let key = keys[i];
        key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments" && (newNode[key] = this[key]);
      }
      return newNode;
    };
    var NodeUtils = class extends UtilParser {
      startNode() {
        let loc = this.state.startLoc;
        return new Node(this, loc.index, loc);
      }
      startNodeAt(loc) {
        return new Node(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, endLoc) {
        return node.type = type, node.end = endLoc.index, node.loc.end = endLoc, this.optionFlags & 128 && (node.range[1] = endLoc.index), this.optionFlags & 4096 && this.processComment(node), node;
      }
      resetStartLocation(node, startLoc) {
        node.start = startLoc.index, node.loc.start = startLoc, this.optionFlags & 128 && (node.range[0] = startLoc.index);
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index, node.loc.end = endLoc, this.optionFlags & 128 && (node.range[1] = endLoc.index);
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
      }
      castNodeTo(node, type) {
        return node.type = type, node;
      }
      cloneIdentifier(node) {
        let {
          type,
          start,
          end,
          loc,
          range,
          name
        } = node, cloned = Object.create(NodePrototype);
        return cloned.type = type, cloned.start = start, cloned.end = end, cloned.loc = loc, cloned.range = range, cloned.name = name, node.extra && (cloned.extra = node.extra), cloned;
      }
      cloneStringLiteral(node) {
        let {
          type,
          start,
          end,
          loc,
          range,
          extra
        } = node, cloned = Object.create(NodePrototype);
        return cloned.type = type, cloned.start = start, cloned.end = end, cloned.loc = loc, cloned.range = range, cloned.extra = extra, cloned.value = node.value, cloned;
      }
    }, unwrapParenthesizedExpression = (node) => node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node, LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = !1) {
        var _node$extra, _node$extra3;
        let parenthesized;
        switch ((node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) && (parenthesized = unwrapParenthesizedExpression(node), isLHS ? parenthesized.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node) : parenthesized.type !== "CallExpression" && parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized) && this.raise(Errors.InvalidParenthesizedAssignment, node) : this.raise(Errors.InvalidParenthesizedAssignment, node)), node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
          case "VoidPattern":
            break;
          case "ObjectExpression":
            this.castNodeTo(node, "ObjectPattern");
            for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              let prop = node.properties[i], isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS), isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc && this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
            }
            break;
          case "ObjectProperty": {
            let {
              key,
              value: value2
            } = node;
            this.isPrivateName(key) && this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start), this.toAssignable(value2, isLHS);
            break;
          }
          case "SpreadElement":
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          case "ArrayExpression":
            this.castNodeTo(node, "ArrayPattern"), this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            node.operator !== "=" && this.raise(Errors.MissingEqInAssignment, node.left.loc.end), this.castNodeTo(node, "AssignmentPattern"), delete node.operator, node.left.type === "VoidPattern" && this.raise(Errors.VoidPatternInitializer, node.left), this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod")
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        else if (prop.type === "SpreadElement") {
          this.castNodeTo(prop, "RestElement");
          let arg = prop.argument;
          this.checkToRestConversion(arg, !1), this.toAssignable(arg, isLHS), isLast || this.raise(Errors.RestTrailingComma, prop);
        } else
          this.toAssignable(prop, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        let end = exprList.length - 1;
        for (let i = 0; i <= end; i++) {
          let elt = exprList[i];
          elt && (this.toAssignableListItem(exprList, i, isLHS), elt.type === "RestElement" && (i < end ? this.raise(Errors.RestTrailingComma, elt) : trailingCommaLoc && this.raise(Errors.RestTrailingComma, trailingCommaLoc)));
        }
      }
      toAssignableListItem(exprList, index, isLHS) {
        let node = exprList[index];
        if (node.type === "SpreadElement") {
          this.castNodeTo(node, "RestElement");
          let arg = node.argument;
          this.checkToRestConversion(arg, !0), this.toAssignable(arg, isLHS);
        } else
          this.toAssignable(node, isLHS);
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
          case "VoidPattern":
            return !0;
          case "ObjectExpression": {
            let last = node.properties.length - 1;
            return node.properties.every((prop, i) => prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop));
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return !1;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (let expr of exprList)
          expr?.type === "ArrayExpression" && this.toReferencedListDeep(expr.elements);
      }
      parseSpread(refExpressionErrors) {
        let node = this.startNode();
        return this.next(), node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0), this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        let node = this.startNode();
        this.next();
        let argument = this.parseBindingAtom();
        return argument.type === "VoidPattern" && this.raise(Errors.UnexpectedVoidPattern, argument), node.argument = argument, this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            let node = this.startNode();
            return this.next(), node.elements = this.parseBindingList(3, 93, 1), this.finishNode(node, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, !0);
          case 88:
            return this.parseVoidPattern(null);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, flags) {
        let allowEmpty = flags & 1, elts = [], first = !0;
        for (; !this.eat(close); )
          if (first ? first = !1 : this.expect(12), allowEmpty && this.match(12))
            elts.push(null);
          else {
            if (this.eat(close))
              break;
            if (this.match(21)) {
              let rest = this.parseRestBinding();
              if ((this.hasPlugin("flow") || flags & 2) && (rest = this.parseFunctionParamType(rest)), elts.push(rest), !this.checkCommaAfterRest(closeCharCode)) {
                this.expect(close);
                break;
              }
            } else {
              let decorators = [];
              if (flags & 2)
                for (this.match(26) && this.hasPlugin("decorators") && this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
                  decorators.push(this.parseDecorator());
              elts.push(this.parseBindingElement(flags, decorators));
            }
          }
        return elts;
      }
      parseBindingRestProperty(prop) {
        return this.next(), this.hasPlugin("discardBinding") && this.match(88) ? (prop.argument = this.parseVoidPattern(null), this.raise(Errors.UnexpectedVoidPattern, prop.argument)) : prop.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        let {
          type,
          startLoc
        } = this.state;
        if (type === 21)
          return this.parseBindingRestProperty(this.startNode());
        let prop = this.startNode();
        return type === 139 ? (this.expectPlugin("destructuringPrivate", startLoc), this.classScope.usePrivateName(this.state.value, startLoc), prop.key = this.parsePrivateName()) : this.parsePropertyName(prop), prop.method = !1, this.parseObjPropValue(prop, startLoc, !1, !1, !0, !1);
      }
      parseBindingElement(flags, decorators) {
        let left = this.parseMaybeDefault();
        return (this.hasPlugin("flow") || flags & 2) && this.parseFunctionParamType(left), decorators.length && (left.decorators = decorators, this.resetStartLocationFromNode(left, decorators[0])), this.parseMaybeDefault(left.loc.start, left);
      }
      parseFunctionParamType(param) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        if (startLoc ?? (startLoc = this.state.startLoc), left = left ?? this.parseBindingAtom(), !this.eat(29)) return left;
        let node = this.startNodeAt(startLoc);
        return left.type === "VoidPattern" && this.raise(Errors.VoidPatternInitializer, left), node.left = left, node.right = this.parseMaybeAssignAllowIn(), this.finishNode(node, "AssignmentPattern");
      }
      isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "AssignmentPattern":
            return "left";
          case "RestElement":
            return "argument";
          case "ObjectProperty":
            return "value";
          case "ParenthesizedExpression":
            return "expression";
          case "ArrayPattern":
            return "elements";
          case "ObjectPattern":
            return "properties";
          case "VoidPattern":
            return !0;
          case "CallExpression":
            if (!disallowCallExpression && !this.state.strict && this.optionFlags & 8192)
              return !0;
        }
        return !1;
      }
      isOptionalMemberExpression(expression) {
        return expression.type === "OptionalMemberExpression";
      }
      checkLVal(expression, ancestor, binding = 64, checkClashes = !1, strictModeChanged = !1, hasParenthesizedAncestor = !1, disallowCallExpression = !1) {
        var _expression$extra;
        let type = expression.type;
        if (this.isObjectMethod(expression)) return;
        let isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
        if (isOptionalMemberExpression || type === "MemberExpression") {
          isOptionalMemberExpression && (this.expectPlugin("optionalChainingAssign", expression.loc.start), ancestor.type !== "AssignmentExpression" && this.raise(Errors.InvalidLhsOptionalChaining, expression, {
            ancestor
          })), binding !== 64 && this.raise(Errors.InvalidPropertyBindingPattern, expression);
          return;
        }
        if (type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged);
          let {
            name
          } = expression;
          checkClashes && (checkClashes.has(name) ? this.raise(Errors.ParamDupe, expression) : checkClashes.add(name));
          return;
        } else type === "VoidPattern" && ancestor.type === "CatchClause" && this.raise(Errors.VoidPatternCatchClauseParam, expression);
        let unwrappedExpression = unwrapParenthesizedExpression(expression);
        disallowCallExpression || (disallowCallExpression = unwrappedExpression.type === "CallExpression" && (unwrappedExpression.callee.type === "Import" || unwrappedExpression.callee.type === "Super"));
        let validity = this.isValidLVal(type, disallowCallExpression, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === !0) return;
        if (validity === !1) {
          let ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, expression, {
            ancestor
          });
          return;
        }
        let key, isParenthesizedExpression;
        typeof validity == "string" ? (key = validity, isParenthesizedExpression = type === "ParenthesizedExpression") : [key, isParenthesizedExpression] = validity;
        let nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
          type
        } : ancestor, val = expression[key];
        if (Array.isArray(val))
          for (let child of val)
            child && this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, !0);
        else val && this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, disallowCallExpression);
      }
      checkIdentifier(at, bindingType, strictModeChanged = !1) {
        this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name)) && (bindingType === 64 ? this.raise(Errors.StrictEvalArguments, at, {
          referenceName: at.name
        }) : this.raise(Errors.StrictEvalArgumentsBinding, at, {
          bindingName: at.name
        })), bindingType & 8192 && at.name === "let" && this.raise(Errors.LetInLexicalBinding, at), bindingType & 64 || this.declareNameFromIdentifier(at, bindingType);
      }
      declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern) break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, node);
        }
      }
      checkCommaAfterRest(close) {
        return this.match(12) ? (this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc), !0) : !1;
      }
    }, keywordAndTSRelationalOperator = /in(?:stanceof)?|as|satisfies/y;
    function nonNull(x) {
      if (x == null)
        throw new Error(`Unexpected ${x} value.`);
      return x;
    }
    function assert(x) {
      if (!x)
        throw new Error("Assert fail");
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen: '${modifier}'.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token
      }) => `'${token}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers
      }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidHeritageClauseType: ({
        token
      }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,
      InvalidModifierOnAwaitUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on an await using declaration.`,
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifierOnUsingDeclaration: (modifier) => `'${modifier}' modifier cannot appear on a using declaration.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
      UsingDeclarationInAmbientContext: (kind) => `'${kind}' declarations are not allowed in ambient contexts.`
    });
    function keywordTypeFromName(value2) {
      switch (value2) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class extends superClass {
      constructor(...args) {
        super(...args), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
      }
      tsNextTokenOnSameLineAndCanFollowModifier() {
        return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
      }
      tsNextTokenCanFollowModifier() {
        return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
          return;
        let modifier = this.state.value;
        if (allowedModifiers.includes(modifier)) {
          if (hasSeenStaticModifier && this.match(106) || stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks())
            return;
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
            return modifier;
        }
      }
      tsParseModifiers({
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }, modified) {
        let enforceOrder = (loc, modifier, before, after) => {
          modifier === before && modified[after] && this.raise(TSErrors.InvalidModifiersOrder, loc, {
            orderedModifiers: [before, after]
          });
        }, incompatible = (loc, modifier, mod1, mod2) => {
          (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) && this.raise(TSErrors.IncompatibleModifiers, loc, {
            modifiers: [mod1, mod2]
          });
        };
        for (; ; ) {
          let {
            startLoc
          } = this.state, modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers ?? []), stopOnStartOfClassStaticBlock, modified.static);
          if (!modifier) break;
          tsIsAccessModifier(modifier) ? modified.accessibility ? this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
            modifier
          }) : (enforceOrder(startLoc, modifier, modifier, "override"), enforceOrder(startLoc, modifier, modifier, "static"), enforceOrder(startLoc, modifier, modifier, "readonly"), modified.accessibility = modifier) : tsIsVarianceAnnotations(modifier) ? (modified[modifier] && this.raise(TSErrors.DuplicateModifier, startLoc, {
            modifier
          }), modified[modifier] = !0, enforceOrder(startLoc, modifier, "in", "out")) : (hasOwnProperty.call(modified, modifier) ? this.raise(TSErrors.DuplicateModifier, startLoc, {
            modifier
          }) : (enforceOrder(startLoc, modifier, "static", "readonly"), enforceOrder(startLoc, modifier, "static", "override"), enforceOrder(startLoc, modifier, "override", "readonly"), enforceOrder(startLoc, modifier, "abstract", "override"), incompatible(startLoc, modifier, "declare", "override"), incompatible(startLoc, modifier, "static", "abstract")), modified[modifier] = !0), disallowedModifiers != null && disallowedModifiers.includes(modifier) && this.raise(errorTemplate, startLoc, {
            modifier
          });
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(kind, parseElement) {
        let result = [];
        for (; !this.tsIsListTerminator(kind); )
          result.push(parseElement());
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, !0, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        let result = [], trailingCommaPos = -1;
        for (; !this.tsIsListTerminator(kind); ) {
          trailingCommaPos = -1;
          let element = parseElement();
          if (element == null)
            return;
          if (result.push(element), this.eat(12)) {
            trailingCommaPos = this.state.lastTokStartLoc.index;
            continue;
          }
          if (this.tsIsListTerminator(kind))
            break;
          expectSuccess && this.expect(12);
          return;
        }
        return refTrailingCommaPos && (refTrailingCommaPos.value = trailingCommaPos), result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        skipFirstToken || (bracket ? this.expect(0) : this.expect(47));
        let result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        return bracket ? this.expect(3) : this.expect(48), result;
      }
      tsParseImportType() {
        let node = this.startNode();
        return this.expect(83), this.expect(10), this.match(134) ? node.argument = this.parseStringLiteral(this.state.value) : (this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc), node.argument = super.parseExprAtom()), this.eat(12) ? node.options = this.tsParseImportTypeOptions() : node.options = null, this.expect(11), this.eat(16) && (node.qualifier = this.tsParseEntityName(3)), this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSImportType");
      }
      tsParseImportTypeOptions() {
        let node = this.startNode();
        this.expect(5);
        let withProperty = this.startNode();
        return this.isContextual(76) ? (withProperty.method = !1, withProperty.key = this.parseIdentifier(!0), withProperty.computed = !1, withProperty.shorthand = !1) : this.unexpected(null, 76), this.expect(14), withProperty.value = this.tsParseImportTypeWithPropertyValue(), node.properties = [this.finishObjectProperty(withProperty)], this.eat(12), this.expect(8), this.finishNode(node, "ObjectExpression");
      }
      tsParseImportTypeWithPropertyValue() {
        let node = this.startNode(), properties = [];
        for (this.expect(5); !this.match(8); ) {
          let type = this.state.type;
          tokenIsIdentifier(type) || type === 134 ? properties.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12);
        }
        return node.properties = properties, this.next(), this.finishNode(node, "ObjectExpression");
      }
      tsParseEntityName(flags) {
        let entity;
        if (flags & 1 && this.match(78))
          if (flags & 2)
            entity = this.parseIdentifier(!0);
          else {
            let node = this.startNode();
            this.next(), entity = this.finishNode(node, "ThisExpression");
          }
        else
          entity = this.parseIdentifier(!!(flags & 1));
        for (; this.eat(16); ) {
          let node = this.startNodeAtNode(entity);
          node.left = entity, node.right = this.parseIdentifier(!!(flags & 1)), entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        let node = this.startNode();
        return node.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        let node = this.startNodeAtNode(lhs);
        return node.parameterName = lhs, node.typeAnnotation = this.tsParseTypeAnnotation(!1), node.asserts = !1, this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        let node = this.startNode();
        return this.next(), this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        let node = this.startNode();
        return this.expect(87), this.match(83) ? node.exprName = this.tsParseImportType() : node.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() && this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter(parseModifiers) {
        let node = this.startNode();
        return parseModifiers(node), node.name = this.tsParseTypeParameterName(), node.constraint = this.tsEatThenParseType(81), node.default = this.tsEatThenParseType(29), this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47))
          return this.tsParseTypeParameters(parseModifiers);
      }
      tsParseTypeParameters(parseModifiers) {
        let node = this.startNode();
        this.match(47) || this.match(143) ? this.next() : this.unexpected();
        let refTrailingCommaPos = {
          value: -1
        };
        return node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), !1, !0, refTrailingCommaPos), node.params.length === 0 && this.raise(TSErrors.EmptyTypeParameters, node), refTrailingCommaPos.value !== -1 && this.addExtra(node, "trailingComma", refTrailingCommaPos.value), this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        let returnTokenRequired = returnToken === 19, paramsKey = "parameters", returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), signature[paramsKey] = this.tsParseBindingListForSignature(), returnTokenRequired ? signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken) : this.match(returnToken) && (signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken));
      }
      tsParseBindingListForSignature() {
        let list = super.parseBindingList(11, 41, 2);
        for (let pattern of list) {
          let {
            type
          } = pattern;
          (type === "AssignmentPattern" || type === "TSParameterProperty") && this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
            type
          });
        }
        return list;
      }
      tsParseTypeMemberSemicolon() {
        !this.eat(12) && !this.isLineTerminator() && this.expect(13);
      }
      tsParseSignatureMember(kind, node) {
        return this.tsFillSignature(14, node), this.tsParseTypeMemberSemicolon(), this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        return this.next(), tokenIsIdentifier(this.state.type) ? (this.next(), this.match(14)) : !1;
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
          return;
        this.expect(0);
        let id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(id), this.expect(3), node.parameters = [id];
        let type = this.tsTryParseTypeAnnotation();
        return type && (node.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17) && (node.optional = !0), this.match(10) || this.match(47)) {
          readonly && this.raise(TSErrors.ReadonlyForMethodSignature, node);
          let method = node;
          method.kind && this.match(47) && this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, method), this.tsParseTypeMemberSemicolon();
          let paramsKey = "parameters", returnTypeKey = "typeAnnotation";
          if (method.kind === "get")
            method[paramsKey].length > 0 && (this.raise(Errors.BadGetterArity, this.state.curPosition()), this.isThisParam(method[paramsKey][0]) && this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition()));
          else if (method.kind === "set") {
            if (method[paramsKey].length !== 1)
              this.raise(Errors.BadSetterArity, this.state.curPosition());
            else {
              let firstParameter = method[paramsKey][0];
              this.isThisParam(firstParameter) && this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition()), firstParameter.type === "Identifier" && firstParameter.optional && this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), firstParameter.type === "RestElement" && this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
            }
            method[returnTypeKey] && this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
          } else
            method.kind = "method";
          return this.finishNode(method, "TSMethodSignature");
        } else {
          let property = node;
          readonly && (property.readonly = !0);
          let type = this.tsTryParseTypeAnnotation();
          return type && (property.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        let node = this.startNode();
        if (this.match(10) || this.match(47))
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        if (this.match(77)) {
          let id = this.startNode();
          return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", node) : (node.key = this.createIdentifier(id, "new"), this.tsParsePropertyOrMethodSignature(node, !1));
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node);
        let idx = this.tsTryParseIndexSignature(node);
        return idx || (super.parsePropertyName(node), !node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier() && (node.kind = node.key.name, super.parsePropertyName(node), !this.match(10) && !this.match(47) && this.unexpected(null, 10)), this.tsParsePropertyOrMethodSignature(node, !!node.readonly));
      }
      tsParseTypeLiteral() {
        let node = this.startNode();
        return node.members = this.tsParseObjectTypeMembers(), this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        let members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        return this.expect(8), members;
      }
      tsIsStartOfMappedType() {
        return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
      }
      tsParseMappedType() {
        let node = this.startNode();
        this.expect(5), this.match(53) ? (node.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (node.readonly = !0), this.expect(0);
        {
          let typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName(), typeParameter.constraint = this.tsExpectThenParseType(58), node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        }
        return node.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (node.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (node.optional = !0), node.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        let node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
        let seenOptionalElement = !1;
        return node.elementTypes.forEach((elementNode) => {
          let {
            type
          } = elementNode;
          seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional) && this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode), seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        }), this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        let restStartLoc = this.state.startLoc, rest = this.eat(21), {
          startLoc
        } = this.state, labeled, label, optional, type, chAfterWord = tokenIsKeywordOrIdentifier(this.state.type) ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58)
          labeled = !0, optional = !1, label = this.parseIdentifier(!0), this.expect(14), type = this.tsParseType();
        else if (chAfterWord === 63) {
          optional = !0;
          let wordName = this.state.value, typeOrLabel = this.tsParseNonArrayType();
          this.lookaheadCharCode() === 58 ? (labeled = !0, label = this.createIdentifier(this.startNodeAt(startLoc), wordName), this.expect(17), this.expect(14), type = this.tsParseType()) : (labeled = !1, type = typeOrLabel, this.expect(17));
        } else
          type = this.tsParseType(), optional = this.eat(17), labeled = this.eat(14);
        if (labeled) {
          let labeledNode;
          label ? (labeledNode = this.startNodeAt(startLoc), labeledNode.optional = optional, labeledNode.label = label, labeledNode.elementType = type, this.eat(17) && (labeledNode.optional = !0, this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (labeledNode = this.startNodeAt(startLoc), labeledNode.optional = optional, this.raise(TSErrors.InvalidTupleMemberLabel, type), labeledNode.label = type, labeledNode.elementType = this.tsParseType()), type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          let optionalTypeNode = this.startNodeAt(startLoc);
          optionalTypeNode.typeAnnotation = type, type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          let restNode = this.startNodeAt(restStartLoc);
          restNode.typeAnnotation = type, type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        let node = this.startNode();
        return this.expect(10), node.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        let node = this.startNode();
        return type === "TSConstructorType" && (node.abstract = !!abstract, abstract && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node)), this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        let node = this.startNode();
        switch (this.state.type) {
          case 135:
          case 136:
          case 134:
          case 85:
          case 86:
            node.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        {
          let node = this.startNode();
          return node.literal = super.parseTemplate(!1), this.finishNode(node, "TSLiteralType");
        }
      }
      parseTemplateSubstitution() {
        return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        let thisKeyword = this.tsParseThisTypeNode();
        return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(thisKeyword) : thisKeyword;
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 134:
          case 135:
          case 136:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              let node = this.startNode(), nextToken = this.lookahead();
              return nextToken.type !== 135 && nextToken.type !== 136 && this.unexpected(), node.literal = this.parseMaybeUnary(), this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            let {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              let nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                let node = this.startNode();
                return this.next(), this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        throw this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let {
          startLoc
        } = this.state, type = this.tsParseNonArrayType();
        for (; !this.hasPrecedingLineBreak() && this.eat(0); )
          if (this.match(3)) {
            let node = this.startNodeAt(startLoc);
            node.elementType = type, this.expect(3), type = this.finishNode(node, "TSArrayType");
          } else {
            let node = this.startNodeAt(startLoc);
            node.objectType = type, node.indexType = this.tsParseType(), this.expect(3), type = this.finishNode(node, "TSIndexedAccessType");
          }
        return type;
      }
      tsParseTypeOperator() {
        let node = this.startNode(), operator = this.state.value;
        return this.next(), node.operator = operator, node.typeAnnotation = this.tsParseTypeOperatorOrHigher(), operator === "readonly" && this.tsCheckTypeAnnotationForReadOnly(node), this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
      }
      tsParseInferType() {
        let node = this.startNode();
        this.expectContextual(115);
        let typeParameter = this.startNode();
        return typeParameter.name = this.tsParseTypeParameterName(), typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter"), this.finishNode(node, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          let constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17))
            return constraint;
        }
      }
      tsParseTypeOperatorOrHigher() {
        return tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        let node = this.startNode(), hasLeadingOperator = this.eat(operator), types3 = [];
        do
          types3.push(parseConstituentType());
        while (this.eat(operator));
        return types3.length === 1 && !hasLeadingOperator ? types3[0] : (node.types = types3, this.finishNode(node, kind));
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78))
          return this.next(), !0;
        if (this.match(5)) {
          let {
            errors
          } = this.state, previousErrorCount = errors.length;
          try {
            return this.parseObjectLike(8, !0), errors.length === previousErrorCount;
          } catch {
            return !1;
          }
        }
        if (this.match(0)) {
          this.next();
          let {
            errors
          } = this.state, previousErrorCount = errors.length;
          try {
            return super.parseBindingList(3, 93, 1), errors.length === previousErrorCount;
          } catch {
            return !1;
          }
        }
        return !1;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          let t = this.startNode();
          this.expect(returnToken);
          let node = this.startNode(), asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            return thisTypePredicate.type === "TSThisType" ? (node.parameterName = thisTypePredicate, node.asserts = !0, node.typeAnnotation = null, thisTypePredicate = this.finishNode(node, "TSTypePredicate")) : (this.resetStartLocationFromNode(thisTypePredicate, node), thisTypePredicate.asserts = !0), t.typeAnnotation = thisTypePredicate, this.finishNode(t, "TSTypeAnnotation");
          }
          let typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable)
            return asserts ? (node.parameterName = this.parseIdentifier(), node.asserts = asserts, node.typeAnnotation = null, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, t);
          let type = this.tsParseTypeAnnotation(!1);
          return node.parameterName = typePredicateVariable, node.typeAnnotation = type, node.asserts = asserts, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14))
          return this.tsParseTypeOrTypePredicateAnnotation(14);
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14))
          return this.tsParseTypeAnnotation();
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        let id = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak())
          return this.next(), id;
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 109)
          return !1;
        let containsEsc = this.state.containsEsc;
        return this.next(), !tokenIsIdentifier(this.state.type) && !this.match(78) ? !1 : (containsEsc && this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
          reservedWord: "asserts"
        }), !0);
      }
      tsParseTypeAnnotation(eatColon = !0, t = this.startNode()) {
        return this.tsInType(() => {
          eatColon && this.expect(14), t.typeAnnotation = this.tsParseType();
        }), this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        let type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
          return type;
        let node = this.startNodeAtNode(type);
        return node.checkType = type, node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && this.isLookaheadContextual("new");
      }
      tsParseNonConditionalType() {
        return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        let node = this.startNode();
        return node.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), node.expression = this.parseMaybeUnary(), this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(token) {
        let originalStartLoc = this.state.startLoc, delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          {
            let node = this.startNode();
            return node.expression = this.tsParseEntityName(3), this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSExpressionWithTypeArguments");
          }
        });
        return delimitedList.length || this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
          token
        }), delimitedList;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual(129), properties.declare && (node.declare = !0), tokenIsIdentifier(this.state.type) ? (node.id = this.parseIdentifier(), this.checkIdentifier(node.id, 130)) : (node.id = null, this.raise(TSErrors.MissingInterfaceName, this.state.startLoc)), node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (node.extends = this.tsParseHeritageClause("extends"));
        let body = this.startNode();
        return body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), node.body = this.finishNode(body, "TSInterfaceBody"), this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        return node.id = this.parseIdentifier(), this.checkIdentifier(node.id, 2), node.typeAnnotation = this.tsInType(() => {
          if (node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookaheadCharCode() !== 46) {
            let node2 = this.startNode();
            return this.next(), this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        }), this.semicolon(), this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInTopLevelContext(cb) {
        if (this.curContext() !== types2.brace) {
          let oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else
          return cb();
      }
      tsInType(cb) {
        let oldInType = this.state.inType;
        this.state.inType = !0;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        let oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = !0;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        let oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = !1;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token) {
        if (this.match(token))
          return this.tsNextThenParseType();
      }
      tsExpectThenParseType(token) {
        return this.tsInType(() => (this.expect(token), this.tsParseType()));
      }
      tsNextThenParseType() {
        return this.tsInType(() => (this.next(), this.tsParseType()));
      }
      tsParseEnumMember() {
        let node = this.startNode();
        return node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (node.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        return properties.const && (node.const = !0), properties.declare && (node.declare = !0), this.expectContextual(126), node.id = this.parseIdentifier(), this.checkIdentifier(node.id, node.const ? 8971 : 8459), this.expect(5), node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseEnumBody() {
        let node = this.startNode();
        return this.expect(5), node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(node, "TSEnumBody");
      }
      tsParseModuleBlock() {
        let node = this.startNode();
        return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(node.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = !1) {
        if (node.id = this.parseIdentifier(), nested || this.checkIdentifier(node.id, 1024), this.eat(16)) {
          let inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, !0), node.body = inner;
        } else
          this.scope.enter(1024), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        return this.isContextual(112) ? (node.kind = "global", node.global = !0, node.id = this.parseIdentifier()) : this.match(134) ? (node.kind = "module", node.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
        node.isExport = isExport || !1, node.id = maybeDefaultIdentifier || this.parseIdentifier(), this.checkIdentifier(node.id, 4096), this.expect(29);
        let moduleReference = this.tsParseModuleReference();
        return node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference" && this.raise(TSErrors.ImportAliasHasImportType, moduleReference), node.moduleReference = moduleReference, this.semicolon(), this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
      }
      tsParseExternalModuleReference() {
        let node = this.startNode();
        return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), node.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        let state = this.state.clone(), res = f();
        return this.state = state, res;
      }
      tsTryParseAndCatch(f) {
        let result = this.tryParse((abort) => f() || abort());
        if (!(result.aborted || !result.node))
          return result.error && (this.state = result.failState), result.node;
      }
      tsTryParse(f) {
        let state = this.state.clone(), result = f();
        if (result !== void 0 && result !== !1)
          return result;
        this.state = state;
      }
      tsTryParseDeclare(node) {
        if (this.isLineTerminator())
          return;
        let startType = this.state.type;
        return this.tsInAmbientContext(() => {
          switch (startType) {
            case 68:
              return node.declare = !0, super.parseFunctionStatement(node, !1, !1);
            case 80:
              return node.declare = !0, this.parseClass(node, !0, !1);
            case 126:
              return this.tsParseEnumDeclaration(node, {
                declare: !0
              });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(node);
            case 100:
              if (this.state.containsEsc)
                return;
            case 75:
            case 74:
              return !this.match(75) || !this.isLookaheadContextual("enum") ? (node.declare = !0, this.parseVarStatement(node, this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(node, {
                const: !0,
                declare: !0
              }));
            case 107:
              if (this.isUsing())
                return this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare"), node.declare = !0, this.parseVarStatement(node, "using", !0);
              break;
            case 96:
              if (this.isAwaitUsing())
                return this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare"), node.declare = !0, this.next(), this.parseVarStatement(node, "await using", !0);
              break;
            case 129: {
              let result = this.tsParseInterfaceDeclaration(node, {
                declare: !0
              });
              if (result) return result;
            }
            default:
              if (tokenIsIdentifier(startType))
                return this.tsParseDeclaration(node, this.state.type, !0, null);
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.type, !0, null);
      }
      tsParseDeclaration(node, type, next, decorators) {
        switch (type) {
          case 124:
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type)))
              return this.tsParseAbstractDeclaration(node, decorators);
            break;
          case 127:
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(134))
                return this.tsParseAmbientExternalModuleDeclaration(node);
              if (tokenIsIdentifier(this.state.type))
                return node.kind = "module", this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case 128:
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
              return node.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(node);
            break;
          case 130:
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
              return this.tsParseTypeAliasDeclaration(node);
            break;
        }
      }
      tsCheckLineTerminator(next) {
        return next ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47)) return;
        let oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = !0;
        let res = this.tsTryParseAndCatch(() => {
          let node = this.startNodeAt(startLoc);
          return node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(node), node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), node;
        });
        if (this.state.maybeInArrowParameters = oldMaybeInArrowParameters, !!res)
          return super.parseArrowExpression(res, null, !0);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() === 47)
          return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        let node = this.startNode();
        return node.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), node.params.length === 0 ? this.raise(TSErrors.EmptyTypeArguments, node) : !this.state.inType && this.curContext() === types2.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
      }
      parseBindingElement(flags, decorators) {
        let startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc, modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        let accessibility = modified.accessibility, override = modified.override, readonly = modified.readonly;
        !(flags & 4) && (accessibility || readonly || override) && this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        let left = this.parseMaybeDefault();
        flags & 2 && this.parseFunctionParamType(left);
        let elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility || readonly || override) {
          let pp = this.startNodeAt(startLoc);
          return decorators.length && (pp.decorators = decorators), accessibility && (pp.accessibility = accessibility), readonly && (pp.readonly = readonly), override && (pp.override = override), elt.type !== "Identifier" && elt.type !== "AssignmentPattern" && this.raise(TSErrors.UnsupportedParameterPropertyKind, pp), pp.parameter = elt, this.finishNode(pp, "TSParameterProperty");
        }
        return decorators.length && (left.decorators = decorators), elt;
      }
      isSimpleParameter(node) {
        return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
      }
      tsDisallowOptionalPattern(node) {
        for (let param of node.params)
          param.type !== "Identifier" && param.optional && !this.state.isAmbientContext && this.raise(TSErrors.PatternIsOptional, param);
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node, params, trailingCommaLoc), this.tsDisallowOptionalPattern(node);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = !1) {
        this.match(14) && (node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
        let bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        return bodilessType && !this.match(5) && this.isLineTerminator() ? this.finishNode(node, bodilessType) : bodilessType === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(TSErrors.DeclareFunctionHasImplementation, node), node.declare) ? super.parseFunctionBodyAndFinish(node, bodilessType, isMethod) : (this.tsDisallowOptionalPattern(node), super.parseFunctionBodyAndFinish(node, type, isMethod));
      }
      registerFunctionStatementId(node) {
        !node.body && node.id ? this.checkIdentifier(node.id, 1024) : super.registerFunctionStatementId(node);
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          node?.type === "TSTypeCastExpression" && this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
        });
      }
      toReferencedList(exprList, isInParens) {
        return this.tsCheckForInvalidTypeCasts(exprList), exprList;
      }
      parseArrayLike(close, isTuple, refExpressionErrors) {
        let node = super.parseArrayLike(close, isTuple, refExpressionErrors);
        return node.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(node.elements), node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = !1, this.next();
          let nonNullExpression = this.startNodeAt(startLoc);
          return nonNullExpression.expression = base, this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = !1;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls)
            return state.stop = !0, base;
          state.optionalChainMember = isOptionalCall = !0, this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc, result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              let asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn)
                return state.stop = !0, asyncArrowFn;
            }
            let typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              let result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              return result2.typeParameters = typeArguments, result2;
            }
            if (!noCalls && this.eat(10)) {
              let node2 = this.startNodeAt(startLoc);
              return node2.callee = base, node2.arguments = this.parseCallExpressionArguments(), this.tsCheckForInvalidTypeCasts(node2.arguments), node2.typeParameters = typeArguments, state.optionalChainMember && (node2.optional = isOptionalCall), this.finishCallExpression(node2, state.optionalChainMember);
            }
            let tokenType = this.state.type;
            if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak())
              return;
            let node = this.startNodeAt(startLoc);
            return node.expression = base, node.typeParameters = typeArguments, this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc && this.unexpected(missingParenErrorLoc, 10), result)
            return result.type === "TSInstantiationExpression" && ((this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), !this.match(16) && !this.match(18) && (result.expression = super.stopParseSubscript(base, state))), result;
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node) {
        var _callee$extra;
        super.parseNewCallee(node);
        let {
          callee
        } = node;
        callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized) && (node.typeParameters = callee.typeParameters, node.callee = callee.expression);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          let node = this.startNodeAt(leftStartLoc);
          return node.expression = left, node.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (isSatisfies && this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
            keyword: "const"
          }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(node, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        this.state.isAmbientContext || super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
      }
      checkImportReflection(node) {
        super.checkImportReflection(node), node.module && node.importKind !== "value" && this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return !0;
        if (this.isContextual(130)) {
          let ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc), isExport ? node.exportKind = phase === "type" ? "type" : "value" : node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
      }
      parseImport(node) {
        if (this.match(134))
          return node.importKind = "value", super.parseImport(node);
        let importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61)
          return node.importKind = "value", this.tsParseImportEqualsDeclaration(node);
        if (this.isContextual(130)) {
          let maybeDefaultIdentifier = this.parseMaybeImportPhase(node, !1);
          if (this.lookaheadCharCode() === 61)
            return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
          importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
        } else
          importNode = super.parseImport(node);
        return importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode), importNode;
      }
      parseExport(node, decorators) {
        if (this.match(83)) {
          let nodeImportEquals = node;
          this.next();
          let maybeDefaultIdentifier = null;
          return this.isContextual(130) && this.isPotentialImportPhase(!1) ? maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, !1) : nodeImportEquals.importKind = "value", this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, !0);
        } else if (this.eat(29)) {
          let assign = node;
          return assign.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          let decl = node;
          return this.expectContextual(128), decl.id = this.parseIdentifier(), this.semicolon(), this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else
          return super.parseExport(node, decorators);
      }
      isAbstractClass() {
        return this.isContextual(124) && this.isLookaheadContextual("class");
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          let cls = this.startNode();
          return this.next(), cls.abstract = !0, this.parseClass(cls, !0, !0);
        }
        if (this.match(129)) {
          let result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node, kind, allowMissingInitializer = !1) {
        let {
          isAmbientContext
        } = this.state, declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext) return declaration;
        if (!node.declare && (kind === "using" || kind === "await using"))
          return this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind), declaration;
        for (let {
          id,
          init
        } of declaration.declarations)
          init && (kind === "var" || kind === "let" || id.typeAnnotation ? this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init) : isValidAmbientConstInitializer(init, this.hasPlugin("estree")) || this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init));
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (!this.state.containsEsc)
          switch (this.state.type) {
            case 75: {
              if (this.isLookaheadContextual("enum")) {
                let node = this.startNode();
                return this.expect(75), this.tsParseEnumDeclaration(node, {
                  const: !0
                });
              }
              break;
            }
            case 124:
            case 125: {
              if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
                let token = this.state.type, node = this.startNode();
                this.next();
                let declaration = token === 125 ? this.tsTryParseDeclare(node) : this.tsParseAbstractDeclaration(node, decorators);
                return declaration ? (token === 125 && (declaration.declare = !0), declaration) : (node.expression = this.createIdentifier(this.startNodeAt(node.loc.start), token === 125 ? "declare" : "abstract"), this.semicolon(!1), this.finishNode(node, "ExpressionStatement"));
              }
              break;
            }
            case 126:
              return this.tsParseEnumDeclaration(this.startNode());
            case 112: {
              if (this.lookaheadCharCode() === 123) {
                let node = this.startNode();
                return this.tsParseAmbientExternalModuleDeclaration(node);
              }
              break;
            }
            case 129: {
              let result = this.tsParseInterfaceDeclaration(this.startNode());
              if (result) return result;
              break;
            }
            case 127: {
              if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {
                let node = this.startNode();
                return this.next(), this.tsParseDeclaration(node, 127, !1, decorators);
              }
              break;
            }
            case 128: {
              if (this.nextTokenIsIdentifierOnSameLine()) {
                let node = this.startNode();
                return this.next(), this.tsParseDeclaration(node, 128, !1, decorators);
              }
              break;
            }
            case 130: {
              if (this.nextTokenIsIdentifierOnSameLine()) {
                let node = this.startNode();
                return this.next(), this.tsParseTypeAliasDeclaration(node);
              }
              break;
            }
          }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => tsIsAccessModifier(modifier) ? member.accessibility === modifier : !!member[modifier]);
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        let modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: !0,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        let callParseClassMemberWithIsStatic = () => {
          this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(member, modifiers) && this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(classBody, member)) : this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
        };
        member.declare ? this.tsInAmbientContext(callParseClassMemberWithIsStatic) : callParseClassMemberWithIsStatic();
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        let idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx), member.abstract && this.raise(TSErrors.IndexSignatureHasAbstract, member), member.accessibility && this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
            modifier: member.accessibility
          }), member.declare && this.raise(TSErrors.IndexSignatureHasDeclare, member), member.override && this.raise(TSErrors.IndexSignatureHasOverride, member);
          return;
        }
        !this.state.inAbstractClass && member.abstract && this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member), member.override && (state.hadSuperClass || this.raise(TSErrors.OverrideNotInSubClass, member)), super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        this.eat(17) && (methodOrProp.optional = !0), methodOrProp.readonly && this.match(10) && this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp), methodOrProp.declare && this.match(10) && this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
      }
      shouldParseExportDeclaration() {
        return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          let nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41)
            return this.setOptionalParametersError(refExpressionErrors), expr;
        }
        return super.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseParenItem(node, startLoc) {
        let newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17) && (newNode.optional = !0, this.resetEndLocation(node)), this.match(14)) {
          let typeCastNode = this.startNodeAt(startLoc);
          return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(125))
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        let startLoc = this.state.startLoc, isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        let declaration = tokenIsIdentifier(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        return declaration ? ((declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) && (node.exportKind = "type"), isDeclare && declaration.type !== "TSImportEqualsDeclaration" && (this.resetStartLocation(declaration, startLoc), declaration.declare = !0), declaration) : null;
      }
      parseClassId(node, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(113))
          return;
        super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
        let typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        typeParameters && (node.typeParameters = typeParameters);
      }
      parseClassPropertyAnnotation(node) {
        node.optional || (this.eat(35) ? node.definite = !0 : this.eat(17) && (node.optional = !0));
        let type = this.tsTryParseTypeAnnotation();
        type && (node.typeAnnotation = type);
      }
      parseClassProperty(node) {
        if (this.parseClassPropertyAnnotation(node), this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29) && this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc), node.abstract && this.match(29)) {
          let {
            key
          } = node;
          this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
            propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
          });
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        return node.abstract && this.raise(TSErrors.PrivateElementHasAbstract, node), node.accessibility && this.raise(TSErrors.PrivateElementHasAccessibility, node, {
          modifier: node.accessibility
        }), this.parseClassPropertyAnnotation(node), super.parseClassPrivateProperty(node);
      }
      parseClassAccessorProperty(node) {
        return this.parseClassPropertyAnnotation(node), node.optional && this.raise(TSErrors.AccessorCannotBeOptional, node), super.parseClassAccessorProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        let typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        typeParameters && isConstructor && this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        let {
          declare = !1,
          kind
        } = method;
        declare && (kind === "get" || kind === "set") && this.raise(TSErrors.DeclareAccessor, method, {
          kind
        }), typeParameters && (method.typeParameters = typeParameters), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        let typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        typeParameters && (method.typeParameters = typeParameters), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node, kind) {
        node.type !== "TSDeclareMethod" && (node.type === "MethodDefinition" && node.value.body == null || super.declareClassPrivateMethodInScope(node, kind));
      }
      parseClassSuper(node) {
        super.parseClassSuper(node), node.superClass && (this.match(47) || this.match(51)) && (node.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (node.implements = this.tsParseHeritageClause("implements"));
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        let typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        return typeParameters && (prop.typeParameters = typeParameters), super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node, isConstructor) {
        let typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        typeParameters && (node.typeParameters = typeParameters), super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind), decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (decl.definite = !0);
        let type = this.tsTryParseTypeAnnotation();
        type && (decl.id.typeAnnotation = type, this.resetEndLocation(decl.id));
      }
      parseAsyncArrowFromCallExpression(node, call) {
        return this.match(14) && (node.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
        let state, jsx2, typeCast;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          if (state = this.state.clone(), jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !jsx2.error) return jsx2.node;
          let {
            context
          } = this.state, currentContext = context[context.length - 1];
          (currentContext === types2.j_oTag || currentContext === types2.j_expr) && context.pop();
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47))
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        (!state || state === this.state) && (state = this.state.clone());
        let typeParameters, arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          let expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          return (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && abort(), ((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0 && this.resetStartLocationFromNode(expr, typeParameters), expr.typeParameters = typeParameters, expr;
        }, state);
        if (!arrow.error && !arrow.aborted)
          return typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow.node;
        if (!jsx2 && (assert(!this.hasPlugin("jsx")), typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !typeCast.error))
          return typeCast.node;
        if ((_jsx2 = jsx2) != null && _jsx2.node)
          return this.state = jsx2.failState, jsx2.node;
        if (arrow.node)
          return this.state = arrow.failState, typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow.node;
        if ((_typeCast = typeCast) != null && _typeCast.node)
          return this.state = typeCast.failState, typeCast.node;
        throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      }
      reportReservedArrowTypeParam(node) {
        var _node$extra2;
        node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedArrowTypeParam, node);
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(refExpressionErrors, sawUnary);
      }
      parseArrow(node) {
        if (this.match(14)) {
          let result = this.tryParse((abort) => {
            let returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            return (this.canInsertSemicolon() || !this.match(19)) && abort(), returnType;
          });
          if (result.aborted) return;
          result.thrown || (result.error && (this.state = result.failState), node.returnType = result.node);
        }
        return super.parseArrow(node);
      }
      parseFunctionParamType(param) {
        this.eat(17) && (param.optional = !0);
        let type = this.tsTryParseTypeAnnotation();
        return type && (param.typeAnnotation = type), this.resetEndLocation(param), param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return !0;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = !1) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            isLHS ? this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node) : this.raise(TSErrors.UnexpectedTypeCastInParameter, node), this.toAssignable(node.expression, isLHS);
            break;
          case "AssignmentExpression":
            !isLHS && node.left.type === "TSTypeCastExpression" && (node.left = this.typeCastToParameter(node.left));
          default:
            super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isLHS);
            break;
          default:
            super.toAssignable(node, isLHS);
        }
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node.expression, !1);
            break;
          default:
            super.checkToRestConversion(node, allowPattern);
        }
      }
      isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "TSTypeCastExpression":
            return !0;
          case "TSParameterProperty":
            return "parameter";
          case "TSNonNullExpression":
            return "expression";
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
            return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", !0];
          default:
            return super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);
        }
      }
      parseBindingAtom() {
        return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.match(47) || this.match(51)) {
          let typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            let call = super.parseMaybeDecoratorArguments(expr, startLoc);
            return call.typeParameters = typeArguments, call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr, startLoc);
      }
      checkCommaAfterRest(close) {
        return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close ? (this.next(), !1) : super.checkCommaAfterRest(close);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        let node = super.parseMaybeDefault(startLoc, left);
        return node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation), node;
      }
      getTokenFromCode(code2) {
        if (this.state.inType) {
          if (code2 === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code2 === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        super.getTokenFromCode(code2);
      }
      reScan_lt_gt() {
        let {
          type
        } = this.state;
        type === 47 ? (this.state.pos -= 1, this.readToken_lt()) : type === 48 && (this.state.pos -= 1, this.readToken_gt());
      }
      reScan_lt() {
        let {
          type
        } = this.state;
        return type === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : type;
      }
      toAssignableListItem(exprList, index, isLHS) {
        let node = exprList[index];
        node.type === "TSTypeCastExpression" && (exprList[index] = this.typeCastToParameter(node)), super.toAssignableListItem(exprList, index, isLHS);
      }
      typeCastToParameter(node) {
        return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), node.expression;
      }
      shouldParseArrow(params) {
        return this.match(14) ? params.every((expr) => this.isAssignable(expr, !0)) : super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
          let typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          typeArguments && (node.typeParameters = typeArguments);
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        let baseCount = super.getGetterSetterExpectedParamCount(method), firstParam = this.getObjectOrClassMethodParams(method)[0];
        return firstParam && this.isThisParam(firstParam) ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        let param = super.parseCatchClauseParam(), type = this.tsTryParseTypeAnnotation();
        return type && (param.typeAnnotation = type, this.resetEndLocation(param)), param;
      }
      tsInAmbientContext(cb) {
        let {
          isAmbientContext: oldIsAmbientContext,
          strict: oldStrict
        } = this.state;
        this.state.isAmbientContext = !0, this.state.strict = !1;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext, this.state.strict = oldStrict;
        }
      }
      parseClass(node, isStatement, optionalId) {
        let oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80))
          return node.abstract = !0, this.maybeTakeDecorators(decorators, this.parseClass(node, !0, !1));
        if (this.isContextual(129))
          return this.hasFollowingLineBreak() ? null : (node.abstract = !0, this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node), this.tsParseInterfaceDeclaration(node));
        throw this.unexpected(null, 80);
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        let method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if ((method.abstract || method.type === "TSAbstractMethodDefinition") && (this.hasPlugin("estree") ? method.value : method).body) {
          let {
            key
          } = method;
          this.raise(TSErrors.AbstractMethodHasImplementation, method, {
            methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
          });
        }
        return method;
      }
      tsParseTypeParameterName() {
        return this.parseIdentifier().name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
      }
      getExpression() {
        return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        return !isString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(node, !1, isInTypeExport), this.finishNode(node, "ExportSpecifier")) : (node.exportKind = "value", super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        return !importedIsString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(specifier, !0, isInTypeOnlyImport), this.finishNode(specifier, "ImportSpecifier")) : (specifier.importKind = "value", super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096));
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        let leftOfAsKey = isImport ? "imported" : "local", rightOfAsKey = isImport ? "local" : "exported", leftOfAs = node[leftOfAsKey], rightOfAs, hasTypeSpecifier = !1, canParseAsKeyword = !0, loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          let firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            let secondAs = this.parseIdentifier();
            tokenIsKeywordOrIdentifier(this.state.type) ? (hasTypeSpecifier = !0, leftOfAs = firstAs, rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName(), canParseAsKeyword = !1) : (rightOfAs = secondAs, canParseAsKeyword = !1);
          } else tokenIsKeywordOrIdentifier(this.state.type) ? (canParseAsKeyword = !1, rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName()) : (hasTypeSpecifier = !0, leftOfAs = firstAs);
        } else tokenIsKeywordOrIdentifier(this.state.type) && (hasTypeSpecifier = !0, isImport ? (leftOfAs = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, !0, !0)) : leftOfAs = this.parseModuleExportName());
        hasTypeSpecifier && isInTypeOnlyImportExport && this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc), node[leftOfAsKey] = leftOfAs, node[rightOfAsKey] = rightOfAs;
        let kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value", canParseAsKeyword && this.eatContextual(93) && (node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName()), node[rightOfAsKey] || (node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey])), isImport && this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
      }
      fillOptionalPropertiesForTSESLint(node) {
        var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$optional5, _node$readonly4, _node$declare7, _node$global, _node$const2, _node$in, _node$out;
        switch (node.type) {
          case "ExpressionStatement":
            (_node$directive = node.directive) != null || (node.directive = void 0);
            return;
          case "RestElement":
            node.value = void 0;
          case "Identifier":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "ObjectPattern":
            (_node$decorators = node.decorators) != null || (node.decorators = []), (_node$optional = node.optional) != null || (node.optional = !1), (_node$typeAnnotation = node.typeAnnotation) != null || (node.typeAnnotation = void 0);
            return;
          case "TSParameterProperty":
            (_node$accessibility = node.accessibility) != null || (node.accessibility = void 0), (_node$decorators2 = node.decorators) != null || (node.decorators = []), (_node$override = node.override) != null || (node.override = !1), (_node$readonly = node.readonly) != null || (node.readonly = !1), (_node$static = node.static) != null || (node.static = !1);
            return;
          case "TSEmptyBodyFunctionExpression":
            node.body = null;
          case "TSDeclareFunction":
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ClassMethod":
          case "ClassPrivateMethod":
            (_node$declare = node.declare) != null || (node.declare = !1), (_node$returnType = node.returnType) != null || (node.returnType = void 0), (_node$typeParameters = node.typeParameters) != null || (node.typeParameters = void 0);
            return;
          case "Property":
            (_node$optional2 = node.optional) != null || (node.optional = !1);
            return;
          case "TSMethodSignature":
          case "TSPropertySignature":
            (_node$optional3 = node.optional) != null || (node.optional = !1);
          case "TSIndexSignature":
            (_node$accessibility2 = node.accessibility) != null || (node.accessibility = void 0), (_node$readonly2 = node.readonly) != null || (node.readonly = !1), (_node$static2 = node.static) != null || (node.static = !1);
            return;
          case "TSAbstractPropertyDefinition":
          case "PropertyDefinition":
          case "TSAbstractAccessorProperty":
          case "AccessorProperty":
            (_node$declare2 = node.declare) != null || (node.declare = !1), (_node$definite = node.definite) != null || (node.definite = !1), (_node$readonly3 = node.readonly) != null || (node.readonly = !1), (_node$typeAnnotation2 = node.typeAnnotation) != null || (node.typeAnnotation = void 0);
          case "TSAbstractMethodDefinition":
          case "MethodDefinition":
            (_node$accessibility3 = node.accessibility) != null || (node.accessibility = void 0), (_node$decorators3 = node.decorators) != null || (node.decorators = []), (_node$override2 = node.override) != null || (node.override = !1), (_node$optional4 = node.optional) != null || (node.optional = !1);
            return;
          case "ClassExpression":
            (_node$id = node.id) != null || (node.id = null);
          case "ClassDeclaration":
            (_node$abstract = node.abstract) != null || (node.abstract = !1), (_node$declare3 = node.declare) != null || (node.declare = !1), (_node$decorators4 = node.decorators) != null || (node.decorators = []), (_node$implements = node.implements) != null || (node.implements = []), (_node$superTypeArgume = node.superTypeArguments) != null || (node.superTypeArguments = void 0), (_node$typeParameters2 = node.typeParameters) != null || (node.typeParameters = void 0);
            return;
          case "TSTypeAliasDeclaration":
          case "VariableDeclaration":
            (_node$declare4 = node.declare) != null || (node.declare = !1);
            return;
          case "VariableDeclarator":
            (_node$definite2 = node.definite) != null || (node.definite = !1);
            return;
          case "TSEnumDeclaration":
            (_node$const = node.const) != null || (node.const = !1), (_node$declare5 = node.declare) != null || (node.declare = !1);
            return;
          case "TSEnumMember":
            (_node$computed = node.computed) != null || (node.computed = !1);
            return;
          case "TSImportType":
            (_node$qualifier = node.qualifier) != null || (node.qualifier = null), (_node$options = node.options) != null || (node.options = null);
            return;
          case "TSInterfaceDeclaration":
            (_node$declare6 = node.declare) != null || (node.declare = !1), (_node$extends = node.extends) != null || (node.extends = []);
            return;
          case "TSMappedType":
            (_node$optional5 = node.optional) != null || (node.optional = !1), (_node$readonly4 = node.readonly) != null || (node.readonly = void 0);
            return;
          case "TSModuleDeclaration":
            (_node$declare7 = node.declare) != null || (node.declare = !1), (_node$global = node.global) != null || (node.global = node.kind === "global");
            return;
          case "TSTypeParameter":
            (_node$const2 = node.const) != null || (node.const = !1), (_node$in = node.in) != null || (node.in = !1), (_node$out = node.out) != null || (node.out = !1);
            return;
        }
      }
      chStartsBindingIdentifierAndNotRelationalOperator(ch, pos) {
        if (isIdentifierStart(ch)) {
          if (keywordAndTSRelationalOperator.lastIndex = pos, keywordAndTSRelationalOperator.test(this.input)) {
            let endCh = this.codePointAtPos(keywordAndTSRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92)
              return !1;
          }
          return !0;
        } else return ch === 92;
      }
      nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
        let next = this.nextTokenInLineStart(), nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifierAndNotRelationalOperator(nextCh, next);
      }
      nextTokenIsIdentifierOrStringLiteralOnSameLine() {
        let next = this.nextTokenInLineStart(), nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifier(nextCh, next) || nextCh === 34 || nextCh === 39;
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression") return !1;
      let {
        computed,
        property
      } = expression;
      return computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0) ? !1 : isUncomputedMemberExpressionChain(expression.object);
    }
    function isValidAmbientConstInitializer(expression, estree2) {
      var _expression$extra;
      let {
        type
      } = expression;
      if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized)
        return !1;
      if (estree2) {
        if (type === "Literal") {
          let {
            value: value2
          } = expression;
          if (typeof value2 == "string" || typeof value2 == "boolean")
            return !0;
        }
      } else if (type === "StringLiteral" || type === "BooleanLiteral")
        return !0;
      return !!(isNumber(expression, estree2) || isNegativeNumber(expression, estree2) || type === "TemplateLiteral" && expression.expressions.length === 0 || isPossiblyLiteralEnum(expression));
    }
    function isNumber(expression, estree2) {
      return estree2 ? expression.type === "Literal" && (typeof expression.value == "number" || "bigint" in expression) : expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression, estree2) {
      if (expression.type === "UnaryExpression") {
        let {
          operator,
          argument
        } = expression;
        if (operator === "-" && isNumber(argument, estree2))
          return !0;
      }
      return !1;
    }
    function isUncomputedMemberExpressionChain(expression) {
      return expression.type === "Identifier" ? !0 : expression.type !== "MemberExpression" || expression.computed ? !1 : isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    }), placeholders = (superClass) => class extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(133)) {
          let node = this.startNode();
          return this.next(), this.assertNoSpace(), node.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        let placeholder = node;
        return (!placeholder.expectedNode || !placeholder.type) && (placeholder = this.finishNode(placeholder, "Placeholder")), placeholder.expectedNode = expectedNode, placeholder;
      }
      getTokenFromCode(code2) {
        code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(code2);
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        word !== void 0 && super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
      }
      cloneIdentifier(node) {
        let cloned = super.cloneIdentifier(node);
        return cloned.type === "Placeholder" && (cloned.expectedNode = node.expectedNode), cloned;
      }
      cloneStringLiteral(node) {
        return node.type === "Placeholder" ? this.cloneIdentifier(node) : super.cloneStringLiteral(node);
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, disallowCallExpression, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);
      }
      toAssignable(node, isLHS) {
        node && node.type === "Placeholder" && node.expectedNode === "Expression" ? node.expectedNode = "Pattern" : super.toAssignable(node, isLHS);
      }
      chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos))
          return !0;
        let next = this.nextTokenStart();
        return this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37;
      }
      verifyBreakContinue(node, isBreak) {
        node.label && node.label.type === "Placeholder" || super.verifyBreakContinue(node, isBreak);
      }
      parseExpressionStatement(node, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized)
          return super.parseExpressionStatement(node, expr);
        if (this.match(14)) {
          let stmt = node;
          return stmt.label = this.finishPlaceholder(expr, "Identifier"), this.next(), stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        let stmtPlaceholder = node;
        return stmtPlaceholder.name = expr.name, this.finishPlaceholder(stmtPlaceholder, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node, isStatement, optionalId) {
        let type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        let oldStrict = this.state.strict, placeholder = this.parsePlaceholder("Identifier");
        if (placeholder)
          if (this.match(81) || this.match(133) || this.match(5))
            node.id = placeholder;
          else {
            if (optionalId || !isStatement)
              return node.id = null, node.body = this.finishPlaceholder(placeholder, "ClassBody"), this.finishNode(node, type);
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
          }
        else
          this.parseClassId(node, isStatement, optionalId);
        return super.parseClassSuper(node), node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict), this.finishNode(node, type);
      }
      parseExport(node, decorators) {
        let placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseExport(node, decorators);
        let node2 = node;
        if (!this.isContextual(98) && !this.match(12))
          return node2.specifiers = [], node2.source = null, node2.declaration = this.finishPlaceholder(placeholder, "Declaration"), this.finishNode(node2, "ExportNamedDeclaration");
        this.expectPlugin("exportDefaultFrom");
        let specifier = this.startNode();
        return specifier.exported = placeholder, node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], super.parseExport(node2, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          let next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from") && this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4)))
            return !0;
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        var _specifiers;
        return (_specifiers = node.specifiers) != null && _specifiers.length ? !0 : super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
      }
      checkExport(node) {
        let {
          specifiers
        } = node;
        specifiers != null && specifiers.length && (node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder")), super.checkExport(node), node.specifiers = specifiers;
      }
      parseImport(node) {
        let placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseImport(node);
        if (node.specifiers = [], !this.isContextual(98) && !this.match(12))
          return node.source = this.finishPlaceholder(placeholder, "StringLiteral"), this.semicolon(), this.finishNode(node, "ImportDeclaration");
        let specifier = this.startNodeAtNode(placeholder);
        return specifier.local = placeholder, node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(node) || this.parseNamedImportSpecifiers(node)), this.expectContextual(98), node.source = this.parseImportSource(), this.semicolon(), this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
      }
    }, v8intrinsic = (superClass) => class extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          let v8IntrinsicStartLoc = this.state.startLoc, node = this.startNode();
          if (this.next(), tokenIsIdentifier(this.state.type)) {
            let name = this.parseIdentifierName(), identifier = this.createIdentifier(node, name);
            if (this.castNodeTo(identifier, "V8IntrinsicIdentifier"), this.match(10))
              return identifier;
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    }, PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"], TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    function validatePlugins(pluginsMap) {
      if (pluginsMap.has("decorators")) {
        if (pluginsMap.has("decorators-legacy"))
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        let decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport != "boolean")
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        let allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
        if (allowCallParenthesized != null && typeof allowCallParenthesized != "boolean")
          throw new Error("'allowCallParenthesized' must be a boolean.");
      }
      if (pluginsMap.has("flow") && pluginsMap.has("typescript"))
        throw new Error("Cannot combine flow and typescript plugins.");
      if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic"))
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      if (pluginsMap.has("pipelineOperator")) {
        var _pluginsMap$get2;
        let proposal = pluginsMap.get("pipelineOperator").proposal;
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          let proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        if (proposal === "hack") {
          if (pluginsMap.has("placeholders"))
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          if (pluginsMap.has("v8intrinsic"))
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          let topicToken = pluginsMap.get("pipelineOperator").topicToken;
          if (!TOPIC_TOKENS.includes(topicToken)) {
            let tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          {
            var _pluginsMap$get;
            if (topicToken === "#" && ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash")
              throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
          }
        } else if (proposal === "smart" && ((_pluginsMap$get2 = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get2.syntaxType) === "hash")
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
      }
      if (pluginsMap.has("moduleAttributes")) {
        if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions"))
          throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
        if (pluginsMap.get("moduleAttributes").version !== "may-2020")
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
      }
      if (pluginsMap.has("importAssertions") && pluginsMap.has("deprecatedImportAssert"))
        throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
      if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax && pluginsMap.set("deprecatedImportAssert", {}), pluginsMap.has("recordAndTuple")) {
        let syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
        if (syntaxType != null) {
          let RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
          if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType))
            throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
        }
      }
      if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
        let error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        throw error.missingPlugins = "doExpressions", error;
      }
      if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07")
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      if (pluginsMap.has("discardBinding") && pluginsMap.get("discardBinding").syntaxType !== "void")
        throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders
    }, mixinPluginNames = Object.keys(mixinPlugins), ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, sawProto, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand)
          return sawProto;
        let key = prop.key;
        return (key.type === "Identifier" ? key.name : key.value) === "__proto__" ? isRecord ? (this.raise(Errors.RecordNoProto, key), !0) : (sawProto && (refExpressionErrors ? refExpressionErrors.doubleProtoLoc === null && (refExpressionErrors.doubleProtoLoc = key.loc.start) : this.raise(Errors.DuplicateProto, key)), !0) : sawProto;
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
      }
      getExpression() {
        if (this.enterInitialScopes(), this.nextToken(), this.match(140))
          throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);
        let expr = this.parseExpression();
        if (!this.match(140))
          throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {
            unexpected: this.input.codePointAt(this.state.start)
          });
        return this.finalizeRemainingComments(), expr.comments = this.comments, expr.errors = this.state.errors, this.optionFlags & 256 && (expr.tokens = this.tokens), expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        return disallowIn ? this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors)) : this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        let startLoc = this.state.startLoc, expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          let node = this.startNodeAt(startLoc);
          for (node.expressions = [expr]; this.eat(12); )
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          return this.toReferencedList(node.expressions), this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors) {
        refExpressionErrors.optionalParametersLoc = this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        let startLoc = this.state.startLoc, isYield = this.isContextual(108);
        if (isYield && this.prodParam.hasYield) {
          this.next();
          let left2 = this.parseYield(startLoc);
          return afterLeftParse && (left2 = afterLeftParse.call(this, left2, startLoc)), left2;
        }
        let ownExpressionErrors;
        refExpressionErrors ? ownExpressionErrors = !1 : (refExpressionErrors = new ExpressionErrors(), ownExpressionErrors = !0);
        let {
          type
        } = this.state;
        (type === 10 || tokenIsIdentifier(type)) && (this.state.potentialArrowAt = this.state.start);
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse && (left = afterLeftParse.call(this, left, startLoc)), tokenIsAssignment(this.state.type)) {
          let node = this.startNodeAt(startLoc), operator = this.state.value;
          if (node.operator = operator, this.match(29)) {
            this.toAssignable(left, !0), node.left = left;
            let startIndex = startLoc.index;
            refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex && (refExpressionErrors.doubleProtoLoc = null), refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex && (refExpressionErrors.shorthandAssignLoc = null), refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex && (this.checkDestructuringPrivate(refExpressionErrors), refExpressionErrors.privateKeyLoc = null), refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex && (refExpressionErrors.voidPatternLoc = null);
          } else
            node.left = left;
          return this.next(), node.right = this.parseMaybeAssign(), this.checkLVal(left, this.finishNode(node, "AssignmentExpression"), void 0, void 0, void 0, void 0, operator === "||=" || operator === "&&=" || operator === "??="), node;
        } else ownExpressionErrors && this.checkExpressionErrors(refExpressionErrors, !0);
        if (isYield) {
          let {
            type: type2
          } = this.state;
          if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
            return this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc), this.parseYield(startLoc);
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        let startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprOps(refExpressionErrors);
        return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          let node = this.startNodeAt(startLoc);
          return node.test = expr, node.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), node.alternate = this.parseMaybeAssign(), this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        let startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          let value2 = this.getPrivateNameSV(left);
          (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(Errors.PrivateInExpectedIn, left, {
            identifierName: value2
          }), this.classScope.usePrivateName(value2, left.loc.start);
        }
        let op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                return left;
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            let node = this.startNodeAt(leftStartLoc);
            node.left = left, node.operator = this.state.value;
            let logical = op === 41 || op === 42, coalesce = op === 40;
            if (coalesce && (prec = tokenOperatorPrecedence(42)), this.next(), op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }]) && this.state.type === 96 && this.prodParam.hasAwait)
              throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
            node.right = this.parseExprOpRightExpr(op, prec);
            let finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression"), nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40)
              throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        let startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => this.parseHackPipeBody());
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(prec));
            }
            if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        let startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        let {
          startLoc
        } = this.state, body = this.parseMaybeAssign();
        return UnparenthesizedPipeBodyDescriptions.has(body.type) && !((_body$extra = body.extra) != null && _body$extra.parenthesized) && this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
          type: body.type
        }), this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipeTopicUnused, startLoc), body;
      }
      checkExponentialAfterUnary(node) {
        this.match(57) && this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        let startLoc = this.state.startLoc, isAwait = this.isContextual(96);
        if (isAwait && this.recordAwaitIfAllowed()) {
          this.next();
          let expr2 = this.parseAwait(startLoc);
          return sawUnary || this.checkExponentialAfterUnary(expr2), expr2;
        }
        let update = this.match(34), node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node.operator = this.state.value, node.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
          let isDelete = this.match(89);
          if (this.next(), node.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(refExpressionErrors, !0), this.state.strict && isDelete) {
            let arg = node.argument;
            arg.type === "Identifier" ? this.raise(Errors.StrictDelete, node) : this.hasPropertyAsPrivateName(arg) && this.raise(Errors.DeletePrivateField, node);
          }
          if (!update)
            return sawUnary || this.checkExponentialAfterUnary(node), this.finishNode(node, "UnaryExpression");
        }
        let expr = this.parseUpdate(node, update, refExpressionErrors);
        if (isAwait) {
          let {
            type
          } = this.state;
          if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
            return this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc), this.parseAwait(startLoc);
        }
        return expr;
      }
      parseUpdate(node, update, refExpressionErrors) {
        if (update) {
          let updateExpressionNode = node;
          return this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression")), node;
        }
        let startLoc = this.state.startLoc, expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, !1)) return expr;
        for (; tokenIsPostfix(this.state.type) && !this.canInsertSemicolon(); ) {
          let node2 = this.startNodeAt(startLoc);
          node2.operator = this.state.value, node2.prefix = !1, node2.argument = expr, this.next(), this.checkLVal(expr, expr = this.finishNode(node2, "UpdateExpression"));
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        let startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprAtom(refExpressionErrors);
        return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        let state = {
          optionalChainMember: !1,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: !1
        };
        do
          base = this.parseSubscript(base, startLoc, noCalls, state), state.maybeAsyncArrow = !1;
        while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        let {
          type
        } = this.state;
        if (!noCalls && type === 15)
          return this.parseBind(base, startLoc, noCalls, state);
        if (tokenIsTemplate(type))
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        let optional = !1;
        if (type === 18) {
          if (noCalls && (this.raise(Errors.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
            return this.stopParseSubscript(base, state);
          state.optionalChainMember = optional = !0, this.next();
        }
        if (!noCalls && this.match(10))
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        {
          let computed = this.eat(0);
          return computed || optional || this.eat(16) ? this.parseMember(base, startLoc, state, computed, optional) : this.stopParseSubscript(base, state);
        }
      }
      stopParseSubscript(base, state) {
        return state.stop = !0, base;
      }
      parseMember(base, startLoc, state, computed, optional) {
        let node = this.startNodeAt(startLoc);
        return node.object = base, node.computed = computed, computed ? (node.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (base.type === "Super" && this.raise(Errors.SuperPrivateField, startLoc), this.classScope.usePrivateName(this.state.value, this.state.startLoc), node.property = this.parsePrivateName()) : node.property = this.parseIdentifier(!0), state.optionalChainMember ? (node.optional = optional, this.finishNode(node, "OptionalMemberExpression")) : this.finishNode(node, "MemberExpression");
      }
      parseBind(base, startLoc, noCalls, state) {
        let node = this.startNodeAt(startLoc);
        return node.object = base, this.next(), node.callee = this.parseNoCallExpr(), state.stop = !0, this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        let oldMaybeInArrowParameters = this.state.maybeInArrowParameters, refExpressionErrors = null;
        this.state.maybeInArrowParameters = !0, this.next();
        let node = this.startNodeAt(startLoc);
        node.callee = base;
        let {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        maybeAsyncArrow && (this.expressionScope.enter(newAsyncArrowScope()), refExpressionErrors = new ExpressionErrors()), optionalChainMember && (node.optional = optional), optional ? node.arguments = this.parseCallExpressionArguments() : node.arguments = this.parseCallExpressionArguments(base.type !== "Super", node, refExpressionErrors);
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        return maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional ? (state.stop = !0, this.checkDestructuringPrivate(refExpressionErrors), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode)) : (maybeAsyncArrow && (this.checkExpressionErrors(refExpressionErrors, !0), this.expressionScope.exit()), this.toReferencedArguments(finishedNode)), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, finishedNode;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        let node = this.startNodeAt(startLoc);
        return node.tag = base, node.quasi = this.parseTemplate(!0), state.optionalChainMember && this.raise(Errors.OptionalChainingNoTemplate, startLoc), this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import")
          if (node.arguments.length === 0 || node.arguments.length > 2)
            this.raise(Errors.ImportCallArity, node);
          else
            for (let arg of node.arguments)
              arg.type === "SpreadElement" && this.raise(Errors.ImportCallSpreadArgument, arg);
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {
        let elts = [], first = !0, oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(11); ) {
          if (first)
            first = !1;
          else if (this.expect(12), this.match(11)) {
            nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
            break;
          }
          elts.push(this.parseExprListItem(11, !1, refExpressionErrors, allowPlaceholder));
        }
        return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        return this.resetPreviousNodeTrailingComments(call), this.expect(19), this.parseArrowExpression(node, call.arguments, !0, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc), call.innerComments && setInnerComments(node, call.innerComments), call.callee.trailingComments && setInnerComments(node, call.callee.trailingComments), node;
      }
      parseNoCallExpr() {
        let startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, !0);
      }
      parseExprAtom(refExpressionErrors) {
        let node, decorators = null, {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            return node = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(node) : this.match(10) ? this.optionFlags & 512 ? this.parseImportCall(node) : this.finishNode(node, "Import") : (this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(node, "Import"));
          case 78:
            return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");
          case 90:
            return this.parseDo(this.startNode(), !1);
          case 56:
          case 31:
            return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
          case 135:
            return this.parseNumericLiteral(this.state.value);
          case 136:
            return this.parseBigIntLiteral(this.state.value);
          case 134:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(!0);
          case 86:
            return this.parseBooleanLiteral(!1);
          case 10: {
            let canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 0:
            return this.parseArrayLike(3, !1, refExpressionErrors);
          case 5:
            return this.parseObjectLike(8, !1, !1, refExpressionErrors);
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), !1);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(!1);
          case 15: {
            node = this.startNode(), this.next(), node.object = null;
            let callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression")
              return this.finishNode(node, "BindExpression");
            throw this.raise(Errors.UnsupportedBind, callee);
          }
          case 139:
            return this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
              identifierName: this.state.value
            }), this.parsePrivateName();
          case 33:
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          case 32:
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          case 37:
          case 38:
            return this.parseTopicReference("hack");
          case 44:
          case 54:
          case 27: {
            let pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal)
              return this.parseTopicReference(pipeProposal);
            throw this.unexpected();
          }
          case 47: {
            let lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            throw isIdentifierStart(lookaheadCh) || lookaheadCh === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          }
          default:
            {
              if (type === 137)
                return this.parseDecimalLiteral(this.state.value);
              if (type === 2 || type === 1)
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !0);
              if (type === 6 || type === 7)
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
            }
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
                return this.parseModuleExpression();
              let canBeArrow = this.state.potentialArrowAt === this.state.start, containsEsc = this.state.containsEsc, id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                let {
                  type: type2
                } = this.state;
                if (type2 === 68)
                  return this.resetPreviousNodeTrailingComments(id), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                if (tokenIsIdentifier(type2))
                  return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id)) : id;
                if (type2 === 90)
                  return this.resetPreviousNodeTrailingComments(id), this.parseDo(this.startNodeAtNode(id), !0);
              }
              return canBeArrow && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(id), [id], !1)) : id;
            } else
              throw this.unexpected();
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        let pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal)
          return this.state.type = topicTokenType, this.state.value = topicTokenValue, this.state.pos--, this.state.end--, this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1), this.parseTopicReference(pipeProposal);
        throw this.unexpected();
      }
      parseTopicReference(pipeProposal) {
        let node = this.startNode(), startLoc = this.state.startLoc, tokenType = this.state.type;
        return this.next(), this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
      }
      finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType))
          return pipeProposal === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(Errors.PipeTopicUnbound, startLoc), this.registerTopicReference(), this.finishNode(node, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(Errors.PrimaryTopicNotAllowed, startLoc), this.registerTopicReference(), this.finishNode(node, "PipelinePrimaryTopicReference"));
        throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
          token: tokenLabelName(tokenType)
        });
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch (pipeProposal) {
          case "hack":
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          case "smart":
            return tokenType === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(!0, this.prodParam.hasYield));
        let params = [this.parseIdentifier()];
        return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(node, params, !0);
      }
      parseDo(node, isAsync) {
        this.expectPlugin("doExpressions"), isAsync && this.expectPlugin("asyncDoExpressions"), node.async = isAsync, this.next();
        let oldLabels = this.state.labels;
        return this.state.labels = [], isAsync ? (this.prodParam.enter(2), node.body = this.parseBlock(), this.prodParam.exit()) : node.body = this.parseBlock(), this.state.labels = oldLabels, this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        let node = this.startNode();
        return this.next(), this.match(10) && !this.scope.allowDirectSuper ? this.optionFlags & 16 || this.raise(Errors.SuperNotAllowed, node) : this.scope.allowSuper || this.optionFlags & 16 || this.raise(Errors.UnexpectedSuper, node), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(Errors.UnsupportedSuper, node), this.finishNode(node, "Super");
      }
      parsePrivateName() {
        let node = this.startNode(), id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1)), name = this.state.value;
        return this.next(), node.id = this.createIdentifier(id, name), this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        let node = this.startNode();
        if (this.next(), this.prodParam.hasYield && this.match(16)) {
          let meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        let containsEsc = this.state.containsEsc;
        return node.property = this.parseIdentifier(!0), (node.property.name !== propertyName || containsEsc) && this.raise(Errors.UnsupportedMetaProperty, node.property, {
          target: meta.name,
          onlyValidPropertyName: propertyName
        }), this.finishNode(node, "MetaProperty");
      }
      parseImportMetaPropertyOrPhaseCall(node) {
        if (this.next(), this.isContextual(105) || this.isContextual(97)) {
          let isSource = this.isContextual(105);
          return this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation"), this.next(), node.phase = isSource ? "source" : "defer", this.parseImportCall(node);
        } else {
          let id = this.createIdentifierAt(this.startNodeAtNode(node), "import", this.state.lastTokStartLoc);
          return this.isContextual(101) && (this.inModule || this.raise(Errors.ImportMetaOutsideModule, id), this.sawUnambiguousESM = !0), this.parseMetaProperty(node, id, "meta");
        }
      }
      parseLiteralAtNode(value2, type, node) {
        return this.addExtra(node, "rawValue", value2), this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end)), node.value = value2, this.next(), this.finishNode(node, type);
      }
      parseLiteral(value2, type) {
        let node = this.startNode();
        return this.parseLiteralAtNode(value2, type, node);
      }
      parseStringLiteral(value2) {
        return this.parseLiteral(value2, "StringLiteral");
      }
      parseNumericLiteral(value2) {
        return this.parseLiteral(value2, "NumericLiteral");
      }
      parseBigIntLiteral(value2) {
        return this.parseLiteral(value2, "BigIntLiteral");
      }
      parseDecimalLiteral(value2) {
        return this.parseLiteral(value2, "DecimalLiteral");
      }
      parseRegExpLiteral(value2) {
        let node = this.startNode();
        return this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end)), node.pattern = value2.pattern, node.flags = value2.flags, this.next(), this.finishNode(node, "RegExpLiteral");
      }
      parseBooleanLiteral(value2) {
        let node = this.startNode();
        return node.value = value2, this.next(), this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        let node = this.startNode();
        return this.next(), this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        let startLoc = this.state.startLoc, val;
        this.next(), this.expressionScope.enter(newArrowHeadScope());
        let oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
        let innerStartLoc = this.state.startLoc, exprList = [], refExpressionErrors = new ExpressionErrors(), first = !0, spreadStartLoc, optionalCommaStartLoc;
        for (; !this.match(11); ) {
          if (first)
            first = !1;
          else if (this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc), this.match(11)) {
            optionalCommaStartLoc = this.state.startLoc;
            break;
          }
          if (this.match(21)) {
            let spreadNodeStartLoc = this.state.startLoc;
            if (spreadStartLoc = this.state.startLoc, exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc)), !this.checkCommaAfterRest(41))
              break;
          } else
            exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(11, refExpressionErrors, this.parseParenItem));
        }
        let innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        return canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode)) ? (this.checkDestructuringPrivate(refExpressionErrors), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(arrowNode, exprList, !1), arrowNode) : (this.expressionScope.exit(), exprList.length || this.unexpected(this.state.lastTokStartLoc), optionalCommaStartLoc && this.unexpected(optionalCommaStartLoc), spreadStartLoc && this.unexpected(spreadStartLoc), this.checkExpressionErrors(refExpressionErrors, !0), this.toReferencedListDeep(exprList, !0), exprList.length > 1 ? (val = this.startNodeAt(innerStartLoc), val.expressions = exprList, this.finishNode(val, "SequenceExpression"), this.resetEndLocation(val, innerEndLoc)) : val = exprList[0], this.wrapParenthesis(startLoc, val));
      }
      wrapParenthesis(startLoc, expression) {
        if (!(this.optionFlags & 1024))
          return this.addExtra(expression, "parenthesized", !0), this.addExtra(expression, "parenStart", startLoc.index), this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index), expression;
        let parenExpression = this.startNodeAt(startLoc);
        return parenExpression.expression = expression, this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(19))
          return node;
      }
      parseParenItem(node, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        let node = this.startNode();
        if (this.next(), this.match(16)) {
          let meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          let metaProp = this.parseMetaProperty(node, meta, "target");
          return this.scope.allowNewTarget || this.raise(Errors.UnexpectedNewTarget, metaProp), metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        if (this.parseNewCallee(node), this.eat(10)) {
          let args = this.parseExprList(11);
          this.toReferencedList(args), node.arguments = args;
        } else
          node.arguments = [];
        return this.finishNode(node, "NewExpression");
      }
      parseNewCallee(node) {
        let isImport = this.match(83), callee = this.parseNoCallExpr();
        node.callee = callee, isImport && (callee.type === "Import" || callee.type === "ImportExpression") && this.raise(Errors.ImportCallNotNewExpression, callee);
      }
      parseTemplateElement(isTagged) {
        let {
          start,
          startLoc,
          end,
          value: value2
        } = this.state, elemStart = start + 1, elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        value2 === null && (isTagged || this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)));
        let isTail = this.match(24), endOffset = isTail ? -1 : -2, elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, `
`),
          cooked: value2 === null ? null : value2.slice(1, endOffset)
        }, elem.tail = isTail, this.next();
        let finishedNode = this.finishNode(elem, "TemplateElement");
        return this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset)), finishedNode;
      }
      parseTemplate(isTagged) {
        let node = this.startNode(), curElt = this.parseTemplateElement(isTagged), quasis = [curElt], substitutions = [];
        for (; !curElt.tail; )
          substitutions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), quasis.push(curElt = this.parseTemplateElement(isTagged));
        return node.expressions = substitutions, node.quasis = quasis, this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        isRecord && this.expectPlugin("recordAndTuple");
        let oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = !1;
        let sawProto = !1, first = !0, node = this.startNode();
        for (node.properties = [], this.next(); !this.match(close); ) {
          if (first)
            first = !1;
          else if (this.expect(12), this.match(close)) {
            this.addTrailingCommaExtraToNode(node);
            break;
          }
          let prop;
          isPattern ? prop = this.parseBindingProperty() : (prop = this.parsePropertyDefinition(refExpressionErrors), sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors)), isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement" && this.raise(Errors.InvalidRecordProperty, prop), prop.shorthand && this.addExtra(prop, "shorthand", !0), node.properties.push(prop);
        }
        this.next(), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        return isPattern ? type = "ObjectPattern" : isRecord && (type = "RecordExpression"), this.finishNode(node, type);
      }
      addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26))
          for (this.hasPlugin("decorators") && this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
            decorators.push(this.parseDecorator());
        let prop = this.startNode(), isAsync = !1, isAccessor = !1, startLoc;
        if (this.match(21))
          return decorators.length && this.unexpected(), this.parseSpread();
        decorators.length && (prop.decorators = decorators, decorators = []), prop.method = !1, refExpressionErrors && (startLoc = this.state.startLoc);
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        let containsEsc = this.state.containsEsc;
        if (this.parsePropertyName(prop, refExpressionErrors), !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          let {
            key
          } = prop, keyName = key.name;
          keyName === "async" && !this.hasPrecedingLineBreak() && (isAsync = !0, this.resetPreviousNodeTrailingComments(key), isGenerator = this.eat(55), this.parsePropertyName(prop)), (keyName === "get" || keyName === "set") && (isAccessor = !0, this.resetPreviousNodeTrailingComments(key), prop.kind = keyName, this.match(55) && (isGenerator = !0, this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
            kind: keyName
          }), this.next()), this.parsePropertyName(prop));
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, !1, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        let paramCount = this.getGetterSetterExpectedParamCount(method), params = this.getObjectOrClassMethodParams(method);
        params.length !== paramCount && this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method), method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement" && this.raise(Errors.BadSetterRestParameter, method);
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          let finishedProp = this.parseMethod(prop, isGenerator, !1, !1, !1, "ObjectMethod");
          return this.checkGetterSetterParams(finishedProp), finishedProp;
        }
        if (isAsync || isGenerator || this.match(10))
          return isPattern && this.unexpected(), prop.kind = "method", prop.method = !0, this.parseMethod(prop, isGenerator, isAsync, !1, !1, "ObjectMethod");
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        if (prop.shorthand = !1, this.eat(14))
          return prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, refExpressionErrors), this.finishObjectProperty(prop);
        if (!prop.computed && prop.key.type === "Identifier") {
          if (this.checkReservedWord(prop.key.name, prop.key.loc.start, !0, !1), isPattern)
            prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
          else if (this.match(29)) {
            let shorthandAssignLoc = this.state.startLoc;
            refExpressionErrors != null ? refExpressionErrors.shorthandAssignLoc === null && (refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc) : this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc), prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
          } else
            prop.value = this.cloneIdentifier(prop.key);
          return prop.shorthand = !0, this.finishObjectProperty(prop);
        }
      }
      finishObjectProperty(node) {
        return this.finishNode(node, "ObjectProperty");
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        let node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        return node || this.unexpected(), node;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0))
          prop.computed = !0, prop.key = this.parseMaybeAssignAllowIn(), this.expect(3);
        else {
          let {
            type,
            value: value2
          } = this.state, key;
          if (tokenIsKeywordOrIdentifier(type))
            key = this.parseIdentifier(!0);
          else
            switch (type) {
              case 135:
                key = this.parseNumericLiteral(value2);
                break;
              case 134:
                key = this.parseStringLiteral(value2);
                break;
              case 136:
                key = this.parseBigIntLiteral(value2);
                break;
              case 139: {
                let privateKeyLoc = this.state.startLoc;
                refExpressionErrors != null ? refExpressionErrors.privateKeyLoc === null && (refExpressionErrors.privateKeyLoc = privateKeyLoc) : this.raise(Errors.UnexpectedPrivateField, privateKeyLoc), key = this.parsePrivateName();
                break;
              }
              default:
                if (type === 137) {
                  key = this.parseDecimalLiteral(value2);
                  break;
                }
                this.unexpected();
            }
          prop.key = key, type !== 139 && (prop.computed = !1);
        }
      }
      initFunction(node, isAsync) {
        node.id = null, node.generator = !1, node.async = isAsync;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = !1) {
        this.initFunction(node, isAsync), node.generator = isGenerator, this.scope.enter(530 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0)), this.prodParam.enter(functionFlags(isAsync, node.generator)), this.parseFunctionParams(node, isConstructor);
        let finishedNode = this.parseFunctionBodyAndFinish(node, type, !0);
        return this.prodParam.exit(), this.scope.exit(), finishedNode;
      }
      parseArrayLike(close, isTuple, refExpressionErrors) {
        isTuple && this.expectPlugin("recordAndTuple");
        let oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = !1;
        let node = this.startNode();
        return this.next(), node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(518);
        let flags = functionFlags(isAsync, !1);
        !this.match(5) && this.prodParam.hasIn && (flags |= 8), this.prodParam.enter(flags), this.initFunction(node, isAsync);
        let oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        return params && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(node, params, trailingCommaLoc)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(node, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, !1), node.params = params;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = !1) {
        return this.parseFunctionBody(node, !1, isMethod), this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = !1) {
        let isExpression = allowExpression && !this.match(5);
        if (this.expressionScope.enter(newExpressionScope()), isExpression)
          node.body = this.parseMaybeAssign(), this.checkParams(node, !1, allowExpression, !1);
        else {
          let oldStrict = this.state.strict, oldLabels = this.state.labels;
          this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), node.body = this.parseBlock(!0, !1, (hasStrictModeDirective) => {
            let nonSimple = !this.isSimpleParamList(node.params);
            hasStrictModeDirective && nonSimple && this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && node.key ? node.key.loc.end : node);
            let strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged), this.state.strict && node.id && this.checkIdentifier(node.id, 65, strictModeChanged);
          }), this.prodParam.exit(), this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node) {
        return node.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++)
          if (!this.isSimpleParameter(params[i])) return !1;
        return !0;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = !0) {
        let checkClashes = !allowDuplicates && /* @__PURE__ */ new Set(), formalParameters = {
          type: "FormalParameters"
        };
        for (let param of node.params)
          this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        let elts = [], first = !0;
        for (; !this.eat(close); ) {
          if (first)
            first = !1;
          else if (this.expect(12), this.match(close)) {
            nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
            break;
          }
          elts.push(this.parseExprListItem(close, allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12))
          allowEmpty || this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
            unexpected: ","
          }), elt = null;
        else if (this.match(21)) {
          let spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication"), allowPlaceholder || this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
          let node = this.startNode();
          this.next(), elt = this.finishNode(node, "ArgumentPlaceholder");
        } else
          elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);
        return elt;
      }
      parseIdentifier(liberal) {
        let node = this.startNode(), name = this.parseIdentifierName(liberal);
        return this.createIdentifier(node, name);
      }
      createIdentifier(node, name) {
        return node.name = name, node.loc.identifierName = name, this.finishNode(node, "Identifier");
      }
      createIdentifierAt(node, name, endLoc) {
        return node.name = name, node.loc.identifierName = name, this.finishNodeAt(node, "Identifier", endLoc);
      }
      parseIdentifierName(liberal) {
        let name, {
          startLoc,
          type
        } = this.state;
        tokenIsKeywordOrIdentifier(type) ? name = this.state.value : this.unexpected();
        let tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        return liberal ? tokenIsKeyword2 && this.replaceToken(132) : this.checkReservedWord(name, startLoc, tokenIsKeyword2, !1), this.next(), name;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10 || !canBeReservedWord(word))
          return;
        if (checkKeywords && isKeyword(word)) {
          this.raise(Errors.UnexpectedKeyword, startLoc, {
            keyword: word
          });
          return;
        }
        if ((this.state.strict ? isBinding ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(word, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, startLoc, {
            reservedWord: word
          });
          return;
        } else if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, startLoc);
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, startLoc);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(Errors.ArgumentsInClass, startLoc);
          return;
        }
      }
      recordAwaitIfAllowed() {
        let isAwaitAllowed = this.prodParam.hasAwait;
        return isAwaitAllowed && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), isAwaitAllowed;
      }
      parseAwait(startLoc) {
        let node = this.startNodeAt(startLoc);
        return this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node), this.eat(55) && this.raise(Errors.ObsoleteAwaitStar, node), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (node.argument = this.parseMaybeUnary(null, !0)), this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousPrefixOrIdentifier() {
        if (this.hasPrecedingLineBreak()) return !0;
        let {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield(startLoc) {
        let node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
        let delegating = !1, argument = null;
        if (!this.hasPrecedingLineBreak())
          switch (delegating = this.eat(55), this.state.type) {
            case 13:
            case 140:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating) break;
            default:
              argument = this.parseMaybeAssign();
          }
        return node.delegate = delegating, node.argument = argument, this.finishNode(node, "YieldExpression");
      }
      parseImportCall(node) {
        if (this.next(), node.source = this.parseMaybeAssignAllowIn(), node.options = null, this.eat(12)) {
          if (this.match(11))
            this.addTrailingCommaExtraToNode(node.source);
          else if (node.options = this.parseMaybeAssignAllowIn(), this.eat(12) && (this.addTrailingCommaExtraToNode(node.options), !this.match(11))) {
            do
              this.parseMaybeAssignAllowIn();
            while (this.eat(12) && !this.match(11));
            this.raise(Errors.ImportCallArity, node);
          }
        }
        return this.expect(11), this.finishNode(node, "ImportExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }]) && left.type === "SequenceExpression" && this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          let bodyNode = this.startNodeAt(startLoc);
          return bodyNode.callee = childExpr, this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          let bodyNode = this.startNodeAt(startLoc);
          return this.checkSmartPipeTopicBodyEarlyErrors(startLoc), bodyNode.expression = childExpr, this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return !0;
          default:
            return !1;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19))
          throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
        this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipelineTopicUnused, startLoc);
      }
      withTopicBindingContext(callback) {
        let outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          let outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else
          return callback();
      }
      withSoloAwaitPermittingContext(callback) {
        let outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = !0;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        let flags = this.prodParam.currentFlags();
        if (8 & ~flags) {
          this.prodParam.enter(flags | 8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        let flags = this.prodParam.currentFlags();
        if (8 & flags) {
          this.prodParam.enter(flags & -9);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        let startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        let oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = !0;
        let ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        let node = this.startNode();
        this.next(), this.match(5) || this.unexpected(null, 5);
        let program = this.startNodeAt(this.state.endLoc);
        this.next();
        let revertScopes = this.initializeScopes(!0);
        this.enterInitialScopes();
        try {
          node.body = this.parseProgram(program, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node, "ModuleExpression");
      }
      parseVoidPattern(refExpressionErrors) {
        this.expectPlugin("discardBinding");
        let node = this.startNode();
        return refExpressionErrors != null && (refExpressionErrors.voidPatternLoc = this.state.startLoc), this.next(), this.finishNode(node, "VoidPattern");
      }
      parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {
        if (refExpressionErrors != null && this.match(88)) {
          let nextCode = this.lookaheadCharCode();
          if (nextCode === 44 || nextCode === (close === 3 ? 93 : close === 8 ? 125 : 41) || nextCode === 61)
            return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));
        }
        return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    }, loopLabel = {
      kind: 1
    }, switchLabel = {
      kind: 2
    }, loneSurrogate = /[\uD800-\uDFFF]/u, keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input, startIndex) {
      for (let i = 0; i < tokens.length; i++) {
        let token = tokens[i], {
          type
        } = token;
        if (typeof type == "number") {
          {
            if (type === 139) {
              let {
                loc,
                start,
                value: value2,
                end
              } = token, hashEndPos = start + 1, hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i, 1, new Token({
                type: getExportedToken(27),
                value: "#",
                start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token({
                type: getExportedToken(132),
                value: value2,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              })), i++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              let {
                loc,
                start,
                value: value2,
                end
              } = token, backquoteEnd = start + 1, backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1), startToken;
              input.charCodeAt(start - startIndex) === 96 ? startToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              }) : startToken = new Token({
                type: getExportedToken(8),
                value: "}",
                start,
                end: backquoteEnd,
                startLoc: loc.start,
                endLoc: backquoteEndLoc
              });
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              type === 24 ? (templateElementEnd = end - 1, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1), templateValue = value2 === null ? null : value2.slice(1, -1), endToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              })) : (templateElementEnd = end - 2, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2), templateValue = value2 === null ? null : value2.slice(1, -2), endToken = new Token({
                type: getExportedToken(23),
                value: "${",
                start: templateElementEnd,
                end,
                startLoc: templateElementEndLoc,
                endLoc: loc.end
              })), tokens.splice(i, 1, startToken, new Token({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken), i += 2;
              continue;
            }
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program) {
        return file.program = this.parseProgram(program, 140, this.options.sourceType === "module" ? "module" : "script"), file.comments = this.comments, this.optionFlags & 256 && (file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex)), this.finishNode(file, "File");
      }
      parseProgram(program, end, sourceType) {
        if (program.sourceType = sourceType, program.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(program, !0, !0, end), this.inModule) {
          if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
            for (let [localName, at] of Array.from(this.scope.undefinedExports))
              this.raise(Errors.ModuleExportUndefined, at, {
                localName
              });
          this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
        }
        let finishedProgram;
        return end === 140 ? finishedProgram = this.finishNode(program, "Program") : finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1)), finishedProgram;
      }
      stmtToDirective(stmt) {
        let directive = this.castNodeTo(stmt, "Directive"), directiveLiteral = this.castNodeTo(stmt.expression, "DirectiveLiteral"), expressionValue = directiveLiteral.value, raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end)), val = directiveLiteral.value = raw.slice(1, -1);
        return this.addExtra(directiveLiteral, "raw", raw), this.addExtra(directiveLiteral, "rawValue", val), this.addExtra(directiveLiteral, "expressionValue", expressionValue), directive.value = directiveLiteral, delete stmt.expression, directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28))
          return null;
        let node = this.startNode();
        return node.value = this.state.value, this.next(), this.finishNode(node, "InterpreterDirective");
      }
      isLet() {
        return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
      }
      isUsing() {
        return this.isContextual(107) ? this.nextTokenIsIdentifierOnSameLine() : !1;
      }
      isForUsing() {
        if (!this.isContextual(107))
          return !1;
        let next = this.nextTokenInLineStart(), nextCh = this.codePointAtPos(next);
        if (this.isUnparsedContextual(next, "of")) {
          let nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);
          if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59)
            return !1;
        }
        return !!(this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, "void"));
      }
      nextTokenIsIdentifierOnSameLine() {
        let next = this.nextTokenInLineStart(), nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifier(nextCh, next);
      }
      isAwaitUsing() {
        if (!this.isContextual(96))
          return !1;
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
          next = this.nextTokenInLineStartSince(next + 5);
          let nextCh = this.codePointAtPos(next);
          if (this.chStartsBindingIdentifier(nextCh, next))
            return !0;
        }
        return !1;
      }
      chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart(ch)) {
          if (keywordRelationalOperator.lastIndex = pos, keywordRelationalOperator.test(this.input)) {
            let endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92)
              return !1;
          }
          return !0;
        } else return ch === 92;
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        let next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasInLineFollowingBindingIdentifierOrBrace() {
        let next = this.nextTokenInLineStart(), nextCh = this.codePointAtPos(next);
        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
      }
      allowsUsing() {
        return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
      }
      parseModuleItem() {
        return this.parseStatementLike(15);
      }
      parseStatementListItem() {
        return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = !1) {
        let flags = 0;
        return this.options.annexB && !this.state.strict && (flags |= 4, allowLabeledFunction && (flags |= 8)), this.parseStatementLike(flags);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(flags) {
        let decorators = null;
        return this.match(26) && (decorators = this.parseDecorators(!0)), this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        let startType = this.state.type, node = this.startNode(), allowDeclaration = !!(flags & 2), allowFunctionDeclaration = !!(flags & 4), topLevel = flags & 1;
        switch (startType) {
          case 60:
            return this.parseBreakContinueStatement(node, !0);
          case 63:
            return this.parseBreakContinueStatement(node, !1);
          case 64:
            return this.parseDebuggerStatement(node);
          case 90:
            return this.parseDoWhileStatement(node);
          case 91:
            return this.parseForStatement(node);
          case 68:
            if (this.lookaheadCharCode() === 46) break;
            return allowFunctionDeclaration || this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(node, !1, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            return allowDeclaration || this.unexpected(), this.parseClass(this.maybeTakeDecorators(decorators, node), !0);
          case 69:
            return this.parseIfStatement(node);
          case 70:
            return this.parseReturnStatement(node);
          case 71:
            return this.parseSwitchStatement(node);
          case 72:
            return this.parseThrowStatement(node);
          case 73:
            return this.parseTryStatement(node);
          case 96:
            if (this.isAwaitUsing())
              return this.allowsUsing() ? allowDeclaration ? this.recordAwaitIfAllowed() || this.raise(Errors.AwaitUsingNotInAsyncContext, node) : this.raise(Errors.UnexpectedLexicalDeclaration, node) : this.raise(Errors.UnexpectedUsingDeclaration, node), this.next(), this.parseVarStatement(node, "await using");
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
              break;
            return this.allowsUsing() ? allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc), this.parseVarStatement(node, "using");
          case 100: {
            if (this.state.containsEsc)
              break;
            let next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
            if (nextCh !== 91 && (!allowDeclaration && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123))
              break;
          }
          case 75:
            allowDeclaration || this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
          case 74: {
            let kind = this.state.value;
            return this.parseVarStatement(node, kind);
          }
          case 92:
            return this.parseWhileStatement(node);
          case 76:
            return this.parseWithStatement(node);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node);
          case 83: {
            let nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46)
              break;
          }
          case 82: {
            !(this.optionFlags & 8) && !topLevel && this.raise(Errors.UnexpectedImportExport, this.state.startLoc), this.next();
            let result;
            return startType === 83 ? result = this.parseImport(node) : result = this.parseExport(node, decorators), this.assertModuleNodeAllowed(result), result;
          }
          default:
            if (this.isAsyncFunction())
              return allowDeclaration || this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(node, !0, !allowDeclaration && allowFunctionDeclaration);
        }
        let maybeName = this.state.value, expr = this.parseExpression();
        return tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(node, maybeName, expr, flags) : this.parseExpressionStatement(node, expr, decorators);
      }
      assertModuleNodeAllowed(node) {
        !(this.optionFlags & 8) && !this.inModule && this.raise(Errors.ImportOutsideModule, node);
      }
      decoratorsEnabledBeforeExport() {
        return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          var _classNode$decorators;
          (_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]), classNode.decorators.unshift(...maybeDecorators)) : classNode.decorators = maybeDecorators, this.resetStartLocationFromNode(classNode, maybeDecorators[0]), exportNode && this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        let decorators = [];
        do
          decorators.push(this.parseDecorator());
        while (this.match(26));
        if (this.match(82))
          allowExport || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(Errors.DecoratorExportClass, this.state.startLoc);
        else if (!this.canHaveLeadingDecorator())
          throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        let node = this.startNode();
        if (this.next(), this.hasPlugin("decorators")) {
          let startLoc = this.state.startLoc, expr;
          if (this.match(10)) {
            let startLoc2 = this.state.startLoc;
            this.next(), expr = this.parseExpression(), this.expect(11), expr = this.wrapParenthesis(startLoc2, expr);
            let paramsStartLoc = this.state.startLoc;
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc2), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && node.expression !== expr && this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
          } else {
            for (expr = this.parseIdentifier(!1); this.eat(16); ) {
              let node2 = this.startNodeAt(startLoc);
              node2.object = expr, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), node2.property = this.parsePrivateName()) : node2.property = this.parseIdentifier(!0), node2.computed = !1, expr = this.finishNode(node2, "MemberExpression");
            }
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
          }
        } else
          node.expression = this.parseExprSubscripts();
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.eat(10)) {
          let node = this.startNodeAt(startLoc);
          return node.callee = expr, node.arguments = this.parseCallExpressionArguments(), this.toReferencedList(node.arguments), this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, isBreak) {
        return this.next(), this.isLineTerminator() ? node.label = null : (node.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(node, isBreak), this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          let lab = this.state.labels[i];
          if ((node.label == null || lab.name === node.label.name) && (lab.kind != null && (isBreak || lab.kind === 1) || node.label && isBreak))
            break;
        }
        if (i === this.state.labels.length) {
          let type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, node, {
            type
          });
        }
      }
      parseDebuggerStatement(node) {
        return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        let val = this.parseExpression();
        return this.expect(11), val;
      }
      parseDoWhileStatement(node) {
        return this.next(), this.state.labels.push(loopLabel), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), node.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next(), this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isContextual(96) && this.recordAwaitIfAllowed() && (awaitAt = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13))
          return awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node, null);
        let startsWithLet = this.isContextual(100);
        {
          let startsWithAwaitUsing = this.isAwaitUsing(), starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing(), isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            let initNode = this.startNode(), kind;
            startsWithAwaitUsing ? (kind = "await using", this.recordAwaitIfAllowed() || this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : kind = this.state.value, this.next(), this.parseVar(initNode, !0, kind);
            let init2 = this.finishNode(initNode, "VariableDeclaration"), isForIn = this.match(58);
            return isForIn && starsWithUsingDeclaration && this.raise(Errors.ForInUsing, init2), (isForIn || this.isContextual(102)) && init2.declarations.length === 1 ? this.parseForIn(node, init2, awaitAt) : (awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node, init2));
          }
        }
        let startsWithAsync = this.isContextual(95), refExpressionErrors = new ExpressionErrors(), init = this.parseExpression(!0, refExpressionErrors), isForOf = this.isContextual(102);
        if (isForOf && (startsWithLet && this.raise(Errors.ForOfLet, init), awaitAt === null && startsWithAsync && init.type === "Identifier" && this.raise(Errors.ForOfAsync, init)), isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors), this.toAssignable(init, !0);
          let type = isForOf ? "ForOfStatement" : "ForInStatement";
          return this.checkLVal(init, {
            type
          }), this.parseForIn(node, init, awaitAt);
        } else
          this.checkExpressionErrors(refExpressionErrors, !0);
        return awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node, init);
      }
      parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        return this.next(), this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
      }
      parseIfStatement(node) {
        return this.next(), node.test = this.parseHeaderExpression(), node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        return this.prodParam.hasReturn || this.raise(Errors.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? node.argument = null : (node.argument = this.parseExpression(), this.semicolon()), this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next(), node.discriminant = this.parseHeaderExpression();
        let cases = node.cases = [];
        this.expect(5), this.state.labels.push(switchLabel), this.scope.enter(256);
        let cur;
        for (let sawDefault; !this.match(8); )
          if (this.match(61) || this.match(65)) {
            let isCase = this.match(61);
            cur && this.finishNode(cur, "SwitchCase"), cases.push(cur = this.startNode()), cur.consequent = [], this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), sawDefault = !0, cur.test = null), this.expect(14);
          } else
            cur ? cur.consequent.push(this.parseStatementListItem()) : this.unexpected();
        return this.scope.exit(), cur && this.finishNode(cur, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        return this.next(), this.hasPrecedingLineBreak() && this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc), node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        let param = this.parseBindingAtom();
        return this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0), this.checkLVal(param, {
          type: "CatchClause"
        }, 9), param;
      }
      parseTryStatement(node) {
        if (this.next(), node.block = this.parseBlock(), node.handler = null, this.match(62)) {
          let clause = this.startNode();
          this.next(), this.match(10) ? (this.expect(10), clause.param = this.parseCatchClauseParam(), this.expect(11)) : (clause.param = null, this.scope.enter(0)), clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), node.handler = this.finishNode(clause, "CatchClause");
        }
        return node.finalizer = this.eat(67) ? this.parseBlock() : null, !node.handler && !node.finalizer && this.raise(Errors.NoCatchOrFinally, node), this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind, allowMissingInitializer = !1) {
        return this.next(), this.parseVar(node, !1, kind, allowMissingInitializer), this.semicolon(), this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        return this.next(), node.test = this.parseHeaderExpression(), this.state.labels.push(loopLabel), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        return this.state.strict && this.raise(Errors.StrictWith, this.state.startLoc), this.next(), node.object = this.parseHeaderExpression(), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        return this.next(), this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, flags) {
        for (let label of this.state.labels)
          label.name === maybeName && this.raise(Errors.LabelRedeclaration, expr, {
            labelName: maybeName
          });
        let kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          let label = this.state.labels[i];
          if (label.statementStart === node.start)
            label.statementStart = this.sourceToOffsetPos(this.state.start), label.kind = kind;
          else
            break;
        }
        return this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.sourceToOffsetPos(this.state.start)
        }), node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr, decorators) {
        return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = !1, createNewLexicalScope = !0, afterBlockParse) {
        let node = this.startNode();
        return allowDirectives && this.state.strictErrors.clear(), this.expect(5), createNewLexicalScope && this.scope.enter(0), this.parseBlockBody(node, allowDirectives, !1, 8, afterBlockParse), createNewLexicalScope && this.scope.exit(), this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        let body = node.body = [], directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        let oldStrict = this.state.strict, hasStrictModeDirective = !1, parsedNonDirective = !1;
        for (; !this.match(end); ) {
          let stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              let directive = this.stmtToDirective(stmt);
              directives.push(directive), !hasStrictModeDirective && directive.value.value === "use strict" && (hasStrictModeDirective = !0, this.setStrict(!0));
              continue;
            }
            parsedNonDirective = !0, this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        afterBlockParse?.call(this, hasStrictModeDirective), oldStrict || this.setStrict(!1), this.next();
      }
      parseFor(node, init) {
        return node.init = init, this.semicolon(!1), node.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), node.update = this.match(11) ? null : this.parseExpression(), this.expect(11), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init, awaitAt) {
        let isForIn = this.match(58);
        return this.next(), isForIn ? awaitAt !== null && this.unexpected(awaitAt) : node.await = awaitAt !== null, init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier") && this.raise(Errors.ForInOfLoopInitializer, init, {
          type: isForIn ? "ForInStatement" : "ForOfStatement"
        }), init.type === "AssignmentPattern" && this.raise(Errors.InvalidLhs, init, {
          ancestor: {
            type: "ForStatement"
          }
        }), node.left = init, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind, allowMissingInitializer = !1) {
        let declarations = node.declarations = [];
        for (node.kind = kind; ; ) {
          let decl = this.startNode();
          if (this.parseVarId(decl, kind), decl.init = this.eat(29) ? isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, decl.init === null && !allowMissingInitializer && (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102))) ? this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
            kind: "destructuring"
          }) : (kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
            kind
          })), declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(12)) break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        let id = this.parseBindingAtom();
        kind === "using" || kind === "await using" ? (id.type === "ArrayPattern" || id.type === "ObjectPattern") && this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start) : id.type === "VoidPattern" && this.raise(Errors.UnexpectedVoidPattern, id.loc.start), this.checkLVal(id, {
          type: "VariableDeclarator"
        }, kind === "var" ? 5 : 8201), decl.id = id;
      }
      parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
      }
      parseFunction(node, flags = 0) {
        let hangingDeclaration = flags & 2, isDeclaration = !!(flags & 1), requireId = isDeclaration && !(flags & 4), isAsync = !!(flags & 8);
        this.initFunction(node, isAsync), this.match(55) && (hangingDeclaration && this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), node.generator = !0), isDeclaration && (node.id = this.parseFunctionId(requireId));
        let oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        return this.state.maybeInArrowParameters = !1, this.scope.enter(514), this.prodParam.enter(functionFlags(isAsync, node.generator)), isDeclaration || (node.id = this.parseFunctionId()), this.parseFunctionParams(node, !1), this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        }), this.prodParam.exit(), this.scope.exit(), isDeclaration && !hangingDeclaration && this.registerFunctionStatementId(node), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, node;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, isConstructor) {
        this.expect(10), this.expressionScope.enter(newParameterDeclarationScope()), node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0)), this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        node.id && this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
      }
      parseClass(node, isStatement, optionalId) {
        this.next();
        let oldStrict = this.state.strict;
        return this.state.strict = !0, this.parseClassId(node, isStatement, optionalId), this.parseClassSuper(node), node.body = this.parseClassBody(!!node.superClass, oldStrict), this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      nameIsConstructor(key) {
        return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        let state = {
          hadConstructor: !1,
          hadSuperClass
        }, decorators = [], classBody = this.startNode();
        if (classBody.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
          for (; !this.match(8); ) {
            if (this.eat(13)) {
              if (decorators.length > 0)
                throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            let member = this.startNode();
            decorators.length && (member.decorators = decorators, this.resetStartLocationFromNode(member, decorators[0]), decorators = []), this.parseClassMember(classBody, member, state), member.kind === "constructor" && member.decorators && member.decorators.length > 0 && this.raise(Errors.DecoratorConstructor, member);
          }
        }), this.state.strict = oldStrict, this.next(), decorators.length)
          throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        return this.classScope.exit(), this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        let key = this.parseIdentifier(!0);
        if (this.isClassMethod()) {
          let method = member;
          return method.kind = "method", method.computed = !1, method.key = key, method.static = !1, this.pushClassMethod(classBody, method, !1, !1, !1, !1), !0;
        } else if (this.isClassProperty()) {
          let prop = member;
          return prop.computed = !1, prop.key = key, prop.static = !1, classBody.body.push(this.parseClassProperty(prop)), !0;
        }
        return this.resetPreviousNodeTrailingComments(key), !1;
      }
      parseClassMember(classBody, member, state) {
        let isStatic = this.isContextual(106);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member))
            return;
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        let publicMethod = member, privateMethod = member, publicProp = member, privateProp = member, accessorProp = member, method = publicMethod, publicMember = publicMethod;
        if (member.static = isStatic, this.parsePropertyNamePrefixOperator(member), this.eat(55)) {
          method.kind = "method";
          let isPrivateName = this.match(139);
          if (this.parseClassElementName(method), this.parsePostMemberNameModifiers(method), isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, !0, !1);
            return;
          }
          this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsGenerator, publicMethod.key), this.pushClassMethod(classBody, publicMethod, !0, !1, !1, !1);
          return;
        }
        let isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type), key = this.parseClassElementName(member), maybeContextualKw = isContextual ? key.name : null, isPrivate = this.isPrivateName(key), maybeQuestionTokenStartLoc = this.state.startLoc;
        if (this.parsePostMemberNameModifiers(publicMember), this.isClassMethod()) {
          if (method.kind = "method", isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, !1, !1);
            return;
          }
          let isConstructor = this.isNonstaticConstructor(publicMethod), allowsDirectSuper = !1;
          isConstructor && (publicMethod.kind = "constructor", state.hadConstructor && !this.hasPlugin("typescript") && this.raise(Errors.DuplicateConstructor, key), isConstructor && this.hasPlugin("typescript") && member.override && this.raise(Errors.OverrideOnConstructor, key), state.hadConstructor = !0, allowsDirectSuper = state.hadSuperClass), this.pushClassMethod(classBody, publicMethod, !1, !1, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty())
          isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp);
        else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          let isGenerator = this.eat(55);
          publicMember.optional && this.unexpected(maybeQuestionTokenStartLoc), method.kind = "method";
          let isPrivate2 = this.match(139);
          this.parseClassElementName(method), this.parsePostMemberNameModifiers(publicMember), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, !0) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAsync, publicMethod.key), this.pushClassMethod(classBody, publicMethod, isGenerator, !0, !1, !1));
        } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key), method.kind = maybeContextualKw;
          let isPrivate2 = this.match(139);
          this.parseClassElementName(publicMethod), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, !1, !1) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAccessor, publicMethod.key), this.pushClassMethod(classBody, publicMethod, !1, !1, !1, !1)), this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(key);
          let isPrivate2 = this.match(139);
          this.parseClassElementName(publicProp), this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else this.isLineTerminator() ? isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp) : this.unexpected();
      }
      parseClassElementName(member) {
        let {
          type,
          value: value2
        } = this.state;
        if ((type === 132 || type === 134) && member.static && value2 === "prototype" && this.raise(Errors.StaticPrototype, this.state.startLoc), type === 139) {
          value2 === "constructor" && this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
          let key = this.parsePrivateName();
          return member.key = key, key;
        }
        return this.parsePropertyName(member), member.key;
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(720);
        let oldLabels = this.state.labels;
        this.state.labels = [], this.prodParam.enter(0);
        let body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = oldLabels, classBody.body.push(this.finishNode(member, "StaticBlock")), (_member$decorators = member.decorators) != null && _member$decorators.length && this.raise(Errors.DecoratorStaticBlock, member);
      }
      pushClassProperty(classBody, prop) {
        !prop.computed && this.nameIsConstructor(prop.key) && this.raise(Errors.ConstructorClassField, prop.key), classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        let node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node), this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        !isPrivate && !prop.computed && this.nameIsConstructor(prop.key) && this.raise(Errors.ConstructorClassField, prop.key);
        let node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node), isPrivate && this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", !0));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        let node = this.parseMethod(method, isGenerator, isAsync, !1, !1, "ClassPrivateMethod", !0);
        classBody.body.push(node);
        let kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node, kind);
      }
      declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassProperty");
      }
      parseClassAccessorProperty(node) {
        return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassAccessorProperty");
      }
      parseInitializer(node) {
        this.scope.enter(592), this.expressionScope.enter(newExpressionScope()), this.prodParam.enter(0), node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
      }
      parseClassId(node, isStatement, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type))
          node.id = this.parseIdentifier(), isStatement && this.declareNameFromIdentifier(node.id, bindingType);
        else if (optionalId || !isStatement)
          node.id = null;
        else
          throw this.raise(Errors.MissingClassName, this.state.startLoc);
      }
      parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node, decorators) {
        let maybeDefaultIdentifier = this.parseMaybeImportPhase(node, !0), hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier), parseAfterDefault = !hasDefault || this.eat(12), hasStar = parseAfterDefault && this.eatExportStar(node), hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node), parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12)), isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault && this.unexpected(), decorators)
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          return this.parseExportFrom(node, !0), this.sawUnambiguousESM = !0, this.finishNode(node, "ExportAllDeclaration");
        }
        let hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers && this.unexpected(null, 5), hasNamespace && parseAfterNamespace && this.unexpected(null, 98);
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          if (hasDeclaration = !1, decorators)
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          this.parseExportFrom(node, isFromRequired);
        } else
          hasDeclaration = this.maybeParseExportDeclaration(node);
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          var _node2$declaration;
          let node2 = node;
          if (this.checkExport(node2, !0, !1, !!node2.source), ((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration")
            this.maybeTakeDecorators(decorators, node2.declaration, node2);
          else if (decorators)
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          return this.sawUnambiguousESM = !0, this.finishNode(node2, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          let node2 = node, decl = this.parseExportDefaultExpression();
          if (node2.declaration = decl, decl.type === "ClassDeclaration")
            this.maybeTakeDecorators(decorators, decl, node2);
          else if (decorators)
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          return this.checkExport(node2, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(node2, "ExportDefaultDeclaration");
        }
        throw this.unexpected(null, 5);
      }
      eatExportStar(node) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier?.loc.start);
          let id = maybeDefaultIdentifier || this.parseIdentifier(!0), specifier = this.startNodeAtNode(id);
          return specifier.exported = id, node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], !0;
        }
        return !1;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
          var _ref, _ref$specifiers;
          (_ref$specifiers = (_ref = node).specifiers) != null || (_ref.specifiers = []);
          let specifier = this.startNodeAt(this.state.lastTokStartLoc);
          return this.next(), specifier.exported = this.parseModuleExportName(), node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier")), !0;
        }
        return !1;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
          let node2 = node;
          node2.specifiers || (node2.specifiers = []);
          let isTypeExport = node2.exportKind === "type";
          return node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport)), node2.source = null, this.hasPlugin("importAssertions") ? node2.assertions = [] : node2.attributes = [], node2.declaration = null, !0;
        }
        return !1;
      }
      maybeParseExportDeclaration(node) {
        return this.shouldParseExportDeclaration() ? (node.specifiers = [], node.source = null, this.hasPlugin("importAssertions") ? node.assertions = [] : node.attributes = [], node.declaration = this.parseExportDeclaration(node), !0) : !1;
      }
      isAsyncFunction() {
        if (!this.isContextual(95)) return !1;
        let next = this.nextTokenInLineStart();
        return this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        let expr = this.startNode();
        if (this.match(68))
          return this.next(), this.parseFunction(expr, 5);
        if (this.isAsyncFunction())
          return this.next(), this.next(), this.parseFunction(expr, 13);
        if (this.match(80))
          return this.parseClass(expr, !0, !0);
        if (this.match(26))
          return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Errors.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
        if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing())
          throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        let res = this.parseMaybeAssignAllowIn();
        return this.semicolon(), res;
      }
      parseExportDeclaration(node) {
        return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        let {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 100)
            return !1;
          if ((type === 130 || type === 129) && !this.state.containsEsc) {
            let next2 = this.nextTokenStart(), nextChar = this.input.charCodeAt(next2);
            if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next2) && !this.input.startsWith("from", next2))
              return this.expectOnePlugin(["flow", "typescript"]), !1;
          }
        } else if (!this.match(65))
          return !1;
        let next = this.nextTokenStart(), hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom)
          return !0;
        if (this.match(65) && hasFrom) {
          let nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return !1;
      }
      parseExportFrom(node, expect) {
        this.eatContextual(98) ? (node.source = this.parseImportSource(), this.checkExport(node), this.maybeParseImportAttributes(node), this.checkJSONModuleImport(node)) : expect && this.unexpected(), this.semicolon();
      }
      shouldParseExportDeclaration() {
        let {
          type
        } = this.state;
        return type === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Errors.DecoratorBeforeExport, this.state.startLoc), !0) : this.isUsing() ? (this.raise(Errors.UsingDeclarationExport, this.state.startLoc), !0) : this.isAwaitUsing() ? (this.raise(Errors.UsingDeclarationExport, this.state.startLoc), !0) : type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          var _node$specifiers;
          if (isDefault) {
            if (this.checkDuplicateExports(node, "default"), this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              let declaration = node.declaration;
              declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized) && this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
            }
          } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length)
            for (let specifier of node.specifiers) {
              let {
                exported
              } = specifier, exportName = exported.type === "Identifier" ? exported.name : exported.value;
              if (this.checkDuplicateExports(specifier, exportName), !isFrom && specifier.local) {
                let {
                  local
                } = specifier;
                local.type !== "Identifier" ? this.raise(Errors.ExportBindingIsString, specifier, {
                  localName: local.value,
                  exportName
                }) : (this.checkReservedWord(local.name, local.loc.start, !0, !1), this.scope.checkLocalExport(local));
              }
            }
          else if (node.declaration) {
            let decl = node.declaration;
            if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
              let {
                id
              } = decl;
              if (!id) throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (decl.type === "VariableDeclaration")
              for (let declaration of decl.declarations)
                this.checkDeclaration(declaration.id);
          }
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier")
          this.checkDuplicateExports(node, node.name);
        else if (node.type === "ObjectPattern")
          for (let prop of node.properties)
            this.checkDeclaration(prop);
        else if (node.type === "ArrayPattern")
          for (let elem of node.elements)
            elem && this.checkDeclaration(elem);
        else node.type === "ObjectProperty" ? this.checkDeclaration(node.value) : node.type === "RestElement" ? this.checkDeclaration(node.argument) : node.type === "AssignmentPattern" && this.checkDeclaration(node.left);
      }
      checkDuplicateExports(node, exportName) {
        this.exportedIdentifiers.has(exportName) && (exportName === "default" ? this.raise(Errors.DuplicateDefaultExport, node) : this.raise(Errors.DuplicateExport, node, {
          exportName
        })), this.exportedIdentifiers.add(exportName);
      }
      parseExportSpecifiers(isInTypeExport) {
        let nodes = [], first = !0;
        for (this.expect(5); !this.eat(8); ) {
          if (first)
            first = !1;
          else if (this.expect(12), this.eat(8)) break;
          let isMaybeTypeOnly = this.isContextual(130), isString = this.match(134), node = this.startNode();
          node.local = this.parseModuleExportName(), nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        return this.eatContextual(93) ? node.exported = this.parseModuleExportName() : isString ? node.exported = this.cloneStringLiteral(node.local) : node.exported || (node.exported = this.cloneIdentifier(node.local)), this.finishNode(node, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(134)) {
          let result = this.parseStringLiteral(this.state.value), surrogate = loneSurrogate.exec(result.value);
          return surrogate && this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
            surrogateCharCode: surrogate[0].charCodeAt(0)
          }), result;
        }
        return this.parseIdentifier(!0);
      }
      isJSONModuleImport(node) {
        return node.assertions != null ? node.assertions.some(({
          key,
          value: value2
        }) => value2.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type")) : !1;
      }
      checkImportReflection(node) {
        let {
          specifiers
        } = node, singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        if (node.phase === "source")
          singleBindingType !== "ImportDefaultSpecifier" && this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
        else if (node.phase === "defer")
          singleBindingType !== "ImportNamespaceSpecifier" && this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
        else if (node.module) {
          var _node$assertions;
          singleBindingType !== "ImportDefaultSpecifier" && this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start), ((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0 && this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
        }
      }
      checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
          let {
            specifiers
          } = node;
          if (specifiers != null) {
            let nonDefaultNamedSpecifier = specifiers.find((specifier) => {
              let imported;
              if (specifier.type === "ExportSpecifier" ? imported = specifier.local : specifier.type === "ImportSpecifier" && (imported = specifier.imported), imported !== void 0)
                return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
            });
            nonDefaultNamedSpecifier !== void 0 && this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
          }
        }
      }
      isPotentialImportPhase(isExport) {
        return isExport ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
      }
      applyImportPhase(node, isExport, phase, loc) {
        isExport || (phase === "module" ? (this.expectPlugin("importReflection", loc), node.module = !0) : this.hasPlugin("importReflection") && (node.module = !1), phase === "source" ? (this.expectPlugin("sourcePhaseImports", loc), node.phase = "source") : phase === "defer" ? (this.expectPlugin("deferredImportEvaluation", loc), node.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (node.phase = null));
      }
      parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport))
          return this.applyImportPhase(node, isExport, null), null;
        let phaseIdentifier = this.startNode(), phaseIdentifierName = this.parseIdentifierName(!0), {
          type
        } = this.state;
        return (tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12) ? (this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start), null) : (this.applyImportPhase(node, isExport, null), this.createIdentifier(phaseIdentifier, phaseIdentifierName));
      }
      isPrecedingIdImportPhase(phase) {
        let {
          type
        } = this.state;
        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      }
      parseImport(node) {
        return this.match(134) ? this.parseImportSourceAndAttributes(node) : this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, !1));
      }
      parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        let parseNext = !this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) || this.eat(12), hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        return parseNext && !hasStar && this.parseNamedImportSpecifiers(node), this.expectContextual(98), this.parseImportSourceAndAttributes(node);
      }
      parseImportSourceAndAttributes(node) {
        var _node$specifiers2;
        return (_node$specifiers2 = node.specifiers) != null || (node.specifiers = []), node.source = this.parseImportSource(), this.maybeParseImportAttributes(node), this.checkImportReflection(node), this.checkJSONModuleImport(node), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.match(134) || this.unexpected(), this.parseExprAtom();
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier(), node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      finishImportSpecifier(specifier, type, bindingType = 8201) {
        return this.checkLVal(specifier.local, {
          type
        }, bindingType), this.finishNode(specifier, type);
      }
      parseImportAttributes() {
        this.expect(5);
        let attrs = [], attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8))
            break;
          let node = this.startNode(), keyName = this.state.value;
          if (attrNames.has(keyName) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
            key: keyName
          }), attrNames.add(keyName), this.match(134) ? node.key = this.parseStringLiteral(keyName) : node.key = this.parseIdentifier(!0), this.expect(14), !this.match(134))
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          node.value = this.parseStringLiteral(this.state.value), attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        return this.expect(8), attrs;
      }
      parseModuleAttributes() {
        let attrs = [], attributes = /* @__PURE__ */ new Set();
        do {
          let node = this.startNode();
          if (node.key = this.parseIdentifier(!0), node.key.name !== "type" && this.raise(Errors.ModuleAttributeDifferentFromType, node.key), attributes.has(node.key.name) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
            key: node.key.name
          }), attributes.add(node.key.name), this.expect(14), !this.match(134))
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          node.value = this.parseStringLiteral(this.state.value), attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAttributes(node) {
        let attributes;
        var useWith = !1;
        if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
            return;
          this.next(), this.hasPlugin("moduleAttributes") ? (attributes = this.parseModuleAttributes(), this.addExtra(node, "deprecatedWithLegacySyntax", !0)) : attributes = this.parseImportAttributes(), useWith = !0;
        } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions") && this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(node, "deprecatedAssertSyntax", !0), this.next(), attributes = this.parseImportAttributes()) : attributes = [];
        !useWith && this.hasPlugin("importAssertions") ? node.assertions = attributes : node.attributes = attributes;
      }
      maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
          let specifier = this.startNodeAtNode(maybeDefaultIdentifier);
          return specifier.local = maybeDefaultIdentifier, node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier")), !0;
        } else if (tokenIsKeywordOrIdentifier(this.state.type))
          return this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier"), !0;
        return !1;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
          let specifier = this.startNode();
          return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier"), !0;
        }
        return !1;
      }
      parseNamedImportSpecifiers(node) {
        let first = !0;
        for (this.expect(5); !this.eat(8); ) {
          if (first)
            first = !1;
          else {
            if (this.eat(14))
              throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
            if (this.expect(12), this.eat(8)) break;
          }
          let specifier = this.startNode(), importedIsString = this.match(134), isMaybeTypeOnly = this.isContextual(130);
          specifier.imported = this.parseModuleExportName();
          let importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
          node.specifiers.push(importSpecifier);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93))
          specifier.local = this.parseIdentifier();
        else {
          let {
            imported
          } = specifier;
          if (importedIsString)
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: imported.value
            });
          this.checkReservedWord(imported.name, specifier.loc.start, !0, !0), specifier.local || (specifier.local = this.cloneIdentifier(imported));
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    }, Parser = class extends StatementParser {
      constructor(options, input, pluginsMap) {
        let normalizedOptions = getOptions(options);
        super(normalizedOptions, input), this.options = normalizedOptions, this.initializeScopes(), this.plugins = pluginsMap, this.filename = normalizedOptions.sourceFilename, this.startIndex = normalizedOptions.startIndex;
        let optionFlags = 0;
        normalizedOptions.allowAwaitOutsideFunction && (optionFlags |= 1), normalizedOptions.allowReturnOutsideFunction && (optionFlags |= 2), normalizedOptions.allowImportExportEverywhere && (optionFlags |= 8), normalizedOptions.allowSuperOutsideMethod && (optionFlags |= 16), normalizedOptions.allowUndeclaredExports && (optionFlags |= 64), normalizedOptions.allowNewTargetOutsideFunction && (optionFlags |= 4), normalizedOptions.allowYieldOutsideFunction && (optionFlags |= 32), normalizedOptions.ranges && (optionFlags |= 128), normalizedOptions.tokens && (optionFlags |= 256), normalizedOptions.createImportExpressions && (optionFlags |= 512), normalizedOptions.createParenthesizedExpressions && (optionFlags |= 1024), normalizedOptions.errorRecovery && (optionFlags |= 2048), normalizedOptions.attachComment && (optionFlags |= 4096), normalizedOptions.annexB && (optionFlags |= 8192), this.optionFlags = optionFlags;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        let file = this.startNode(), program = this.startNode();
        this.nextToken(), file.errors = null;
        let result = this.parseTopLevel(file, program);
        return result.errors = this.state.errors, result.comments.length = this.state.commentsLen, result;
      }
    };
    function parse3(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          let parser3 = getParser(options, input), ast = parser3.parse();
          if (parser3.sawUnambiguousESM)
            return ast;
          if (parser3.ambiguousScriptDifferentAst)
            try {
              return options.sourceType = "script", getParser(options, input).parse();
            } catch {
            }
          else
            ast.program.sourceType = "script";
          return ast;
        } catch (moduleError) {
          try {
            return options.sourceType = "script", getParser(options, input).parse();
          } catch {
          }
          throw moduleError;
        }
      } else
        return getParser(options, input).parse();
    }
    function parseExpression2(input, options) {
      let parser3 = getParser(options, input);
      return parser3.options.strictMode && (parser3.state.strict = !0), parser3.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      let tokenTypes2 = {};
      for (let typeName of Object.keys(internalTokenTypes))
        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
      return tokenTypes2;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      let cls = Parser, pluginsMap = /* @__PURE__ */ new Map();
      if (options != null && options.plugins) {
        for (let plugin of options.plugins) {
          let name, opts;
          typeof plugin == "string" ? name = plugin : [name, opts] = plugin, pluginsMap.has(name) || pluginsMap.set(name, opts || {});
        }
        validatePlugins(pluginsMap), cls = getParserClass(pluginsMap);
      }
      return new cls(options, input, pluginsMap);
    }
    var parserClassCache = /* @__PURE__ */ new Map();
    function getParserClass(pluginsMap) {
      let pluginList = [];
      for (let name of mixinPluginNames)
        pluginsMap.has(name) && pluginList.push(name);
      let key = pluginList.join("|"), cls = parserClassCache.get(key);
      if (!cls) {
        cls = Parser;
        for (let plugin of pluginList)
          cls = mixinPlugins[plugin](cls);
        parserClassCache.set(key, cls);
      }
      return cls;
    }
    exports.parse = parse3;
    exports.parseExpression = parseExpression2;
    exports.tokTypes = tokTypes;
  }
});

// ../node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "../node_modules/js-tokens/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0], closed: void 0 };
      return match[1] ? (token.type = "string", token.closed = !!(match[3] || match[4])) : match[5] ? token.type = "comment" : match[6] ? (token.type = "comment", token.closed = !!match[7]) : match[8] ? token.type = "regex" : match[9] ? token.type = "number" : match[10] ? token.type = "name" : match[11] ? token.type = "punctuator" : match[12] && (token.type = "whitespace"), token;
    };
  }
});

// ../node_modules/@babel/code-frame/lib/index.js
var require_lib6 = __commonJS({
  "../node_modules/@babel/code-frame/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var picocolors = require_picocolors(), jsTokens = require_js_tokens(), helperValidatorIdentifier = require_lib2();
    function isColorSupported() {
      return typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? !1 : picocolors.isColorSupported;
    }
    var compose = (f, g) => (v) => f(g(v));
    function buildDefs(colors) {
      return {
        keyword: colors.cyan,
        capitalized: colors.yellow,
        jsxIdentifier: colors.yellow,
        punctuator: colors.yellow,
        number: colors.magenta,
        string: colors.green,
        regex: colors.magenta,
        comment: colors.gray,
        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
        gutter: colors.gray,
        marker: compose(colors.red, colors.bold),
        message: compose(colors.red, colors.bold),
        reset: colors.reset
      };
    }
    var defsOn = buildDefs(picocolors.createColors(!0)), defsOff = buildDefs(picocolors.createColors(!1));
    function getDefs(enabled) {
      return enabled ? defsOn : defsOff;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]), NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/, BRACKET = /^[()[\]{}]$/, tokenize;
    {
      let JSX_TAG = /^[a-z][\w-]*$/i, getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, !0) || sometimesKeywords.has(token.value))
            return "keyword";
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</"))
            return "jsxIdentifier";
          if (token.value[0] !== token.value[0].toLowerCase())
            return "capitalized";
        }
        return token.type === "punctuator" && BRACKET.test(token.value) ? "bracket" : token.type === "invalid" && (token.value === "@" || token.value === "#") ? "punctuator" : token.type;
      };
      tokenize = function* (text) {
        let match;
        for (; match = jsTokens.default.exec(text); ) {
          let token = jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlight(text) {
      if (text === "") return "";
      let defs = getDefs(!0), highlighted = "";
      for (let {
        type,
        value: value2
      } of tokenize(text))
        type in defs ? highlighted += value2.split(NEWLINE$1).map((str) => defs[type](str)).join(`
`) : highlighted += value2;
      return highlighted;
    }
    var deprecationWarningShown = !1, NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      let startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start), endLoc = Object.assign({}, startLoc, loc.end), {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {}, startLine = startLoc.line, startColumn = startLoc.column, endLine = endLoc.line, endColumn = endLoc.column, start = Math.max(startLine - (linesAbove + 1), 0), end = Math.min(source.length, endLine + linesBelow);
      startLine === -1 && (start = 0), endLine === -1 && (end = source.length);
      let lineDiff = endLine - startLine, markerLines = {};
      if (lineDiff)
        for (let i = 0; i <= lineDiff; i++) {
          let lineNumber = i + startLine;
          if (!startColumn)
            markerLines[lineNumber] = !0;
          else if (i === 0) {
            let sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff)
            markerLines[lineNumber] = [0, endColumn];
          else {
            let sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      else
        startColumn === endColumn ? startColumn ? markerLines[startLine] = [startColumn, 0] : markerLines[startLine] = !0 : markerLines[startLine] = [startColumn, endColumn - startColumn];
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      let shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode, defs = getDefs(shouldHighlight), lines = rawLines.split(NEWLINE), {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts), hasColumns = loc.start && typeof loc.start.column == "number", numberMaxWidth = String(end).length, frame = (shouldHighlight ? highlight(rawLines) : rawLines).split(NEWLINE, end).slice(start, end).map((line, index2) => {
        let number = start + 1 + index2, gutter = ` ${` ${number}`.slice(-numberMaxWidth)} |`, hasMarker = markerLines[number], lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            let markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " "), numberOfMarkers = hasMarker[1] || 1;
            markerLine = [`
 `, defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join(""), lastMarkerLine && opts.message && (markerLine += " " + defs.message(opts.message));
          }
          return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else
          return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
      }).join(`
`);
      return opts.message && !hasColumns && (frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`), shouldHighlight ? defs.reset(frame) : frame;
    }
    function index(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = !0;
        let message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning)
          process.emitWarning(message, "DeprecationWarning");
        else {
          let deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning", console.warn(new Error(message));
        }
      }
      return colNumber = Math.max(colNumber, 0), codeFrameColumns(rawLines, {
        start: {
          column: colNumber,
          line: lineNumber
        }
      }, opts);
    }
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = index;
    exports.highlight = highlight;
  }
});

// ../node_modules/@babel/template/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/@babel/template/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = parseAndBuildMetadata;
    var _t = require_lib4(), _parser = require_lib5(), _codeFrame = require_lib6(), {
      isCallExpression,
      isExpressionStatement,
      isFunction,
      isIdentifier,
      isJSXIdentifier,
      isNewExpression,
      isPlaceholder,
      isStatement,
      isStringLiteral,
      removePropertiesDeep,
      traverse: traverse2
    } = _t, PATTERN = /^[_$A-Z0-9]+$/;
    function parseAndBuildMetadata(formatter, code, opts) {
      let {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = opts, ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
      removePropertiesDeep(ast, {
        preserveComments
      }), formatter.validate(ast);
      let state = {
        syntactic: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        legacy: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders
      };
      return traverse2(ast, placeholderVisitorHandler, state), Object.assign({
        ast
      }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
    }
    function placeholderVisitorHandler(node, ancestors, state) {
      var _state$placeholderWhi;
      let name, hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
      if (isPlaceholder(node)) {
        if (state.syntacticPlaceholders === !1)
          throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
        name = node.name.name, hasSyntacticPlaceholders = !0;
      } else {
        if (hasSyntacticPlaceholders || state.syntacticPlaceholders)
          return;
        if (isIdentifier(node) || isJSXIdentifier(node))
          name = node.name;
        else if (isStringLiteral(node))
          name = node.value;
        else
          return;
      }
      if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null))
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      if (!hasSyntacticPlaceholders && (state.placeholderPattern === !1 || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name)))
        return;
      ancestors = ancestors.slice();
      let {
        node: parent,
        key
      } = ancestors[ancestors.length - 1], type;
      isStringLiteral(node) || isPlaceholder(node, {
        expectedNode: "StringLiteral"
      }) ? type = "string" : isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params" ? type = "param" : isExpressionStatement(parent) && !isPlaceholder(node) ? (type = "statement", ancestors = ancestors.slice(0, -1)) : isStatement(node) && isPlaceholder(node) ? type = "statement" : type = "other";
      let {
        placeholders,
        placeholderNames
      } = hasSyntacticPlaceholders ? state.syntactic : state.legacy;
      placeholders.push({
        name,
        type,
        resolve: (ast) => resolveAncestors(ast, ancestors),
        isDuplicate: placeholderNames.has(name)
      }), placeholderNames.add(name);
    }
    function resolveAncestors(ast, ancestors) {
      let parent = ast;
      for (let i = 0; i < ancestors.length - 1; i++) {
        let {
          key: key2,
          index: index2
        } = ancestors[i];
        index2 === void 0 ? parent = parent[key2] : parent = parent[key2][index2];
      }
      let {
        key,
        index
      } = ancestors[ancestors.length - 1];
      return {
        parent,
        key,
        index
      };
    }
    function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
      let plugins = (parserOpts.plugins || []).slice();
      syntacticPlaceholders !== !1 && plugins.push("placeholders"), parserOpts = Object.assign({
        allowAwaitOutsideFunction: !0,
        allowReturnOutsideFunction: !0,
        allowNewTargetOutsideFunction: !0,
        allowSuperOutsideMethod: !0,
        allowYieldOutsideFunction: !0,
        sourceType: "module"
      }, parserOpts, {
        plugins
      });
      try {
        return (0, _parser.parse)(code, parserOpts);
      } catch (err) {
        let loc = err.loc;
        throw loc && (err.message += `
` + (0, _codeFrame.codeFrameColumns)(code, {
          start: loc
        }), err.code = "BABEL_TEMPLATE_PARSE_ERROR"), err;
      }
    }
  }
});

// ../node_modules/@babel/template/lib/populate.js
var require_populate = __commonJS({
  "../node_modules/@babel/template/lib/populate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = populatePlaceholders;
    var _t = require_lib4(), {
      blockStatement,
      cloneNode,
      emptyStatement,
      expressionStatement,
      identifier,
      isStatement,
      isStringLiteral,
      stringLiteral,
      validate
    } = _t;
    function populatePlaceholders(metadata, replacements) {
      let ast = cloneNode(metadata.ast);
      return replacements && (metadata.placeholders.forEach((placeholder) => {
        if (!hasOwnProperty.call(replacements, placeholder.name)) {
          let placeholderName = placeholder.name;
          throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
        }
      }), Object.keys(replacements).forEach((key) => {
        if (!metadata.placeholderNames.has(key))
          throw new Error(`Unknown substitution "${key}" given`);
      })), metadata.placeholders.slice().reverse().forEach((placeholder) => {
        try {
          var _ref;
          applyReplacement(placeholder, ast, (_ref = replacements && replacements[placeholder.name]) != null ? _ref : null);
        } catch (e) {
          throw e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`, e;
        }
      }), ast;
    }
    function applyReplacement(placeholder, ast, replacement) {
      placeholder.isDuplicate && (Array.isArray(replacement) ? replacement = replacement.map((node) => cloneNode(node)) : typeof replacement == "object" && (replacement = cloneNode(replacement)));
      let {
        parent,
        key,
        index
      } = placeholder.resolve(ast);
      if (placeholder.type === "string") {
        if (typeof replacement == "string" && (replacement = stringLiteral(replacement)), !replacement || !isStringLiteral(replacement))
          throw new Error("Expected string substitution");
      } else if (placeholder.type === "statement")
        index === void 0 ? replacement ? Array.isArray(replacement) ? replacement = blockStatement(replacement) : typeof replacement == "string" ? replacement = expressionStatement(identifier(replacement)) : isStatement(replacement) || (replacement = expressionStatement(replacement)) : replacement = emptyStatement() : replacement && !Array.isArray(replacement) && (typeof replacement == "string" && (replacement = identifier(replacement)), isStatement(replacement) || (replacement = expressionStatement(replacement)));
      else if (placeholder.type === "param") {
        if (typeof replacement == "string" && (replacement = identifier(replacement)), index === void 0) throw new Error("Assertion failure.");
      } else if (typeof replacement == "string" && (replacement = identifier(replacement)), Array.isArray(replacement))
        throw new Error("Cannot replace single expression with an array.");
      function set(parent2, key2, value2) {
        let node = parent2[key2];
        parent2[key2] = value2, (node.type === "Identifier" || node.type === "Placeholder") && (node.typeAnnotation && (value2.typeAnnotation = node.typeAnnotation), node.optional && (value2.optional = node.optional), node.decorators && (value2.decorators = node.decorators));
      }
      if (index === void 0)
        validate(parent, key, replacement), set(parent, key, replacement);
      else {
        let items = parent[key].slice();
        placeholder.type === "statement" || placeholder.type === "param" ? replacement == null ? items.splice(index, 1) : Array.isArray(replacement) ? items.splice(index, 1, ...replacement) : set(items, index, replacement) : set(items, index, replacement), validate(parent, key, items), parent[key] = items;
      }
    }
  }
});

// ../node_modules/@babel/template/lib/string.js
var require_string = __commonJS({
  "../node_modules/@babel/template/lib/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = stringTemplate;
    var _options = require_options(), _parse = require_parse(), _populate = require_populate();
    function stringTemplate(formatter, code, opts) {
      code = formatter.code(code);
      let metadata;
      return (arg) => {
        let replacements = (0, _options.normalizeReplacements)(arg);
        return metadata || (metadata = (0, _parse.default)(formatter, code, opts)), formatter.unwrap((0, _populate.default)(metadata, replacements));
      };
    }
  }
});

// ../node_modules/@babel/template/lib/literal.js
var require_literal = __commonJS({
  "../node_modules/@babel/template/lib/literal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = literalTemplate;
    var _options = require_options(), _parse = require_parse(), _populate = require_populate();
    function literalTemplate(formatter, tpl, opts) {
      let {
        metadata,
        names
      } = buildLiteralData(formatter, tpl, opts);
      return (arg) => {
        let defaultReplacements = {};
        return arg.forEach((replacement, i) => {
          defaultReplacements[names[i]] = replacement;
        }), (arg2) => {
          let replacements = (0, _options.normalizeReplacements)(arg2);
          return replacements && Object.keys(replacements).forEach((key) => {
            if (hasOwnProperty.call(defaultReplacements, key))
              throw new Error("Unexpected replacement overlap.");
          }), formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
      };
    }
    function buildLiteralData(formatter, tpl, opts) {
      let prefix = "BABEL_TPL$", raw = tpl.join("");
      do
        prefix = "$$" + prefix;
      while (raw.includes(prefix));
      let {
        names,
        code
      } = buildTemplateCode(tpl, prefix);
      return {
        metadata: (0, _parse.default)(formatter, formatter.code(code), {
          parser: opts.parser,
          placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
          placeholderPattern: opts.placeholderPattern,
          preserveComments: opts.preserveComments,
          syntacticPlaceholders: opts.syntacticPlaceholders
        }),
        names
      };
    }
    function buildTemplateCode(tpl, prefix) {
      let names = [], code = tpl[0];
      for (let i = 1; i < tpl.length; i++) {
        let value2 = `${prefix}${i - 1}`;
        names.push(value2), code += value2 + tpl[i];
      }
      return {
        names,
        code
      };
    }
  }
});

// ../node_modules/@babel/template/lib/builder.js
var require_builder = __commonJS({
  "../node_modules/@babel/template/lib/builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = createTemplateBuilder;
    var _options = require_options(), _string = require_string(), _literal = require_literal(), NO_PLACEHOLDER = (0, _options.validate)({
      placeholderPattern: !1
    });
    function createTemplateBuilder(formatter, defaultOpts) {
      let templateFnCache = /* @__PURE__ */ new WeakMap(), templateAstCache = /* @__PURE__ */ new WeakMap(), cachedOpts = defaultOpts || (0, _options.validate)(null);
      return Object.assign((tpl, ...args) => {
        if (typeof tpl == "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
        } else if (Array.isArray(tpl)) {
          let builder = templateFnCache.get(tpl);
          return builder || (builder = (0, _literal.default)(formatter, tpl, cachedOpts), templateFnCache.set(tpl, builder)), extendedTrace(builder(args));
        } else if (typeof tpl == "object" && tpl) {
          if (args.length > 0) throw new Error("Unexpected extra params.");
          return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }, {
        ast: (tpl, ...args) => {
          if (typeof tpl == "string") {
            if (args.length > 1) throw new Error("Unexpected extra params.");
            return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
          } else if (Array.isArray(tpl)) {
            let builder = templateAstCache.get(tpl);
            return builder || (builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER)), templateAstCache.set(tpl, builder)), builder(args)();
          }
          throw new Error(`Unexpected template param ${typeof tpl}`);
        }
      });
    }
    function extendedTrace(fn) {
      let rootStack = "";
      try {
        throw new Error();
      } catch (error) {
        error.stack && (rootStack = error.stack.split(`
`).slice(3).join(`
`));
      }
      return (arg) => {
        try {
          return fn(arg);
        } catch (err) {
          throw err.stack += `
    =============
${rootStack}`, err;
        }
      };
    }
  }
});

// ../node_modules/@babel/template/lib/index.js
var require_lib7 = __commonJS({
  "../node_modules/@babel/template/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports.default = void 0;
    var formatters = require_formatters(), _builder = require_builder(), smart = exports.smart = (0, _builder.default)(formatters.smart), statement = exports.statement = (0, _builder.default)(formatters.statement), statements = exports.statements = (0, _builder.default)(formatters.statements), expression = exports.expression = (0, _builder.default)(formatters.expression), program = exports.program = (0, _builder.default)(formatters.program), _default = exports.default = Object.assign(smart.bind(void 0), {
      smart,
      statement,
      statements,
      expression,
      program,
      ast: smart.ast
    });
  }
});

// ../node_modules/@babel/helpers/lib/helpers-generated.js
var require_helpers_generated = __commonJS({
  "../node_modules/@babel/helpers/lib/helpers-generated.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _template = require_lib7();
    function helper(minVersion, source, metadata) {
      return Object.freeze({
        minVersion,
        ast: () => _template.default.program.ast(source, {
          preserveComments: !0
        }),
        metadata
      });
    }
    var helpers = exports.default = {
      __proto__: null,
      OverloadYield: helper("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", {
        globals: [],
        locals: {
          _OverloadYield: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_OverloadYield",
        dependencies: {},
        internal: !1
      }),
      applyDecoratedDescriptor: helper("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach(function(i){a[i]=n[i]}),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce(function(r,n){return n(i,e,r)||r},a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', {
        globals: ["Object"],
        locals: {
          _applyDecoratedDescriptor: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_applyDecoratedDescriptor",
        dependencies: {},
        internal: !1
      }),
      applyDecs2311: helper("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionName(function(){return v(this)},r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!==(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', {
        globals: ["Symbol", "Object", "TypeError", "Error"],
        locals: {
          applyDecs2311: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "applyDecs2311",
        dependencies: {
          checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee"],
          setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"],
          toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee"]
        },
        internal: !1
      }),
      arrayLikeToArray: helper("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}", {
        globals: ["Array"],
        locals: {
          _arrayLikeToArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_arrayLikeToArray",
        dependencies: {},
        internal: !1
      }),
      arrayWithHoles: helper("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", {
        globals: ["Array"],
        locals: {
          _arrayWithHoles: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_arrayWithHoles",
        dependencies: {},
        internal: !1
      }),
      arrayWithoutHoles: helper("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", {
        globals: ["Array"],
        locals: {
          _arrayWithoutHoles: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_arrayWithoutHoles",
        dependencies: {
          arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"]
        },
        internal: !1
      }),
      assertClassBrand: helper("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}', {
        globals: ["TypeError"],
        locals: {
          _assertClassBrand: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_assertClassBrand",
        dependencies: {},
        internal: !1
      }),
      assertThisInitialized: helper("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}`, {
        globals: ["ReferenceError"],
        locals: {
          _assertThisInitialized: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_assertThisInitialized",
        dependencies: {},
        internal: !1
      }),
      asyncGeneratorDelegate: helper("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise(function(n){n(t[e](r))}),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', {
        globals: ["Promise", "Symbol"],
        locals: {
          _asyncGeneratorDelegate: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_asyncGeneratorDelegate",
        dependencies: {
          OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"]
        },
        internal: !1
      }),
      asyncIterator: helper("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then(function(r){return{value:r,done:n}})}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', {
        globals: ["Symbol", "TypeError", "Object", "Promise"],
        locals: {
          _asyncIterator: ["body.0.id"],
          AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expressions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"]
        },
        exportBindingAssignments: [],
        exportName: "_asyncIterator",
        dependencies: {},
        internal: !1
      }),
      asyncToGenerator: helper("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise(function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)})}}', {
        globals: ["Promise"],
        locals: {
          asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"],
          _asyncToGenerator: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_asyncToGenerator",
        dependencies: {},
        internal: !1
      }),
      awaitAsyncGenerator: helper("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", {
        globals: [],
        locals: {
          _awaitAsyncGenerator: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_awaitAsyncGenerator",
        dependencies: {
          OverloadYield: ["body.0.body.body.0.argument.callee"]
        },
        internal: !1
      }),
      callSuper: helper("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", {
        globals: ["Reflect"],
        locals: {
          _callSuper: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_callSuper",
        dependencies: {
          getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee"],
          isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"],
          possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"]
        },
        internal: !1
      }),
      checkInRHS: helper("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==e?typeof e:"null"));return e}`, {
        globals: ["Object", "TypeError"],
        locals: {
          _checkInRHS: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_checkInRHS",
        dependencies: {},
        internal: !1
      }),
      checkPrivateRedeclaration: helper("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}', {
        globals: ["TypeError"],
        locals: {
          _checkPrivateRedeclaration: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_checkPrivateRedeclaration",
        dependencies: {},
        internal: !1
      }),
      classCallCheck: helper("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}', {
        globals: ["TypeError"],
        locals: {
          _classCallCheck: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classCallCheck",
        dependencies: {},
        internal: !1
      }),
      classNameTDZError: helper("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in computed property keys.')}`, {
        globals: ["ReferenceError"],
        locals: {
          _classNameTDZError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classNameTDZError",
        dependencies: {},
        internal: !1
      }),
      classPrivateFieldGet2: helper("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", {
        globals: [],
        locals: {
          _classPrivateFieldGet2: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldGet2",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
        },
        internal: !1
      }),
      classPrivateFieldInitSpec: helper("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", {
        globals: [],
        locals: {
          _classPrivateFieldInitSpec: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldInitSpec",
        dependencies: {
          checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
        },
        internal: !1
      }),
      classPrivateFieldLooseBase: helper("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}', {
        globals: ["TypeError"],
        locals: {
          _classPrivateFieldBase: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldBase",
        dependencies: {},
        internal: !1
      }),
      classPrivateFieldLooseKey: helper("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', {
        globals: [],
        locals: {
          id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.right.argument"],
          _classPrivateFieldKey: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldKey",
        dependencies: {},
        internal: !1
      }),
      classPrivateFieldSet2: helper("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", {
        globals: [],
        locals: {
          _classPrivateFieldSet2: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldSet2",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
        },
        internal: !1
      }),
      classPrivateGetter: helper("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", {
        globals: [],
        locals: {
          _classPrivateGetter: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateGetter",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
        },
        internal: !1
      }),
      classPrivateMethodInitSpec: helper("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", {
        globals: [],
        locals: {
          _classPrivateMethodInitSpec: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateMethodInitSpec",
        dependencies: {
          checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
        },
        internal: !1
      }),
      classPrivateSetter: helper("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", {
        globals: [],
        locals: {
          _classPrivateSetter: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateSetter",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
        },
        internal: !1
      }),
      classStaticPrivateMethodGet: helper("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", {
        globals: [],
        locals: {
          _classStaticPrivateMethodGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateMethodGet",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
        },
        internal: !1
      }),
      construct: helper("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", {
        globals: ["Reflect"],
        locals: {
          _construct: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_construct",
        dependencies: {
          isNativeReflectConstruct: ["body.0.body.body.0.test.callee"],
          setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"]
        },
        internal: !1
      }),
      createClass: helper("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', {
        globals: ["Object"],
        locals: {
          _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.1.right.callee"],
          _createClass: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createClass",
        dependencies: {
          toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"]
        },
        internal: !1
      }),
      createForOfIteratorHelper: helper("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}', {
        globals: ["Symbol", "Array", "TypeError"],
        locals: {
          _createForOfIteratorHelper: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createForOfIteratorHelper",
        dependencies: {
          unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"]
        },
        internal: !1
      }),
      createForOfIteratorHelperLoose: helper("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
        globals: ["Symbol", "Array", "TypeError"],
        locals: {
          _createForOfIteratorHelperLoose: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createForOfIteratorHelperLoose",
        dependencies: {
          unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"]
        },
        internal: !1
      }),
      createSuper: helper("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}", {
        globals: ["Reflect"],
        locals: {
          _createSuper: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createSuper",
        dependencies: {
          getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee"],
          isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"],
          possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"]
        },
        internal: !1
      }),
      decorate: helper("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r(function(e){o.initializeInstanceElements(e,a.elements)},t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach(function(t){r.forEach(function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)},this)},this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach(function(i){r.forEach(function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}},this)},this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach(function(e){this.addElementPlacement(e,o)},this),e.forEach(function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)},this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map(function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r},this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descriptor\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can't be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected '"+r+"' to be a function");return t}`, {
        globals: ["Object", "TypeError", "Symbol", "ReferenceError"],
        locals: {
          _decorate: ["body.0.id"],
          _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"],
          _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"],
          _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"],
          _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"],
          _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"],
          _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.consequent.test.right.callee"],
          _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"]
        },
        exportBindingAssignments: [],
        exportName: "_decorate",
        dependencies: {
          toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"],
          toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.body.0.declarations.1.init.callee"]
        },
        internal: !1
      }),
      defaults: helper("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", {
        globals: ["Object"],
        locals: {
          _defaults: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_defaults",
        dependencies: {},
        internal: !1
      }),
      defineAccessor: helper("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}", {
        globals: ["Object"],
        locals: {
          _defineAccessor: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_defineAccessor",
        dependencies: {},
        internal: !1
      }),
      defineProperty: helper("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}", {
        globals: ["Object"],
        locals: {
          _defineProperty: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_defineProperty",
        dependencies: {
          toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"]
        },
        internal: !1
      }),
      extends: helper("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", {
        globals: ["Object"],
        locals: {
          _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_extends",
        dependencies: {},
        internal: !1
      }),
      get: helper("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}', {
        globals: ["Reflect", "Object"],
        locals: {
          _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_get",
        dependencies: {
          superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"]
        },
        internal: !1
      }),
      getPrototypeOf: helper("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", {
        globals: ["Object"],
        locals: {
          _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_getPrototypeOf",
        dependencies: {},
        internal: !1
      }),
      identity: helper("7.17.0", "function _identity(t){return t}", {
        globals: [],
        locals: {
          _identity: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_identity",
        dependencies: {},
        internal: !1
      }),
      importDeferProxy: helper("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}", {
        globals: ["Proxy", "Reflect"],
        locals: {
          _importDeferProxy: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_importDeferProxy",
        dependencies: {},
        internal: !1
      }),
      inherits: helper("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', {
        globals: ["TypeError", "Object"],
        locals: {
          _inherits: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_inherits",
        dependencies: {
          setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"]
        },
        internal: !1
      }),
      inheritsLoose: helper("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}", {
        globals: ["Object"],
        locals: {
          _inheritsLoose: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_inheritsLoose",
        dependencies: {
          setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"]
        },
        internal: !1
      }),
      initializerDefineProperty: helper("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", {
        globals: ["Object"],
        locals: {
          _initializerDefineProperty: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_initializerDefineProperty",
        dependencies: {},
        internal: !1
      }),
      initializerWarningHelper: helper("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.")}', {
        globals: ["Error"],
        locals: {
          _initializerWarningHelper: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_initializerWarningHelper",
        dependencies: {},
        internal: !1
      }),
      instanceof: helper("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}', {
        globals: ["Symbol"],
        locals: {
          _instanceof: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_instanceof",
        dependencies: {},
        internal: !1
      }),
      interopRequireDefault: helper("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", {
        globals: [],
        locals: {
          _interopRequireDefault: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_interopRequireDefault",
        dependencies: {},
        internal: !1
      }),
      interopRequireWildcard: helper("7.14.0", 'function _interopRequireWildcard(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(_interopRequireWildcard=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,f={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return f;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,f)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(f,t,i):f[t]=e[t]);return f})(e,t)}', {
        globals: ["WeakMap", "Object"],
        locals: {
          _interopRequireWildcard: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
        },
        exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
        exportName: "_interopRequireWildcard",
        dependencies: {},
        internal: !1
      }),
      isNativeFunction: helper("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}', {
        globals: ["Function"],
        locals: {
          _isNativeFunction: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_isNativeFunction",
        dependencies: {},
        internal: !1
      }),
      isNativeReflectConstruct: helper("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", {
        globals: ["Boolean", "Reflect"],
        locals: {
          _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
        },
        exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
        exportName: "_isNativeReflectConstruct",
        dependencies: {},
        internal: !1
      }),
      iterableToArray: helper("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)}', {
        globals: ["Symbol", "Array"],
        locals: {
          _iterableToArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_iterableToArray",
        dependencies: {},
        internal: !1
      }),
      iterableToArrayLimit: helper("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}', {
        globals: ["Symbol", "Object"],
        locals: {
          _iterableToArrayLimit: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_iterableToArrayLimit",
        dependencies: {},
        internal: !1
      }),
      jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', {
        globals: ["Symbol", "Array"],
        locals: {
          REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.value", "body.1.body.body.0.expression.right.left"],
          _createRawReactElement: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createRawReactElement",
        dependencies: {},
        internal: !1
      }),
      maybeArrayLike: helper("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', {
        globals: ["Array"],
        locals: {
          _maybeArrayLike: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_maybeArrayLike",
        dependencies: {
          arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"]
        },
        internal: !1
      }),
      newArrowCheck: helper("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', {
        globals: ["TypeError"],
        locals: {
          _newArrowCheck: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_newArrowCheck",
        dependencies: {},
        internal: !1
      }),
      nonIterableRest: helper("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
        globals: ["TypeError"],
        locals: {
          _nonIterableRest: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_nonIterableRest",
        dependencies: {},
        internal: !1
      }),
      nonIterableSpread: helper("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
        globals: ["TypeError"],
        locals: {
          _nonIterableSpread: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_nonIterableSpread",
        dependencies: {},
        internal: !1
      }),
      nullishReceiverError: helper("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}', {
        globals: ["TypeError"],
        locals: {
          _nullishReceiverError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_nullishReceiverError",
        dependencies: {},
        internal: !1
      }),
      objectDestructuringEmpty: helper("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+t)}', {
        globals: ["TypeError"],
        locals: {
          _objectDestructuringEmpty: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectDestructuringEmpty",
        dependencies: {},
        internal: !1
      }),
      objectSpread2: helper("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){defineProperty(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}", {
        globals: ["Object"],
        locals: {
          ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee"],
          _objectSpread2: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectSpread2",
        dependencies: {
          defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"]
        },
        internal: !1
      }),
      objectWithoutProperties: helper("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],-1===t.indexOf(o)&&{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", {
        globals: ["Object"],
        locals: {
          _objectWithoutProperties: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectWithoutProperties",
        dependencies: {
          objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"]
        },
        internal: !1
      }),
      objectWithoutPropertiesLoose: helper("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(-1!==e.indexOf(n))continue;t[n]=r[n]}return t}", {
        globals: [],
        locals: {
          _objectWithoutPropertiesLoose: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectWithoutPropertiesLoose",
        dependencies: {},
        internal: !1
      }),
      possibleConstructorReturn: helper("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', {
        globals: ["TypeError"],
        locals: {
          _possibleConstructorReturn: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_possibleConstructorReturn",
        dependencies: {
          assertThisInitialized: ["body.0.body.body.2.argument.callee"]
        },
        internal: !1
      }),
      readOnlyError: helper("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, {
        globals: ["TypeError"],
        locals: {
          _readOnlyError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_readOnlyError",
        dependencies: {},
        internal: !1
      }),
      regenerator: helper("7.27.0", `function _regenerator(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
var e,t,r="function"==typeof Symbol?Symbol:{},n=r.iterator||"@@iterator",o=r.toStringTag||"@@toStringTag";function i(r,n,o,i){var c=n&&n.prototype instanceof Generator?n:Generator,u=Object.create(c.prototype);return define(u,"_invoke",function(r,n,o){var i,c,u,f=0,p=o||[],y=!1,G={p:0,n:0,v:e,a:d,f:d.bind(e,4),d:function(t,r){return i=t,c=0,u=e,G.n=r,a}};function d(r,n){for(c=r,u=n,t=0;!y&&f&&!o&&t<p.length;t++){var o,i=p[t],d=G.p,l=i[2];r>3?(o=l===n)&&(u=i[(c=i[4])?5:(c=3,3)],i[4]=i[5]=e):i[0]<=d&&((o=r<2&&d<i[1])?(c=0,G.v=n,G.n=i[1]):d<l&&(o=r<3||i[0]>n||n>l)&&(i[4]=r,i[5]=n,G.n=l,c=0))}if(o||r>1)return a;throw y=!0,n}return function(o,p,l){if(f>1)throw TypeError("Generator is already running");for(y&&1===p&&d(p,l),c=p,u=l;(t=c<2?e:u)||!y;){i||(c?c<3?(c>1&&(G.n=-1),d(c,u)):G.n=u:G.v=u);try{if(f=2,i){if(c||(o="next"),t=i[o]){if(!(t=t.call(i,u)))throw TypeError("iterator result is not an object");if(!t.done)return t;u=t.value,c<2&&(c=0)}else 1===c&&(t=i.return)&&t.call(i),c<2&&(u=TypeError("The iterator does not provide a '"+o+"' method"),c=1);i=e}else if((t=(y=G.n<0)?u:r.call(n,G))!==a)break}catch(t){i=e,c=1,u=t}finally{f=1}}return{value:t,done:y}}}(r,o,i),!0),u}var a={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}t=Object.getPrototypeOf;var c=[][n]?t(t([][n]())):(define(t={},n,function(){return this}),t),u=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(c);function f(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,GeneratorFunctionPrototype):(e.__proto__=GeneratorFunctionPrototype,define(e,o,"GeneratorFunction")),e.prototype=Object.create(u),e}return GeneratorFunction.prototype=GeneratorFunctionPrototype,define(u,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName="GeneratorFunction",define(GeneratorFunctionPrototype,o,"GeneratorFunction"),define(u),define(u,o,"Generator"),define(u,n,function(){return this}),define(u,"toString",function(){return"[object Generator]"}),(_regenerator=function(){return{w:i,m:f}})()}`, {
        globals: ["Symbol", "Object", "TypeError"],
        locals: {
          _regenerator: ["body.0.id", "body.0.body.body.9.argument.expressions.9.callee.left"]
        },
        exportBindingAssignments: ["body.0.body.body.9.argument.expressions.9.callee"],
        exportName: "_regenerator",
        dependencies: {
          regeneratorDefine: ["body.0.body.body.1.body.body.1.argument.expressions.0.callee", "body.0.body.body.7.declarations.0.init.alternate.expressions.0.callee", "body.0.body.body.8.body.body.0.argument.expressions.0.alternate.expressions.1.callee", "body.0.body.body.9.argument.expressions.1.callee", "body.0.body.body.9.argument.expressions.2.callee", "body.0.body.body.9.argument.expressions.4.callee", "body.0.body.body.9.argument.expressions.5.callee", "body.0.body.body.9.argument.expressions.6.callee", "body.0.body.body.9.argument.expressions.7.callee", "body.0.body.body.9.argument.expressions.8.callee"]
        },
        internal: !1
      }),
      regeneratorAsync: helper("7.27.0", "function _regeneratorAsync(n,e,r,t,o){var a=asyncGen(n,e,r,t,o);return a.next().then(function(n){return n.done?n.value:a.next()})}", {
        globals: [],
        locals: {
          _regeneratorAsync: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_regeneratorAsync",
        dependencies: {
          regeneratorAsyncGen: ["body.0.body.body.0.declarations.0.init.callee"]
        },
        internal: !1
      }),
      regeneratorAsyncGen: helper("7.27.0", "function _regeneratorAsyncGen(r,e,t,o,n){return new regeneratorAsyncIterator(regenerator().w(r,e,t,o),n||Promise)}", {
        globals: ["Promise"],
        locals: {
          _regeneratorAsyncGen: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_regeneratorAsyncGen",
        dependencies: {
          regenerator: ["body.0.body.body.0.argument.arguments.0.callee.object.callee"],
          regeneratorAsyncIterator: ["body.0.body.body.0.argument.callee"]
        },
        internal: !1
      }),
      regeneratorAsyncIterator: helper("7.27.0", 'function AsyncIterator(t,e){function n(r,o,i,f){try{var c=t[r](o),u=c.value;return u instanceof OverloadYield?e.resolve(u.v).then(function(t){n("next",t,i,f)},function(t){n("throw",t,i,f)}):e.resolve(u).then(function(t){c.value=t,i(c)},function(t){return n("throw",t,i,f)})}catch(t){f(t)}}var r;this.next||(define(AsyncIterator.prototype),define(AsyncIterator.prototype,"function"==typeof Symbol&&Symbol.asyncIterator||"@asyncIterator",function(){return this})),define(this,"_invoke",function(t,o,i){function f(){return new e(function(e,r){n(t,i,e,r)})}return r=r?r.then(f,f):f()},!0)}', {
        globals: ["Symbol"],
        locals: {
          AsyncIterator: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.expressions.0.arguments.0.object", "body.0.body.body.2.expression.expressions.0.right.expressions.1.arguments.0.object"]
        },
        exportBindingAssignments: [],
        exportName: "AsyncIterator",
        dependencies: {
          OverloadYield: ["body.0.body.body.0.body.body.0.block.body.1.argument.test.right"],
          regeneratorDefine: ["body.0.body.body.2.expression.expressions.0.right.expressions.0.callee", "body.0.body.body.2.expression.expressions.0.right.expressions.1.callee", "body.0.body.body.2.expression.expressions.1.callee"]
        },
        internal: !0
      }),
      regeneratorDefine: helper("7.27.0", 'function regeneratorDefine(e,r,n,t){var i=Object.defineProperty;try{i({},"",{})}catch(e){i=0}regeneratorDefine=function(e,r,n,t){function o(r,n){regeneratorDefine(e,r,function(e){return this._invoke(r,n,e)})}r?i?i(e,r,{value:n,enumerable:!t,configurable:!t,writable:!t}):e[r]=n:(o("next",0),o("throw",1),o("return",2))},regeneratorDefine(e,r,n,t)}', {
        globals: ["Object"],
        locals: {
          regeneratorDefine: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.body.body.0.body.body.0.expression.callee", "body.0.body.body.2.expression.expressions.1.callee", "body.0.body.body.2.expression.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.2.expression.expressions.0"],
        exportName: "regeneratorDefine",
        dependencies: {},
        internal: !0
      }),
      regeneratorKeys: helper("7.27.0", "function _regeneratorKeys(e){var n=Object(e),r=[];for(var t in n)r.unshift(t);return function e(){for(;r.length;)if((t=r.pop())in n)return e.value=t,e.done=!1,e;return e.done=!0,e}}", {
        globals: ["Object"],
        locals: {
          _regeneratorKeys: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_regeneratorKeys",
        dependencies: {},
        internal: !1
      }),
      regeneratorValues: helper("7.18.0", 'function _regeneratorValues(e){if(null!=e){var t=e["function"==typeof Symbol&&Symbol.iterator||"@@iterator"],r=0;if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length))return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}}}throw new TypeError(typeof e+" is not iterable")}', {
        globals: ["Symbol", "isNaN", "TypeError"],
        locals: {
          _regeneratorValues: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_regeneratorValues",
        dependencies: {},
        internal: !1
      }),
      set: helper("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', {
        globals: ["Reflect", "Object", "TypeError"],
        locals: {
          set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.body.0.argument.expressions.0.left"],
          _set: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_set",
        dependencies: {
          superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"],
          defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"]
        },
        internal: !1
      }),
      setFunctionName: helper("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', {
        globals: ["Object"],
        locals: {
          setFunctionName: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "setFunctionName",
        dependencies: {},
        internal: !1
      }),
      setPrototypeOf: helper("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", {
        globals: ["Object"],
        locals: {
          _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_setPrototypeOf",
        dependencies: {},
        internal: !1
      }),
      skipFirstGeneratorNext: helper("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}", {
        globals: [],
        locals: {
          _skipFirstGeneratorNext: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_skipFirstGeneratorNext",
        dependencies: {},
        internal: !1
      }),
      slicedToArray: helper("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}", {
        globals: [],
        locals: {
          _slicedToArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_slicedToArray",
        dependencies: {
          arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
          iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"],
          unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
          nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
        },
        internal: !1
      }),
      superPropBase: helper("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}", {
        globals: [],
        locals: {
          _superPropBase: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_superPropBase",
        dependencies: {
          getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"]
        },
        internal: !1
      }),
      superPropGet: helper("7.25.0", 'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t)}:p}', {
        globals: [],
        locals: {
          _superPropGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_superPropGet",
        dependencies: {
          get: ["body.0.body.body.0.declarations.0.init.callee"],
          getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"]
        },
        internal: !1
      }),
      superPropSet: helper("7.25.0", "function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", {
        globals: [],
        locals: {
          _superPropSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_superPropSet",
        dependencies: {
          set: ["body.0.body.body.0.argument.callee"],
          getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"]
        },
        internal: !1
      }),
      taggedTemplateLiteral: helper("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}", {
        globals: ["Object"],
        locals: {
          _taggedTemplateLiteral: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_taggedTemplateLiteral",
        dependencies: {},
        internal: !1
      }),
      taggedTemplateLiteralLoose: helper("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", {
        globals: [],
        locals: {
          _taggedTemplateLiteralLoose: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_taggedTemplateLiteralLoose",
        dependencies: {},
        internal: !1
      }),
      tdz: helper("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', {
        globals: ["ReferenceError"],
        locals: {
          _tdzError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_tdzError",
        dependencies: {},
        internal: !1
      }),
      temporalRef: helper("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", {
        globals: [],
        locals: {
          _temporalRef: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_temporalRef",
        dependencies: {
          temporalUndefined: ["body.0.body.body.0.argument.test.right"],
          tdz: ["body.0.body.body.0.argument.consequent.callee"]
        },
        internal: !1
      }),
      temporalUndefined: helper("7.0.0-beta.0", "function _temporalUndefined(){}", {
        globals: [],
        locals: {
          _temporalUndefined: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_temporalUndefined",
        dependencies: {},
        internal: !1
      }),
      toArray: helper("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}", {
        globals: [],
        locals: {
          _toArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_toArray",
        dependencies: {
          arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
          iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
          unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
          nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
        },
        internal: !1
      }),
      toConsumableArray: helper("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}", {
        globals: [],
        locals: {
          _toConsumableArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_toConsumableArray",
        dependencies: {
          arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
          iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
          unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
          nonIterableSpread: ["body.0.body.body.0.argument.right.callee"]
        },
        internal: !1
      }),
      toPrimitive: helper("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}', {
        globals: ["Symbol", "TypeError", "String", "Number"],
        locals: {
          toPrimitive: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "toPrimitive",
        dependencies: {},
        internal: !1
      }),
      toPropertyKey: helper("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', {
        globals: [],
        locals: {
          toPropertyKey: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "toPropertyKey",
        dependencies: {
          toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"]
        },
        internal: !1
      }),
      toSetter: helper("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,t.apply(n,e)}})}', {
        globals: ["Object"],
        locals: {
          _toSetter: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_toSetter",
        dependencies: {},
        internal: !1
      }),
      tsRewriteRelativeImportExtensions: helper("7.27.0", 'function tsRewriteRelativeImportExtensions(t,e){return"string"==typeof t&&/^\\.\\.?\\//.test(t)?t.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+)?)\\.([cm]?)ts$/i,function(t,s,r,n,o){return s?e?".jsx":".js":!r||n&&o?r+n+"."+o.toLowerCase()+"js":t}):t}', {
        globals: [],
        locals: {
          tsRewriteRelativeImportExtensions: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "tsRewriteRelativeImportExtensions",
        dependencies: {},
        internal: !1
      }),
      typeof: helper("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}', {
        globals: ["Symbol"],
        locals: {
          _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_typeof",
        dependencies: {},
        internal: !1
      }),
      unsupportedIterableToArray: helper("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', {
        globals: ["Array"],
        locals: {
          _unsupportedIterableToArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_unsupportedIterableToArray",
        dependencies: {
          arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee"]
        },
        internal: !1
      }),
      usingCtx: helper("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)return s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n,next()}return next()}}}', {
        globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"],
        locals: {
          _usingCtx: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_usingCtx",
        dependencies: {},
        internal: !1
      }),
      wrapAsyncGenerator: helper("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then(function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)},function(e){resume("throw",e)})}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise(function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))})},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', {
        globals: ["Promise", "Symbol"],
        locals: {
          _wrapAsyncGenerator: ["body.0.id"],
          AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.object.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.expressions.3.left.object.object"]
        },
        exportBindingAssignments: [],
        exportName: "_wrapAsyncGenerator",
        dependencies: {
          OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"]
        },
        internal: !1
      }),
      wrapNativeSuper: helper("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', {
        globals: ["Map", "TypeError", "Object"],
        locals: {
          _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"],
        exportName: "_wrapNativeSuper",
        dependencies: {
          getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"],
          setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"],
          isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"],
          construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"]
        },
        internal: !1
      }),
      wrapRegExp: helper("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce(function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r},Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)(>|$)/g,function(e,r,t){if(""===t)return e;var p=o[r];return Array.isArray(p)?"$"+p.join("$"):"number"==typeof p?"$"+p:""}))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)})}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', {
        globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"],
        locals: {
          _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.expression"],
        exportName: "_wrapRegExp",
        dependencies: {
          setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"],
          inherits: ["body.0.body.body.4.argument.expressions.0.callee"]
        },
        internal: !1
      }),
      writeOnlyError: helper("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, {
        globals: ["TypeError"],
        locals: {
          _writeOnlyError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_writeOnlyError",
        dependencies: {},
        internal: !1
      })
    };
    Object.assign(helpers, {
      AwaitValue: helper("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", {
        globals: [],
        locals: {
          _AwaitValue: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_AwaitValue",
        dependencies: {},
        internal: !1
      }),
      applyDecs: helper("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push(function(e,t){return f.get.call(e,t)}),e.push(function(e,t){return f.set.call(e,t)})):2===o?e.push(f):e.push(function(e,t){return f.call(e,t)}):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push(function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e})}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,function(){for(var e=0;e<o.length;e++)o[e].call(i)})}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}', {
        globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"],
        locals: {
          old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"],
          old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expressions.3.callee"],
          old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"],
          old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee"],
          old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee"],
          old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"],
          old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee"],
          old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee"],
          old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"],
          old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"],
          old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"],
          old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressions.1.callee"],
          old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"],
          applyDecs: ["body.13.id"]
        },
        exportBindingAssignments: [],
        exportName: "applyDecs",
        dependencies: {
          setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
          toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
        },
        internal: !1
      }),
      applyDecs2203: helper("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push(function(e,t){return u.get.call(e,t)}),e.push(function(e,t){return u.set.call(e,t)})):2===n?e.push(u):e.push(function(e,t){return u.call(e,t)}):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,function(){for(var e=0;e<a.length;e++)a[e].call(n)})}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', {
        globals: ["Error", "TypeError", "Object", "Map", "Array"],
        locals: {
          applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"],
          applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee.left"],
          applyDecs2203: ["body.2.id"]
        },
        exportBindingAssignments: [],
        exportName: "applyDecs2203",
        dependencies: {},
        internal: !1
      }),
      applyDecs2203R: helper("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push(function(e,t){return f.get.call(e,t)}),e.push(function(e,t){return f.set.call(e,t)})):2===a?e.push(f):e.push(function(e,t){return f.call(e,t)}):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', {
        globals: ["Error", "TypeError", "Object", "Map", "Array"],
        locals: {
          applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
          applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
        },
        exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
        exportName: "applyDecs2203R",
        dependencies: {
          setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
          toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
        },
        internal: !1
      }),
      applyDecs2301: helper("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push(function(e,t){return p.get.call(e,t)}),e.push(function(e,t){return p.set.call(e,t)})):2===a?e.push(p):e.push(function(e,t){return p.call(e,t)}):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', {
        globals: ["Error", "TypeError", "Object", "Map", "Array"],
        locals: {
          applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
          applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
        },
        exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
        exportName: "applyDecs2301",
        dependencies: {
          checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee"],
          setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
          toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
        },
        internal: !1
      }),
      applyDecs2305: helper("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName(function(){return g(this)},n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push(function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t}),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', {
        globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"],
        locals: {
          applyDecs2305: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "applyDecs2305",
        dependencies: {
          checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"],
          setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"],
          toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee"]
        },
        internal: !1
      }),
      classApplyDescriptorDestructureSet: helper("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");return t}', {
        globals: ["TypeError"],
        locals: {
          _classApplyDescriptorDestructureSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classApplyDescriptorDestructureSet",
        dependencies: {},
        internal: !1
      }),
      classApplyDescriptorGet: helper("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", {
        globals: [],
        locals: {
          _classApplyDescriptorGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classApplyDescriptorGet",
        dependencies: {},
        internal: !1
      }),
      classApplyDescriptorSet: helper("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=l}}', {
        globals: ["TypeError"],
        locals: {
          _classApplyDescriptorSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classApplyDescriptorSet",
        dependencies: {},
        internal: !1
      }),
      classCheckPrivateStaticAccess: helper("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", {
        globals: [],
        locals: {
          _classCheckPrivateStaticAccess: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classCheckPrivateStaticAccess",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.callee"]
        },
        internal: !1
      }),
      classCheckPrivateStaticFieldDescriptor: helper("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError("attempted to "+e+" private static field before its declaration")}', {
        globals: ["TypeError"],
        locals: {
          _classCheckPrivateStaticFieldDescriptor: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classCheckPrivateStaticFieldDescriptor",
        dependencies: {},
        internal: !1
      }),
      classExtractFieldDescriptor: helper("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", {
        globals: [],
        locals: {
          _classExtractFieldDescriptor: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classExtractFieldDescriptor",
        dependencies: {
          classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"]
        },
        internal: !1
      }),
      classPrivateFieldDestructureSet: helper("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}", {
        globals: [],
        locals: {
          _classPrivateFieldDestructureSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldDestructureSet",
        dependencies: {
          classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"],
          classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
        },
        internal: !1
      }),
      classPrivateFieldGet: helper("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}", {
        globals: [],
        locals: {
          _classPrivateFieldGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldGet",
        dependencies: {
          classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"],
          classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
        },
        internal: !1
      }),
      classPrivateFieldSet: helper("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}", {
        globals: [],
        locals: {
          _classPrivateFieldSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldSet",
        dependencies: {
          classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"],
          classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
        },
        internal: !1
      }),
      classPrivateMethodGet: helper("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", {
        globals: [],
        locals: {
          _classPrivateMethodGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateMethodGet",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
        },
        internal: !1
      }),
      classPrivateMethodSet: helper("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', {
        globals: ["TypeError"],
        locals: {
          _classPrivateMethodSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateMethodSet",
        dependencies: {},
        internal: !1
      }),
      classStaticPrivateFieldDestructureSet: helper("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', {
        globals: [],
        locals: {
          _classStaticPrivateFieldDestructureSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateFieldDestructureSet",
        dependencies: {
          classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"],
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
          classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
        },
        internal: !1
      }),
      classStaticPrivateFieldSpecGet: helper("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', {
        globals: [],
        locals: {
          _classStaticPrivateFieldSpecGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateFieldSpecGet",
        dependencies: {
          classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"],
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
          classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
        },
        internal: !1
      }),
      classStaticPrivateFieldSpecSet: helper("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', {
        globals: [],
        locals: {
          _classStaticPrivateFieldSpecSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateFieldSpecSet",
        dependencies: {
          classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"],
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
          classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
        },
        internal: !1
      }),
      classStaticPrivateMethodSet: helper("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static private field")}', {
        globals: ["TypeError"],
        locals: {
          _classStaticPrivateMethodSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateMethodSet",
        dependencies: {},
        internal: !1
      }),
      defineEnumerableProperties: helper("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}', {
        globals: ["Object"],
        locals: {
          _defineEnumerableProperties: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_defineEnumerableProperties",
        dependencies: {},
        internal: !1
      }),
      dispose: helper("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', {
        globals: ["SuppressedError", "Error", "Object", "Promise"],
        locals: {
          dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expressions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"],
          _dispose: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_dispose",
        dependencies: {},
        internal: !1
      }),
      objectSpread: helper("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})),o.forEach(function(r){defineProperty(e,r,t[r])})}return e}', {
        globals: ["Object"],
        locals: {
          _objectSpread: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectSpread",
        dependencies: {
          defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"]
        },
        internal: !1
      }),
      regeneratorRuntime: helper("7.18.0", 'function _regeneratorRuntime(){"use strict";var r=regenerator(),e=r.m(_regeneratorRuntime),t=(Object.getPrototypeOf?Object.getPrototypeOf(e):e.__proto__).constructor;function n(r){var e="function"==typeof r&&r.constructor;return!!e&&(e===t||"GeneratorFunction"===(e.displayName||e.name))}var o={throw:1,return:2,break:3,continue:3};function a(r){var e,t;return function(n){e||(e={stop:function(){return t(n.a,2)},catch:function(){return n.v},abrupt:function(r,e){return t(n.a,o[r],e)},delegateYield:function(r,o,a){return e.resultName=o,t(n.d,values(r),a)},finish:function(r){return t(n.f,r)}},t=function(r,t,o){n.p=e.prev,n.n=e.next;try{return r(t,o)}finally{e.next=n.n}}),e.resultName&&(e[e.resultName]=n.v,e.resultName=void 0),e.sent=n.v,e.next=n.n;try{return r.call(this,e)}finally{n.p=e.prev,n.n=e.next}}}return(_regeneratorRuntime=function(){return{wrap:function(e,t,n,o){return r.w(a(e),t,n,o&&o.reverse())},isGeneratorFunction:n,mark:r.m,awrap:function(r,e){return new OverloadYield(r,e)},AsyncIterator:AsyncIterator,async:function(r,e,t,o,u){return(n(e)?asyncGen:async)(a(r),e,t,o,u)},keys:keys,values:values}})()}', {
        globals: ["Object"],
        locals: {
          _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.declarations.1.init.arguments.0", "body.0.body.body.4.argument.callee.left"]
        },
        exportBindingAssignments: ["body.0.body.body.4.argument.callee"],
        exportName: "_regeneratorRuntime",
        dependencies: {
          OverloadYield: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.3.value.body.body.0.argument.callee"],
          regenerator: ["body.0.body.body.0.declarations.0.init.callee"],
          regeneratorAsync: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.alternate"],
          regeneratorAsyncGen: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.consequent"],
          regeneratorAsyncIterator: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.4.value"],
          regeneratorKeys: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.6.value"],
          regeneratorValues: ["body.0.body.body.3.body.body.1.argument.body.body.0.expression.expressions.0.right.expressions.0.right.properties.3.value.body.body.0.argument.expressions.1.arguments.1.callee", "body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.7.value"]
        },
        internal: !1
      }),
      using: helper("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}', {
        globals: ["Object", "TypeError", "Symbol"],
        locals: {
          _using: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_using",
        dependencies: {},
        internal: !1
      })
    });
  }
});

// ../node_modules/@babel/helpers/lib/index.js
var require_lib8 = __commonJS({
  "../node_modules/@babel/helpers/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    exports.get = get;
    exports.getDependencies = getDependencies;
    exports.isInternal = isInternal;
    exports.list = void 0;
    exports.minVersion = minVersion;
    var _t = require_lib4(), _helpersGenerated = require_helpers_generated(), {
      cloneNode,
      identifier
    } = _t;
    function deep(obj, path, value2) {
      try {
        let parts = path.split("."), last = parts.shift();
        for (; parts.length > 0; )
          obj = obj[last], last = parts.shift();
        if (arguments.length > 2)
          obj[last] = value2;
        else
          return obj[last];
      } catch (e) {
        throw e.message += ` (when accessing ${path})`, e;
      }
    }
    function permuteHelperAST(ast, metadata, bindingName, localBindings, getDependency, adjustAst) {
      let {
        locals,
        dependencies,
        exportBindingAssignments,
        exportName
      } = metadata, bindings = new Set(localBindings || []);
      bindingName && bindings.add(bindingName);
      for (let [name, paths] of (Object.entries || ((o) => Object.keys(o).map((k) => [k, o[k]])))(locals)) {
        let newName = name;
        if (bindingName && name === exportName)
          newName = bindingName;
        else
          for (; bindings.has(newName); ) newName = "_" + newName;
        if (newName !== name)
          for (let path of paths)
            deep(ast, path, identifier(newName));
      }
      for (let [name, paths] of (Object.entries || ((o) => Object.keys(o).map((k) => [k, o[k]])))(dependencies)) {
        let ref = typeof getDependency == "function" && getDependency(name) || identifier(name);
        for (let path of paths)
          deep(ast, path, cloneNode(ref));
      }
      adjustAst?.(ast, exportName, (map) => {
        exportBindingAssignments.forEach((p) => deep(ast, p, map(deep(ast, p))));
      });
    }
    var helperData = /* @__PURE__ */ Object.create(null);
    function loadHelper(name) {
      if (!helperData[name]) {
        let helper = _helpersGenerated.default[name];
        if (!helper)
          throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {
            code: "BABEL_HELPER_UNKNOWN",
            helper: name
          });
        helperData[name] = {
          minVersion: helper.minVersion,
          build(getDependency, bindingName, localBindings, adjustAst) {
            let ast = helper.ast();
            return permuteHelperAST(ast, helper.metadata, bindingName, localBindings, getDependency, adjustAst), {
              nodes: ast.body,
              globals: helper.metadata.globals
            };
          },
          getDependencies() {
            return Object.keys(helper.metadata.dependencies);
          }
        };
      }
      return helperData[name];
    }
    function get(name, getDependency, bindingName, localBindings, adjustAst) {
      if (typeof bindingName == "object") {
        let id = bindingName;
        id?.type === "Identifier" ? bindingName = id.name : bindingName = void 0;
      }
      return loadHelper(name).build(getDependency, bindingName, localBindings, adjustAst);
    }
    function minVersion(name) {
      return loadHelper(name).minVersion;
    }
    function getDependencies(name) {
      return loadHelper(name).getDependencies();
    }
    function isInternal(name) {
      var _helpers$name;
      return (_helpers$name = _helpersGenerated.default[name]) == null ? void 0 : _helpers$name.metadata.internal;
    }
    exports.ensure = (name) => {
      loadHelper(name);
    };
    var list = exports.list = Object.keys(_helpersGenerated.default).map((name) => name.replace(/^_/, "")), _default = exports.default = get;
  }
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS({
  "../node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;
    var ReferencedIdentifier = exports.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], ReferencedMemberExpression = exports.ReferencedMemberExpression = ["MemberExpression"], BindingIdentifier = exports.BindingIdentifier = ["Identifier"], Statement = exports.Statement = ["Statement"], Expression = exports.Expression = ["Expression"], Scope = exports.Scope = ["Scopable", "Pattern"], Referenced = exports.Referenced = null, BlockScoped = exports.BlockScoped = ["FunctionDeclaration", "ClassDeclaration", "VariableDeclaration"], Var = exports.Var = ["VariableDeclaration"], User = exports.User = null, Generated = exports.Generated = null, Pure = exports.Pure = null, Flow = exports.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], RestProperty = exports.RestProperty = ["RestElement"], SpreadProperty = exports.SpreadProperty = ["RestElement"], ExistentialTypeParam = exports.ExistentialTypeParam = ["ExistsTypeAnnotation"], NumericLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], ForAwaitStatement = exports.ForAwaitStatement = ["ForOfStatement"];
  }
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var require_virtual_types_validator = __commonJS({
  "../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.isBindingIdentifier = isBindingIdentifier;
    exports.isBlockScoped = isBlockScoped;
    exports.isExpression = isExpression;
    exports.isFlow = isFlow;
    exports.isForAwaitStatement = isForAwaitStatement;
    exports.isGenerated = isGenerated;
    exports.isPure = isPure;
    exports.isReferenced = isReferenced;
    exports.isReferencedIdentifier = isReferencedIdentifier;
    exports.isReferencedMemberExpression = isReferencedMemberExpression;
    exports.isRestProperty = isRestProperty;
    exports.isScope = isScope;
    exports.isSpreadProperty = isSpreadProperty;
    exports.isStatement = isStatement;
    exports.isUser = isUser;
    exports.isVar = isVar;
    var _t = require_lib4(), {
      isBinding,
      isBlockScoped: nodeIsBlockScoped,
      isExportDeclaration,
      isExpression: nodeIsExpression,
      isFlow: nodeIsFlow,
      isForStatement,
      isForXStatement,
      isIdentifier,
      isImportDeclaration,
      isImportSpecifier,
      isJSXIdentifier,
      isJSXMemberExpression,
      isMemberExpression,
      isRestElement: nodeIsRestElement,
      isReferenced: nodeIsReferenced,
      isScope: nodeIsScope,
      isStatement: nodeIsStatement,
      isVar: nodeIsVar,
      isVariableDeclaration,
      react,
      isForOfStatement
    } = _t, {
      isCompatTag
    } = react;
    function isReferencedIdentifier(opts) {
      let {
        node,
        parent
      } = this;
      return isIdentifier(node, opts) ? nodeIsReferenced(node, parent, this.parentPath.parent) : isJSXIdentifier(node, opts) ? !isJSXMemberExpression(parent) && isCompatTag(node.name) ? !1 : nodeIsReferenced(node, parent, this.parentPath.parent) : !1;
    }
    function isReferencedMemberExpression() {
      let {
        node,
        parent
      } = this;
      return isMemberExpression(node) && nodeIsReferenced(node, parent);
    }
    function isBindingIdentifier() {
      let {
        node,
        parent
      } = this, grandparent = this.parentPath.parent;
      return isIdentifier(node) && isBinding(node, parent, grandparent);
    }
    function isStatement() {
      let {
        node,
        parent
      } = this;
      return nodeIsStatement(node) ? !(isVariableDeclaration(node) && (isForXStatement(parent, {
        left: node
      }) || isForStatement(parent, {
        init: node
      }))) : !1;
    }
    function isExpression() {
      return this.isIdentifier() ? this.isReferencedIdentifier() : nodeIsExpression(this.node);
    }
    function isScope() {
      return nodeIsScope(this.node, this.parent);
    }
    function isReferenced() {
      return nodeIsReferenced(this.node, this.parent);
    }
    function isBlockScoped() {
      return nodeIsBlockScoped(this.node);
    }
    function isVar() {
      return nodeIsVar(this.node);
    }
    function isUser() {
      var _this$node;
      return !!((_this$node = this.node) != null && _this$node.loc);
    }
    function isGenerated() {
      return !this.isUser();
    }
    function isPure(constantsOnly) {
      return this.scope.isPure(this.node, constantsOnly);
    }
    function isFlow() {
      let {
        node
      } = this;
      return nodeIsFlow(node) ? !0 : isImportDeclaration(node) ? node.importKind === "type" || node.importKind === "typeof" : isExportDeclaration(node) ? node.exportKind === "type" : isImportSpecifier(node) ? node.importKind === "type" || node.importKind === "typeof" : !1;
    }
    function isRestProperty() {
      var _this$parentPath;
      return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
    }
    function isSpreadProperty() {
      var _this$parentPath2;
      return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
    }
    function isForAwaitStatement() {
      return isForOfStatement(this.node, {
        await: !0
      });
    }
    exports.isExistentialTypeParam = function() {
      throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
    }, exports.isNumericLiteralTypeAnnotation = function() {
      throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
    };
  }
});

// ../node_modules/@babel/traverse/lib/visitors.js
var require_visitors = __commonJS({
  "../node_modules/@babel/traverse/lib/visitors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.environmentVisitor = environmentVisitor;
    exports.explode = explode$1;
    exports.isExplodedVisitor = isExplodedVisitor;
    exports.merge = merge;
    exports.verify = verify$1;
    var virtualTypes = require_virtual_types(), virtualTypesValidators = require_virtual_types_validator(), _t = require_lib4(), _context = require_context2(), {
      DEPRECATED_KEYS,
      DEPRECATED_ALIASES,
      FLIPPED_ALIAS_KEYS,
      TYPES,
      __internal__deprecationWarning: deprecationWarning
    } = _t;
    function isVirtualType(type) {
      return type in virtualTypes;
    }
    function isExplodedVisitor(visitor) {
      return visitor?._exploded;
    }
    function explode$1(visitor) {
      if (isExplodedVisitor(visitor)) return visitor;
      visitor._exploded = !0;
      for (let nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        let parts = nodeType.split("|");
        if (parts.length === 1) continue;
        let fns = visitor[nodeType];
        delete visitor[nodeType];
        for (let part of parts)
          visitor[part] = fns;
      }
      verify$1(visitor), delete visitor.__esModule, ensureEntranceObjects(visitor), ensureCallbackArrays(visitor);
      for (let nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType) || !isVirtualType(nodeType)) continue;
        let fns = visitor[nodeType];
        for (let type of Object.keys(fns))
          fns[type] = wrapCheck(nodeType, fns[type]);
        delete visitor[nodeType];
        let types2 = virtualTypes[nodeType];
        if (types2 !== null)
          for (let type of types2) {
            var _visitor$type;
            (_visitor$type = visitor[type]) != null || (visitor[type] = {}), mergePair(visitor[type], fns);
          }
        else
          mergePair(visitor, fns);
      }
      for (let nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        let aliases = FLIPPED_ALIAS_KEYS[nodeType];
        if (nodeType in DEPRECATED_KEYS) {
          let deprecatedKey = DEPRECATED_KEYS[nodeType];
          deprecationWarning(nodeType, deprecatedKey, "Visitor "), aliases = [deprecatedKey];
        } else if (nodeType in DEPRECATED_ALIASES) {
          let deprecatedAlias = DEPRECATED_ALIASES[nodeType];
          deprecationWarning(nodeType, deprecatedAlias, "Visitor "), aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
        }
        if (!aliases) continue;
        let fns = visitor[nodeType];
        delete visitor[nodeType];
        for (let alias of aliases) {
          let existing = visitor[alias];
          existing ? mergePair(existing, fns) : visitor[alias] = Object.assign({}, fns);
        }
      }
      for (let nodeType of Object.keys(visitor))
        shouldIgnoreKey(nodeType) || ensureCallbackArrays(visitor[nodeType]);
      return visitor;
    }
    function verify$1(visitor) {
      if (!visitor._verified) {
        if (typeof visitor == "function")
          throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
        for (let nodeType of Object.keys(visitor)) {
          if ((nodeType === "enter" || nodeType === "exit") && validateVisitorMethods(nodeType, visitor[nodeType]), shouldIgnoreKey(nodeType)) continue;
          if (!TYPES.includes(nodeType))
            throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse 7.28.5`);
          let visitors = visitor[nodeType];
          if (typeof visitors == "object")
            for (let visitorKey of Object.keys(visitors))
              if (visitorKey === "enter" || visitorKey === "exit")
                validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
              else
                throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
        }
        visitor._verified = !0;
      }
    }
    function validateVisitorMethods(path, val) {
      let fns = [].concat(val);
      for (let fn of fns)
        if (typeof fn != "function")
          throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
    }
    function merge(visitors, states = [], wrapper) {
      let mergedVisitor = {
        _verified: !0,
        _exploded: !0
      };
      Object.defineProperty(mergedVisitor, "_exploded", {
        enumerable: !1
      }), Object.defineProperty(mergedVisitor, "_verified", {
        enumerable: !1
      });
      for (let i = 0; i < visitors.length; i++) {
        let visitor = explode$1(visitors[i]), state = states[i], topVisitor = visitor;
        (state || wrapper) && (topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper)), mergePair(mergedVisitor, topVisitor);
        for (let key of Object.keys(visitor)) {
          if (shouldIgnoreKey(key)) continue;
          let typeVisitor = visitor[key];
          (state || wrapper) && (typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper));
          let nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
          mergePair(nodeVisitor, typeVisitor);
        }
      }
      return mergedVisitor;
    }
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      let newVisitor = {};
      for (let phase of ["enter", "exit"]) {
        let fns = oldVisitor[phase];
        Array.isArray(fns) && (fns = fns.map(function(fn) {
          let newFn = fn;
          return state && (newFn = function(path) {
            fn.call(state, path, state);
          }), wrapper && (newFn = wrapper(state?.key, phase, newFn)), newFn !== fn && (newFn.toString = () => fn.toString()), newFn;
        }), newVisitor[phase] = fns);
      }
      return newVisitor;
    }
    function ensureEntranceObjects(obj) {
      for (let key of Object.keys(obj)) {
        if (shouldIgnoreKey(key)) continue;
        let fns = obj[key];
        typeof fns == "function" && (obj[key] = {
          enter: fns
        });
      }
    }
    function ensureCallbackArrays(obj) {
      obj.enter && !Array.isArray(obj.enter) && (obj.enter = [obj.enter]), obj.exit && !Array.isArray(obj.exit) && (obj.exit = [obj.exit]);
    }
    function wrapCheck(nodeType, fn) {
      let fnKey = `is${nodeType}`, validator = virtualTypesValidators[fnKey], newFn = function(path) {
        if (validator.call(path))
          return fn.apply(this, arguments);
      };
      return newFn.toString = () => fn.toString(), newFn;
    }
    function shouldIgnoreKey(key) {
      return key[0] === "_" || key === "enter" || key === "exit" || key === "shouldSkip" || key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist";
    }
    function mergePair(dest, src) {
      for (let phase of ["enter", "exit"])
        src[phase] && (dest[phase] = [].concat(dest[phase] || [], src[phase]));
    }
    var _environmentVisitor = {
      FunctionParent(path) {
        path.isArrowFunctionExpression() || (path.skip(), path.isMethod() && (path.requeueComputedKeyAndDecorators ? path.requeueComputedKeyAndDecorators() : _context.requeueComputedKeyAndDecorators.call(path)));
      },
      Property(path) {
        path.isObjectProperty() || (path.skip(), path.requeueComputedKeyAndDecorators ? path.requeueComputedKeyAndDecorators() : _context.requeueComputedKeyAndDecorators.call(path));
      }
    };
    function environmentVisitor(visitor) {
      return merge([_environmentVisitor, visitor]);
    }
  }
});

// ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS({
  "../node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var t = require_lib4(), _t = t, _traverseNode = require_traverse_node(), _visitors = require_visitors(), _context = require_context2(), {
      getAssignmentIdentifiers
    } = _t, renameVisitor = {
      ReferencedIdentifier({
        node
      }, state) {
        node.name === state.oldName && (node.name = state.newName);
      },
      Scope(path, state) {
        path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier) || (path.skip(), path.isMethod() && (path.requeueComputedKeyAndDecorators ? path.requeueComputedKeyAndDecorators() : _context.requeueComputedKeyAndDecorators.call(path)));
      },
      ObjectProperty({
        node,
        scope
      }, state) {
        let {
          name
        } = node.key;
        if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {
          node.shorthand = !1;
          {
            var _node$extra;
            (_node$extra = node.extra) != null && _node$extra.shorthand && (node.extra.shorthand = !1);
          }
        }
      },
      "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
        if (path.isVariableDeclaration()) return;
        let ids = path.isAssignmentExpression() ? getAssignmentIdentifiers(path.node) : path.getOuterBindingIdentifiers();
        for (let name in ids)
          name === state.oldName && (ids[name].name = state.newName);
      }
    }, Renamer = class {
      constructor(binding, oldName, newName) {
        this.newName = newName, this.oldName = oldName, this.binding = binding;
      }
      maybeConvertFromExportDeclaration(parentDeclar) {
        let maybeExportDeclar = parentDeclar.parentPath;
        if (maybeExportDeclar.isExportDeclaration()) {
          if (maybeExportDeclar.isExportDefaultDeclaration()) {
            let {
              declaration
            } = maybeExportDeclar.node;
            if (t.isDeclaration(declaration) && !declaration.id)
              return;
          }
          maybeExportDeclar.isExportAllDeclaration() || maybeExportDeclar.splitExportDeclaration();
        }
      }
      maybeConvertFromClassFunctionDeclaration(path) {
        return path;
      }
      maybeConvertFromClassFunctionExpression(path) {
        return path;
      }
      rename() {
        let {
          binding,
          oldName,
          newName
        } = this, {
          scope,
          path
        } = binding, parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
        parentDeclar && parentDeclar.getOuterBindingIdentifiers()[oldName] === binding.identifier && this.maybeConvertFromExportDeclaration(parentDeclar);
        let blockToTraverse = arguments[0] || scope.block, skipKeys = {
          discriminant: !0
        };
        t.isMethod(blockToTraverse) && (blockToTraverse.computed && (skipKeys.key = !0), t.isObjectMethod(blockToTraverse) || (skipKeys.decorators = !0)), (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys), arguments[0] || (scope.removeOwnBinding(oldName), scope.bindings[newName] = binding, this.binding.identifier.name = newName), parentDeclar && (this.maybeConvertFromClassFunctionDeclaration(path), this.maybeConvertFromClassFunctionExpression(path));
      }
    };
    exports.default = Renamer;
  }
});

// ../node_modules/@babel/traverse/lib/scope/traverseForScope.js
var require_traverseForScope = __commonJS({
  "../node_modules/@babel/traverse/lib/scope/traverseForScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = traverseForScope;
    var _t = require_lib4(), _index = require_lib10(), _visitors = require_visitors(), _context = require_context2(), {
      VISITOR_KEYS
    } = _t;
    function traverseForScope(path, visitors, state) {
      let exploded = (0, _visitors.explode)(visitors);
      if (exploded.enter || exploded.exit)
        throw new Error("Should not be used with enter/exit visitors.");
      _traverse(path.parentPath, path.parent, path.node, path.container, path.key, path.listKey, path.hub, path);
      function _traverse(parentPath, parent, node, container, key, listKey, hub, inPath) {
        if (!node)
          return;
        let path2 = inPath || _index.NodePath.get({
          hub,
          parentPath,
          parent,
          container,
          listKey,
          key
        });
        _context.setScope.call(path2);
        let visitor = exploded[node.type];
        if (visitor) {
          if (visitor.enter)
            for (let visit of visitor.enter)
              visit.call(state, path2, state);
          if (visitor.exit)
            for (let visit of visitor.exit)
              visit.call(state, path2, state);
        }
        if (path2.shouldSkip)
          return;
        let keys = VISITOR_KEYS[node.type];
        if (keys != null && keys.length)
          for (let key2 of keys) {
            let prop = node[key2];
            if (prop)
              if (Array.isArray(prop))
                for (let i = 0; i < prop.length; i++) {
                  let value2 = prop[i];
                  _traverse(path2, node, value2, prop, i, key2);
                }
              else
                _traverse(path2, node, prop, node, key2, null);
          }
      }
    }
  }
});

// ../node_modules/@babel/traverse/lib/scope/binding.js
var require_binding = __commonJS({
  "../node_modules/@babel/traverse/lib/scope/binding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var Binding = class {
      constructor({
        identifier,
        scope,
        path,
        kind
      }) {
        this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = identifier, this.scope = scope, this.path = path, this.kind = kind, (kind === "var" || kind === "hoisted") && isInitInLoop(path) && this.reassign(path), this.clearValue();
      }
      deoptValue() {
        this.clearValue(), this.hasDeoptedValue = !0;
      }
      setValue(value2) {
        this.hasDeoptedValue || (this.hasValue = !0, this.value = value2);
      }
      clearValue() {
        this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
      }
      reassign(path) {
        this.constant = !1, !this.constantViolations.includes(path) && this.constantViolations.push(path);
      }
      reference(path) {
        this.referencePaths.includes(path) || (this.referenced = !0, this.references++, this.referencePaths.push(path));
      }
      dereference() {
        this.references--, this.referenced = !!this.references;
      }
    };
    exports.default = Binding;
    function isInitInLoop(path) {
      let isFunctionDeclarationOrHasInit = !path.isVariableDeclarator() || path.node.init;
      for (let {
        parentPath,
        key
      } = path; parentPath; {
        parentPath,
        key
      } = parentPath) {
        if (parentPath.isFunctionParent()) return !1;
        if (key === "left" && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key === "body" && parentPath.isLoop())
          return !0;
      }
      return !1;
    }
  }
});

// ../node_modules/@babel/traverse/lib/cache.js
var require_cache = __commonJS({
  "../node_modules/@babel/traverse/lib/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.clear = clear;
    exports.clearPath = clearPath;
    exports.clearScope = clearScope;
    exports.getCachedPaths = getCachedPaths;
    exports.getOrCreateCachedPaths = getOrCreateCachedPaths;
    exports.scope = exports.path = void 0;
    var pathsCache = exports.path = /* @__PURE__ */ new WeakMap(), scope = exports.scope = /* @__PURE__ */ new WeakMap();
    function clear() {
      clearPath(), clearScope();
    }
    function clearPath() {
      exports.path = pathsCache = /* @__PURE__ */ new WeakMap();
    }
    function clearScope() {
      exports.scope = scope = /* @__PURE__ */ new WeakMap();
    }
    function getCachedPaths(path) {
      let {
        parent,
        parentPath
      } = path;
      return pathsCache.get(parent);
    }
    function getOrCreateCachedPaths(node, parentPath) {
      let paths = pathsCache.get(node);
      return paths || pathsCache.set(node, paths = /* @__PURE__ */ new Map()), paths;
    }
  }
});

// ../node_modules/@babel/helper-globals/data/builtin-lower.json
var require_builtin_lower = __commonJS({
  "../node_modules/@babel/helper-globals/data/builtin-lower.json"(exports, module) {
    module.exports = [
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "globalThis",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
  }
});

// ../node_modules/@babel/helper-globals/data/builtin-upper.json
var require_builtin_upper = __commonJS({
  "../node_modules/@babel/helper-globals/data/builtin-upper.json"(exports, module) {
    module.exports = [
      "AggregateError",
      "Array",
      "ArrayBuffer",
      "Atomics",
      "BigInt",
      "BigInt64Array",
      "BigUint64Array",
      "Boolean",
      "DataView",
      "Date",
      "Error",
      "EvalError",
      "FinalizationRegistry",
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Function",
      "Infinity",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Intl",
      "Iterator",
      "JSON",
      "Map",
      "Math",
      "NaN",
      "Number",
      "Object",
      "Promise",
      "Proxy",
      "RangeError",
      "ReferenceError",
      "Reflect",
      "RegExp",
      "Set",
      "SharedArrayBuffer",
      "String",
      "Symbol",
      "SyntaxError",
      "TypeError",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "URIError",
      "WeakMap",
      "WeakRef",
      "WeakSet"
    ];
  }
});

// ../node_modules/@babel/traverse/lib/scope/index.js
var require_scope = __commonJS({
  "../node_modules/@babel/traverse/lib/scope/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _renamer = require_renamer(), _index = require_lib10(), _traverseForScope = require_traverseForScope(), _binding = require_binding(), _t = require_lib4(), t = _t, _cache = require_cache(), globalsBuiltinLower = require_builtin_lower(), globalsBuiltinUpper = require_builtin_upper(), {
      assignmentExpression,
      callExpression,
      cloneNode,
      getBindingIdentifiers,
      identifier,
      isArrayExpression,
      isBinary,
      isCallExpression,
      isClass,
      isClassBody,
      isClassDeclaration,
      isExportAllDeclaration,
      isExportDefaultDeclaration,
      isExportNamedDeclaration,
      isFunctionDeclaration,
      isIdentifier,
      isImportDeclaration,
      isLiteral,
      isMemberExpression,
      isMethod,
      isModuleSpecifier,
      isNullLiteral,
      isObjectExpression,
      isProperty,
      isPureish,
      isRegExpLiteral,
      isSuper,
      isTaggedTemplateExpression,
      isTemplateLiteral,
      isThisExpression,
      isUnaryExpression,
      isVariableDeclaration,
      expressionStatement,
      matchesPattern,
      memberExpression,
      numericLiteral,
      toIdentifier,
      variableDeclaration,
      variableDeclarator,
      isRecordExpression,
      isTupleExpression,
      isObjectProperty,
      isTopicReference,
      isMetaProperty,
      isPrivateName,
      isExportDeclaration,
      buildUndefinedNode,
      sequenceExpression
    } = _t;
    function gatherNodeParts(node, parts) {
      switch (node?.type) {
        default:
          if (isImportDeclaration(node) || isExportDeclaration(node)) {
            var _node$specifiers;
            if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source)
              gatherNodeParts(node.source, parts);
            else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length)
              for (let e of node.specifiers) gatherNodeParts(e, parts);
            else (isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration && gatherNodeParts(node.declaration, parts);
          } else isModuleSpecifier(node) ? gatherNodeParts(node.local, parts) : isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node) && parts.push(node.value);
          break;
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node.object, parts), gatherNodeParts(node.property, parts);
          break;
        case "Identifier":
        case "JSXIdentifier":
          parts.push(node.name);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node.callee, parts);
          break;
        case "ObjectExpression":
        case "ObjectPattern":
          for (let e of node.properties)
            gatherNodeParts(e, parts);
          break;
        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node.argument, parts);
          break;
        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node.key, parts);
          break;
        case "ThisExpression":
          parts.push("this");
          break;
        case "Super":
          parts.push("super");
          break;
        case "Import":
        case "ImportExpression":
          parts.push("import");
          break;
        case "DoExpression":
          parts.push("do");
          break;
        case "YieldExpression":
          parts.push("yield"), gatherNodeParts(node.argument, parts);
          break;
        case "AwaitExpression":
          parts.push("await"), gatherNodeParts(node.argument, parts);
          break;
        case "AssignmentExpression":
          gatherNodeParts(node.left, parts);
          break;
        case "VariableDeclarator":
          gatherNodeParts(node.id, parts);
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node.id, parts);
          break;
        case "PrivateName":
          gatherNodeParts(node.id, parts);
          break;
        case "ParenthesizedExpression":
          gatherNodeParts(node.expression, parts);
          break;
        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node.argument, parts);
          break;
        case "MetaProperty":
          gatherNodeParts(node.meta, parts), gatherNodeParts(node.property, parts);
          break;
        case "JSXElement":
          gatherNodeParts(node.openingElement, parts);
          break;
        case "JSXOpeningElement":
          gatherNodeParts(node.name, parts);
          break;
        case "JSXFragment":
          gatherNodeParts(node.openingFragment, parts);
          break;
        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;
        case "JSXNamespacedName":
          gatherNodeParts(node.namespace, parts), gatherNodeParts(node.name, parts);
          break;
      }
    }
    function resetScope(scope) {
      scope.references = /* @__PURE__ */ Object.create(null), scope.uids = /* @__PURE__ */ Object.create(null), scope.bindings = /* @__PURE__ */ Object.create(null), scope.globals = /* @__PURE__ */ Object.create(null);
    }
    function isAnonymousFunctionExpression(path) {
      return path.isFunctionExpression() && !path.node.id || path.isArrowFunctionExpression();
    }
    NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    var NOT_LOCAL_BINDING, collectorVisitor = {
      ForStatement(path) {
        let declar = path.get("init");
        if (declar.isVar()) {
          let {
            scope
          } = path;
          (scope.getFunctionParent() || scope.getProgramParent()).registerBinding("var", declar);
        }
      },
      Declaration(path) {
        if (path.isBlockScoped() || path.isImportDeclaration() || path.isExportDeclaration()) return;
        (path.scope.getFunctionParent() || path.scope.getProgramParent()).registerDeclaration(path);
      },
      ImportDeclaration(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },
      TSImportEqualsDeclaration(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },
      ReferencedIdentifier(path, state) {
        t.isTSQualifiedName(path.parent) && path.parent.right === path.node || path.parentPath.isTSImportEqualsDeclaration() || state.references.push(path);
      },
      ForXStatement(path, state) {
        let left = path.get("left");
        if (left.isPattern() || left.isIdentifier())
          state.constantViolations.push(path);
        else if (left.isVar()) {
          let {
            scope
          } = path;
          (scope.getFunctionParent() || scope.getProgramParent()).registerBinding("var", left);
        }
      },
      ExportDeclaration: {
        exit(path) {
          let {
            node,
            scope
          } = path;
          if (isExportAllDeclaration(node)) return;
          let declar = node.declaration;
          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            let id = declar.id;
            if (!id) return;
            let binding = scope.getBinding(id.name);
            binding?.reference(path);
          } else if (isVariableDeclaration(declar))
            for (let decl of declar.declarations)
              for (let name of Object.keys(getBindingIdentifiers(decl))) {
                let binding = scope.getBinding(name);
                binding?.reference(path);
              }
        }
      },
      LabeledStatement(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },
      AssignmentExpression(path, state) {
        state.assignments.push(path);
      },
      UpdateExpression(path, state) {
        state.constantViolations.push(path);
      },
      UnaryExpression(path, state) {
        path.node.operator === "delete" && state.constantViolations.push(path);
      },
      BlockScoped(path) {
        let scope = path.scope;
        if (scope.path === path && (scope = scope.parent), scope.getBlockParent().registerDeclaration(path), path.isClassDeclaration() && path.node.id) {
          let name = path.node.id.name;
          path.scope.bindings[name] = path.scope.parent.getBinding(name);
        }
      },
      CatchClause(path) {
        path.scope.registerBinding("let", path);
      },
      Function(path) {
        let params = path.get("params");
        for (let param of params)
          path.scope.registerBinding("param", param);
        path.isFunctionExpression() && path.node.id && !path.node.id[NOT_LOCAL_BINDING] && path.scope.registerBinding("local", path.get("id"), path);
      },
      ClassExpression(path) {
        path.node.id && !path.node.id[NOT_LOCAL_BINDING] && path.scope.registerBinding("local", path.get("id"), path);
      },
      TSTypeAnnotation(path) {
        path.skip();
      }
    }, scopeVisitor, uid = 0, Scope = class _Scope {
      constructor(path) {
        this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.referencesSet = void 0, this.globals = void 0, this.uidsSet = void 0, this.data = void 0, this.crawling = void 0;
        let {
          node
        } = path, cached = _cache.scope.get(node);
        if (cached?.path === path)
          return cached;
        _cache.scope.set(node, this), this.uid = uid++, this.block = node, this.path = path, this.labels = /* @__PURE__ */ new Map(), this.inited = !1, Object.defineProperties(this, {
          references: {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: /* @__PURE__ */ Object.create(null)
          },
          uids: {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: /* @__PURE__ */ Object.create(null)
          }
        });
      }
      get parent() {
        var _parent;
        let parent, path = this.path;
        do {
          var _path;
          let shouldSkip = path.key === "key" || path.listKey === "decorators";
          path = path.parentPath, shouldSkip && path.isMethod() && (path = path.parentPath), (_path = path) != null && _path.isScope() && (parent = path);
        } while (path && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
      get references() {
        throw new Error("Scope#references is not available in Babel 8. Use Scope#referencesSet instead.");
      }
      get uids() {
        throw new Error("Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.");
      }
      generateDeclaredUidIdentifier(name) {
        let id = this.generateUidIdentifier(name);
        return this.push({
          id
        }), cloneNode(id);
      }
      generateUidIdentifier(name) {
        return identifier(this.generateUid(name));
      }
      generateUid(name = "temp") {
        name = toIdentifier(name).replace(/^_+/, "").replace(/\d+$/g, "");
        let uid2, i = 0;
        do
          uid2 = `_${name}`, i >= 11 ? uid2 += i - 1 : i >= 9 ? uid2 += i - 9 : i >= 1 && (uid2 += i + 1), i++;
        while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
        let program = this.getProgramParent();
        return program.references[uid2] = !0, program.uids[uid2] = !0, uid2;
      }
      generateUidBasedOnNode(node, defaultName) {
        let parts = [];
        gatherNodeParts(node, parts);
        let id = parts.join("$");
        return id = id.replace(/^_/, "") || defaultName || "ref", this.generateUid(id.slice(0, 20));
      }
      generateUidIdentifierBasedOnNode(node, defaultName) {
        return identifier(this.generateUidBasedOnNode(node, defaultName));
      }
      isStatic(node) {
        if (isThisExpression(node) || isSuper(node) || isTopicReference(node))
          return !0;
        if (isIdentifier(node)) {
          let binding = this.getBinding(node.name);
          return binding ? binding.constant : this.hasBinding(node.name);
        }
        return !1;
      }
      maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node))
          return null;
        {
          let id = this.generateUidIdentifierBasedOnNode(node);
          return dontPush ? id : (this.push({
            id
          }), cloneNode(id));
        }
      }
      checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === "param" || local.kind === "local") return;
        if (kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const")
          throw this.path.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
      }
      rename(oldName, newName) {
        let binding = this.getBinding(oldName);
        binding && (newName || (newName = this.generateUidIdentifier(oldName).name), new _renamer.default(binding, oldName, newName).rename(arguments[2]));
      }
      dump() {
        let sep = "-".repeat(60);
        console.log(sep);
        let scope = this;
        do {
          console.log("#", scope.block.type);
          for (let name of Object.keys(scope.bindings)) {
            let binding = scope.bindings[name];
            console.log(" -", name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      }
      hasLabel(name) {
        return !!this.getLabel(name);
      }
      getLabel(name) {
        return this.labels.get(name);
      }
      registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      }
      registerDeclaration(path) {
        if (path.isLabeledStatement())
          this.registerLabel(path);
        else if (path.isFunctionDeclaration())
          this.registerBinding("hoisted", path.get("id"), path);
        else if (path.isVariableDeclaration()) {
          let declarations = path.get("declarations"), {
            kind
          } = path.node;
          for (let declar of declarations)
            this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
        } else if (path.isClassDeclaration()) {
          if (path.node.declare) return;
          this.registerBinding("let", path);
        } else if (path.isImportDeclaration()) {
          let isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof", specifiers = path.get("specifiers");
          for (let specifier of specifiers) {
            let isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
            this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
          }
        } else if (path.isExportDeclaration()) {
          let declar = path.get("declaration");
          (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) && this.registerDeclaration(declar);
        } else
          this.registerBinding("unknown", path);
      }
      buildUndefinedNode() {
        return buildUndefinedNode();
      }
      registerConstantViolation(path) {
        let ids = path.getAssignmentIdentifiers();
        for (let name of Object.keys(ids)) {
          var _this$getBinding;
          (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path);
        }
      }
      registerBinding(kind, path, bindingPath = path) {
        if (!kind) throw new ReferenceError("no `kind`");
        if (path.isVariableDeclaration()) {
          let declarators = path.get("declarations");
          for (let declar of declarators)
            this.registerBinding(kind, declar);
          return;
        }
        let parent = this.getProgramParent(), ids = path.getOuterBindingIdentifiers(!0);
        for (let name of Object.keys(ids)) {
          parent.references[name] = !0;
          for (let id of ids[name]) {
            let local = this.getOwnBinding(name);
            if (local) {
              if (local.identifier === id) continue;
              this.checkBlockScopedCollisions(local, kind, name, id);
            }
            local ? local.reassign(bindingPath) : this.bindings[name] = new _binding.default({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind
            });
          }
        }
      }
      addGlobal(node) {
        this.globals[node.name] = node;
      }
      hasUid(name) {
        {
          let scope = this;
          do
            if (scope.uids[name]) return !0;
          while (scope = scope.parent);
          return !1;
        }
      }
      hasGlobal(name) {
        let scope = this;
        do
          if (scope.globals[name]) return !0;
        while (scope = scope.parent);
        return !1;
      }
      hasReference(name) {
        return !!this.getProgramParent().references[name];
      }
      isPure(node, constantsOnly) {
        if (isIdentifier(node)) {
          let binding = this.getBinding(node.name);
          return binding ? constantsOnly ? binding.constant : !0 : !1;
        } else {
          if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node))
            return !0;
          if (isClass(node)) {
            var _node$decorators;
            return node.superClass && !this.isPure(node.superClass, constantsOnly) || ((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0 ? !1 : this.isPure(node.body, constantsOnly);
          } else if (isClassBody(node)) {
            for (let method of node.body)
              if (!this.isPure(method, constantsOnly)) return !1;
            return !0;
          } else {
            if (isBinary(node))
              return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
            if (isArrayExpression(node) || isTupleExpression(node)) {
              for (let elem of node.elements)
                if (elem !== null && !this.isPure(elem, constantsOnly)) return !1;
              return !0;
            } else if (isObjectExpression(node) || isRecordExpression(node)) {
              for (let prop of node.properties)
                if (!this.isPure(prop, constantsOnly)) return !1;
              return !0;
            } else if (isMethod(node)) {
              var _node$decorators2;
              return !(node.computed && !this.isPure(node.key, constantsOnly) || ((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0);
            } else if (isProperty(node)) {
              var _node$decorators3;
              return !(node.computed && !this.isPure(node.key, constantsOnly) || ((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0 || (isObjectProperty(node) || node.static) && node.value !== null && !this.isPure(node.value, constantsOnly));
            } else {
              if (isUnaryExpression(node))
                return this.isPure(node.argument, constantsOnly);
              if (isTemplateLiteral(node)) {
                for (let expression of node.expressions)
                  if (!this.isPure(expression, constantsOnly)) return !1;
                return !0;
              } else return isTaggedTemplateExpression(node) ? matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", {
                noGlobals: !0
              }) && this.isPure(node.quasi, constantsOnly) : isMemberExpression(node) ? !node.computed && isIdentifier(node.object) && node.object.name === "Symbol" && isIdentifier(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {
                noGlobals: !0
              }) : isCallExpression(node) ? matchesPattern(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {
                noGlobals: !0
              }) && node.arguments.length === 1 && t.isStringLiteral(node.arguments[0]) : isPureish(node);
            }
          }
        }
      }
      setData(key, val) {
        return this.data[key] = val;
      }
      getData(key) {
        let scope = this;
        do {
          let data = scope.data[key];
          if (data != null) return data;
        } while (scope = scope.parent);
      }
      removeData(key) {
        let scope = this;
        do
          scope.data[key] != null && (scope.data[key] = null);
        while (scope = scope.parent);
      }
      init() {
        this.inited || (this.inited = !0, this.crawl());
      }
      crawl() {
        let path = this.path;
        resetScope(this), this.data = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          if (scope.crawling) return;
          if (scope.path.isProgram())
            break;
        } while (scope = scope.parent);
        let programParent = scope, state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        if (this.crawling = !0, scopeVisitor || (scopeVisitor = _index.default.visitors.merge([{
          Scope(path2) {
            resetScope(path2.scope);
          }
        }, collectorVisitor])), path.type !== "Program") {
          let typeVisitors = scopeVisitor[path.type];
          if (typeVisitors)
            for (let visit of typeVisitors.enter)
              visit.call(state, path, state);
        }
        path.traverse(scopeVisitor, state), this.crawling = !1;
        for (let path2 of state.assignments) {
          let ids = path2.getAssignmentIdentifiers();
          for (let name of Object.keys(ids))
            path2.scope.getBinding(name) || programParent.addGlobal(ids[name]);
          path2.scope.registerConstantViolation(path2);
        }
        for (let ref of state.references) {
          let binding = ref.scope.getBinding(ref.node.name);
          binding ? binding.reference(ref) : programParent.addGlobal(ref.node);
        }
        for (let path2 of state.constantViolations)
          path2.scope.registerConstantViolation(path2);
      }
      push(opts) {
        let path = this.path;
        path.isPattern() ? path = this.getPatternParent().path : !path.isBlockStatement() && !path.isProgram() && (path = this.getBlockParent().path), path.isSwitchStatement() && (path = (this.getFunctionParent() || this.getProgramParent()).path);
        let {
          init,
          unique,
          kind = "var",
          id
        } = opts;
        if (!init && !unique && (kind === "var" || kind === "let") && isAnonymousFunctionExpression(path) && isCallExpression(path.parent, {
          callee: path.node
        }) && path.parent.arguments.length <= path.node.params.length && isIdentifier(id)) {
          path.pushContainer("params", id), path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
          return;
        }
        (path.isLoop() || path.isCatchClause() || path.isFunction()) && (path.ensureBlock(), path = path.get("body"));
        let blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist, dataKey = `declaration:${kind}:${blockHoist}`, declarPath = !unique && path.getData(dataKey);
        if (!declarPath) {
          let declar = variableDeclaration(kind, []);
          declar._blockHoist = blockHoist, [declarPath] = path.unshiftContainer("body", [declar]), unique || path.setData(dataKey, declarPath);
        }
        let declarator = variableDeclarator(id, init), len = declarPath.node.declarations.push(declarator);
        path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
      }
      getProgramParent() {
        let scope = this;
        do
          if (scope.path.isProgram())
            return scope;
        while (scope = scope.parent);
        throw new Error("Couldn't find a Program");
      }
      getFunctionParent() {
        let scope = this;
        do
          if (scope.path.isFunctionParent())
            return scope;
        while (scope = scope.parent);
        return null;
      }
      getBlockParent() {
        let scope = this;
        do
          if (scope.path.isBlockParent())
            return scope;
        while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getPatternParent() {
        let scope = this;
        do
          if (!scope.path.isPattern())
            return scope.getBlockParent();
        while (scope = scope.parent.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getAllBindings() {
        let ids = /* @__PURE__ */ Object.create(null), scope = this;
        do {
          for (let key of Object.keys(scope.bindings))
            key in ids || (ids[key] = scope.bindings[key]);
          scope = scope.parent;
        } while (scope);
        return ids;
      }
      bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      }
      getBinding(name) {
        let scope = this, previousPath;
        do {
          let binding = scope.getOwnBinding(name);
          if (binding) {
            var _previousPath;
            if (!((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local"))
              return binding;
          } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression())
            break;
          previousPath = scope.path;
        } while (scope = scope.parent);
      }
      getOwnBinding(name) {
        return this.bindings[name];
      }
      getBindingIdentifier(name) {
        var _this$getBinding2;
        return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;
      }
      getOwnBindingIdentifier(name) {
        let binding = this.bindings[name];
        return binding?.identifier;
      }
      hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      }
      hasBinding(name, opts) {
        if (!name) return !1;
        let noGlobals, noUids, upToScope;
        typeof opts == "object" ? (noGlobals = opts.noGlobals, noUids = opts.noUids, upToScope = opts.upToScope) : typeof opts == "boolean" && (noGlobals = opts);
        let scope = this;
        do {
          if (upToScope === scope)
            break;
          if (scope.hasOwnBinding(name))
            return !0;
        } while (scope = scope.parent);
        return !!(!noUids && this.hasUid(name) || !noGlobals && _Scope.globals.includes(name) || !noGlobals && _Scope.contextVariables.includes(name));
      }
      parentHasBinding(name, opts) {
        var _this$parent;
        return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);
      }
      moveBindingTo(name, scope) {
        let info = this.getBinding(name);
        info && (info.scope.removeOwnBinding(name), info.scope = scope, scope.bindings[name] = info);
      }
      removeOwnBinding(name) {
        delete this.bindings[name];
      }
      removeBinding(name) {
        var _this$getBinding3;
        (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
        {
          let scope = this;
          do
            scope.uids[name] && (scope.uids[name] = !1);
          while (scope = scope.parent);
        }
      }
      hoistVariables(emit = (id) => this.push({
        id
      })) {
        this.crawl();
        let seen = /* @__PURE__ */ new Set();
        for (let name of Object.keys(this.bindings)) {
          let binding = this.bindings[name];
          if (!binding) continue;
          let {
            path
          } = binding;
          if (!path.isVariableDeclarator()) continue;
          let {
            parent,
            parentPath
          } = path;
          if (parent.kind !== "var" || seen.has(parent)) continue;
          seen.add(path.parent);
          let firstId, init = [];
          for (let decl of parent.declarations) {
            firstId ?? (firstId = decl.id), decl.init && init.push(assignmentExpression("=", decl.id, decl.init));
            let ids = Object.keys(getBindingIdentifiers(decl, !1, !0, !0));
            for (let name2 of ids)
              emit(identifier(name2), decl.init != null);
          }
          if (parentPath.parentPath.isForXStatement({
            left: parent
          }))
            parentPath.replaceWith(firstId);
          else if (init.length === 0)
            parentPath.remove();
          else {
            let expr = init.length === 1 ? init[0] : sequenceExpression(init);
            parentPath.parentPath.isForStatement({
              init: parent
            }) ? parentPath.replaceWith(expr) : parentPath.replaceWith(expressionStatement(expr));
          }
        }
      }
    };
    exports.default = Scope;
    Scope.globals = [...globalsBuiltinLower, ...globalsBuiltinUpper];
    Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    Scope.prototype._renameFromMap = function(map, oldName, newName, value2) {
      map[oldName] && (map[newName] = value2, map[oldName] = null);
    }, Scope.prototype.traverse = function(node, opts, state) {
      (0, _index.default)(node, opts, this, state, this.path);
    }, Scope.prototype._generateUid = function(name, i) {
      let id = name;
      return i > 1 && (id += i), `_${id}`;
    }, Scope.prototype.toArray = function(node, i, arrayLikeIsIterable) {
      if (isIdentifier(node)) {
        let binding = this.getBinding(node.name);
        if (binding != null && binding.constant && binding.path.isGenericType("Array"))
          return node;
      }
      if (isArrayExpression(node))
        return node;
      if (isIdentifier(node, {
        name: "arguments"
      }))
        return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
      let helperName, args = [node];
      return i === !0 ? helperName = "toConsumableArray" : typeof i == "number" ? (args.push(numericLiteral(i)), helperName = "slicedToArray") : helperName = "toArray", arrayLikeIsIterable && (args.unshift(this.path.hub.addHelper(helperName)), helperName = "maybeArrayLike"), callExpression(this.path.hub.addHelper(helperName), args);
    }, Scope.prototype.getAllBindingsOfKind = function(...kinds) {
      let ids = /* @__PURE__ */ Object.create(null);
      for (let kind of kinds) {
        let scope = this;
        do {
          for (let name of Object.keys(scope.bindings)) {
            let binding = scope.bindings[name];
            binding.kind === kind && (ids[name] = binding);
          }
          scope = scope.parent;
        } while (scope);
      }
      return ids;
    }, Object.defineProperties(Scope.prototype, {
      parentBlock: {
        configurable: !0,
        enumerable: !0,
        get() {
          return this.path.parent;
        }
      },
      hub: {
        configurable: !0,
        enumerable: !0,
        get() {
          return this.path.hub;
        }
      }
    });
  }
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module) {
    (function(global2, factory) {
      if (typeof exports == "object" && typeof module < "u")
        factory(module), module.exports = def(module);
      else if (typeof define == "function" && define.amd)
        define(["module"], function(mod) {
          factory.apply(this, arguments), mod.exports = def(mod);
        });
      else {
        let mod = { exports: {} };
        factory(mod), global2 = typeof globalThis < "u" ? globalThis : global2 || self, global2.sourcemapCodec = def(mod);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(exports, (function(module2) {
      "use strict";
      var __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __hasOwnProp = Object.prototype.hasOwnProperty, __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: !0 });
      }, __copyProps = (to, from, except, desc) => {
        if (from && typeof from == "object" || typeof from == "function")
          for (let key of __getOwnPropNames(from))
            !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        return to;
      }, __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod), sourcemap_codec_exports = {};
      __export(sourcemap_codec_exports, {
        decode: () => decode,
        decodeGeneratedRanges: () => decodeGeneratedRanges,
        decodeOriginalScopes: () => decodeOriginalScopes,
        encode: () => encode,
        encodeGeneratedRanges: () => encodeGeneratedRanges,
        encodeOriginalScopes: () => encodeOriginalScopes
      }), module2.exports = __toCommonJS(sourcemap_codec_exports);
      var comma = 44, semicolon = 59, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", intToChar = new Uint8Array(64), charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        let c = chars.charCodeAt(i);
        intToChar[i] = c, charToInt[c] = i;
      }
      function decodeInteger(reader, relative) {
        let value2 = 0, shift = 0, integer = 0;
        do {
          let c = reader.next();
          integer = charToInt[c], value2 |= (integer & 31) << shift, shift += 5;
        } while (integer & 32);
        let shouldNegate = value2 & 1;
        return value2 >>>= 1, shouldNegate && (value2 = -2147483648 | -value2), relative + value2;
      }
      function encodeInteger(builder, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5, delta > 0 && (clamped |= 32), builder.write(intToChar[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max) {
        return reader.pos >= max ? !1 : reader.peek() !== comma;
      }
      var bufLength = 1024 * 16, td = typeof TextDecoder < "u" ? new TextDecoder() : typeof Buffer < "u" ? {
        decode(buf) {
          return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++)
            out += String.fromCharCode(buf[i]);
          return out;
        }
      }, StringWriter = class {
        constructor() {
          this.pos = 0, this.out = "", this.buffer = new Uint8Array(bufLength);
        }
        write(v) {
          let { buffer } = this;
          buffer[this.pos++] = v, this.pos === bufLength && (this.out += td.decode(buffer), this.pos = 0);
        }
        flush() {
          let { buffer, out, pos } = this;
          return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
        }
      }, StringReader = class {
        constructor(buffer) {
          this.pos = 0, this.buffer = buffer;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char) {
          let { buffer, pos } = this, idx = buffer.indexOf(char, pos);
          return idx === -1 ? buffer.length : idx;
        }
      }, EMPTY = [];
      function decodeOriginalScopes(input) {
        let { length } = input, reader = new StringReader(input), scopes = [], stack = [], line = 0;
        for (; reader.pos < length; reader.pos++) {
          line = decodeInteger(reader, line);
          let column = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length)) {
            let last = stack.pop();
            last[2] = line, last[3] = column;
            continue;
          }
          let kind = decodeInteger(reader, 0), scope = decodeInteger(reader, 0) & 1 ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind], vars = EMPTY;
          if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
              let varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length));
          }
          scope.vars = vars, scopes.push(scope), stack.push(scope);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        let writer = new StringWriter();
        for (let i = 0; i < scopes.length; )
          i = _encodeOriginalScopes(scopes, i, writer, [0]);
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index, writer, state) {
        let scope = scopes[index], { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
        index > 0 && writer.write(comma), state[0] = encodeInteger(writer, startLine, state[0]), encodeInteger(writer, startColumn, 0), encodeInteger(writer, kind, 0);
        let fields = scope.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0), scope.length === 6 && encodeInteger(writer, scope[5], 0);
        for (let v of vars)
          encodeInteger(writer, v, 0);
        for (index++; index < scopes.length; ) {
          let next = scopes[index], { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn)
            break;
          index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        return writer.write(comma), state[0] = encodeInteger(writer, endLine, state[0]), encodeInteger(writer, endColumn, 0), index;
      }
      function decodeGeneratedRanges(input) {
        let { length } = input, reader = new StringReader(input), ranges = [], stack = [], genLine = 0, definitionSourcesIndex = 0, definitionScopeIndex = 0, callsiteSourcesIndex = 0, callsiteLine = 0, callsiteColumn = 0, bindingLine = 0, bindingColumn = 0;
        do {
          let semi = reader.indexOf(";"), genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            if (genColumn = decodeInteger(reader, genColumn), !hasMoreVlq(reader, semi)) {
              let last = stack.pop();
              last[2] = genLine, last[3] = genColumn;
              continue;
            }
            let fields = decodeInteger(reader, 0), hasDefinition = fields & 1, hasCallsite = fields & 2, hasScope = fields & 4, callsite = null, bindings = EMPTY, range;
            if (hasDefinition) {
              let defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(
                reader,
                definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0
              ), definitionSourcesIndex = defSourcesIndex, range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else
              range = [genLine, genColumn, 0, 0];
            if (range.isScope = !!hasScope, hasCallsite) {
              let prevCsi = callsiteSourcesIndex, prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              let sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0), callsiteColumn = decodeInteger(
                reader,
                sameSource && prevLine === callsiteLine ? callsiteColumn : 0
              ), callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            if (range.callsite = callsite, hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine, bindingColumn = genColumn;
                let expressionsCount = decodeInteger(reader, 0), expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (let i = -1; i > expressionsCount; i--) {
                    let prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine), bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    let expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else
                  expressionRanges = [[expressionsCount]];
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings, ranges.push(range), stack.push(range);
          }
          genLine++, reader.pos = semi + 1;
        } while (reader.pos < length);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0) return "";
        let writer = new StringWriter();
        for (let i = 0; i < ranges.length; )
          i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index, writer, state) {
        let range = ranges[index], {
          0: startLine,
          1: startColumn,
          2: endLine,
          3: endColumn,
          isScope,
          callsite,
          bindings
        } = range;
        state[0] < startLine ? (catchupLine(writer, state[0], startLine), state[0] = startLine, state[1] = 0) : index > 0 && writer.write(comma), state[1] = encodeInteger(writer, range[1], state[1]);
        let fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
        if (encodeInteger(writer, fields, 0), range.length === 6) {
          let { 4: sourcesIndex, 5: scopesIndex } = range;
          sourcesIndex !== state[2] && (state[3] = 0), state[2] = encodeInteger(writer, sourcesIndex, state[2]), state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          let { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
          sourcesIndex !== state[4] ? (state[5] = 0, state[6] = 0) : callLine !== state[5] && (state[6] = 0), state[4] = encodeInteger(writer, sourcesIndex, state[4]), state[5] = encodeInteger(writer, callLine, state[5]), state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings)
          for (let binding of bindings) {
            binding.length > 1 && encodeInteger(writer, -binding.length, 0);
            let expression = binding[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine, bindingStartColumn = startColumn;
            for (let i = 1; i < binding.length; i++) {
              let expRange = binding[i];
              bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine), bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn), encodeInteger(writer, expRange[0], 0);
            }
          }
        for (index++; index < ranges.length; ) {
          let next = ranges[index], { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn)
            break;
          index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        return state[0] < endLine ? (catchupLine(writer, state[0], endLine), state[0] = endLine, state[1] = 0) : writer.write(comma), state[1] = encodeInteger(writer, endColumn, state[1]), index;
      }
      function catchupLine(writer, lastLine, line) {
        do
          writer.write(semicolon);
        while (++lastLine < line);
      }
      function decode(mappings) {
        let { length } = mappings, reader = new StringReader(mappings), decoded = [], genColumn = 0, sourcesIndex = 0, sourceLine = 0, sourceColumn = 0, namesIndex = 0;
        do {
          let semi = reader.indexOf(";"), line = [], sorted = !0, lastCol = 0;
          for (genColumn = 0; reader.pos < semi; ) {
            let seg;
            genColumn = decodeInteger(reader, genColumn), genColumn < lastCol && (sorted = !1), lastCol = genColumn, hasMoreVlq(reader, semi) ? (sourcesIndex = decodeInteger(reader, sourcesIndex), sourceLine = decodeInteger(reader, sourceLine), sourceColumn = decodeInteger(reader, sourceColumn), hasMoreVlq(reader, semi) ? (namesIndex = decodeInteger(reader, namesIndex), seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]) : seg = [genColumn, sourcesIndex, sourceLine, sourceColumn]) : seg = [genColumn], line.push(seg), reader.pos++;
          }
          sorted || sort(line), decoded.push(line), reader.pos = semi + 1;
        } while (reader.pos <= length);
        return decoded;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        let writer = new StringWriter(), sourcesIndex = 0, sourceLine = 0, sourceColumn = 0, namesIndex = 0;
        for (let i = 0; i < decoded.length; i++) {
          let line = decoded[i];
          if (i > 0 && writer.write(semicolon), line.length === 0) continue;
          let genColumn = 0;
          for (let j = 0; j < line.length; j++) {
            let segment = line[j];
            j > 0 && writer.write(comma), genColumn = encodeInteger(writer, segment[0], genColumn), segment.length !== 1 && (sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex), sourceLine = encodeInteger(writer, segment[2], sourceLine), sourceColumn = encodeInteger(writer, segment[3], sourceColumn), segment.length !== 4 && (namesIndex = encodeInteger(writer, segment[4], namesIndex)));
          }
        }
        return writer.flush();
      }
    }));
  }
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module < "u" ? module.exports = factory() : typeof define == "function" && define.amd ? define(factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports, (function() {
      "use strict";
      let schemeRegex = /^[\w+.-]+:\/\//, urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        let match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        let match = fileRegex.exec(input), path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          let url2 = parseAbsoluteUrl("http:" + input);
          return url2.scheme = "", url2.type = 6, url2;
        }
        if (isAbsolutePath(input)) {
          let url2 = parseAbsoluteUrl("http://foo.com" + input);
          return url2.scheme = "", url2.host = "", url2.type = 5, url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        let url = parseAbsoluteUrl("http://foo.com/" + input);
        return url.scheme = "", url.host = "", url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1, url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        let index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type), url.path === "/" ? url.path = base.path : url.path = stripPathFilename(base.path) + url.path;
      }
      function normalizePath(url, type) {
        let rel = type <= 4, pieces = url.path.split("/"), pointer = 1, positive = 0, addTrailingSlash = !1;
        for (let i = 1; i < pieces.length; i++) {
          let piece = pieces[i];
          if (!piece) {
            addTrailingSlash = !0;
            continue;
          }
          if (addTrailingSlash = !1, piece !== ".") {
            if (piece === "..") {
              positive ? (addTrailingSlash = !0, positive--, pointer--) : rel && (pieces[pointer++] = piece);
              continue;
            }
            pieces[pointer++] = piece, positive++;
          }
        }
        let path = "";
        for (let i = 1; i < pointer; i++)
          path += "/" + pieces[i];
        (!path || addTrailingSlash && !path.endsWith("/..")) && (path += "/"), url.path = path;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        let url = parseUrl(input), inputType = url.type;
        if (base && inputType !== 7) {
          let baseUrl = parseUrl(base), baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            // fall through
            case 2:
              url.query = baseUrl.query;
            // fall through
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            // fall through
            case 5:
              url.user = baseUrl.user, url.host = baseUrl.host, url.port = baseUrl.port;
            // fall through
            case 6:
              url.scheme = baseUrl.scheme;
          }
          baseType > inputType && (inputType = baseType);
        }
        normalizePath(url, inputType);
        let queryHash = url.query + url.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return queryHash;
          case 4: {
            let path = url.path.slice(1);
            return path ? isRelative(base || input) && !isRelative(path) ? "./" + path + queryHash : path + queryHash : queryHash || ".";
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    }));
  }
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module) {
    (function(global2, factory) {
      if (typeof exports == "object" && typeof module < "u")
        factory(module, require_resolve_uri_umd(), require_sourcemap_codec_umd()), module.exports = def(module);
      else if (typeof define == "function" && define.amd)
        define(["module", "@jridgewell/resolve-uri", "@jridgewell/sourcemap-codec"], function(mod) {
          factory.apply(this, arguments), mod.exports = def(mod);
        });
      else {
        let mod = { exports: {} };
        factory(mod, global2.resolveURI, global2.sourcemapCodec), global2 = typeof globalThis < "u" ? globalThis : global2 || self, global2.traceMapping = def(mod);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(exports, (function(module2, require_resolveURI, require_sourcemapCodec) {
      "use strict";
      var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJS2 = (cb, mod) => function() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      }, __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: !0 });
      }, __copyProps = (to, from, except, desc) => {
        if (from && typeof from == "object" || typeof from == "function")
          for (let key of __getOwnPropNames(from))
            !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        return to;
      }, __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
        mod
      )), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod), require_sourcemap_codec = __commonJS2({
        "umd:@jridgewell/sourcemap-codec"(exports2, module22) {
          module22.exports = require_sourcemapCodec;
        }
      }), require_resolve_uri = __commonJS2({
        "umd:@jridgewell/resolve-uri"(exports2, module22) {
          module22.exports = require_resolveURI;
        }
      }), trace_mapping_exports = {};
      __export(trace_mapping_exports, {
        AnyMap: () => FlattenMap,
        FlattenMap: () => FlattenMap,
        GREATEST_LOWER_BOUND: () => GREATEST_LOWER_BOUND,
        LEAST_UPPER_BOUND: () => LEAST_UPPER_BOUND,
        TraceMap: () => TraceMap,
        allGeneratedPositionsFor: () => allGeneratedPositionsFor,
        decodedMap: () => decodedMap,
        decodedMappings: () => decodedMappings,
        eachMapping: () => eachMapping,
        encodedMap: () => encodedMap,
        encodedMappings: () => encodedMappings,
        generatedPositionFor: () => generatedPositionFor,
        isIgnored: () => isIgnored,
        originalPositionFor: () => originalPositionFor,
        presortedDecodedMap: () => presortedDecodedMap,
        sourceContentFor: () => sourceContentFor,
        traceSegment: () => traceSegment
      }), module2.exports = __toCommonJS(trace_mapping_exports);
      var import_sourcemap_codec = __toESM2(require_sourcemap_codec()), import_resolve_uri = __toESM2(require_resolve_uri());
      function stripFilename(path) {
        if (!path) return "";
        let index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function resolver(mapUrl, sourceRoot) {
        let from = stripFilename(mapUrl), prefix = sourceRoot ? sourceRoot + "/" : "";
        return (source) => (0, import_resolve_uri.default)(prefix + (source || ""), from);
      }
      var COLUMN = 0, SOURCES_INDEX = 1, SOURCE_LINE = 2, SOURCE_COLUMN = 3, NAMES_INDEX = 4, REV_GENERATED_LINE = 1, REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        let unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length) return mappings;
        owned || (mappings = mappings.slice());
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1))
          mappings[i] = sortSegments(mappings[i], owned);
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++)
          if (!isSorted(mappings[i])) return i;
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++)
          if (line[j][COLUMN] < line[j - 1][COLUMN])
            return !1;
        return !0;
      }
      function sortSegments(line, owned) {
        return owned || (line = line.slice()), line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      function buildBySources(decoded, memos) {
        let sources = memos.map(() => []);
        for (let i = 0; i < decoded.length; i++) {
          let line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            let seg = line[j];
            if (seg.length === 1) continue;
            let sourceIndex2 = seg[SOURCES_INDEX], sourceLine = seg[SOURCE_LINE], sourceColumn = seg[SOURCE_COLUMN], source = sources[sourceIndex2];
            (source[sourceLine] || (source[sourceLine] = [])).push([sourceColumn, i, seg[COLUMN]]);
          }
        }
        for (let i = 0; i < sources.length; i++) {
          let source = sources[i];
          for (let j = 0; j < source.length; j++) {
            let line = source[j];
            line && line.sort(sortComparator);
          }
        }
        return sources;
      }
      var found = !1;
      function binarySearch(haystack, needle, low, high) {
        for (; low <= high; ) {
          let mid = low + (high - low >> 1), cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0)
            return found = !0, mid;
          cmp < 0 ? low = mid + 1 : high = mid - 1;
        }
        return found = !1, low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length && haystack[i][COLUMN] === needle; index = i++)
          ;
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0 && haystack[i][COLUMN] === needle; index = i--)
          ;
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        let { lastKey, lastNeedle, lastIndex } = state, low = 0, high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle)
            return found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle, lastIndex;
          needle >= lastNeedle ? low = lastIndex === -1 ? 0 : lastIndex : high = lastIndex;
        }
        return state.lastKey = key, state.lastNeedle = needle, state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function parse3(map) {
        return typeof map == "string" ? JSON.parse(map) : map;
      }
      var FlattenMap = function(map, mapUrl) {
        let parsed = parse3(map);
        if (!("sections" in parsed))
          return new TraceMap(parsed, mapUrl);
        let mappings = [], sources = [], sourcesContent = [], names = [], ignoreList = [];
        recurse(
          parsed,
          mapUrl,
          mappings,
          sources,
          sourcesContent,
          names,
          ignoreList,
          0,
          0,
          1 / 0,
          1 / 0
        );
        let joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        let { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          let { map, offset } = sections[i], sl = stopLine, sc = stopColumn;
          if (i + 1 < sections.length) {
            let nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line), sl === stopLine ? sc = Math.min(stopColumn, columnOffset + nextOffset.column) : sl < stopLine && (sc = columnOffset + nextOffset.column);
          }
          addSection(
            map,
            mapUrl,
            mappings,
            sources,
            sourcesContent,
            names,
            ignoreList,
            lineOffset + offset.line,
            columnOffset + offset.column,
            sl,
            sc
          );
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        let parsed = parse3(input);
        if ("sections" in parsed) return recurse(...arguments);
        let map = new TraceMap(parsed, mapUrl), sourcesOffset = sources.length, namesOffset = names.length, decoded = decodedMappings(map), { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        if (append(sources, resolvedSources), append(names, map.names), contents) append(sourcesContent, contents);
        else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);
        if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          let lineI = lineOffset + i;
          if (lineI > stopLine) return;
          let out = getLine(mappings, lineI), cOffset = i === 0 ? columnOffset : 0, line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            let seg = line[j], column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn) return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            let sourcesIndex = sourcesOffset + seg[SOURCES_INDEX], sourceLine = seg[SOURCE_LINE], sourceColumn = seg[SOURCE_COLUMN];
            out.push(
              seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]
            );
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++) arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++) arr[i] = [];
        return arr[index];
      }
      var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)", COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)", LEAST_UPPER_BOUND = -1, GREATEST_LOWER_BOUND = 1, TraceMap = class {
        constructor(map, mapUrl) {
          let isString = typeof map == "string";
          if (!isString && map._decodedMemo) return map;
          let parsed = parse3(map), { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version, this.file = file, this.names = names || [], this.sourceRoot = sourceRoot, this.sources = sources, this.sourcesContent = sourcesContent, this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          let resolve = resolver(mapUrl, sourceRoot);
          this.resolvedSources = sources.map(resolve);
          let { mappings } = parsed;
          if (typeof mappings == "string")
            this._encoded = mappings, this._decoded = void 0;
          else if (Array.isArray(mappings))
            this._encoded = void 0, this._decoded = maybeSort(mappings, isString);
          else throw parsed.sections ? new Error("TraceMap passed sectioned source map, please use FlattenMap export instead") : new Error(`invalid source map: ${JSON.stringify(parsed)}`);
          this._decodedMemo = memoizedState(), this._bySources = void 0, this._bySourceMemos = void 0;
        }
      };
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a, _b;
        return (_b = (_a = map)._encoded) != null ? _b : _a._encoded = (0, import_sourcemap_codec.encode)(map._decoded);
      }
      function decodedMappings(map) {
        var _a;
        return (_a = map)._decoded || (_a._decoded = (0, import_sourcemap_codec.decode)(map._encoded));
      }
      function traceSegment(map, line, column) {
        let decoded = decodedMappings(map);
        if (line >= decoded.length) return null;
        let segments = decoded[line], index = traceSegmentInternal(
          segments,
          map._decodedMemo,
          line,
          column,
          GREATEST_LOWER_BOUND
        );
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor(map, needle) {
        let { line, column, bias } = needle;
        if (line--, line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        let decoded = decodedMappings(map);
        if (line >= decoded.length) return OMapping(null, null, null, null);
        let segments = decoded[line], index = traceSegmentInternal(
          segments,
          map._decodedMemo,
          line,
          column,
          bias || GREATEST_LOWER_BOUND
        );
        if (index === -1) return OMapping(null, null, null, null);
        let segment = segments[index];
        if (segment.length === 1) return OMapping(null, null, null, null);
        let { names, resolvedSources } = map;
        return OMapping(
          resolvedSources[segment[SOURCES_INDEX]],
          segment[SOURCE_LINE] + 1,
          segment[SOURCE_COLUMN],
          segment.length === 5 ? names[segment[NAMES_INDEX]] : null
        );
      }
      function generatedPositionFor(map, needle) {
        let { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, !1);
      }
      function allGeneratedPositionsFor(map, needle) {
        let { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, !0);
      }
      function eachMapping(map, cb) {
        let decoded = decodedMappings(map), { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          let line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            let seg = line[j], generatedLine = i + 1, generatedColumn = seg[0], source = null, originalLine = null, originalColumn = null, name = null;
            seg.length !== 1 && (source = resolvedSources[seg[1]], originalLine = seg[2] + 1, originalColumn = seg[3]), seg.length === 5 && (name = names[seg[4]]), cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      }
      function sourceIndex(map, source) {
        let { sources, resolvedSources } = map, index = sources.indexOf(source);
        return index === -1 && (index = resolvedSources.indexOf(source)), index;
      }
      function sourceContentFor(map, source) {
        let { sourcesContent } = map;
        if (sourcesContent == null) return null;
        let index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source) {
        let { ignoreList } = map;
        if (ignoreList == null) return !1;
        let index = sourceIndex(map, source);
        return index === -1 ? !1 : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        let tracer = new TraceMap(clone(map, []), mapUrl);
        return tracer._decoded = map.mappings, tracer;
      }
      function decodedMap(map) {
        return clone(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone(map, encodedMappings(map));
      }
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line, column, name) {
        return { source, line, column, name };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        return found ? index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index) : bias === LEAST_UPPER_BOUND && index++, index === -1 || index === segments.length ? -1 : index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND && min++, min === -1 || min === segments.length) return [];
        let matchedColumn = found ? column : segments[min][COLUMN];
        found || (min = lowerBound(segments, matchedColumn, min));
        let max = upperBound(segments, matchedColumn, min), result = [];
        for (; min <= max; min++) {
          let segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a, _b;
        if (line--, line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        let { sources, resolvedSources } = map, sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1 && (sourceIndex2 = resolvedSources.indexOf(source)), sourceIndex2 === -1) return all ? [] : GMapping(null, null);
        let bySourceMemos = (_a = map)._bySourceMemos || (_a._bySourceMemos = sources.map(memoizedState)), segments = ((_b = map)._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos)))[sourceIndex2][line];
        if (segments == null) return all ? [] : GMapping(null, null);
        let memo = bySourceMemos[sourceIndex2];
        if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);
        let index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1) return GMapping(null, null);
        let segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
    }));
  }
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module) {
    (function(global2, factory) {
      if (typeof exports == "object" && typeof module < "u")
        factory(module, require_sourcemap_codec_umd(), require_trace_mapping_umd()), module.exports = def(module);
      else if (typeof define == "function" && define.amd)
        define(["module", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], function(mod) {
          factory.apply(this, arguments), mod.exports = def(mod);
        });
      else {
        let mod = { exports: {} };
        factory(mod, global2.sourcemapCodec, global2.traceMapping), global2 = typeof globalThis < "u" ? globalThis : global2 || self, global2.genMapping = def(mod);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(exports, (function(module2, require_sourcemapCodec, require_traceMapping) {
      "use strict";
      var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJS2 = (cb, mod) => function() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      }, __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: !0 });
      }, __copyProps = (to, from, except, desc) => {
        if (from && typeof from == "object" || typeof from == "function")
          for (let key of __getOwnPropNames(from))
            !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        return to;
      }, __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
        mod
      )), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod), require_sourcemap_codec = __commonJS2({
        "umd:@jridgewell/sourcemap-codec"(exports2, module22) {
          module22.exports = require_sourcemapCodec;
        }
      }), require_trace_mapping = __commonJS2({
        "umd:@jridgewell/trace-mapping"(exports2, module22) {
          module22.exports = require_traceMapping;
        }
      }), gen_mapping_exports = {};
      __export(gen_mapping_exports, {
        GenMapping: () => GenMapping,
        addMapping: () => addMapping,
        addSegment: () => addSegment,
        allMappings: () => allMappings,
        fromMap: () => fromMap,
        maybeAddMapping: () => maybeAddMapping,
        maybeAddSegment: () => maybeAddSegment,
        setIgnore: () => setIgnore,
        setSourceContent: () => setSourceContent,
        toDecodedMap: () => toDecodedMap,
        toEncodedMap: () => toEncodedMap
      }), module2.exports = __toCommonJS(gen_mapping_exports);
      var SetArray = class {
        constructor() {
          this._indexes = { __proto__: null }, this.array = [];
        }
      };
      function cast(set) {
        return set;
      }
      function get(setarr, key) {
        return setarr._indexes[key];
      }
      function put(setarr, key) {
        let index = get(setarr, key);
        if (index !== void 0) return index;
        let { array, _indexes: indexes } = setarr, length = array.push(key);
        return indexes[key] = length - 1;
      }
      function remove(setarr, key) {
        let index = get(setarr, key);
        if (index === void 0) return;
        let { array, _indexes: indexes } = setarr;
        for (let i = index + 1; i < array.length; i++) {
          let k = array[i];
          array[i - 1] = k, indexes[k]--;
        }
        indexes[key] = void 0, array.pop();
      }
      var import_sourcemap_codec = __toESM2(require_sourcemap_codec()), import_trace_mapping = __toESM2(require_trace_mapping()), COLUMN = 0, SOURCES_INDEX = 1, SOURCE_LINE = 2, SOURCE_COLUMN = 3, NAMES_INDEX = 4, NO_NAME = -1, GenMapping = class {
        constructor({ file, sourceRoot } = {}) {
          this._names = new SetArray(), this._sources = new SetArray(), this._sourcesContent = [], this._mappings = [], this.file = file, this.sourceRoot = sourceRoot, this._ignoreList = new SetArray();
        }
      };
      function cast2(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(
          !1,
          map,
          genLine,
          genColumn,
          source,
          sourceLine,
          sourceColumn,
          name,
          content
        );
      }
      function addMapping(map, mapping) {
        return addMappingInternal(!1, map, mapping);
      }
      var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => addSegmentInternal(
        !0,
        map,
        genLine,
        genColumn,
        source,
        sourceLine,
        sourceColumn,
        name,
        content
      ), maybeAddMapping = (map, mapping) => addMappingInternal(!0, map, mapping);
      function setSourceContent(map, source, content) {
        let {
          _sources: sources,
          _sourcesContent: sourcesContent
          // _originalScopes: originalScopes,
        } = map, index = put(sources, source);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source, ignore = !0) {
        let {
          _sources: sources,
          _sourcesContent: sourcesContent,
          _ignoreList: ignoreList
          // _originalScopes: originalScopes,
        } = map, index = put(sources, source);
        index === sourcesContent.length && (sourcesContent[index] = null), ignore ? put(ignoreList, index) : remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        let {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names,
          _ignoreList: ignoreList
          // _originalScopes: originalScopes,
          // _generatedRanges: generatedRanges,
        } = map;
        return removeEmptyFinalLines(mappings), {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          // originalScopes,
          // generatedRanges,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        let decoded = toDecodedMap(map);
        return Object.assign({}, decoded, {
          // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
          // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
          mappings: (0, import_sourcemap_codec.encode)(decoded.mappings)
        });
      }
      function fromMap(input) {
        let map = new import_trace_mapping.TraceMap(input), gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        return putAll(gen._names, map.names), putAll(gen._sources, map.sources), gen._sourcesContent = map.sourcesContent || map.sources.map(() => null), gen._mappings = (0, import_trace_mapping.decodedMappings)(map), map.ignoreList && putAll(gen._ignoreList, map.ignoreList), gen;
      }
      function allMappings(map) {
        let out = [], { _mappings: mappings, _sources: sources, _names: names } = map;
        for (let i = 0; i < mappings.length; i++) {
          let line = mappings[i];
          for (let j = 0; j < line.length; j++) {
            let seg = line[j], generated = { line: i + 1, column: seg[COLUMN] }, source, original, name;
            seg.length !== 1 && (source = sources.array[seg[SOURCES_INDEX]], original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] }, seg.length === 5 && (name = names.array[seg[NAMES_INDEX]])), out.push({ generated, source, original, name });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        let {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names
          // _originalScopes: originalScopes,
        } = map, line = getIndex(mappings, genLine), index = getColumnIndex(line, genColumn);
        if (!source)
          return skipable && skipSourceless(line, index) ? void 0 : insert(line, index, [genColumn]);
        let sourcesIndex = put(sources, source), namesIndex = name ? put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length && (sourcesContent[sourcesIndex] = content ?? null), !(skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)))
          return insert(
            line,
            index,
            name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]
          );
      }
      function assert(_val) {
      }
      function getIndex(arr, index) {
        for (let i = arr.length; i <= index; i++)
          arr[i] = [];
        return arr[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          let current = line[i];
          if (genColumn >= current[COLUMN]) break;
        }
        return index;
      }
      function insert(array, index, value2) {
        for (let i = array.length; i > index; i--)
          array[i] = array[i - 1];
        array[index] = value2;
      }
      function removeEmptyFinalLines(mappings) {
        let { length } = mappings, len = length;
        for (let i = len - 1; i >= 0 && !(mappings[i].length > 0); len = i, i--)
          ;
        len < length && (mappings.length = len);
      }
      function putAll(setarr, array) {
        for (let i = 0; i < array.length; i++) put(setarr, array[i]);
      }
      function skipSourceless(line, index) {
        return index === 0 ? !0 : line[index - 1].length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0) return !1;
        let prev = line[index - 1];
        return prev.length === 1 ? !1 : sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        let { generated, source, original, name, content } = mapping;
        return source ? addSegmentInternal(
          skipable,
          map,
          generated.line - 1,
          generated.column,
          source,
          original.line - 1,
          original.column,
          name,
          content
        ) : addSegmentInternal(
          skipable,
          map,
          generated.line - 1,
          generated.column,
          null,
          null,
          null,
          null,
          null
        );
      }
    }));
  }
});

// ../node_modules/@babel/generator/lib/source-map.js
var require_source_map = __commonJS({
  "../node_modules/@babel/generator/lib/source-map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _genMapping = require_gen_mapping_umd(), _traceMapping = require_trace_mapping_umd(), SourceMap = class {
      constructor(opts, code) {
        var _opts$sourceFileName;
        this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = null;
        let map = this._map = new _genMapping.GenMapping({
          sourceRoot: opts.sourceRoot
        });
        if (this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/"), this._rawMappings = void 0, opts.inputSourceMap) {
          this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
          let resolvedSources = this._inputMap.resolvedSources;
          if (resolvedSources.length)
            for (let i = 0; i < resolvedSources.length; i++) {
              var _this$_inputMap$sourc;
              (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
            }
        }
        if (typeof code == "string" && !opts.inputSourceMap)
          (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
        else if (typeof code == "object")
          for (let sourceFileName of Object.keys(code))
            (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
      }
      get() {
        return (0, _genMapping.toEncodedMap)(this._map);
      }
      getDecoded() {
        return (0, _genMapping.toDecodedMap)(this._map);
      }
      getRawMappings() {
        return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
      }
      mark(generated, line, column, identifierName, identifierNamePos, filename) {
        var _originalMapping;
        this._rawMappings = void 0;
        let originalMapping;
        if (line != null)
          if (this._inputMap) {
            if (originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
              line,
              column
            }), !originalMapping.name && identifierNamePos) {
              let originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
              originalIdentifierMapping.name && (identifierName = originalIdentifierMapping.name);
            }
          } else
            originalMapping = {
              name: null,
              source: filename?.replace(/\\/g, "/") || this._sourceFileName,
              line,
              column
            };
        (0, _genMapping.maybeAddMapping)(this._map, {
          name: identifierName,
          generated,
          source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
          original: originalMapping
        });
      }
    };
    exports.default = SourceMap;
  }
});

// ../node_modules/@babel/generator/lib/buffer.js
var require_buffer = __commonJS({
  "../node_modules/@babel/generator/lib/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var Buffer2 = class {
      constructor(map, indentChar) {
        this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
          line: 1,
          column: 0
        }, this._sourcePosition = {
          identifierName: void 0,
          identifierNamePos: void 0,
          line: void 0,
          column: void 0,
          filename: void 0
        }, this._map = map, this._indentChar = indentChar;
        for (let i = 0; i < 64; i++)
          this._fastIndentations.push(indentChar.repeat(i));
        this._allocQueue();
      }
      _allocQueue() {
        let queue = this._queue;
        for (let i = 0; i < 16; i++)
          queue.push({
            char: 0,
            repeat: 1,
            line: void 0,
            column: void 0,
            identifierName: void 0,
            identifierNamePos: void 0,
            filename: ""
          });
      }
      _pushQueue(char, repeat, line, column, filename) {
        let cursor = this._queueCursor;
        cursor === this._queue.length && this._allocQueue();
        let item = this._queue[cursor];
        item.char = char, item.repeat = repeat, item.line = line, item.column = column, item.filename = filename, this._queueCursor++;
      }
      _popQueue() {
        if (this._queueCursor === 0)
          throw new Error("Cannot pop from empty queue");
        return this._queue[--this._queueCursor];
      }
      get() {
        this._flush();
        let map = this._map, result = {
          code: (this._buf + this._str).trimRight(),
          decodedMap: map?.getDecoded(),
          get __mergedMap() {
            return this.map;
          },
          get map() {
            let resultMap = map ? map.get() : null;
            return result.map = resultMap, resultMap;
          },
          set map(value2) {
            Object.defineProperty(result, "map", {
              value: value2,
              writable: !0
            });
          },
          get rawMappings() {
            let mappings = map?.getRawMappings();
            return result.rawMappings = mappings, mappings;
          },
          set rawMappings(value2) {
            Object.defineProperty(result, "rawMappings", {
              value: value2,
              writable: !0
            });
          }
        };
        return result;
      }
      append(str, maybeNewline) {
        this._flush(), this._append(str, this._sourcePosition, maybeNewline);
      }
      appendChar(char) {
        this._flush(), this._appendChar(char, 1, this._sourcePosition);
      }
      queue(char) {
        if (char === 10)
          for (; this._queueCursor !== 0; ) {
            let char2 = this._queue[this._queueCursor - 1].char;
            if (char2 !== 32 && char2 !== 9)
              break;
            this._queueCursor--;
          }
        let sourcePosition = this._sourcePosition;
        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
      }
      queueIndentation(repeat) {
        repeat !== 0 && this._pushQueue(-1, repeat, void 0, void 0, void 0);
      }
      _flush() {
        let queueCursor = this._queueCursor, queue = this._queue;
        for (let i = 0; i < queueCursor; i++) {
          let item = queue[i];
          this._appendChar(item.char, item.repeat, item);
        }
        this._queueCursor = 0;
      }
      _appendChar(char, repeat, sourcePos) {
        if (this._last = char, char === -1) {
          let fastIndentation = this._fastIndentations[repeat];
          fastIndentation !== void 0 ? this._str += fastIndentation : this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
        } else
          this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
        char !== 10 ? (this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename), this._position.column += repeat) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (sourcePos.identifierName = void 0, sourcePos.identifierNamePos = void 0);
      }
      _append(str, sourcePos, maybeNewline) {
        let len = str.length, position = this._position;
        if (this._last = str.charCodeAt(len - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = str, this._appendCount = 0) : this._str += str, !maybeNewline && !this._map) {
          position.column += len;
          return;
        }
        let {
          column,
          identifierName,
          identifierNamePos,
          filename
        } = sourcePos, line = sourcePos.line;
        (identifierName != null || identifierNamePos != null) && this._canMarkIdName && (sourcePos.identifierName = void 0, sourcePos.identifierNamePos = void 0);
        let i = str.indexOf(`
`), last = 0;
        for (i !== 0 && this._mark(line, column, identifierName, identifierNamePos, filename); i !== -1; )
          position.line++, position.column = 0, last = i + 1, last < len && line !== void 0 && this._mark(++line, 0, void 0, void 0, filename), i = str.indexOf(`
`, last);
        position.column += len - last;
      }
      _mark(line, column, identifierName, identifierNamePos, filename) {
        var _this$_map;
        (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
      }
      removeTrailingNewline() {
        let queueCursor = this._queueCursor;
        queueCursor !== 0 && this._queue[queueCursor - 1].char === 10 && this._queueCursor--;
      }
      removeLastSemicolon() {
        let queueCursor = this._queueCursor;
        queueCursor !== 0 && this._queue[queueCursor - 1].char === 59 && this._queueCursor--;
      }
      getLastChar() {
        let queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
      }
      getNewlineCount() {
        let queueCursor = this._queueCursor, count = 0;
        if (queueCursor === 0) return this._last === 10 ? 1 : 0;
        for (let i = queueCursor - 1; i >= 0 && this._queue[i].char === 10; i--)
          count++;
        return count === queueCursor && this._last === 10 ? count + 1 : count;
      }
      endsWithCharAndNewline() {
        let queue = this._queue, queueCursor = this._queueCursor;
        if (queueCursor !== 0)
          return queue[queueCursor - 1].char !== 10 ? void 0 : queueCursor > 1 ? queue[queueCursor - 2].char : this._last;
      }
      hasContent() {
        return this._queueCursor !== 0 || !!this._last;
      }
      exactSource(loc, cb) {
        if (!this._map) {
          cb();
          return;
        }
        this.source("start", loc);
        let identifierName = loc.identifierName, sourcePos = this._sourcePosition;
        identifierName && (this._canMarkIdName = !1, sourcePos.identifierName = identifierName), cb(), identifierName && (this._canMarkIdName = !0, sourcePos.identifierName = void 0, sourcePos.identifierNamePos = void 0), this.source("end", loc);
      }
      source(prop, loc) {
        this._map && this._normalizePosition(prop, loc, 0);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        this._map && this._normalizePosition(prop, loc, columnOffset);
      }
      _normalizePosition(prop, loc, columnOffset) {
        let pos = loc[prop], target = this._sourcePosition;
        pos && (target.line = pos.line, target.column = Math.max(pos.column + columnOffset, 0), target.filename = loc.filename);
      }
      getCurrentColumn() {
        let queue = this._queue, queueCursor = this._queueCursor, lastIndex = -1, len = 0;
        for (let i = 0; i < queueCursor; i++) {
          let item = queue[i];
          item.char === 10 && (lastIndex = len), len += item.repeat;
        }
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
      }
      getCurrentLine() {
        let count = 0, queue = this._queue;
        for (let i = 0; i < this._queueCursor; i++)
          queue[i].char === 10 && count++;
        return this._position.line + count;
      }
    };
    exports.default = Buffer2;
  }
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace = __commonJS({
  "../node_modules/@babel/generator/lib/node/whitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.nodes = void 0;
    var _t = require_lib4(), {
      FLIPPED_ALIAS_KEYS,
      isArrayExpression,
      isAssignmentExpression,
      isBinary,
      isBlockStatement,
      isCallExpression,
      isFunction,
      isIdentifier,
      isLiteral,
      isMemberExpression,
      isObjectExpression,
      isOptionalCallExpression,
      isOptionalMemberExpression,
      isStringLiteral
    } = _t;
    function crawlInternal(node, state) {
      return node && (isMemberExpression(node) || isOptionalMemberExpression(node) ? (crawlInternal(node.object, state), node.computed && crawlInternal(node.property, state)) : isBinary(node) || isAssignmentExpression(node) ? (crawlInternal(node.left, state), crawlInternal(node.right, state)) : isCallExpression(node) || isOptionalCallExpression(node) ? (state.hasCall = !0, crawlInternal(node.callee, state)) : isFunction(node) ? state.hasFunction = !0 : isIdentifier(node) && (state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee))), state;
    }
    function crawl(node) {
      return crawlInternal(node, {
        hasCall: !1,
        hasFunction: !1,
        hasHelper: !1
      });
    }
    function isHelper(node) {
      return node ? isMemberExpression(node) ? isHelper(node.object) || isHelper(node.property) : isIdentifier(node) ? node.name === "require" || node.name.charCodeAt(0) === 95 : isCallExpression(node) ? isHelper(node.callee) : isBinary(node) || isAssignmentExpression(node) ? isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right) : !1 : !1;
    }
    function isType(node) {
      return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
    }
    var nodes = exports.nodes = {
      AssignmentExpression(node) {
        let state = crawl(node.right);
        return state.hasCall && state.hasHelper || state.hasFunction ? state.hasFunction ? 3 : 2 : 0;
      },
      SwitchCase(node, parent) {
        return (node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
      },
      LogicalExpression(node) {
        return isFunction(node.left) || isFunction(node.right) ? 2 : 0;
      },
      Literal(node) {
        return isStringLiteral(node) && node.value === "use strict" ? 2 : 0;
      },
      CallExpression(node) {
        return isFunction(node.callee) || isHelper(node) ? 3 : 0;
      },
      OptionalCallExpression(node) {
        return isFunction(node.callee) ? 3 : 0;
      },
      VariableDeclaration(node) {
        for (let i = 0; i < node.declarations.length; i++) {
          let declar = node.declarations[i], enabled = isHelper(declar.id) && !isType(declar.init);
          if (!enabled && declar.init) {
            let state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }
          if (enabled)
            return 3;
        }
        return 0;
      },
      IfStatement(node) {
        return isBlockStatement(node.consequent) ? 3 : 0;
      }
    };
    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
      return parent.properties[0] === node ? 1 : 0;
    };
    nodes.ObjectTypeCallProperty = function(node, parent) {
      var _parent$properties;
      return parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length) ? 1 : 0;
    };
    nodes.ObjectTypeIndexer = function(node, parent) {
      var _parent$properties2, _parent$callPropertie;
      return parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length) ? 1 : 0;
    };
    nodes.ObjectTypeInternalSlot = function(node, parent) {
      var _parent$properties3, _parent$callPropertie2, _parent$indexers;
      return parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length) ? 1 : 0;
    };
    [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([type, amounts]) {
      [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
        let ret = amounts ? 3 : 0;
        nodes[type2] = () => ret;
      });
    });
  }
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses = __commonJS({
  "../node_modules/@babel/generator/lib/node/parentheses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.AssignmentExpression = AssignmentExpression;
    exports.Binary = Binary;
    exports.BinaryExpression = BinaryExpression;
    exports.ClassExpression = ClassExpression;
    exports.ArrowFunctionExpression = exports.ConditionalExpression = ConditionalExpression;
    exports.DoExpression = DoExpression;
    exports.FunctionExpression = FunctionExpression;
    exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports.Identifier = Identifier;
    exports.LogicalExpression = LogicalExpression;
    exports.NullableTypeAnnotation = NullableTypeAnnotation;
    exports.ObjectExpression = ObjectExpression;
    exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
    exports.SequenceExpression = SequenceExpression;
    exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;
    exports.TSConditionalType = TSConditionalType;
    exports.TSConstructorType = exports.TSFunctionType = TSFunctionType;
    exports.TSInferType = TSInferType;
    exports.TSInstantiationExpression = TSInstantiationExpression;
    exports.TSIntersectionType = TSIntersectionType;
    exports.UnaryLike = exports.TSTypeAssertion = UnaryLike;
    exports.TSTypeOperator = TSTypeOperator;
    exports.TSUnionType = TSUnionType;
    exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
    exports.UpdateExpression = UpdateExpression;
    exports.AwaitExpression = exports.YieldExpression = YieldExpression;
    var _t = require_lib4(), _index = require_node(), {
      isArrayTypeAnnotation,
      isBinaryExpression,
      isCallExpression,
      isForOfStatement,
      isIndexedAccessType,
      isMemberExpression,
      isObjectPattern,
      isOptionalMemberExpression,
      isYieldExpression,
      isStatement
    } = _t, PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
    function getBinaryPrecedence(node, nodeType) {
      if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression")
        return PRECEDENCE.get(node.operator);
      if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression")
        return PRECEDENCE.get("in");
    }
    function isTSTypeExpression(nodeType) {
      return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
    }
    var isClassExtendsClause = (node, parent) => {
      let parentType = parent.type;
      return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node;
    }, hasPostfixPart = (node, parent) => {
      let parentType = parent.type;
      return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node || parentType === "TaggedTemplateExpression" && parent.tag === node || parentType === "TSNonNullExpression";
    };
    function NullableTypeAnnotation(node, parent) {
      return isArrayTypeAnnotation(parent);
    }
    function FunctionTypeAnnotation(node, parent, tokenContext) {
      let parentType = parent.type;
      return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || !!(tokenContext & _index.TokenContext.arrowFlowReturnType);
    }
    function UpdateExpression(node, parent) {
      return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
    }
    function needsParenBeforeExpressionBrace(tokenContext) {
      return !!(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
    }
    function ObjectExpression(node, parent, tokenContext) {
      return needsParenBeforeExpressionBrace(tokenContext);
    }
    function DoExpression(node, parent, tokenContext) {
      return !node.async && !!(tokenContext & _index.TokenContext.expressionStatement);
    }
    function Binary(node, parent) {
      let parentType = parent.type;
      if (node.type === "BinaryExpression" && node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**")
        return parent.left === node;
      if (isClassExtendsClause(node, parent) || hasPostfixPart(node, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression")
        return !0;
      let parentPos = getBinaryPrecedence(parent, parentType);
      if (parentPos != null) {
        let nodePos = getBinaryPrecedence(node, node.type);
        if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node || parentPos > nodePos)
          return !0;
      }
    }
    function UnionTypeAnnotation(node, parent) {
      let parentType = parent.type;
      return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
    }
    function OptionalIndexedAccessType(node, parent) {
      return isIndexedAccessType(parent) && parent.objectType === node;
    }
    function TSAsExpression(node, parent) {
      return (parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node || parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node === parent.left ? !0 : Binary(node, parent);
    }
    function TSConditionalType(node, parent) {
      let parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter" || (parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node || parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node);
    }
    function TSUnionType(node, parent) {
      let parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSIntersectionType(node, parent) {
      let parentType = parent.type;
      return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInferType(node, parent) {
      let parentType = parent.type;
      return !!(parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType" || node.typeParameter.constraint && (parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node);
    }
    function TSTypeOperator(node, parent) {
      let parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInstantiationExpression(node, parent) {
      let parentType = parent.type;
      return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
    }
    function TSFunctionType(node, parent) {
      let parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node);
    }
    function BinaryExpression(node, parent, tokenContext) {
      return node.operator === "in" && !!(tokenContext & _index.TokenContext.forInOrInitHeadAccumulate);
    }
    function SequenceExpression(node, parent) {
      let parentType = parent.type;
      return parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node || parentType === "OptionalMemberExpression" && parent.property === node || parentType === "TemplateLiteral" ? !1 : parentType === "ClassDeclaration" ? !0 : parentType === "ForOfStatement" ? parent.right === node : parentType === "ExportDefaultDeclaration" ? !0 : !isStatement(parent);
    }
    function YieldExpression(node, parent) {
      let parentType = parent.type;
      return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node, parent) || parentType === "AwaitExpression" && isYieldExpression(node) || parentType === "ConditionalExpression" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);
    }
    function ClassExpression(node, parent, tokenContext) {
      return !!(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function UnaryLike(node, parent) {
      return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node || isClassExtendsClause(node, parent);
    }
    function FunctionExpression(node, parent, tokenContext) {
      return !!(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function ConditionalExpression(node, parent) {
      let parentType = parent.type;
      return parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node || parentType === "AwaitExpression" || isTSTypeExpression(parentType) ? !0 : UnaryLike(node, parent);
    }
    function OptionalMemberExpression(node, parent) {
      return isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node;
    }
    function AssignmentExpression(node, parent, tokenContext) {
      return needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left) ? !0 : ConditionalExpression(node, parent);
    }
    function LogicalExpression(node, parent) {
      let parentType = parent.type;
      if (isTSTypeExpression(parentType)) return !0;
      if (parentType !== "LogicalExpression") return !1;
      switch (node.operator) {
        case "||":
          return parent.operator === "??" || parent.operator === "&&";
        case "&&":
          return parent.operator === "??";
        case "??":
          return parent.operator !== "??";
      }
    }
    function Identifier(node, parent, tokenContext, getRawIdentifier) {
      var _node$extra;
      let parentType = parent.type;
      if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node) {
        let rightType = parent.right.type;
        if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null)
          return !0;
      }
      return getRawIdentifier && getRawIdentifier(node) !== node.name ? !1 : node.name === "let" ? (isMemberExpression(parent, {
        object: node,
        computed: !0
      }) || isOptionalMemberExpression(parent, {
        object: node,
        computed: !0,
        optional: !1
      })) && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forInitHead | _index.TokenContext.forInHead) ? !0 : !!(tokenContext & _index.TokenContext.forOfHead) : node.name === "async" && isForOfStatement(parent, {
        left: node,
        await: !1
      });
    }
  }
});

// ../node_modules/@babel/generator/lib/node/index.js
var require_node = __commonJS({
  "../node_modules/@babel/generator/lib/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.TokenContext = void 0;
    exports.isLastChild = isLastChild;
    exports.needsParens = needsParens;
    exports.needsWhitespace = needsWhitespace;
    exports.needsWhitespaceAfter = needsWhitespaceAfter;
    exports.needsWhitespaceBefore = needsWhitespaceBefore;
    var whitespace = require_whitespace(), parens = require_parentheses(), _t = require_lib4(), {
      FLIPPED_ALIAS_KEYS,
      VISITOR_KEYS,
      isCallExpression,
      isDecorator,
      isExpressionStatement,
      isMemberExpression,
      isNewExpression,
      isParenthesizedExpression
    } = _t, TokenContext = exports.TokenContext = {
      normal: 0,
      expressionStatement: 1,
      arrowBody: 2,
      exportDefault: 4,
      arrowFlowReturnType: 8,
      forInitHead: 16,
      forInHead: 32,
      forOfHead: 64,
      forInOrInitHeadAccumulate: 128,
      forInOrInitHeadAccumulatePassThroughMask: 128
    };
    function expandAliases(obj) {
      let map = /* @__PURE__ */ new Map();
      function add(type, func) {
        let fn = map.get(type);
        map.set(type, fn ? function(node, parent, stack, getRawIdentifier) {
          var _fn;
          return (_fn = fn(node, parent, stack, getRawIdentifier)) != null ? _fn : func(node, parent, stack, getRawIdentifier);
        } : func);
      }
      for (let type of Object.keys(obj)) {
        let aliases = FLIPPED_ALIAS_KEYS[type];
        if (aliases)
          for (let alias of aliases)
            add(alias, obj[type]);
        else
          add(type, obj[type]);
      }
      return map;
    }
    var expandedParens = expandAliases(parens), expandedWhitespaceNodes = expandAliases(whitespace.nodes);
    function isOrHasCallExpression(node) {
      return isCallExpression(node) ? !0 : isMemberExpression(node) && isOrHasCallExpression(node.object);
    }
    function needsWhitespace(node, parent, type) {
      var _expandedWhitespaceNo;
      if (!node) return !1;
      isExpressionStatement(node) && (node = node.expression);
      let flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? void 0 : _expandedWhitespaceNo(node, parent);
      return typeof flag == "number" ? (flag & type) !== 0 : !1;
    }
    function needsWhitespaceBefore(node, parent) {
      return needsWhitespace(node, parent, 1);
    }
    function needsWhitespaceAfter(node, parent) {
      return needsWhitespace(node, parent, 2);
    }
    function needsParens(node, parent, tokenContext, getRawIdentifier) {
      var _expandedParens$get;
      return parent ? isNewExpression(parent) && parent.callee === node && isOrHasCallExpression(node) ? !0 : isDecorator(parent) ? !isDecoratorMemberExpression(node) && !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression(node) : ((_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, tokenContext, getRawIdentifier)) || !1 : !1;
    }
    function isDecoratorMemberExpression(node) {
      switch (node.type) {
        case "Identifier":
          return !0;
        case "MemberExpression":
          return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
        default:
          return !1;
      }
    }
    function isLastChild(parent, child) {
      let visitorKeys = VISITOR_KEYS[parent.type];
      for (let i = visitorKeys.length - 1; i >= 0; i--) {
        let val = parent[visitorKeys[i]];
        if (val === child)
          return !0;
        if (Array.isArray(val)) {
          let j = val.length - 1;
          for (; j >= 0 && val[j] === null; ) j--;
          return j >= 0 && val[j] === child;
        } else if (val)
          return !1;
      }
      return !1;
    }
  }
});

// ../node_modules/@babel/generator/lib/token-map.js
var require_token_map = __commonJS({
  "../node_modules/@babel/generator/lib/token-map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.TokenMap = void 0;
    var _t = require_lib4(), {
      traverseFast,
      VISITOR_KEYS
    } = _t, TokenMap = class {
      constructor(ast, tokens, source) {
        this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = tokens, this._source = source, traverseFast(ast, (node) => {
          let indexes = this._getTokensIndexesOfNode(node);
          indexes.length > 0 && this._nodesToTokenIndexes.set(node, indexes);
        }), this._tokensCache.clear();
      }
      has(node) {
        return this._nodesToTokenIndexes.has(node);
      }
      getIndexes(node) {
        return this._nodesToTokenIndexes.get(node);
      }
      find(node, condition) {
        let indexes = this._nodesToTokenIndexes.get(node);
        if (indexes)
          for (let k = 0; k < indexes.length; k++) {
            let index = indexes[k], tok = this._tokens[index];
            if (condition(tok, index)) return tok;
          }
        return null;
      }
      findLastIndex(node, condition) {
        let indexes = this._nodesToTokenIndexes.get(node);
        if (indexes)
          for (let k = indexes.length - 1; k >= 0; k--) {
            let index = indexes[k], tok = this._tokens[index];
            if (condition(tok, index)) return index;
          }
        return -1;
      }
      findMatching(node, test, occurrenceCount = 0) {
        let indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          let i = 0, count = occurrenceCount;
          if (count > 1) {
            let cache = this._nodesOccurrencesCountCache.get(node);
            cache && cache.test === test && cache.count < count && (i = cache.i + 1, occurrenceCount -= cache.count + 1);
          }
          for (; i < indexes.length; i++) {
            let tok = this._tokens[indexes[i]];
            if (this.matchesOriginal(tok, test)) {
              if (occurrenceCount === 0)
                return count > 0 && this._nodesOccurrencesCountCache.set(node, {
                  test,
                  count,
                  i
                }), tok;
              occurrenceCount--;
            }
          }
        }
        return null;
      }
      matchesOriginal(token, test) {
        return token.end - token.start !== test.length ? !1 : token.value != null ? token.value === test : this._source.startsWith(test, token.start);
      }
      startMatches(node, test) {
        let indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return !1;
        let tok = this._tokens[indexes[0]];
        return tok.start !== node.start ? !1 : this.matchesOriginal(tok, test);
      }
      endMatches(node, test) {
        let indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return !1;
        let tok = this._tokens[indexes[indexes.length - 1]];
        return tok.end !== node.end ? !1 : this.matchesOriginal(tok, test);
      }
      _getTokensIndexesOfNode(node) {
        if (node.start == null || node.end == null) return [];
        let {
          first,
          last
        } = this._findTokensOfNode(node, 0, this._tokens.length - 1), low = first, children = childrenIterator(node);
        (node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration && node.declaration.type === "ClassDeclaration" && children.next();
        let indexes = [];
        for (let child of children) {
          if (child == null || child.start == null || child.end == null) continue;
          let childTok = this._findTokensOfNode(child, low, last), high = childTok.first;
          for (let k = low; k < high; k++) indexes.push(k);
          low = childTok.last + 1;
        }
        for (let k = low; k <= last; k++) indexes.push(k);
        return indexes;
      }
      _findTokensOfNode(node, low, high) {
        let cached = this._tokensCache.get(node);
        if (cached) return cached;
        let first = this._findFirstTokenOfNode(node.start, low, high), last = this._findLastTokenOfNode(node.end, first, high);
        return this._tokensCache.set(node, {
          first,
          last
        }), {
          first,
          last
        };
      }
      _findFirstTokenOfNode(start, low, high) {
        for (; low <= high; ) {
          let mid = high + low >> 1;
          if (start < this._tokens[mid].start)
            high = mid - 1;
          else if (start > this._tokens[mid].start)
            low = mid + 1;
          else
            return mid;
        }
        return low;
      }
      _findLastTokenOfNode(end, low, high) {
        for (; low <= high; ) {
          let mid = high + low >> 1;
          if (end < this._tokens[mid].end)
            high = mid - 1;
          else if (end > this._tokens[mid].end)
            low = mid + 1;
          else
            return mid;
        }
        return high;
      }
    };
    exports.TokenMap = TokenMap;
    function* childrenIterator(node) {
      if (node.type === "TemplateLiteral") {
        yield node.quasis[0];
        for (let i = 1; i < node.quasis.length; i++)
          yield node.expressions[i - 1], yield node.quasis[i];
        return;
      }
      let keys = VISITOR_KEYS[node.type];
      for (let key of keys) {
        let child = node[key];
        child && (Array.isArray(child) ? yield* child : yield child);
      }
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals = __commonJS({
  "../node_modules/@babel/generator/lib/generators/template-literals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.TaggedTemplateExpression = TaggedTemplateExpression;
    exports.TemplateElement = TemplateElement;
    exports.TemplateLiteral = TemplateLiteral;
    exports._printTemplate = _printTemplate;
    function TaggedTemplateExpression(node) {
      this.print(node.tag), this.print(node.typeParameters), this.print(node.quasi);
    }
    function TemplateElement() {
      throw new Error("TemplateElement printing is handled in TemplateLiteral");
    }
    function _printTemplate(node, substitutions) {
      let quasis = node.quasis, partRaw = "`";
      for (let i = 0; i < quasis.length - 1; i++)
        if (partRaw += quasis[i].value.raw, this.token(partRaw + "${", !0), this.print(substitutions[i]), partRaw = "}", this.tokenMap) {
          let token = this.tokenMap.findMatching(node, "}", i);
          token && this._catchUpTo(token.loc.start);
        }
      partRaw += quasis[quasis.length - 1].value.raw, this.token(partRaw + "`", !0);
    }
    function TemplateLiteral(node) {
      this._printTemplate(node, node.expressions);
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions = __commonJS({
  "../node_modules/@babel/generator/lib/generators/expressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
    exports.AssignmentPattern = AssignmentPattern;
    exports.AwaitExpression = AwaitExpression;
    exports.BindExpression = BindExpression;
    exports.CallExpression = CallExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.Decorator = Decorator;
    exports.DoExpression = DoExpression;
    exports.EmptyStatement = EmptyStatement;
    exports.ExpressionStatement = ExpressionStatement;
    exports.Import = Import;
    exports.MemberExpression = MemberExpression;
    exports.MetaProperty = MetaProperty;
    exports.ModuleExpression = ModuleExpression;
    exports.NewExpression = NewExpression;
    exports.OptionalCallExpression = OptionalCallExpression;
    exports.OptionalMemberExpression = OptionalMemberExpression;
    exports.ParenthesizedExpression = ParenthesizedExpression;
    exports.PrivateName = PrivateName;
    exports.SequenceExpression = SequenceExpression;
    exports.Super = Super;
    exports.ThisExpression = ThisExpression;
    exports.UnaryExpression = UnaryExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    exports.YieldExpression = YieldExpression;
    exports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
    var _t = require_lib4(), _index = require_node(), {
      isCallExpression,
      isLiteral,
      isMemberExpression,
      isNewExpression,
      isPattern
    } = _t;
    function UnaryExpression(node) {
      let {
        operator
      } = node;
      operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw" ? (this.word(operator), this.space()) : this.token(operator), this.print(node.argument);
    }
    function DoExpression(node) {
      node.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(node.body);
    }
    function ParenthesizedExpression(node) {
      this.tokenChar(40);
      let exit = this.enterDelimited();
      this.print(node.expression), exit(), this.rightParens(node);
    }
    function UpdateExpression(node) {
      node.prefix ? (this.token(node.operator), this.print(node.argument)) : (this.print(node.argument, !0), this.token(node.operator));
    }
    function ConditionalExpression(node) {
      this.print(node.test), this.space(), this.tokenChar(63), this.space(), this.print(node.consequent), this.space(), this.tokenChar(58), this.space(), this.print(node.alternate);
    }
    function NewExpression(node, parent) {
      if (this.word("new"), this.space(), this.print(node.callee), this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
        callee: node
      }) && !isMemberExpression(parent) && !isNewExpression(parent) || (this.print(node.typeArguments), this.print(node.typeParameters), node.optional && this.token("?."), node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ")")))
        return;
      this.tokenChar(40);
      let exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")")), exit(), this.rightParens(node);
    }
    function SequenceExpression(node) {
      this.printList(node.expressions);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function _shouldPrintDecoratorsBeforeExport(node) {
      return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof node.start == "number" && node.start === node.declaration.start;
    }
    function Decorator(node) {
      this.tokenChar(64), this.print(node.expression), this.newline();
    }
    function OptionalMemberExpression(node) {
      let {
        computed
      } = node, {
        optional,
        property
      } = node;
      if (this.print(node.object), !computed && isMemberExpression(property))
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      isLiteral(property) && typeof property.value == "number" && (computed = !0), optional && this.token("?."), computed ? (this.tokenChar(91), this.print(property), this.tokenChar(93)) : (optional || this.tokenChar(46), this.print(property));
    }
    function OptionalCallExpression(node) {
      this.print(node.callee), this.print(node.typeParameters), node.optional && this.token("?."), this.print(node.typeArguments), this.tokenChar(40);
      let exit = this.enterDelimited();
      this.printList(node.arguments), exit(), this.rightParens(node);
    }
    function CallExpression(node) {
      this.print(node.callee), this.print(node.typeArguments), this.print(node.typeParameters), this.tokenChar(40);
      let exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")")), exit(), this.rightParens(node);
    }
    function Import() {
      this.word("import");
    }
    function AwaitExpression(node) {
      this.word("await"), this.space(), this.print(node.argument);
    }
    function YieldExpression(node) {
      node.delegate ? (this.word("yield", !0), this.tokenChar(42), node.argument && (this.space(), this.print(node.argument))) : node.argument ? (this.word("yield", !0), this.space(), this.print(node.argument)) : this.word("yield");
    }
    function EmptyStatement() {
      this.semicolon(!0);
    }
    function ExpressionStatement(node) {
      this.tokenContext |= _index.TokenContext.expressionStatement, this.print(node.expression), this.semicolon();
    }
    function AssignmentPattern(node) {
      this.print(node.left), (node.left.type === "Identifier" || isPattern(node.left)) && (node.left.optional && this.tokenChar(63), this.print(node.left.typeAnnotation)), this.space(), this.tokenChar(61), this.space(), this.print(node.right);
    }
    function AssignmentExpression(node) {
      this.print(node.left), this.space(), node.operator === "in" || node.operator === "instanceof" ? this.word(node.operator) : (this.token(node.operator), this._endsWithDiv = node.operator === "/"), this.space(), this.print(node.right);
    }
    function BindExpression(node) {
      this.print(node.object), this.token("::"), this.print(node.callee);
    }
    function MemberExpression(node) {
      if (this.print(node.object), !node.computed && isMemberExpression(node.property))
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      let computed = node.computed;
      if (isLiteral(node.property) && typeof node.property.value == "number" && (computed = !0), computed) {
        let exit = this.enterDelimited();
        this.tokenChar(91), this.print(node.property), this.tokenChar(93), exit();
      } else
        this.tokenChar(46), this.print(node.property);
    }
    function MetaProperty(node) {
      this.print(node.meta), this.tokenChar(46), this.print(node.property);
    }
    function PrivateName(node) {
      this.tokenChar(35), this.print(node.id);
    }
    function V8IntrinsicIdentifier(node) {
      this.tokenChar(37), this.word(node.name);
    }
    function ModuleExpression(node) {
      this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
      let {
        body
      } = node;
      (body.body.length || body.directives.length) && this.newline(), this.print(body), this.dedent(), this.rightBrace(node);
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var require_statements = __commonJS({
  "../node_modules/@babel/generator/lib/generators/statements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.BreakStatement = BreakStatement;
    exports.CatchClause = CatchClause;
    exports.ContinueStatement = ContinueStatement;
    exports.DebuggerStatement = DebuggerStatement;
    exports.DoWhileStatement = DoWhileStatement;
    exports.ForOfStatement = exports.ForInStatement = void 0;
    exports.ForStatement = ForStatement;
    exports.IfStatement = IfStatement;
    exports.LabeledStatement = LabeledStatement;
    exports.ReturnStatement = ReturnStatement;
    exports.SwitchCase = SwitchCase;
    exports.SwitchStatement = SwitchStatement;
    exports.ThrowStatement = ThrowStatement;
    exports.TryStatement = TryStatement;
    exports.VariableDeclaration = VariableDeclaration;
    exports.VariableDeclarator = VariableDeclarator;
    exports.WhileStatement = WhileStatement;
    exports.WithStatement = WithStatement;
    var _t = require_lib4(), {
      isFor,
      isForStatement,
      isIfStatement,
      isStatement
    } = _t;
    function WithStatement(node) {
      this.word("with"), this.space(), this.tokenChar(40), this.print(node.object), this.tokenChar(41), this.printBlock(node);
    }
    function IfStatement(node) {
      this.word("if"), this.space(), this.tokenChar(40), this.print(node.test), this.tokenChar(41), this.space();
      let needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
      needsBlock && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(node.consequent), needsBlock && (this.dedent(), this.newline(), this.tokenChar(125)), node.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(node.alternate));
    }
    function getLastStatement(statement) {
      let {
        body
      } = statement;
      return isStatement(body) === !1 ? statement : getLastStatement(body);
    }
    function ForStatement(node) {
      this.word("for"), this.space(), this.tokenChar(40);
      {
        let exit = this.enterForStatementInit();
        this.print(node.init), exit();
      }
      this.tokenChar(59), node.test && (this.space(), this.print(node.test)), this.token(";", !1, 1), node.update && (this.space(), this.print(node.update)), this.tokenChar(41), this.printBlock(node);
    }
    function WhileStatement(node) {
      this.word("while"), this.space(), this.tokenChar(40), this.print(node.test), this.tokenChar(41), this.printBlock(node);
    }
    function ForXStatement(node) {
      this.word("for"), this.space();
      let isForOf = node.type === "ForOfStatement";
      isForOf && node.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
      {
        let exit = this.enterForXStatementInit(isForOf);
        this.print(node.left), exit?.();
      }
      this.space(), this.word(isForOf ? "of" : "in"), this.space(), this.print(node.right), this.tokenChar(41), this.printBlock(node);
    }
    var ForInStatement = exports.ForInStatement = ForXStatement, ForOfStatement = exports.ForOfStatement = ForXStatement;
    function DoWhileStatement(node) {
      this.word("do"), this.space(), this.print(node.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(node.test), this.tokenChar(41), this.semicolon();
    }
    function printStatementAfterKeyword(printer, node) {
      node && (printer.space(), printer.printTerminatorless(node)), printer.semicolon();
    }
    function BreakStatement(node) {
      this.word("break"), printStatementAfterKeyword(this, node.label);
    }
    function ContinueStatement(node) {
      this.word("continue"), printStatementAfterKeyword(this, node.label);
    }
    function ReturnStatement(node) {
      this.word("return"), printStatementAfterKeyword(this, node.argument);
    }
    function ThrowStatement(node) {
      this.word("throw"), printStatementAfterKeyword(this, node.argument);
    }
    function LabeledStatement(node) {
      this.print(node.label), this.tokenChar(58), this.space(), this.print(node.body);
    }
    function TryStatement(node) {
      this.word("try"), this.space(), this.print(node.block), this.space(), node.handlers ? this.print(node.handlers[0]) : this.print(node.handler), node.finalizer && (this.space(), this.word("finally"), this.space(), this.print(node.finalizer));
    }
    function CatchClause(node) {
      this.word("catch"), this.space(), node.param && (this.tokenChar(40), this.print(node.param), this.print(node.param.typeAnnotation), this.tokenChar(41), this.space()), this.print(node.body);
    }
    function SwitchStatement(node) {
      this.word("switch"), this.space(), this.tokenChar(40), this.print(node.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(node.cases, !0), this.rightBrace(node);
    }
    function SwitchCase(node) {
      node.test ? (this.word("case"), this.space(), this.print(node.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), node.consequent.length && (this.newline(), this.printSequence(node.consequent, !0));
    }
    function DebuggerStatement() {
      this.word("debugger"), this.semicolon();
    }
    function VariableDeclaration(node, parent) {
      node.declare && (this.word("declare"), this.space());
      let {
        kind
      } = node;
      kind === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(kind, kind === "using"), this.space();
      let hasInits = !1;
      if (!isFor(parent))
        for (let declar of node.declarations)
          declar.init && (hasInits = !0);
      if (this.printList(node.declarations, void 0, void 0, node.declarations.length > 1, hasInits ? function(occurrenceCount) {
        this.token(",", !1, occurrenceCount), this.newline();
      } : void 0), isFor(parent)) {
        if (isForStatement(parent)) {
          if (parent.init === node) return;
        } else if (parent.left === node) return;
      }
      this.semicolon();
    }
    function VariableDeclarator(node) {
      this.print(node.id), node.definite && this.tokenChar(33), this.print(node.id.typeAnnotation), node.init && (this.space(), this.tokenChar(61), this.space(), this.print(node.init));
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var require_classes = __commonJS({
  "../node_modules/@babel/generator/lib/generators/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ClassAccessorProperty = ClassAccessorProperty;
    exports.ClassBody = ClassBody;
    exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
    exports.ClassMethod = ClassMethod;
    exports.ClassPrivateMethod = ClassPrivateMethod;
    exports.ClassPrivateProperty = ClassPrivateProperty;
    exports.ClassProperty = ClassProperty;
    exports.StaticBlock = StaticBlock;
    exports._classMethodHead = _classMethodHead;
    var _t = require_lib4(), {
      isExportDefaultDeclaration,
      isExportNamedDeclaration
    } = _t;
    function ClassDeclaration(node, parent) {
      (!(isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent)) || !this._shouldPrintDecoratorsBeforeExport(parent)) && this.printJoin(node.decorators), node.declare && (this.word("declare"), this.space()), node.abstract && (this.word("abstract"), this.space()), this.word("class"), node.id && (this.space(), this.print(node.id)), this.print(node.typeParameters), node.superClass && (this.space(), this.word("extends"), this.space(), this.print(node.superClass), this.print(node.superTypeParameters)), node.implements && (this.space(), this.word("implements"), this.space(), this.printList(node.implements)), this.space(), this.print(node.body);
    }
    function ClassBody(node) {
      if (this.tokenChar(123), node.body.length === 0)
        this.tokenChar(125);
      else {
        this.newline();
        let separator = classBodyEmptySemicolonsPrinter(this, node);
        separator?.(-1);
        let exit = this.enterDelimited();
        this.printJoin(node.body, !0, !0, separator, !0), exit(), this.endsWith(10) || this.newline(), this.rightBrace(node);
      }
    }
    function classBodyEmptySemicolonsPrinter(printer, node) {
      if (!printer.tokenMap || node.start == null || node.end == null)
        return null;
      let indexes = printer.tokenMap.getIndexes(node);
      if (!indexes) return null;
      let k = 1, occurrenceCount = 0, nextLocIndex = 0, advanceNextLocIndex = () => {
        for (; nextLocIndex < node.body.length && node.body[nextLocIndex].start == null; )
          nextLocIndex++;
      };
      return advanceNextLocIndex(), (i) => {
        nextLocIndex <= i && (nextLocIndex = i + 1, advanceNextLocIndex());
        let end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start, tok;
        for (; k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end; )
          printer.token(";", void 0, occurrenceCount++), k++;
      };
    }
    function ClassProperty(node) {
      if (this.printJoin(node.decorators), !node.static && !this.format.preserveFormat) {
        var _node$key$loc;
        let endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
        endLine && this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node), node.computed ? (this.tokenChar(91), this.print(node.key), this.tokenChar(93)) : (this._variance(node), this.print(node.key)), node.optional && this.tokenChar(63), node.definite && this.tokenChar(33), this.print(node.typeAnnotation), node.value && (this.space(), this.tokenChar(61), this.space(), this.print(node.value)), this.semicolon();
    }
    function ClassAccessorProperty(node) {
      var _node$key$loc2;
      this.printJoin(node.decorators);
      let endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
      endLine && this.catchUp(endLine), this.tsPrintClassMemberModifiers(node), this.word("accessor", !0), this.space(), node.computed ? (this.tokenChar(91), this.print(node.key), this.tokenChar(93)) : (this._variance(node), this.print(node.key)), node.optional && this.tokenChar(63), node.definite && this.tokenChar(33), this.print(node.typeAnnotation), node.value && (this.space(), this.tokenChar(61), this.space(), this.print(node.value)), this.semicolon();
    }
    function ClassPrivateProperty(node) {
      this.printJoin(node.decorators), this.tsPrintClassMemberModifiers(node), this.print(node.key), node.optional && this.tokenChar(63), node.definite && this.tokenChar(33), this.print(node.typeAnnotation), node.value && (this.space(), this.tokenChar(61), this.space(), this.print(node.value)), this.semicolon();
    }
    function ClassMethod(node) {
      this._classMethodHead(node), this.space(), this.print(node.body);
    }
    function ClassPrivateMethod(node) {
      this._classMethodHead(node), this.space(), this.print(node.body);
    }
    function _classMethodHead(node) {
      if (this.printJoin(node.decorators), !this.format.preserveFormat) {
        var _node$key$loc3;
        let endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
        endLine && this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node), this._methodHead(node);
    }
    function StaticBlock(node) {
      this.word("static"), this.space(), this.tokenChar(123), node.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(node.body, !0), this.rightBrace(node));
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var require_methods = __commonJS({
  "../node_modules/@babel/generator/lib/generators/methods.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ArrowFunctionExpression = ArrowFunctionExpression;
    exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
    exports._functionHead = _functionHead;
    exports._methodHead = _methodHead;
    exports._param = _param;
    exports._parameters = _parameters;
    exports._params = _params;
    exports._predicate = _predicate;
    exports._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
    var _t = require_lib4(), _index = require_node(), {
      isIdentifier
    } = _t;
    function _params(node, idNode, parentNode) {
      this.print(node.typeParameters);
      let nameInfo = _getFuncIdName.call(this, idNode, parentNode);
      nameInfo && this.sourceIdentifierName(nameInfo.name, nameInfo.pos), this.tokenChar(40), this._parameters(node.params, ")");
      let noLineTerminator = node.type === "ArrowFunctionExpression";
      this.print(node.returnType, noLineTerminator), this._noLineTerminator = noLineTerminator;
    }
    function _parameters(parameters, endToken) {
      let exit = this.enterDelimited(), trailingComma = this.shouldPrintTrailingComma(endToken), paramLength = parameters.length;
      for (let i = 0; i < paramLength; i++)
        this._param(parameters[i]), (trailingComma || i < paramLength - 1) && (this.token(",", void 0, i), this.space());
      this.token(endToken), exit();
    }
    function _param(parameter) {
      this.printJoin(parameter.decorators), this.print(parameter), parameter.optional && this.tokenChar(63), this.print(parameter.typeAnnotation);
    }
    function _methodHead(node) {
      let kind = node.kind, key = node.key;
      (kind === "get" || kind === "set") && (this.word(kind), this.space()), node.async && (this.word("async", !0), this.space()), (kind === "method" || kind === "init") && node.generator && this.tokenChar(42), node.computed ? (this.tokenChar(91), this.print(key), this.tokenChar(93)) : this.print(key), node.optional && this.tokenChar(63), this._params(node, node.computed && node.key.type !== "StringLiteral" ? void 0 : node.key);
    }
    function _predicate(node, noLineTerminatorAfter) {
      node.predicate && (node.returnType || this.tokenChar(58), this.space(), this.print(node.predicate, noLineTerminatorAfter));
    }
    function _functionHead(node, parent) {
      node.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), node.generator && (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), node.id && this.print(node.id), this._params(node, node.id, parent), node.type !== "TSDeclareFunction" && this._predicate(node);
    }
    function FunctionExpression(node, parent) {
      this._functionHead(node, parent), this.space(), this.print(node.body);
    }
    function ArrowFunctionExpression(node, parent) {
      node.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(node) ? this._params(node, void 0, parent) : this.print(node.params[0], !0), this._predicate(node, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= _index.TokenContext.arrowBody, this.print(node.body);
    }
    function _shouldPrintArrowParamsParens(node) {
      var _firstParam$leadingCo, _firstParam$trailingC;
      if (node.params.length !== 1 || node.typeParameters || node.returnType || node.predicate)
        return !0;
      let firstParam = node.params[0];
      if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length)
        return !0;
      if (this.tokenMap) {
        if (node.loc == null || this.tokenMap.findMatching(node, "(") !== null) return !0;
        let arrowToken = this.tokenMap.findMatching(node, "=>");
        return arrowToken?.loc == null ? !0 : arrowToken.loc.start.line !== node.loc.start.line;
      }
      return !!this.format.retainLines;
    }
    function _getFuncIdName(idNode, parent) {
      let id = idNode;
      if (!id && parent) {
        let parentType = parent.type;
        parentType === "VariableDeclarator" ? id = parent.id : parentType === "AssignmentExpression" || parentType === "AssignmentPattern" ? id = parent.left : parentType === "ObjectProperty" || parentType === "ClassProperty" ? (!parent.computed || parent.key.type === "StringLiteral") && (id = parent.key) : (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") && (id = parent.key);
      }
      if (!id) return;
      let nameInfo;
      if (id.type === "Identifier") {
        var _id$loc, _id$loc2;
        nameInfo = {
          pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
          name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
        };
      } else if (id.type === "PrivateName") {
        var _id$loc3;
        nameInfo = {
          pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
          name: "#" + id.id.name
        };
      } else if (id.type === "StringLiteral") {
        var _id$loc4;
        nameInfo = {
          pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
          name: id.value
        };
      }
      return nameInfo;
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var require_modules = __commonJS({
  "../node_modules/@babel/generator/lib/generators/modules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ExportAllDeclaration = ExportAllDeclaration;
    exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
    exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
    exports.ExportNamedDeclaration = ExportNamedDeclaration;
    exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    exports.ExportSpecifier = ExportSpecifier;
    exports.ImportAttribute = ImportAttribute;
    exports.ImportDeclaration = ImportDeclaration;
    exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
    exports.ImportExpression = ImportExpression;
    exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    exports.ImportSpecifier = ImportSpecifier;
    exports._printAttributes = _printAttributes;
    var _t = require_lib4(), _index = require_node(), {
      isClassDeclaration,
      isExportDefaultSpecifier,
      isExportNamespaceSpecifier,
      isImportDefaultSpecifier,
      isImportNamespaceSpecifier,
      isStatement
    } = _t;
    function ImportSpecifier(node) {
      (node.importKind === "type" || node.importKind === "typeof") && (this.word(node.importKind), this.space()), this.print(node.imported), node.local && node.local.name !== node.imported.name && (this.space(), this.word("as"), this.space(), this.print(node.local));
    }
    function ImportDefaultSpecifier(node) {
      this.print(node.local);
    }
    function ExportDefaultSpecifier(node) {
      this.print(node.exported);
    }
    function ExportSpecifier(node) {
      node.exportKind === "type" && (this.word("type"), this.space()), this.print(node.local), node.exported && node.local.name !== node.exported.name && (this.space(), this.word("as"), this.space(), this.print(node.exported));
    }
    function ExportNamespaceSpecifier(node) {
      this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(node.exported);
    }
    var warningShown = !1;
    function _printAttributes(node, hasPreviousBrace) {
      var _node$extra;
      let {
        importAttributesKeyword
      } = this.format, {
        attributes,
        assertions
      } = node;
      attributes && !importAttributesKeyword && node.extra && (node.extra.deprecatedAssertSyntax || node.extra.deprecatedWithLegacySyntax) && !warningShown && (warningShown = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
      let useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
      if (this.word(useAssertKeyword ? "assert" : "with"), this.space(), !useAssertKeyword && (importAttributesKeyword === "with-legacy" || !importAttributesKeyword && (_node$extra = node.extra) != null && _node$extra.deprecatedWithLegacySyntax)) {
        this.printList(attributes || assertions);
        return;
      }
      let occurrenceCount = hasPreviousBrace ? 1 : 0;
      this.token("{", void 0, occurrenceCount), this.space(), this.printList(attributes || assertions, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", void 0, occurrenceCount);
    }
    function ExportAllDeclaration(node) {
      var _node$attributes, _node$assertions;
      this.word("export"), this.space(), node.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length ? (this.print(node.source, !0), this.space(), this._printAttributes(node, !1)) : this.print(node.source), this.semicolon();
    }
    function maybePrintDecoratorsBeforeExport(printer, node) {
      isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node) && printer.printJoin(node.declaration.decorators);
    }
    function ExportNamedDeclaration(node) {
      if (maybePrintDecoratorsBeforeExport(this, node), this.word("export"), this.space(), node.declaration) {
        let declar = node.declaration;
        this.print(declar), isStatement(declar) || this.semicolon();
      } else {
        node.exportKind === "type" && (this.word("type"), this.space());
        let specifiers = node.specifiers.slice(0), hasSpecial = !1;
        for (; ; ) {
          let first = specifiers[0];
          if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first))
            hasSpecial = !0, this.print(specifiers.shift()), specifiers.length && (this.tokenChar(44), this.space());
          else
            break;
        }
        let hasBrace = !1;
        if ((specifiers.length || !specifiers.length && !hasSpecial) && (hasBrace = !0, this.tokenChar(123), specifiers.length && (this.space(), this.printList(specifiers, this.shouldPrintTrailingComma("}")), this.space()), this.tokenChar(125)), node.source) {
          var _node$attributes2, _node$assertions2;
          this.space(), this.word("from"), this.space(), (_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length ? (this.print(node.source, !0), this.space(), this._printAttributes(node, hasBrace)) : this.print(node.source);
        }
        this.semicolon();
      }
    }
    function ExportDefaultDeclaration(node) {
      maybePrintDecoratorsBeforeExport(this, node), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |= _index.TokenContext.exportDefault;
      let declar = node.declaration;
      this.print(declar), isStatement(declar) || this.semicolon();
    }
    function ImportDeclaration(node) {
      var _node$attributes3, _node$assertions3;
      this.word("import"), this.space();
      let isTypeKind = node.importKind === "type" || node.importKind === "typeof";
      isTypeKind ? (this.noIndentInnerCommentsHere(), this.word(node.importKind), this.space()) : node.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : node.phase && (this.noIndentInnerCommentsHere(), this.word(node.phase), this.space());
      let specifiers = node.specifiers.slice(0), hasSpecifiers = !!specifiers.length;
      for (; hasSpecifiers; ) {
        let first = specifiers[0];
        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first))
          this.print(specifiers.shift()), specifiers.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let hasBrace = !1;
      specifiers.length ? (hasBrace = !0, this.tokenChar(123), this.space(), this.printList(specifiers, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(125)) : isTypeKind && !hasSpecifiers && (hasBrace = !0, this.tokenChar(123), this.tokenChar(125)), (hasSpecifiers || isTypeKind) && (this.space(), this.word("from"), this.space()), (_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length ? (this.print(node.source, !0), this.space(), this._printAttributes(node, hasBrace)) : this.print(node.source), this.semicolon();
    }
    function ImportAttribute(node) {
      this.print(node.key), this.tokenChar(58), this.space(), this.print(node.value);
    }
    function ImportNamespaceSpecifier(node) {
      this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(node.local);
    }
    function ImportExpression(node) {
      this.word("import"), node.phase && (this.tokenChar(46), this.word(node.phase)), this.tokenChar(40);
      let shouldPrintTrailingComma = this.shouldPrintTrailingComma(")");
      this.print(node.source), node.options != null && (this.tokenChar(44), this.space(), this.print(node.options)), shouldPrintTrailingComma && this.tokenChar(44), this.rightParens(node);
    }
  }
});

// ../node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "../node_modules/jsesc/jsesc.js"(exports, module) {
    "use strict";
    var object = {}, hasOwnProperty2 = object.hasOwnProperty, forOwn = (object2, callback) => {
      for (let key in object2)
        hasOwnProperty2.call(object2, key) && callback(key, object2[key]);
    }, extend = (destination, source) => (source && forOwn(source, (key, value2) => {
      destination[key] = value2;
    }), destination), forEach = (array, callback) => {
      let length = array.length, index = -1;
      for (; ++index < length; )
        callback(array[index]);
    }, fourHexEscape = (hex) => "\\u" + ("0000" + hex).slice(-4), hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      return lowercase ? hexadecimal2 : hexadecimal2.toUpperCase();
    }, toString = object.toString, isArray = Array.isArray, isBuffer = (value2) => typeof Buffer == "function" && Buffer.isBuffer(value2), isObject = (value2) => toString.call(value2) == "[object Object]", isString = (value2) => typeof value2 == "string" || toString.call(value2) == "[object String]", isNumber = (value2) => typeof value2 == "number" || toString.call(value2) == "[object Number]", isBigInt = (value2) => typeof value2 == "bigint", isFunction = (value2) => typeof value2 == "function", isMap = (value2) => toString.call(value2) == "[object Map]", isSet = (value2) => toString.call(value2) == "[object Set]", singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
      // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
      // '\v': '\\x0B'
    }, regexSingleEscape = /[\\\b\f\n\r\t]/, regexDigit = /[0-9]/, regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g, escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, jsesc = (argument, options) => {
      let increaseIndentation = () => {
        oldIndent = indent, ++options.indentLevel, indent = options.indent.repeat(options.indentLevel);
      }, defaults = {
        escapeEverything: !1,
        minimal: !1,
        isScriptContext: !1,
        quotes: "single",
        wrap: !1,
        es6: !1,
        json: !1,
        compact: !0,
        lowercaseHex: !1,
        numbers: "decimal",
        indent: "	",
        indentLevel: 0,
        __inline1__: !1,
        __inline2__: !1
      }, json = options && options.json;
      json && (defaults.quotes = "double", defaults.wrap = !0), options = extend(defaults, options), options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick" && (options.quotes = "single");
      let quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'", compact = options.compact, lowercaseHex = options.lowercaseHex, indent = options.indent.repeat(options.indentLevel), oldIndent = "", inline1 = options.__inline1__, inline2 = options.__inline2__, newLine = compact ? "" : `
`, result, isEmpty = !0, useBinNumbers = options.numbers == "binary", useOctNumbers = options.numbers == "octal", useDecNumbers = options.numbers == "decimal", useHexNumbers = options.numbers == "hexadecimal";
      if (json && argument && isFunction(argument.toJSON) && (argument = argument.toJSON()), !isString(argument)) {
        if (isMap(argument))
          return argument.size == 0 ? "new Map()" : (compact || (options.__inline1__ = !0, options.__inline2__ = !1), "new Map(" + jsesc(Array.from(argument), options) + ")");
        if (isSet(argument))
          return argument.size == 0 ? "new Set()" : "new Set(" + jsesc(Array.from(argument), options) + ")";
        if (isBuffer(argument))
          return argument.length == 0 ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
        if (isArray(argument))
          return result = [], options.wrap = !0, inline1 && (options.__inline1__ = !1, options.__inline2__ = !0), inline2 || increaseIndentation(), forEach(argument, (value2) => {
            isEmpty = !1, inline2 && (options.__inline2__ = !1), result.push(
              (compact || inline2 ? "" : indent) + jsesc(value2, options)
            );
          }), isEmpty ? "[]" : inline2 ? "[" + result.join(", ") + "]" : "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        if (isNumber(argument) || isBigInt(argument)) {
          if (json)
            return JSON.stringify(Number(argument));
          let result2;
          if (useDecNumbers)
            result2 = String(argument);
          else if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            lowercaseHex || (hexadecimal2 = hexadecimal2.toUpperCase()), result2 = "0x" + hexadecimal2;
          } else useBinNumbers ? result2 = "0b" + argument.toString(2) : useOctNumbers && (result2 = "0o" + argument.toString(8));
          return isBigInt(argument) ? result2 + "n" : result2;
        } else return isBigInt(argument) ? json ? JSON.stringify(Number(argument)) : argument + "n" : isObject(argument) ? (result = [], options.wrap = !0, increaseIndentation(), forOwn(argument, (key, value2) => {
          isEmpty = !1, result.push(
            (compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value2, options)
          );
        }), isEmpty ? "{}" : "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}") : json ? JSON.stringify(argument) || "null" : String(argument);
      }
      let regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      return result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options.minimal) return pair;
          let first = pair.charCodeAt(0), second = pair.charCodeAt(1);
          if (options.es6) {
            let codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            return "\\u{" + hexadecimal(codePoint, lowercaseHex) + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone)
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        if (char == "\0" && !json && !regexDigit.test(string.charAt(index + 1)))
          return "\\0";
        if (quoteChar)
          return quoteChar == quote || options.escapeEverything ? "\\" + quoteChar : quoteChar;
        if (regexSingleEscape.test(char))
          return singleEscapes[char];
        if (options.minimal && !regexWhitespace.test(char))
          return char;
        let hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        return json || hex.length > 2 ? fourHexEscape(hex) : "\\x" + ("00" + hex).slice(-2);
      }), quote == "`" && (result = result.replace(/\$\{/g, "\\${")), options.isScriptContext && (result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--")), options.wrap && (result = quote + result + quote), result;
    };
    jsesc.version = "3.0.2";
    module.exports = jsesc;
  }
});

// ../node_modules/@babel/generator/lib/generators/types.js
var require_types = __commonJS({
  "../node_modules/@babel/generator/lib/generators/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ArgumentPlaceholder = ArgumentPlaceholder;
    exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
    exports.BigIntLiteral = BigIntLiteral;
    exports.BooleanLiteral = BooleanLiteral;
    exports.Identifier = Identifier;
    exports.NullLiteral = NullLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
    exports.ObjectMethod = ObjectMethod;
    exports.ObjectProperty = ObjectProperty;
    exports.PipelineBareFunction = PipelineBareFunction;
    exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
    exports.PipelineTopicExpression = PipelineTopicExpression;
    exports.RecordExpression = RecordExpression;
    exports.RegExpLiteral = RegExpLiteral;
    exports.SpreadElement = exports.RestElement = RestElement;
    exports.StringLiteral = StringLiteral;
    exports.TopicReference = TopicReference;
    exports.TupleExpression = TupleExpression;
    exports.VoidPattern = VoidPattern;
    exports._getRawIdentifier = _getRawIdentifier;
    var _t = require_lib4(), _jsesc = require_jsesc(), {
      isAssignmentPattern,
      isIdentifier
    } = _t, lastRawIdentNode = null, lastRawIdentResult = "";
    function _getRawIdentifier(node) {
      if (node === lastRawIdentNode) return lastRawIdentResult;
      lastRawIdentNode = node;
      let {
        name
      } = node, token = this.tokenMap.find(node, (tok) => tok.value === name);
      return token ? (lastRawIdentResult = this._originalCode.slice(token.start, token.end), lastRawIdentResult) : lastRawIdentResult = node.name;
    }
    function Identifier(node) {
      var _node$loc;
      this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name), this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
    }
    function ArgumentPlaceholder() {
      this.tokenChar(63);
    }
    function RestElement(node) {
      this.token("..."), this.print(node.argument);
    }
    function ObjectExpression(node) {
      let props = node.properties;
      if (this.tokenChar(123), props.length) {
        let exit = this.enterDelimited();
        this.space(), this.printList(props, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), exit();
      }
      this.sourceWithOffset("end", node.loc, -1), this.tokenChar(125);
    }
    function ObjectMethod(node) {
      this.printJoin(node.decorators), this._methodHead(node), this.space(), this.print(node.body);
    }
    function ObjectProperty(node) {
      if (this.printJoin(node.decorators), node.computed)
        this.tokenChar(91), this.print(node.key), this.tokenChar(93);
      else {
        if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
          this.print(node.value);
          return;
        }
        if (this.print(node.key), node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name)
          return;
      }
      this.tokenChar(58), this.space(), this.print(node.value);
    }
    function ArrayExpression(node) {
      let elems = node.elements, len = elems.length;
      this.tokenChar(91);
      let exit = this.enterDelimited();
      for (let i = 0; i < elems.length; i++) {
        let elem = elems[i];
        elem ? (i > 0 && this.space(), this.print(elem), (i < len - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, i)) : this.token(",", !1, i);
      }
      exit(), this.tokenChar(93);
    }
    function RecordExpression(node) {
      let props = node.properties, startToken, endToken;
      if (this.format.recordAndTupleSyntaxType === "bar")
        startToken = "{|", endToken = "|}";
      else {
        if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
          throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
        startToken = "#{", endToken = "}";
      }
      this.token(startToken), props.length && (this.space(), this.printList(props, this.shouldPrintTrailingComma(endToken), !0, !0), this.space()), this.token(endToken);
    }
    function TupleExpression(node) {
      let elems = node.elements, len = elems.length, startToken, endToken;
      if (this.format.recordAndTupleSyntaxType === "bar")
        startToken = "[|", endToken = "|]";
      else if (this.format.recordAndTupleSyntaxType === "hash")
        startToken = "#[", endToken = "]";
      else
        throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
      this.token(startToken);
      for (let i = 0; i < elems.length; i++) {
        let elem = elems[i];
        elem && (i > 0 && this.space(), this.print(elem), (i < len - 1 || this.shouldPrintTrailingComma(endToken)) && this.token(",", !1, i));
      }
      this.token(endToken);
    }
    function RegExpLiteral(node) {
      this.word(`/${node.pattern}/${node.flags}`);
    }
    function BooleanLiteral(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral(node) {
      let raw = this.getPossibleRaw(node), opts = this.format.jsescOption, value2 = node.value, str = value2 + "";
      opts.numbers ? this.number(_jsesc(value2, opts), value2) : raw == null ? this.number(str, value2) : this.format.minified ? this.number(raw.length < str.length ? raw : str, value2) : this.number(raw, value2);
    }
    function StringLiteral(node) {
      let raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      let val = _jsesc(node.value, this.format.jsescOption);
      this.token(val);
    }
    function BigIntLiteral(node) {
      let raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node.value + "n");
    }
    var validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
    function TopicReference() {
      let {
        topicToken
      } = this.format;
      if (validTopicTokenSet.has(topicToken))
        this.token(topicToken);
      else {
        let givenTopicTokenJSON = JSON.stringify(topicToken), validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
        throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
      }
    }
    function PipelineTopicExpression(node) {
      this.print(node.expression);
    }
    function PipelineBareFunction(node) {
      this.print(node.callee);
    }
    function PipelinePrimaryTopicReference() {
      this.tokenChar(35);
    }
    function VoidPattern() {
      this.word("void");
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var require_flow2 = __commonJS({
  "../node_modules/@babel/generator/lib/generators/flow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.AnyTypeAnnotation = AnyTypeAnnotation;
    exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports.DeclareClass = DeclareClass;
    exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports.DeclareExportDeclaration = DeclareExportDeclaration;
    exports.DeclareFunction = DeclareFunction;
    exports.DeclareInterface = DeclareInterface;
    exports.DeclareModule = DeclareModule;
    exports.DeclareModuleExports = DeclareModuleExports;
    exports.DeclareOpaqueType = DeclareOpaqueType;
    exports.DeclareTypeAlias = DeclareTypeAlias;
    exports.DeclareVariable = DeclareVariable;
    exports.DeclaredPredicate = DeclaredPredicate;
    exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports.EnumBooleanBody = EnumBooleanBody;
    exports.EnumBooleanMember = EnumBooleanMember;
    exports.EnumDeclaration = EnumDeclaration;
    exports.EnumDefaultedMember = EnumDefaultedMember;
    exports.EnumNumberBody = EnumNumberBody;
    exports.EnumNumberMember = EnumNumberMember;
    exports.EnumStringBody = EnumStringBody;
    exports.EnumStringMember = EnumStringMember;
    exports.EnumSymbolBody = EnumSymbolBody;
    exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports.FunctionTypeParam = FunctionTypeParam;
    exports.IndexedAccessType = IndexedAccessType;
    exports.InferredPredicate = InferredPredicate;
    exports.InterfaceDeclaration = InterfaceDeclaration;
    exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
    exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports.MixedTypeAnnotation = MixedTypeAnnotation;
    exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    exports.NumberTypeAnnotation = NumberTypeAnnotation;
    exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports.ObjectTypeIndexer = ObjectTypeIndexer;
    exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports.ObjectTypeProperty = ObjectTypeProperty;
    exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports.OpaqueType = OpaqueType;
    exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    exports.StringTypeAnnotation = StringTypeAnnotation;
    exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports.ThisTypeAnnotation = ThisTypeAnnotation;
    exports.TupleTypeAnnotation = TupleTypeAnnotation;
    exports.TypeAlias = TypeAlias;
    exports.TypeAnnotation = TypeAnnotation;
    exports.TypeCastExpression = TypeCastExpression;
    exports.TypeParameter = TypeParameter;
    exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
    exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports.UnionTypeAnnotation = UnionTypeAnnotation;
    exports.Variance = Variance;
    exports.VoidTypeAnnotation = VoidTypeAnnotation;
    exports._interfaceish = _interfaceish;
    exports._variance = _variance;
    var _t = require_lib4(), _modules = require_modules(), _index = require_node(), _types2 = require_types(), {
      isDeclareExportDeclaration,
      isStatement
    } = _t;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node) {
      this.print(node.elementType, !0), this.tokenChar(91), this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node, parent) {
      isDeclareExportDeclaration(parent) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(node);
    }
    function DeclareFunction(node, parent) {
      isDeclareExportDeclaration(parent) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(node.id), this.print(node.id.typeAnnotation.typeAnnotation), node.predicate && (this.space(), this.print(node.predicate)), this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37), this.word("checks");
    }
    function DeclaredPredicate(node) {
      this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(node.value), this.tokenChar(41);
    }
    function DeclareInterface(node) {
      this.word("declare"), this.space(), this.InterfaceDeclaration(node);
    }
    function DeclareModule(node) {
      this.word("declare"), this.space(), this.word("module"), this.space(), this.print(node.id), this.space(), this.print(node.body);
    }
    function DeclareModuleExports(node) {
      this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(node.typeAnnotation);
    }
    function DeclareTypeAlias(node) {
      this.word("declare"), this.space(), this.TypeAlias(node);
    }
    function DeclareOpaqueType(node, parent) {
      isDeclareExportDeclaration(parent) || (this.word("declare"), this.space()), this.OpaqueType(node);
    }
    function DeclareVariable(node, parent) {
      isDeclareExportDeclaration(parent) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(node.id), this.print(node.id.typeAnnotation), this.semicolon();
    }
    function DeclareExportDeclaration(node) {
      this.word("declare"), this.space(), this.word("export"), this.space(), node.default && (this.word("default"), this.space()), FlowExportDeclaration.call(this, node);
    }
    function DeclareExportAllDeclaration(node) {
      this.word("declare"), this.space(), _modules.ExportAllDeclaration.call(this, node);
    }
    function EnumDeclaration(node) {
      let {
        id,
        body
      } = node;
      this.word("enum"), this.space(), this.print(id), this.print(body);
    }
    function enumExplicitType(context, name, hasExplicitType) {
      hasExplicitType && (context.space(), context.word("of"), context.space(), context.word(name)), context.space();
    }
    function enumBody(context, node) {
      let {
        members
      } = node;
      context.token("{"), context.indent(), context.newline();
      for (let member of members)
        context.print(member), context.newline();
      node.hasUnknownMembers && (context.token("..."), context.newline()), context.dedent(), context.token("}");
    }
    function EnumBooleanBody(node) {
      let {
        explicitType
      } = node;
      enumExplicitType(this, "boolean", explicitType), enumBody(this, node);
    }
    function EnumNumberBody(node) {
      let {
        explicitType
      } = node;
      enumExplicitType(this, "number", explicitType), enumBody(this, node);
    }
    function EnumStringBody(node) {
      let {
        explicitType
      } = node;
      enumExplicitType(this, "string", explicitType), enumBody(this, node);
    }
    function EnumSymbolBody(node) {
      enumExplicitType(this, "symbol", !0), enumBody(this, node);
    }
    function EnumDefaultedMember(node) {
      let {
        id
      } = node;
      this.print(id), this.tokenChar(44);
    }
    function enumInitializedMember(context, node) {
      context.print(node.id), context.space(), context.token("="), context.space(), context.print(node.init), context.token(",");
    }
    function EnumBooleanMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumNumberMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumStringMember(node) {
      enumInitializedMember(this, node);
    }
    function FlowExportDeclaration(node) {
      if (node.declaration) {
        let declar = node.declaration;
        this.print(declar), isStatement(declar) || this.semicolon();
      } else
        this.tokenChar(123), node.specifiers.length && (this.space(), this.printList(node.specifiers), this.space()), this.tokenChar(125), node.source && (this.space(), this.word("from"), this.space(), this.print(node.source)), this.semicolon();
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node, parent) {
      this.print(node.typeParameters), this.tokenChar(40), node.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(node.this.typeAnnotation), (node.params.length || node.rest) && (this.tokenChar(44), this.space())), this.printList(node.params), node.rest && (node.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(node.rest)), this.tokenChar(41);
      let type = parent?.type;
      type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(node.returnType);
    }
    function FunctionTypeParam(node) {
      this.print(node.name), node.optional && this.tokenChar(63), node.name && (this.tokenChar(58), this.space()), this.print(node.typeAnnotation);
    }
    function InterfaceExtends(node) {
      this.print(node.id), this.print(node.typeParameters, !0);
    }
    function _interfaceish(node) {
      var _node$extends;
      if (this.print(node.id), this.print(node.typeParameters), (_node$extends = node.extends) != null && _node$extends.length && (this.space(), this.word("extends"), this.space(), this.printList(node.extends)), node.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        (_node$mixins = node.mixins) != null && _node$mixins.length && (this.space(), this.word("mixins"), this.space(), this.printList(node.mixins)), (_node$implements = node.implements) != null && _node$implements.length && (this.space(), this.word("implements"), this.space(), this.printList(node.implements));
      }
      this.space(), this.print(node.body);
    }
    function _variance(node) {
      var _node$variance;
      let kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;
      kind != null && (kind === "plus" ? this.tokenChar(43) : kind === "minus" && this.tokenChar(45));
    }
    function InterfaceDeclaration(node) {
      this.word("interface"), this.space(), this._interfaceish(node);
    }
    function andSeparator(occurrenceCount) {
      this.space(), this.token("&", !1, occurrenceCount), this.space();
    }
    function InterfaceTypeAnnotation(node) {
      var _node$extends2;
      this.word("interface"), (_node$extends2 = node.extends) != null && _node$extends2.length && (this.space(), this.word("extends"), this.space(), this.printList(node.extends)), this.space(), this.print(node.body);
    }
    function IntersectionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, andSeparator);
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node) {
      this.tokenChar(63), this.print(node.typeAnnotation);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node) {
      this.tokenChar(91), this.printList(node.types), this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node) {
      this.word("typeof"), this.space(), this.print(node.argument);
    }
    function TypeAlias(node) {
      this.word("type"), this.space(), this.print(node.id), this.print(node.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(node.right), this.semicolon();
    }
    function TypeAnnotation(node, parent) {
      this.tokenChar(58), this.space(), parent.type === "ArrowFunctionExpression" ? this.tokenContext |= _index.TokenContext.arrowFlowReturnType : node.optional && this.tokenChar(63), this.print(node.typeAnnotation);
    }
    function TypeParameterInstantiation(node) {
      this.tokenChar(60), this.printList(node.params), this.tokenChar(62);
    }
    function TypeParameter(node) {
      this._variance(node), this.word(node.name), node.bound && this.print(node.bound), node.default && (this.space(), this.tokenChar(61), this.space(), this.print(node.default));
    }
    function OpaqueType(node) {
      this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(node.id), this.print(node.typeParameters), node.supertype && (this.tokenChar(58), this.space(), this.print(node.supertype)), node.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(node.impltype)), this.semicolon();
    }
    function ObjectTypeAnnotation(node) {
      node.exact ? this.token("{|") : this.tokenChar(123);
      let props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
      props.length && (this.newline(), this.space(), this.printJoin(props, !0, !0, void 0, void 0, () => {
        (props.length !== 1 || node.inexact) && (this.tokenChar(44), this.space());
      }), this.space()), node.inexact && (this.indent(), this.token("..."), props.length && this.newline(), this.dedent()), node.exact ? this.token("|}") : this.tokenChar(125);
    }
    function ObjectTypeInternalSlot(node) {
      node.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(node.id), this.tokenChar(93), this.tokenChar(93), node.optional && this.tokenChar(63), node.method || (this.tokenChar(58), this.space()), this.print(node.value);
    }
    function ObjectTypeCallProperty(node) {
      node.static && (this.word("static"), this.space()), this.print(node.value);
    }
    function ObjectTypeIndexer(node) {
      node.static && (this.word("static"), this.space()), this._variance(node), this.tokenChar(91), node.id && (this.print(node.id), this.tokenChar(58), this.space()), this.print(node.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(node.value);
    }
    function ObjectTypeProperty(node) {
      node.proto && (this.word("proto"), this.space()), node.static && (this.word("static"), this.space()), (node.kind === "get" || node.kind === "set") && (this.word(node.kind), this.space()), this._variance(node), this.print(node.key), node.optional && this.tokenChar(63), node.method || (this.tokenChar(58), this.space()), this.print(node.value);
    }
    function ObjectTypeSpreadProperty(node) {
      this.token("..."), this.print(node.argument);
    }
    function QualifiedTypeIdentifier(node) {
      this.print(node.qualification), this.tokenChar(46), this.print(node.id);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator(occurrenceCount) {
      this.space(), this.token("|", !1, occurrenceCount), this.space();
    }
    function UnionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, orSeparator);
    }
    function TypeCastExpression(node) {
      this.tokenChar(40), this.print(node.expression), this.print(node.typeAnnotation), this.tokenChar(41);
    }
    function Variance(node) {
      node.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node) {
      this.print(node.objectType, !0), this.tokenChar(91), this.print(node.indexType), this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node) {
      this.print(node.objectType), node.optional && this.token("?."), this.tokenChar(91), this.print(node.indexType), this.tokenChar(93);
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/base.js
var require_base = __commonJS({
  "../node_modules/@babel/generator/lib/generators/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.BlockStatement = BlockStatement;
    exports.Directive = Directive;
    exports.DirectiveLiteral = DirectiveLiteral;
    exports.File = File2;
    exports.InterpreterDirective = InterpreterDirective;
    exports.Placeholder = Placeholder;
    exports.Program = Program;
    function File2(node) {
      node.program && this.print(node.program.interpreter), this.print(node.program);
    }
    function Program(node) {
      var _node$directives;
      this.noIndentInnerCommentsHere(), this.printInnerComments();
      let directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
      if (directivesLen) {
        var _node$directives$trai;
        let newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, void 0, newline), (_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length || this.newline(newline);
      }
      this.printSequence(node.body);
    }
    function BlockStatement(node) {
      var _node$directives2;
      this.tokenChar(123);
      let exit = this.enterDelimited(), directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
      if (directivesLen) {
        var _node$directives$trai2;
        let newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, !0, newline), (_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length || this.newline(newline);
      }
      this.printSequence(node.body, !0), exit(), this.rightBrace(node);
    }
    function Directive(node) {
      this.print(node.value), this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/, unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral(node) {
      let raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      let {
        value: value2
      } = node;
      if (!unescapedDoubleQuoteRE.test(value2))
        this.token(`"${value2}"`);
      else if (!unescapedSingleQuoteRE.test(value2))
        this.token(`'${value2}'`);
      else
        throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
    }
    function InterpreterDirective(node) {
      this.token(`#!${node.value}`), this.newline(1, !0);
    }
    function Placeholder(node) {
      this.token("%%"), this.print(node.name), this.token("%%"), node.expectedNode === "Statement" && this.semicolon();
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx2 = __commonJS({
  "../node_modules/@babel/generator/lib/generators/jsx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.JSXAttribute = JSXAttribute;
    exports.JSXClosingElement = JSXClosingElement;
    exports.JSXClosingFragment = JSXClosingFragment;
    exports.JSXElement = JSXElement;
    exports.JSXEmptyExpression = JSXEmptyExpression;
    exports.JSXExpressionContainer = JSXExpressionContainer;
    exports.JSXFragment = JSXFragment;
    exports.JSXIdentifier = JSXIdentifier;
    exports.JSXMemberExpression = JSXMemberExpression;
    exports.JSXNamespacedName = JSXNamespacedName;
    exports.JSXOpeningElement = JSXOpeningElement;
    exports.JSXOpeningFragment = JSXOpeningFragment;
    exports.JSXSpreadAttribute = JSXSpreadAttribute;
    exports.JSXSpreadChild = JSXSpreadChild;
    exports.JSXText = JSXText;
    function JSXAttribute(node) {
      this.print(node.name), node.value && (this.tokenChar(61), this.print(node.value));
    }
    function JSXIdentifier(node) {
      this.word(node.name);
    }
    function JSXNamespacedName(node) {
      this.print(node.namespace), this.tokenChar(58), this.print(node.name);
    }
    function JSXMemberExpression(node) {
      this.print(node.object), this.tokenChar(46), this.print(node.property);
    }
    function JSXSpreadAttribute(node) {
      this.tokenChar(123), this.token("..."), this.print(node.argument), this.rightBrace(node);
    }
    function JSXExpressionContainer(node) {
      this.tokenChar(123), this.print(node.expression), this.rightBrace(node);
    }
    function JSXSpreadChild(node) {
      this.tokenChar(123), this.token("..."), this.print(node.expression), this.rightBrace(node);
    }
    function JSXText(node) {
      let raw = this.getPossibleRaw(node);
      raw !== void 0 ? this.token(raw, !0) : this.token(node.value, !0);
    }
    function JSXElement(node) {
      let open = node.openingElement;
      if (this.print(open), !open.selfClosing) {
        this.indent();
        for (let child of node.children)
          this.print(child);
        this.dedent(), this.print(node.closingElement);
      }
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node) {
      this.tokenChar(60), this.print(node.name), node.typeArguments && this.print(node.typeArguments), this.print(node.typeParameters), node.attributes.length > 0 && (this.space(), this.printJoin(node.attributes, void 0, void 0, spaceSeparator)), node.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(62);
    }
    function JSXClosingElement(node) {
      this.tokenChar(60), this.tokenChar(47), this.print(node.name), this.tokenChar(62);
    }
    function JSXEmptyExpression() {
      this.printInnerComments();
    }
    function JSXFragment(node) {
      this.print(node.openingFragment), this.indent();
      for (let child of node.children)
        this.print(child);
      this.dedent(), this.print(node.closingFragment);
    }
    function JSXOpeningFragment() {
      this.tokenChar(60), this.tokenChar(62);
    }
    function JSXClosingFragment() {
      this.token("</"), this.tokenChar(62);
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript2 = __commonJS({
  "../node_modules/@babel/generator/lib/generators/typescript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.TSAnyKeyword = TSAnyKeyword;
    exports.TSArrayType = TSArrayType;
    exports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;
    exports.TSBigIntKeyword = TSBigIntKeyword;
    exports.TSBooleanKeyword = TSBooleanKeyword;
    exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    exports.TSInterfaceHeritage = exports.TSClassImplements = TSClassImplements;
    exports.TSConditionalType = TSConditionalType;
    exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    exports.TSConstructorType = TSConstructorType;
    exports.TSDeclareFunction = TSDeclareFunction;
    exports.TSDeclareMethod = TSDeclareMethod;
    exports.TSEnumBody = TSEnumBody;
    exports.TSEnumDeclaration = TSEnumDeclaration;
    exports.TSEnumMember = TSEnumMember;
    exports.TSExportAssignment = TSExportAssignment;
    exports.TSExternalModuleReference = TSExternalModuleReference;
    exports.TSFunctionType = TSFunctionType;
    exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    exports.TSImportType = TSImportType;
    exports.TSIndexSignature = TSIndexSignature;
    exports.TSIndexedAccessType = TSIndexedAccessType;
    exports.TSInferType = TSInferType;
    exports.TSInstantiationExpression = TSInstantiationExpression;
    exports.TSInterfaceBody = TSInterfaceBody;
    exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
    exports.TSIntersectionType = TSIntersectionType;
    exports.TSIntrinsicKeyword = TSIntrinsicKeyword;
    exports.TSLiteralType = TSLiteralType;
    exports.TSMappedType = TSMappedType;
    exports.TSMethodSignature = TSMethodSignature;
    exports.TSModuleBlock = TSModuleBlock;
    exports.TSModuleDeclaration = TSModuleDeclaration;
    exports.TSNamedTupleMember = TSNamedTupleMember;
    exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    exports.TSNeverKeyword = TSNeverKeyword;
    exports.TSNonNullExpression = TSNonNullExpression;
    exports.TSNullKeyword = TSNullKeyword;
    exports.TSNumberKeyword = TSNumberKeyword;
    exports.TSObjectKeyword = TSObjectKeyword;
    exports.TSOptionalType = TSOptionalType;
    exports.TSParameterProperty = TSParameterProperty;
    exports.TSParenthesizedType = TSParenthesizedType;
    exports.TSPropertySignature = TSPropertySignature;
    exports.TSQualifiedName = TSQualifiedName;
    exports.TSRestType = TSRestType;
    exports.TSStringKeyword = TSStringKeyword;
    exports.TSSymbolKeyword = TSSymbolKeyword;
    exports.TSTemplateLiteralType = TSTemplateLiteralType;
    exports.TSThisType = TSThisType;
    exports.TSTupleType = TSTupleType;
    exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    exports.TSTypeAnnotation = TSTypeAnnotation;
    exports.TSTypeAssertion = TSTypeAssertion;
    exports.TSTypeLiteral = TSTypeLiteral;
    exports.TSTypeOperator = TSTypeOperator;
    exports.TSTypeParameter = TSTypeParameter;
    exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    exports.TSTypePredicate = TSTypePredicate;
    exports.TSTypeQuery = TSTypeQuery;
    exports.TSTypeReference = TSTypeReference;
    exports.TSUndefinedKeyword = TSUndefinedKeyword;
    exports.TSUnionType = TSUnionType;
    exports.TSUnknownKeyword = TSUnknownKeyword;
    exports.TSVoidKeyword = TSVoidKeyword;
    exports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
    exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    function TSTypeAnnotation(node, parent) {
      this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node ? "=>" : ":"), this.space(), node.optional && this.tokenChar(63), this.print(node.typeAnnotation);
    }
    function TSTypeParameterInstantiation(node, parent) {
      this.tokenChar(60);
      let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node.params.length === 1;
      this.tokenMap && node.start != null && node.end != null && (printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, (t) => this.tokenMap.matchesOriginal(t, ","))), printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"))), this.printList(node.params, printTrailingSeparator), this.tokenChar(62);
    }
    function TSTypeParameter(node) {
      node.const && (this.word("const"), this.space()), node.in && (this.word("in"), this.space()), node.out && (this.word("out"), this.space()), this.word(node.name), node.constraint && (this.space(), this.word("extends"), this.space(), this.print(node.constraint)), node.default && (this.space(), this.tokenChar(61), this.space(), this.print(node.default));
    }
    function TSParameterProperty(node) {
      node.accessibility && (this.word(node.accessibility), this.space()), node.readonly && (this.word("readonly"), this.space()), this._param(node.parameter);
    }
    function TSDeclareFunction(node, parent) {
      node.declare && (this.word("declare"), this.space()), this._functionHead(node, parent), this.semicolon();
    }
    function TSDeclareMethod(node) {
      this._classMethodHead(node), this.semicolon();
    }
    function TSQualifiedName(node) {
      this.print(node.left), this.tokenChar(46), this.print(node.right);
    }
    function TSCallSignatureDeclaration(node) {
      this.tsPrintSignatureDeclarationBase(node), maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function maybePrintTrailingCommaOrSemicolon(printer, node) {
      if (!printer.tokenMap || !node.start || !node.end) {
        printer.semicolon();
        return;
      }
      printer.tokenMap.endMatches(node, ",") ? printer.token(",") : printer.tokenMap.endMatches(node, ";") && printer.semicolon();
    }
    function TSConstructSignatureDeclaration(node) {
      this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(node), maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSPropertySignature(node) {
      let {
        readonly
      } = node;
      readonly && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(node), this.print(node.typeAnnotation), maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function tsPrintPropertyOrMethodName(node) {
      node.computed && this.tokenChar(91), this.print(node.key), node.computed && this.tokenChar(93), node.optional && this.tokenChar(63);
    }
    function TSMethodSignature(node) {
      let {
        kind
      } = node;
      (kind === "set" || kind === "get") && (this.word(kind), this.space()), this.tsPrintPropertyOrMethodName(node), this.tsPrintSignatureDeclarationBase(node), maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSIndexSignature(node) {
      let {
        readonly,
        static: isStatic
      } = node;
      isStatic && (this.word("static"), this.space()), readonly && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(node.parameters, "]"), this.print(node.typeAnnotation), maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSBigIntKeyword() {
      this.word("bigint");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSIntrinsicKeyword() {
      this.word("intrinsic");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node) {
      this.tsPrintFunctionOrConstructorType(node);
    }
    function TSConstructorType(node) {
      node.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(node);
    }
    function tsPrintFunctionOrConstructorType(node) {
      let {
        typeParameters
      } = node, parameters = node.parameters;
      this.print(typeParameters), this.tokenChar(40), this._parameters(parameters, ")"), this.space();
      let returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function TSTypeReference(node) {
      let typeArguments = node.typeParameters;
      this.print(node.typeName, !!typeArguments), this.print(typeArguments);
    }
    function TSTypePredicate(node) {
      node.asserts && (this.word("asserts"), this.space()), this.print(node.parameterName), node.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(node.typeAnnotation.typeAnnotation));
    }
    function TSTypeQuery(node) {
      this.word("typeof"), this.space(), this.print(node.exprName);
      let typeArguments = node.typeParameters;
      typeArguments && this.print(typeArguments);
    }
    function TSTypeLiteral(node) {
      printBraced(this, node, () => this.printJoin(node.members, !0, !0));
    }
    function TSArrayType(node) {
      this.print(node.elementType, !0), this.tokenChar(91), this.tokenChar(93);
    }
    function TSTupleType(node) {
      this.tokenChar(91), this.printList(node.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
    }
    function TSOptionalType(node) {
      this.print(node.typeAnnotation), this.tokenChar(63);
    }
    function TSRestType(node) {
      this.token("..."), this.print(node.typeAnnotation);
    }
    function TSNamedTupleMember(node) {
      this.print(node.label), node.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(node.elementType);
    }
    function TSUnionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "|");
    }
    function TSIntersectionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "&");
    }
    function tsPrintUnionOrIntersectionType(printer, node, sep) {
      var _printer$tokenMap;
      let hasLeadingToken = 0;
      (_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep) && (hasLeadingToken = 1, printer.token(sep)), printer.printJoin(node.types, void 0, void 0, function(i) {
        this.space(), this.token(sep, void 0, i + hasLeadingToken), this.space();
      });
    }
    function TSConditionalType(node) {
      this.print(node.checkType), this.space(), this.word("extends"), this.space(), this.print(node.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(node.trueType), this.space(), this.tokenChar(58), this.space(), this.print(node.falseType);
    }
    function TSInferType(node) {
      this.word("infer"), this.print(node.typeParameter);
    }
    function TSParenthesizedType(node) {
      this.tokenChar(40), this.print(node.typeAnnotation), this.tokenChar(41);
    }
    function TSTypeOperator(node) {
      this.word(node.operator), this.space(), this.print(node.typeAnnotation);
    }
    function TSIndexedAccessType(node) {
      this.print(node.objectType, !0), this.tokenChar(91), this.print(node.indexType), this.tokenChar(93);
    }
    function TSMappedType(node) {
      let {
        nameType,
        optional,
        readonly,
        typeAnnotation
      } = node;
      this.tokenChar(123);
      let exit = this.enterDelimited();
      this.space(), readonly && (tokenIfPlusMinus(this, readonly), this.word("readonly"), this.space()), this.tokenChar(91), this.word(node.typeParameter.name), this.space(), this.word("in"), this.space(), this.print(node.typeParameter.constraint), nameType && (this.space(), this.word("as"), this.space(), this.print(nameType)), this.tokenChar(93), optional && (tokenIfPlusMinus(this, optional), this.tokenChar(63)), typeAnnotation && (this.tokenChar(58), this.space(), this.print(typeAnnotation)), this.space(), exit(), this.tokenChar(125);
    }
    function tokenIfPlusMinus(self2, tok) {
      tok !== !0 && self2.token(tok);
    }
    function TSTemplateLiteralType(node) {
      this._printTemplate(node, node.types);
    }
    function TSLiteralType(node) {
      this.print(node.literal);
    }
    function TSClassImplements(node) {
      this.print(node.expression), this.print(node.typeArguments);
    }
    function TSInterfaceDeclaration(node) {
      let {
        declare,
        id,
        typeParameters,
        extends: extendz,
        body
      } = node;
      declare && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(id), this.print(typeParameters), extendz != null && extendz.length && (this.space(), this.word("extends"), this.space(), this.printList(extendz)), this.space(), this.print(body);
    }
    function TSInterfaceBody(node) {
      printBraced(this, node, () => this.printJoin(node.body, !0, !0));
    }
    function TSTypeAliasDeclaration(node) {
      let {
        declare,
        id,
        typeParameters,
        typeAnnotation
      } = node;
      declare && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(id), this.print(typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(typeAnnotation), this.semicolon();
    }
    function TSTypeExpression(node) {
      let {
        type,
        expression,
        typeAnnotation
      } = node;
      this.print(expression, !0), this.space(), this.word(type === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(typeAnnotation);
    }
    function TSTypeAssertion(node) {
      let {
        typeAnnotation,
        expression
      } = node;
      this.tokenChar(60), this.print(typeAnnotation), this.tokenChar(62), this.space(), this.print(expression);
    }
    function TSInstantiationExpression(node) {
      this.print(node.expression), this.print(node.typeParameters);
    }
    function TSEnumDeclaration(node) {
      let {
        declare,
        const: isConst,
        id
      } = node;
      declare && (this.word("declare"), this.space()), isConst && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(id), this.space(), TSEnumBody.call(this, node);
    }
    function TSEnumBody(node) {
      printBraced(this, node, () => {
        var _this$shouldPrintTrai;
        return this.printList(node.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : !0, !0, !0);
      });
    }
    function TSEnumMember(node) {
      let {
        id,
        initializer
      } = node;
      this.print(id), initializer && (this.space(), this.tokenChar(61), this.space(), this.print(initializer));
    }
    function TSModuleDeclaration(node) {
      let {
        declare,
        id,
        kind
      } = node;
      declare && (this.word("declare"), this.space());
      {
        if (node.global || (this.word(kind ?? (id.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(id), !node.body) {
          this.semicolon();
          return;
        }
        let body = node.body;
        for (; body.type === "TSModuleDeclaration"; )
          this.tokenChar(46), this.print(body.id), body = body.body;
        this.space(), this.print(body);
      }
    }
    function TSModuleBlock(node) {
      printBraced(this, node, () => this.printSequence(node.body, !0));
    }
    function TSImportType(node) {
      let {
        argument,
        qualifier,
        options
      } = node;
      this.word("import"), this.tokenChar(40), this.print(argument), options && (this.tokenChar(44), this.print(options)), this.tokenChar(41), qualifier && (this.tokenChar(46), this.print(qualifier));
      let typeArguments = node.typeParameters;
      typeArguments && this.print(typeArguments);
    }
    function TSImportEqualsDeclaration(node) {
      let {
        id,
        moduleReference
      } = node;
      node.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(id), this.space(), this.tokenChar(61), this.space(), this.print(moduleReference), this.semicolon();
    }
    function TSExternalModuleReference(node) {
      this.token("require("), this.print(node.expression), this.tokenChar(41);
    }
    function TSNonNullExpression(node) {
      this.print(node.expression), this.tokenChar(33);
    }
    function TSExportAssignment(node) {
      this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(node.expression), this.semicolon();
    }
    function TSNamespaceExportDeclaration(node) {
      this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(node.id), this.semicolon();
    }
    function tsPrintSignatureDeclarationBase(node) {
      let {
        typeParameters
      } = node, parameters = node.parameters;
      this.print(typeParameters), this.tokenChar(40), this._parameters(parameters, ")");
      let returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function tsPrintClassMemberModifiers(node) {
      let isPrivateField = node.type === "ClassPrivateProperty", isPublicField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
      printModifiersList(this, node, [isPublicField && node.declare && "declare", !isPrivateField && node.accessibility]), node.static && (this.word("static"), this.space()), printModifiersList(this, node, [!isPrivateField && node.abstract && "abstract", !isPrivateField && node.override && "override", (isPublicField || isPrivateField) && node.readonly && "readonly"]);
    }
    function printBraced(printer, node, cb) {
      printer.token("{");
      let exit = printer.enterDelimited();
      cb(), exit(), printer.rightBrace(node);
    }
    function printModifiersList(printer, node, modifiers) {
      var _printer$tokenMap2;
      let modifiersSet = /* @__PURE__ */ new Set();
      for (let modifier of modifiers)
        modifier && modifiersSet.add(modifier);
      (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, (tok) => modifiersSet.has(tok.value) ? (printer.token(tok.value), printer.space(), modifiersSet.delete(tok.value), modifiersSet.size === 0) : !1);
      for (let modifier of modifiersSet)
        printer.word(modifier), printer.space();
    }
  }
});

// ../node_modules/@babel/generator/lib/generators/index.js
var require_generators = __commonJS({
  "../node_modules/@babel/generator/lib/generators/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var _templateLiterals = require_template_literals();
    Object.keys(_templateLiterals).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _templateLiterals[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _templateLiterals[key];
        }
      });
    });
    var _expressions = require_expressions();
    Object.keys(_expressions).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _expressions[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _expressions[key];
        }
      });
    });
    var _statements = require_statements();
    Object.keys(_statements).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _statements[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _statements[key];
        }
      });
    });
    var _classes = require_classes();
    Object.keys(_classes).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _classes[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _classes[key];
        }
      });
    });
    var _methods = require_methods();
    Object.keys(_methods).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _methods[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _methods[key];
        }
      });
    });
    var _modules = require_modules();
    Object.keys(_modules).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _modules[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _modules[key];
        }
      });
    });
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _types[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _types[key];
        }
      });
    });
    var _flow = require_flow2();
    Object.keys(_flow).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _flow[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _flow[key];
        }
      });
    });
    var _base = require_base();
    Object.keys(_base).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _base[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _base[key];
        }
      });
    });
    var _jsx = require_jsx2();
    Object.keys(_jsx).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _jsx[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _jsx[key];
        }
      });
    });
    var _typescript = require_typescript2();
    Object.keys(_typescript).forEach(function(key) {
      key === "default" || key === "__esModule" || key in exports && exports[key] === _typescript[key] || Object.defineProperty(exports, key, {
        enumerable: !0,
        get: function() {
          return _typescript[key];
        }
      });
    });
  }
});

// ../node_modules/@babel/generator/lib/generators/deprecated.js
var require_deprecated = __commonJS({
  "../node_modules/@babel/generator/lib/generators/deprecated.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.addDeprecatedGenerators = addDeprecatedGenerators;
    function addDeprecatedGenerators(PrinterClass) {
      {
        let deprecatedBabel7Generators = {
          Noop() {
          },
          TSExpressionWithTypeArguments(node) {
            this.print(node.expression), this.print(node.typeParameters);
          },
          DecimalLiteral(node) {
            let raw = this.getPossibleRaw(node);
            if (!this.format.minified && raw !== void 0) {
              this.word(raw);
              return;
            }
            this.word(node.value + "m");
          }
        };
        Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
      }
    }
  }
});

// ../node_modules/@babel/generator/lib/printer.js
var require_printer = __commonJS({
  "../node_modules/@babel/generator/lib/printer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _buffer = require_buffer(), _index = require_node(), n = _index, _t = require_lib4(), _tokenMap = require_token_map(), generatorFunctions = require_generators(), _deprecated = require_deprecated(), {
      isExpression,
      isFunction,
      isStatement,
      isClassBody,
      isTSInterfaceBody,
      isTSEnumMember
    } = _t, SCIENTIFIC_NOTATION = /e/i, ZERO_DECIMAL_INTEGER = /\.0+$/, HAS_NEWLINE = /[\n\r\u2028\u2029]/, HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
    function commentIsNewline(c) {
      return c.type === "CommentLine" || HAS_NEWLINE.test(c.value);
    }
    var {
      needsParens
    } = n, Printer = class {
      constructor(format, map, tokens = null, originalCode = null) {
        this.tokenContext = _index.TokenContext.normal, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier = this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = format, this._tokens = tokens, this._originalCode = originalCode, this._indentRepeat = format.indent.style.length, this._inputMap = map?._inputMap || null, this._buf = new _buffer.default(map, format.indent.style[0]);
      }
      enterForStatementInit() {
        return this.tokenContext |= _index.TokenContext.forInitHead | _index.TokenContext.forInOrInitHeadAccumulate, () => this.tokenContext = _index.TokenContext.normal;
      }
      enterForXStatementInit(isForOf) {
        return isForOf ? (this.tokenContext |= _index.TokenContext.forOfHead, null) : (this.tokenContext |= _index.TokenContext.forInHead | _index.TokenContext.forInOrInitHeadAccumulate, () => this.tokenContext = _index.TokenContext.normal);
      }
      enterDelimited() {
        let oldTokenContext = this.tokenContext, oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        return !(oldTokenContext & _index.TokenContext.forInOrInitHeadAccumulate) && oldNoLineTerminatorAfterNode === null ? () => {
        } : (this._noLineTerminatorAfterNode = null, this.tokenContext = _index.TokenContext.normal, () => {
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode, this.tokenContext = oldTokenContext;
        });
      }
      generate(ast) {
        return this.format.preserveFormat && (this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode)), this.print(ast), this._maybeAddAuxComment(), this._buf.get();
      }
      indent() {
        let {
          format
        } = this;
        format.preserveFormat || format.compact || format.concise || this._indent++;
      }
      dedent() {
        let {
          format
        } = this;
        format.preserveFormat || format.compact || format.concise || this._indent--;
      }
      semicolon(force = !1) {
        if (this._maybeAddAuxComment(), force) {
          this._appendChar(59), this._noLineTerminator = !1;
          return;
        }
        if (this.tokenMap) {
          let node = this._currentNode;
          if (node.start != null && node.end != null) {
            if (!this.tokenMap.endMatches(node, ";")) {
              this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
              return;
            }
            let indexes = this.tokenMap.getIndexes(this._currentNode);
            this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
          }
        }
        this._queue(59), this._noLineTerminator = !1;
      }
      rightBrace(node) {
        this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", node.loc, -1), this.tokenChar(125);
      }
      rightParens(node) {
        this.sourceWithOffset("end", node.loc, -1), this.tokenChar(41);
      }
      space(force = !1) {
        let {
          format
        } = this;
        if (!(format.compact || format.preserveFormat)) {
          if (force)
            this._space();
          else if (this._buf.hasContent()) {
            let lastCp = this.getLastChar();
            lastCp !== 32 && lastCp !== 10 && this._space();
          }
        }
      }
      word(str, noLineTerminatorAfter = !1) {
        this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask, this._maybePrintInnerComments(str), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(str), (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) && this._space(), this._append(str, !1), this._endsWithWord = !0, this._noLineTerminator = noLineTerminatorAfter;
      }
      number(str, number) {
        function isNonDecimalLiteral(str2) {
          if (str2.length > 2 && str2.charCodeAt(0) === 48) {
            let secondChar = str2.charCodeAt(1);
            return secondChar === 98 || secondChar === 111 || secondChar === 120;
          }
          return !1;
        }
        this.word(str), this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
      }
      token(str, maybeNewline = !1, occurrenceCount = 0) {
        this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask, this._maybePrintInnerComments(str, occurrenceCount), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(str, occurrenceCount);
        let lastChar = this.getLastChar(), strFirst = str.charCodeAt(0);
        (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) && this._space(), this._append(str, maybeNewline), this._noLineTerminator = !1;
      }
      tokenChar(char) {
        this.tokenContext &= _index.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
        let str = String.fromCharCode(char);
        this._maybePrintInnerComments(str), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(str);
        let lastChar = this.getLastChar();
        (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) && this._space(), this._appendChar(char), this._noLineTerminator = !1;
      }
      newline(i = 1, force) {
        if (!(i <= 0)) {
          if (!force) {
            if (this.format.retainLines || this.format.compact) return;
            if (this.format.concise) {
              this.space();
              return;
            }
          }
          i > 2 && (i = 2), i -= this._buf.getNewlineCount();
          for (let j = 0; j < i; j++)
            this._newline();
        }
      }
      endsWith(char) {
        return this.getLastChar() === char;
      }
      getLastChar() {
        return this._buf.getLastChar();
      }
      endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
      }
      removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }
      exactSource(loc, cb) {
        if (!loc) {
          cb();
          return;
        }
        this._catchUp("start", loc), this._buf.exactSource(loc, cb);
      }
      source(prop, loc) {
        loc && (this._catchUp(prop, loc), this._buf.source(prop, loc));
      }
      sourceWithOffset(prop, loc, columnOffset) {
        !loc || this.format.preserveFormat || (this._catchUp(prop, loc), this._buf.sourceWithOffset(prop, loc, columnOffset));
      }
      sourceIdentifierName(identifierName, pos) {
        if (!this._buf._canMarkIdName) return;
        let sourcePosition = this._buf._sourcePosition;
        sourcePosition.identifierNamePos = pos, sourcePosition.identifierName = identifierName;
      }
      _space() {
        this._queue(32);
      }
      _newline() {
        this._queue(10);
      }
      _catchUpToCurrentToken(str, occurrenceCount = 0) {
        let token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
        token && this._catchUpTo(token.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() && (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1;
      }
      _append(str, maybeNewline) {
        this._maybeIndent(str.charCodeAt(0)), this._buf.append(str, maybeNewline), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
      }
      _appendChar(char) {
        this._maybeIndent(char), this._buf.appendChar(char), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
      }
      _queue(char) {
        this._maybeIndent(char), this._buf.queue(char), this._endsWithWord = !1, this._endsWithInteger = !1;
      }
      _maybeIndent(firstChar) {
        this._indent && firstChar !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
      }
      _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10))
          return !0;
      }
      catchUp(line) {
        if (!this.format.retainLines) return;
        let count = line - this._buf.getCurrentLine();
        for (let i = 0; i < count; i++)
          this._newline();
      }
      _catchUp(prop, loc) {
        let {
          format
        } = this;
        if (!format.preserveFormat) {
          format.retainLines && loc != null && loc[prop] && this.catchUp(loc[prop].line);
          return;
        }
        let pos = loc?.[prop];
        pos != null && this._catchUpTo(pos);
      }
      _catchUpTo({
        line,
        column,
        index
      }) {
        let count = line - this._buf.getCurrentLine();
        if (count > 0 && this._noLineTerminator)
          return;
        for (let i = 0; i < count; i++)
          this._newline();
        let spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
        if (spacesCount > 0) {
          let spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(spacesCount);
          this._append(spaces, !1);
        }
      }
      _getIndent() {
        return this._indentRepeat * this._indent;
      }
      printTerminatorless(node) {
        this._noLineTerminator = !0, this.print(node);
      }
      print(node, noLineTerminatorAfter = !1, trailingCommentsLineOffset) {
        var _node$extra, _node$leadingComments, _node$leadingComments2;
        if (!node) return;
        this._endsWithInnerRaw = !1;
        let nodeType = node.type, format = this.format, oldConcise = format.concise;
        node._compact && (format.concise = !0);
        let printMethod = this[nodeType];
        if (printMethod === void 0)
          throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
        let parent = this._currentNode;
        this._currentNode = node, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
        let oldInAux = this._insideAux;
        this._insideAux = node.loc == null, this._maybeAddAuxComment(this._insideAux && !oldInAux);
        let parenthesized = (_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized, shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node, parent, this.tokenContext, format.preserveFormat ? this._boundGetRawIdentifier : void 0);
        if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === "CommentBlock")
          switch (parent?.type) {
            case "ExpressionStatement":
            case "VariableDeclarator":
            case "AssignmentExpression":
            case "ReturnStatement":
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              if (parent.callee !== node) break;
            default:
              shouldPrintParens = !0;
          }
        let indentParenthesized = !1;
        !shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine()) && (shouldPrintParens = !0, indentParenthesized = !0);
        let oldNoLineTerminatorAfterNode, oldTokenContext;
        if (!shouldPrintParens && (noLineTerminatorAfter || (noLineTerminatorAfter = !!parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node)), noLineTerminatorAfter)) {
          var _node$trailingComment;
          (_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline) ? isExpression(node) && (shouldPrintParens = !0) : (oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = node);
        }
        shouldPrintParens && (this.tokenChar(40), indentParenthesized && this.indent(), this._endsWithInnerRaw = !1, this.tokenContext & _index.TokenContext.forInOrInitHeadAccumulate && (oldTokenContext = this.tokenContext, this.tokenContext = _index.TokenContext.normal), oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(node, parent);
        let loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
        this.exactSource(loc, printMethod.bind(this, node, parent)), shouldPrintParens ? (this._printTrailingComments(node, parent), indentParenthesized && (this.dedent(), this.newline()), this.tokenChar(41), this._noLineTerminator = noLineTerminatorAfter, oldTokenContext && (this.tokenContext = oldTokenContext)) : noLineTerminatorAfter && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(node, parent)) : this._printTrailingComments(node, parent, trailingCommentsLineOffset), this._currentNode = parent, format.concise = oldConcise, this._insideAux = oldInAux, oldNoLineTerminatorAfterNode !== void 0 && (this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode), this._endsWithInnerRaw = !1;
      }
      _maybeAddAuxComment(enteredPositionlessNode) {
        enteredPositionlessNode && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
      }
      _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = !0;
        let comment = this.format.auxiliaryCommentBefore;
        comment && this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
      _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = !1;
        let comment = this.format.auxiliaryCommentAfter;
        comment && this._printComment({
          type: "CommentBlock",
          value: comment
        }, 0);
      }
      getPossibleRaw(node) {
        let extra = node.extra;
        if (extra?.raw != null && extra.rawValue != null && node.value === extra.rawValue)
          return extra.raw;
      }
      printJoin(nodes, statement, indent, separator, printTrailingSeparator, iterator, trailingCommentsLineOffset) {
        if (!(nodes != null && nodes.length)) return;
        if (indent == null && this.format.retainLines) {
          var _nodes$0$loc;
          let startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
          startLine != null && startLine !== this._buf.getCurrentLine() && (indent = !0);
        }
        indent && this.indent();
        let newlineOpts = {
          nextNodeStartLine: 0
        }, boundSeparator = separator?.bind(this), len = nodes.length;
        for (let i = 0; i < len; i++) {
          let node = nodes[i];
          if (node && (statement && this._printNewline(i === 0, newlineOpts), this.print(node, void 0, trailingCommentsLineOffset || 0), iterator?.(node, i), boundSeparator != null && (i < len - 1 ? boundSeparator(i, !1) : printTrailingSeparator && boundSeparator(i, !0)), statement)) {
            var _node$trailingComment2;
            if ((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length || (this._lastCommentLine = 0), i + 1 === len)
              this.newline(1);
            else {
              var _nextNode$loc;
              let nextNode = nodes[i + 1];
              newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0, this._printNewline(!0, newlineOpts);
            }
          }
        }
        indent && this.dedent();
      }
      printAndIndentOnComments(node) {
        let indent = node.leadingComments && node.leadingComments.length > 0;
        indent && this.indent(), this.print(node), indent && this.dedent();
      }
      printBlock(parent) {
        let node = parent.body;
        node.type !== "EmptyStatement" && this.space(), this.print(node);
      }
      _printTrailingComments(node, parent, lineOffset) {
        let {
          innerComments,
          trailingComments
        } = node;
        innerComments != null && innerComments.length && this._printComments(2, innerComments, node, parent, lineOffset), trailingComments != null && trailingComments.length && this._printComments(2, trailingComments, node, parent, lineOffset);
      }
      _printLeadingComments(node, parent) {
        let comments = node.leadingComments;
        comments != null && comments.length && this._printComments(0, comments, node, parent);
      }
      _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
        if (this._endsWithInnerRaw) {
          var _this$tokenMap;
          this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
        }
        this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
      }
      printInnerComments(nextToken) {
        let node = this._currentNode, comments = node.innerComments;
        if (!(comments != null && comments.length)) return;
        let hasSpace = this.endsWith(32), indent = this._indentInnerComments, printedCommentsCount = this._printedComments.size;
        indent && this.indent(), this._printComments(1, comments, node, void 0, void 0, nextToken), hasSpace && printedCommentsCount !== this._printedComments.size && this.space(), indent && this.dedent();
      }
      noIndentInnerCommentsHere() {
        this._indentInnerComments = !1;
      }
      printSequence(nodes, indent, trailingCommentsLineOffset) {
        this.printJoin(nodes, !0, indent ?? !1, void 0, void 0, void 0, trailingCommentsLineOffset);
      }
      printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
        this.printJoin(items, statement, indent, separator ?? commaSeparator, printTrailingSeparator, iterator);
      }
      shouldPrintTrailingComma(listEnd) {
        if (!this.tokenMap) return null;
        let listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token) => this.tokenMap.matchesOriginal(token, listEnd));
        return listEndIndex <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
      }
      _printNewline(newLine, opts) {
        let format = this.format;
        if (format.retainLines || format.compact) return;
        if (format.concise) {
          this.space();
          return;
        }
        if (!newLine)
          return;
        let startLine = opts.nextNodeStartLine, lastCommentLine = this._lastCommentLine;
        if (startLine > 0 && lastCommentLine > 0) {
          let offset = startLine - lastCommentLine;
          if (offset >= 0) {
            this.newline(offset || 1);
            return;
          }
        }
        this._buf.hasContent() && this.newline(1);
      }
      _shouldPrintComment(comment, nextToken) {
        if (comment.ignore || this._printedComments.has(comment)) return 0;
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value))
          return 2;
        if (nextToken && this.tokenMap) {
          let commentTok = this.tokenMap.find(this._currentNode, (token) => token.value === comment.value);
          if (commentTok && commentTok.start > nextToken.start)
            return 2;
        }
        return this._printedComments.add(comment), this.format.shouldPrintComment(comment.value) ? 1 : 0;
      }
      _printComment(comment, skipNewLines) {
        let noLineTerminator = this._noLineTerminator, isBlockComment = comment.type === "CommentBlock", printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        printNewLines && this._buf.hasContent() && skipNewLines !== 2 && this.newline(1);
        let lastCharCode = this.getLastChar();
        lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40 && this.space();
        let val;
        if (isBlockComment) {
          if (val = `/*${comment.value}*/`, this.format.indent.adjustMultilineComment) {
            var _comment$loc;
            let offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
            if (offset) {
              let newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
              val = val.replace(newlineRegex, `
`);
            }
            if (this.format.concise)
              val = val.replace(/\n(?!$)/g, `
`);
            else {
              let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
              (this._shouldIndent(47) || this.format.retainLines) && (indentSize += this._getIndent()), val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
            }
          }
        } else noLineTerminator ? val = `/*${comment.value}*/` : val = `//${comment.value}`;
        if (this._endsWithDiv && this._space(), this.tokenMap) {
          let {
            _printSemicolonBeforeNextToken,
            _printSemicolonBeforeNextNode
          } = this;
          this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", comment.loc), this._append(val, isBlockComment), this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode, this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
        } else
          this.source("start", comment.loc), this._append(val, isBlockComment);
        !isBlockComment && !noLineTerminator && this.newline(1, !0), printNewLines && skipNewLines !== 3 && this.newline(1);
      }
      _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {
        let nodeLoc = node.loc, len = comments.length, hasLoc = !!nodeLoc, nodeStartLine = hasLoc ? nodeLoc.start.line : 0, nodeEndLine = hasLoc ? nodeLoc.end.line : 0, lastLine = 0, leadingCommentNewline = 0, maybeNewline = this._noLineTerminator ? function() {
        } : this.newline.bind(this);
        for (let i = 0; i < len; i++) {
          let comment = comments[i], shouldPrint = this._shouldPrintComment(comment, nextToken);
          if (shouldPrint === 2) {
            hasLoc = !1;
            break;
          }
          if (hasLoc && comment.loc && shouldPrint === 1) {
            let commentStartLine = comment.loc.start.line, commentEndLine = comment.loc.end.line;
            if (type === 0) {
              let offset = 0;
              i === 0 ? this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine) && (offset = leadingCommentNewline = 1) : offset = commentStartLine - lastLine, lastLine = commentEndLine, maybeNewline(offset), this._printComment(comment, 1), i + 1 === len && (maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline)), lastLine = nodeStartLine);
            } else if (type === 1) {
              let offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
              lastLine = commentEndLine, maybeNewline(offset), this._printComment(comment, 1), i + 1 === len && (maybeNewline(Math.min(1, nodeEndLine - lastLine)), lastLine = nodeEndLine);
            } else {
              let offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
              lastLine = commentEndLine, maybeNewline(offset), this._printComment(comment, 1);
            }
          } else {
            if (hasLoc = !1, shouldPrint !== 1)
              continue;
            if (len === 1) {
              let singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value), shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node);
              type === 0 ? this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                body: node
              }) ? 1 : 0) : shouldSkipNewline && type === 2 ? this._printComment(comment, 1) : this._printComment(comment, 0);
            } else type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody" ? this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0) : this._printComment(comment, 0);
          }
        }
        type === 2 && hasLoc && lastLine && (this._lastCommentLine = lastLine);
      }
    };
    Object.assign(Printer.prototype, generatorFunctions);
    (0, _deprecated.addDeprecatedGenerators)(Printer);
    var _default = exports.default = Printer;
    function commaSeparator(occurrenceCount, last) {
      this.token(",", !1, occurrenceCount), last || this.space();
    }
  }
});

// ../node_modules/@babel/generator/lib/index.js
var require_lib9 = __commonJS({
  "../node_modules/@babel/generator/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    exports.generate = generate2;
    var _sourceMap = require_source_map(), _printer = require_printer();
    function normalizeOptions(code, opts, ast) {
      if (opts.experimental_preserveFormat) {
        if (typeof code != "string")
          throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
        if (!opts.retainLines)
          throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
        if (opts.compact && opts.compact !== "auto")
          throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
        if (opts.minified)
          throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
        if (opts.jsescOption)
          throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
        if (!Array.isArray(ast.tokens))
          throw new Error("`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.");
      }
      let format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        preserveFormat: opts.experimental_preserveFormat,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: !0,
          style: "  "
        },
        jsescOption: Object.assign({
          quotes: "double",
          wrap: !0,
          minimal: !1
        }, opts.jsescOption),
        topicToken: opts.topicToken,
        importAttributesKeyword: opts.importAttributesKeyword
      };
      {
        var _opts$recordAndTupleS;
        format.decoratorsBeforeExport = opts.decoratorsBeforeExport, format.jsescOption.json = opts.jsonCompatibleStrings, format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
      }
      format.minified ? (format.compact = !0, format.shouldPrintComment = format.shouldPrintComment || (() => format.comments)) : format.shouldPrintComment = format.shouldPrintComment || ((value2) => format.comments || value2.includes("@license") || value2.includes("@preserve")), format.compact === "auto" && (format.compact = typeof code == "string" && code.length > 5e5, format.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of 500KB.`)), (format.compact || format.preserveFormat) && (format.indent.adjustMultilineComment = !1);
      let {
        auxiliaryCommentBefore,
        auxiliaryCommentAfter,
        shouldPrintComment
      } = format;
      return auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore) && (format.auxiliaryCommentBefore = void 0), auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter) && (format.auxiliaryCommentAfter = void 0), format;
    }
    exports.CodeGenerator = class {
      constructor(ast, opts = {}, code) {
        this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = ast, this._format = normalizeOptions(code, opts, ast), this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      }
      generate() {
        return new _printer.default(this._format, this._map).generate(this._ast);
      }
    };
    function generate2(ast, opts = {}, code) {
      let format = normalizeOptions(code, opts, ast), map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      return new _printer.default(format, map, ast.tokens, typeof code == "string" ? code : null).generate(ast);
    }
    var _default = exports.default = generate2;
  }
});

// ../node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry = __commonJS({
  "../node_modules/@babel/traverse/lib/path/ancestry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.find = find;
    exports.findParent = findParent;
    exports.getAncestry = getAncestry;
    exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
    exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
    exports.getFunctionParent = getFunctionParent;
    exports.getStatementParent = getStatementParent;
    exports.inType = inType;
    exports.isAncestor = isAncestor;
    exports.isDescendant = isDescendant;
    var _t = require_lib4(), {
      VISITOR_KEYS
    } = _t;
    function findParent(callback) {
      let path = this;
      for (; path = path.parentPath; )
        if (callback(path)) return path;
      return null;
    }
    function find(callback) {
      let path = this;
      do
        if (callback(path)) return path;
      while (path = path.parentPath);
      return null;
    }
    function getFunctionParent() {
      return this.findParent((p) => p.isFunction());
    }
    function getStatementParent() {
      let path = this;
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement())
          break;
        path = path.parentPath;
      } while (path);
      if (path && (path.isProgram() || path.isFile()))
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      return path;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest, keys = VISITOR_KEYS[deepest.type];
        for (let ancestry of ancestries) {
          let path = ancestry[i + 1];
          if (!earliest) {
            earliest = path;
            continue;
          }
          if (path.listKey && earliest.listKey === path.listKey && path.key < earliest.key) {
            earliest = path;
            continue;
          }
          let earliestKeyIndex = keys.indexOf(earliest.parentKey), currentKeyIndex = keys.indexOf(path.parentKey);
          earliestKeyIndex > currentKeyIndex && (earliest = path);
        }
        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter) {
      if (!paths.length)
        return this;
      if (paths.length === 1)
        return paths[0];
      let minDepth = 1 / 0, lastCommonIndex, lastCommon, ancestries = paths.map((path) => {
        let ancestry = [];
        do
          ancestry.unshift(path);
        while ((path = path.parentPath) && path !== this);
        return ancestry.length < minDepth && (minDepth = ancestry.length), ancestry;
      }), first = ancestries[0];
      depthLoop: for (let i = 0; i < minDepth; i++) {
        let shouldMatch = first[i];
        for (let ancestry of ancestries)
          if (ancestry[i] !== shouldMatch)
            break depthLoop;
        lastCommonIndex = i, lastCommon = shouldMatch;
      }
      if (lastCommon)
        return filter ? filter(lastCommon, lastCommonIndex, ancestries) : lastCommon;
      throw new Error("Couldn't find intersection");
    }
    function getAncestry() {
      let path = this, paths = [];
      do
        paths.push(path);
      while (path = path.parentPath);
      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent((parent) => parent === maybeAncestor);
    }
    function inType(...candidateTypes) {
      let path = this;
      for (; path; ) {
        if (candidateTypes.includes(path.node.type)) return !0;
        path = path.parentPath;
      }
      return !1;
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/inference/util.js
var require_util = __commonJS({
  "../node_modules/@babel/traverse/lib/path/inference/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.createUnionType = createUnionType;
    var _t = require_lib4(), {
      createFlowUnionType,
      createTSUnionType,
      createUnionTypeAnnotation,
      isFlowType,
      isTSType
    } = _t;
    function createUnionType(types2) {
      {
        if (types2.every((v) => isFlowType(v)))
          return createFlowUnionType ? createFlowUnionType(types2) : createUnionTypeAnnotation(types2);
        if (types2.every((v) => isTSType(v)) && createTSUnionType)
          return createTSUnionType(types2);
      }
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS({
  "../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = _default;
    var _t = require_lib4(), _util = require_util(), {
      BOOLEAN_NUMBER_BINARY_OPERATORS,
      createTypeAnnotationBasedOnTypeof,
      numberTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function _default(node) {
      if (!this.isReferenced()) return;
      let binding = this.scope.getBinding(node.name);
      if (binding)
        return binding.identifier.typeAnnotation ? binding.identifier.typeAnnotation : getTypeAnnotationBindingConstantViolations(binding, this, node.name);
      if (node.name === "undefined")
        return voidTypeAnnotation();
      if (node.name === "NaN" || node.name === "Infinity")
        return numberTypeAnnotation();
      node.name;
    }
    function getTypeAnnotationBindingConstantViolations(binding, path, name) {
      let types2 = [], functionConstantViolations = [], constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations), testType = getConditionalAnnotation(binding, path, name);
      if (testType) {
        let testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter((path2) => !testConstantViolations.includes(path2)), types2.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations.push(...functionConstantViolations);
        for (let violation of constantViolations)
          types2.push(violation.getTypeAnnotation());
      }
      if (types2.length)
        return (0, _util.createUnionType)(types2);
    }
    function getConstantViolationsBefore(binding, path, functions) {
      let violations = binding.constantViolations.slice();
      return violations.unshift(binding.path), violations.filter((violation) => {
        violation = violation.resolve();
        let status = violation._guessExecutionStatusRelativeTo(path);
        return functions && status === "unknown" && functions.push(violation), status === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name, path) {
      let operator = path.node.operator, right = path.get("right").resolve(), left = path.get("left").resolve(), target;
      if (left.isIdentifier({
        name
      }) ? target = right : right.isIdentifier({
        name
      }) && (target = left), target)
        return operator === "===" ? target.getTypeAnnotation() : BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator) ? numberTypeAnnotation() : void 0;
      if (operator !== "===" && operator !== "==") return;
      let typeofPath, typePath;
      if (left.isUnaryExpression({
        operator: "typeof"
      }) ? (typeofPath = left, typePath = right) : right.isUnaryExpression({
        operator: "typeof"
      }) && (typeofPath = right, typePath = left), !typeofPath || !typeofPath.get("argument").isIdentifier({
        name
      }) || (typePath = typePath.resolve(), !typePath.isLiteral())) return;
      let typeValue = typePath.node.value;
      if (typeof typeValue == "string")
        return createTypeAnnotationBasedOnTypeof(typeValue);
    }
    function getParentConditionalPath(binding, path, name) {
      let parentPath;
      for (; parentPath = path.parentPath; ) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression())
          return path.key === "test" ? void 0 : parentPath;
        if (parentPath.isFunction() && (name == null || parentPath.parentPath.scope.getBinding(name) !== binding))
          return;
        path = parentPath;
      }
    }
    function getConditionalAnnotation(binding, path, name) {
      let ifStatement = getParentConditionalPath(binding, path, name);
      if (!ifStatement) return;
      let paths = [ifStatement.get("test")], types2 = [];
      for (let i = 0; i < paths.length; i++) {
        let path2 = paths[i];
        if (path2.isLogicalExpression())
          path2.node.operator === "&&" && (paths.push(path2.get("left")), paths.push(path2.get("right")));
        else if (path2.isBinaryExpression()) {
          let type = inferAnnotationFromBinaryExpression(name, path2);
          type && types2.push(type);
        }
      }
      return types2.length ? {
        typeAnnotation: (0, _util.createUnionType)(types2),
        ifStatement
      } : getConditionalAnnotation(binding, ifStatement, name);
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS({
  "../node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ArrayExpression = ArrayExpression;
    exports.AssignmentExpression = AssignmentExpression;
    exports.BinaryExpression = BinaryExpression;
    exports.BooleanLiteral = BooleanLiteral;
    exports.CallExpression = CallExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
    Object.defineProperty(exports, "Identifier", {
      enumerable: !0,
      get: function() {
        return _infererReference.default;
      }
    });
    exports.LogicalExpression = LogicalExpression;
    exports.NewExpression = NewExpression;
    exports.NullLiteral = NullLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.ObjectExpression = ObjectExpression;
    exports.ParenthesizedExpression = ParenthesizedExpression;
    exports.RegExpLiteral = RegExpLiteral;
    exports.RestElement = RestElement;
    exports.SequenceExpression = SequenceExpression;
    exports.StringLiteral = StringLiteral;
    exports.TSAsExpression = TSAsExpression;
    exports.TSNonNullExpression = TSNonNullExpression;
    exports.TaggedTemplateExpression = TaggedTemplateExpression;
    exports.TemplateLiteral = TemplateLiteral;
    exports.TypeCastExpression = TypeCastExpression;
    exports.UnaryExpression = UnaryExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.VariableDeclarator = VariableDeclarator;
    var _t = require_lib4(), _infererReference = require_inferer_reference(), _util = require_util(), {
      BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS,
      anyTypeAnnotation,
      arrayTypeAnnotation,
      booleanTypeAnnotation,
      buildMatchMemberExpression,
      genericTypeAnnotation,
      identifier,
      nullLiteralTypeAnnotation,
      numberTypeAnnotation,
      stringTypeAnnotation,
      tupleTypeAnnotation,
      unionTypeAnnotation,
      voidTypeAnnotation,
      isIdentifier
    } = _t;
    function VariableDeclarator() {
      if (this.get("id").isIdentifier())
        return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }
    TypeCastExpression.validParent = !0;
    function TSAsExpression(node) {
      return node.typeAnnotation;
    }
    TSAsExpression.validParent = !0;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node) {
      if (node.callee.type === "Identifier")
        return genericTypeAnnotation(node.callee);
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node) {
      let operator = node.operator;
      if (operator === "void")
        return voidTypeAnnotation();
      if (NUMBER_UNARY_OPERATORS.includes(operator))
        return numberTypeAnnotation();
      if (STRING_UNARY_OPERATORS.includes(operator))
        return stringTypeAnnotation();
      if (BOOLEAN_UNARY_OPERATORS.includes(operator))
        return booleanTypeAnnotation();
    }
    function BinaryExpression(node) {
      let operator = node.operator;
      if (NUMBER_BINARY_OPERATORS.includes(operator))
        return numberTypeAnnotation();
      if (BOOLEAN_BINARY_OPERATORS.includes(operator))
        return booleanTypeAnnotation();
      if (operator === "+") {
        let right = this.get("right"), left = this.get("left");
        return left.isBaseType("number") && right.isBaseType("number") ? numberTypeAnnotation() : left.isBaseType("string") || right.isBaseType("string") ? stringTypeAnnotation() : unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      let argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      let argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node) {
      let operator = node.operator;
      if (operator === "++" || operator === "--")
        return numberTypeAnnotation();
    }
    function StringLiteral() {
      return stringTypeAnnotation();
    }
    function NumericLiteral() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier("Object"));
    }
    function ArrayExpression() {
      return genericTypeAnnotation(identifier("Array"));
    }
    function RestElement() {
      return ArrayExpression();
    }
    RestElement.validParent = !0;
    function Func() {
      return genericTypeAnnotation(identifier("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression("Array.from"), isObjectKeys = buildMatchMemberExpression("Object.keys"), isObjectValues = buildMatchMemberExpression("Object.values"), isObjectEntries = buildMatchMemberExpression("Object.entries");
    function CallExpression() {
      let {
        callee
      } = this.node;
      return isObjectKeys(callee) ? arrayTypeAnnotation(stringTypeAnnotation()) : isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
        name: "Array"
      }) ? arrayTypeAnnotation(anyTypeAnnotation()) : isObjectEntries(callee) ? arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()])) : resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      if (callee = callee.resolve(), callee.isFunction()) {
        let {
          node
        } = callee;
        if (node.async)
          return node.generator ? genericTypeAnnotation(identifier("AsyncIterator")) : genericTypeAnnotation(identifier("Promise"));
        if (node.generator)
          return genericTypeAnnotation(identifier("Iterator"));
        if (callee.node.returnType)
          return callee.node.returnType;
      }
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference = __commonJS({
  "../node_modules/@babel/traverse/lib/path/inference/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports._getTypeAnnotation = _getTypeAnnotation;
    exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
    exports.couldBeBaseType = couldBeBaseType;
    exports.getTypeAnnotation = getTypeAnnotation;
    exports.isBaseType = isBaseType;
    exports.isGenericType = isGenericType;
    var inferers = require_inferers(), _t = require_lib4(), {
      anyTypeAnnotation,
      isAnyTypeAnnotation,
      isArrayTypeAnnotation,
      isBooleanTypeAnnotation,
      isEmptyTypeAnnotation,
      isFlowBaseAnnotation,
      isGenericTypeAnnotation,
      isIdentifier,
      isMixedTypeAnnotation,
      isNumberTypeAnnotation,
      isStringTypeAnnotation,
      isTSArrayType,
      isTSTypeAnnotation,
      isTSTypeReference,
      isTupleTypeAnnotation,
      isTypeAnnotation,
      isUnionTypeAnnotation,
      isVoidTypeAnnotation,
      stringTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function getTypeAnnotation() {
      let type = this.getData("typeAnnotation");
      return type != null || (type = _getTypeAnnotation.call(this) || anyTypeAnnotation(), (isTypeAnnotation(type) || isTSTypeAnnotation(type)) && (type = type.typeAnnotation), this.setData("typeAnnotation", type)), type;
    }
    var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
    function _getTypeAnnotation() {
      let node = this.node;
      if (!node)
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          let declar = this.parentPath.parentPath, declarParent = declar.parentPath;
          return declar.key === "left" && declarParent.isForInStatement() ? stringTypeAnnotation() : declar.key === "left" && declarParent.isForOfStatement() ? anyTypeAnnotation() : voidTypeAnnotation();
        } else
          return;
      if (node.typeAnnotation)
        return node.typeAnnotation;
      if (!typeAnnotationInferringNodes.has(node)) {
        typeAnnotationInferringNodes.add(node);
        try {
          var _inferer;
          let inferer = inferers[node.type];
          if (inferer)
            return inferer.call(this, node);
          if (inferer = inferers[this.parentPath.type], (_inferer = inferer) != null && _inferer.validParent)
            return this.parentPath.getTypeAnnotation();
        } finally {
          typeAnnotationInferringNodes.delete(node);
        }
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    function _isBaseType(baseName, type, soft) {
      if (baseName === "string")
        return isStringTypeAnnotation(type);
      if (baseName === "number")
        return isNumberTypeAnnotation(type);
      if (baseName === "boolean")
        return isBooleanTypeAnnotation(type);
      if (baseName === "any")
        return isAnyTypeAnnotation(type);
      if (baseName === "mixed")
        return isMixedTypeAnnotation(type);
      if (baseName === "empty")
        return isEmptyTypeAnnotation(type);
      if (baseName === "void")
        return isVoidTypeAnnotation(type);
      if (soft)
        return !1;
      throw new Error(`Unknown base type ${baseName}`);
    }
    function couldBeBaseType(name) {
      let type = this.getTypeAnnotation();
      if (isAnyTypeAnnotation(type)) return !0;
      if (isUnionTypeAnnotation(type)) {
        for (let type2 of type.types)
          if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, !0))
            return !0;
        return !1;
      } else
        return _isBaseType(name, type, !0);
    }
    function baseTypeStrictlyMatches(rightArg) {
      let left = this.getTypeAnnotation(), right = rightArg.getTypeAnnotation();
      return !isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left) ? right.type === left.type : !1;
    }
    function isGenericType(genericName) {
      let type = this.getTypeAnnotation();
      return genericName === "Array" && (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) ? !0 : isGenericTypeAnnotation(type) && isIdentifier(type.id, {
        name: genericName
      }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
        name: genericName
      });
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks = __commonJS({
  "../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.hooks = void 0;
    var hooks = exports.hooks = [function(self2, parent) {
      if (self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement())
        return parent.remove(), !0;
    }, function(self2, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1)
        return parent.replaceWith(parent.node.expressions[0]), !0;
    }, function(self2, parent) {
      if (parent.isBinary())
        return self2.key === "left" ? parent.replaceWith(parent.node.right) : parent.replaceWith(parent.node.left), !0;
    }, function(self2, parent) {
      if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression()))
        return self2.replaceWith({
          type: "BlockStatement",
          directives: [],
          body: []
        }), !0;
    }];
  }
});

// ../node_modules/@babel/traverse/lib/path/removal.js
var require_removal = __commonJS({
  "../node_modules/@babel/traverse/lib/path/removal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports._assertUnremoved = _assertUnremoved;
    exports._callRemovalHooks = _callRemovalHooks;
    exports._markRemoved = _markRemoved;
    exports._remove = _remove;
    exports._removeFromScope = _removeFromScope;
    exports.remove = remove;
    var _removalHooks = require_removal_hooks(), _cache = require_cache(), _replacement = require_replacement(), _index = require_path(), t = require_lib4(), _modification = require_modification(), _context = require_context2();
    function remove() {
      var _this$opts;
      if (_assertUnremoved.call(this), _context.resync.call(this), _callRemovalHooks.call(this)) {
        _markRemoved.call(this);
        return;
      }
      (_this$opts = this.opts) != null && _this$opts.noScope || _removeFromScope.call(this), this.shareCommentsWithSiblings(), _remove.call(this), _markRemoved.call(this);
    }
    function _removeFromScope() {
      let bindings = t.getBindingIdentifiers(this.node, !1, !1, !0);
      Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
    }
    function _callRemovalHooks() {
      if (this.parentPath) {
        for (let fn of _removalHooks.hooks)
          if (fn(this, this.parentPath)) return !0;
      }
    }
    function _remove() {
      Array.isArray(this.container) ? (this.container.splice(this.key, 1), _modification.updateSiblingKeys.call(this, this.key, -1)) : _replacement._replaceWith.call(this, null);
    }
    function _markRemoved() {
      if (this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED, this.parent) {
        var _getCachedPaths;
        (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node);
      }
      this.node = null;
    }
    function _assertUnremoved() {
      if (this.removed)
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/lib/hoister.js
var require_hoister = __commonJS({
  "../node_modules/@babel/traverse/lib/path/lib/hoister.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _t = require_lib4(), _t2 = _t, {
      react
    } = _t, {
      cloneNode,
      jsxExpressionContainer,
      variableDeclaration,
      variableDeclarator
    } = _t2, referenceVisitor = {
      ReferencedIdentifier(path, state) {
        if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression())
          return;
        if (path.node.name === "this") {
          let scope = path.scope;
          do
            if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression())
              break;
          while (scope = scope.parent);
          scope && state.breakOnScopePaths.push(scope.path);
        }
        let binding = path.scope.getBinding(path.node.name);
        if (binding) {
          for (let violation of binding.constantViolations)
            if (violation.scope !== binding.path.scope) {
              state.mutableBinding = !0, path.stop();
              return;
            }
          binding === state.scope.getBinding(path.node.name) && (state.bindings[path.node.name] = binding);
        }
      }
    }, PathHoister = class {
      constructor(path, scope) {
        this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = scope, this.path = path, this.attachAfter = !1;
      }
      isCompatibleScope(scope) {
        for (let key of Object.keys(this.bindings)) {
          let binding = this.bindings[key];
          if (!scope.bindingIdentifierEquals(key, binding.identifier))
            return !1;
        }
        return !0;
      }
      getCompatibleScopes() {
        let scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope))
            this.scopes.push(scope);
          else
            break;
          if (this.breakOnScopePaths.includes(scope.path))
            break;
        } while (scope = scope.parent);
      }
      getAttachmentPath() {
        let path = this._getAttachmentPath();
        if (!path) return;
        let targetScope = path.scope;
        if (targetScope.path === path && (targetScope = path.scope.parent), targetScope.path.isProgram() || targetScope.path.isFunction())
          for (let name of Object.keys(this.bindings)) {
            if (!targetScope.hasOwnBinding(name)) continue;
            let binding = this.bindings[name];
            if (binding.kind === "param" || binding.path.parentKey === "params")
              continue;
            if (this.getAttachmentParentForPath(binding.path).key >= path.key) {
              this.attachAfter = !0, path = binding.path;
              for (let violationPath of binding.constantViolations)
                this.getAttachmentParentForPath(violationPath).key > path.key && (path = violationPath);
            }
          }
        return path;
      }
      _getAttachmentPath() {
        let scope = this.scopes.pop();
        if (scope) {
          if (scope.path.isFunction())
            if (this.hasOwnParamBindings(scope)) {
              if (this.scope === scope) return;
              let bodies = scope.path.get("body").get("body");
              for (let i = 0; i < bodies.length; i++)
                if (!bodies[i].node._blockHoist)
                  return bodies[i];
            } else
              return this.getNextScopeAttachmentParent();
          else if (scope.path.isProgram())
            return this.getNextScopeAttachmentParent();
        }
      }
      getNextScopeAttachmentParent() {
        let scope = this.scopes.pop();
        if (scope) return this.getAttachmentParentForPath(scope.path);
      }
      getAttachmentParentForPath(path) {
        do
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement())
            return path;
        while (path = path.parentPath);
        return path;
      }
      hasOwnParamBindings(scope) {
        for (let name of Object.keys(this.bindings)) {
          if (!scope.hasOwnBinding(name)) continue;
          let binding = this.bindings[name];
          if (binding.kind === "param" && binding.constant) return !0;
        }
        return !1;
      }
      run() {
        if (this.path.traverse(referenceVisitor, this), this.mutableBinding) return;
        this.getCompatibleScopes();
        let attachTo = this.getAttachmentPath();
        if (!attachTo || attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
        let uid = attachTo.scope.generateUidIdentifier("ref"), declarator = variableDeclarator(uid, this.path.node), insertFn = this.attachAfter ? "insertAfter" : "insertBefore", [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]), parent = this.path.parentPath;
        return parent.isJSXElement() && this.path.container === parent.node.children && (uid = jsxExpressionContainer(uid)), this.path.replaceWith(cloneNode(uid)), attached.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
      }
    };
    exports.default = PathHoister;
  }
});

// ../node_modules/@babel/traverse/lib/path/modification.js
var require_modification = __commonJS({
  "../node_modules/@babel/traverse/lib/path/modification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports._containerInsert = _containerInsert;
    exports._containerInsertAfter = _containerInsertAfter;
    exports._containerInsertBefore = _containerInsertBefore;
    exports._verifyNodeList = _verifyNodeList;
    exports.insertAfter = insertAfter;
    exports.insertBefore = insertBefore;
    exports.pushContainer = pushContainer;
    exports.unshiftContainer = unshiftContainer;
    exports.updateSiblingKeys = updateSiblingKeys;
    var _cache = require_cache(), _index = require_path(), _context = require_context2(), _removal = require_removal(), _t = require_lib4(), _hoister = require_hoister(), {
      arrowFunctionExpression,
      assertExpression,
      assignmentExpression,
      blockStatement,
      callExpression,
      cloneNode,
      expressionStatement,
      isAssignmentExpression,
      isCallExpression,
      isExportNamedDeclaration,
      isExpression,
      isIdentifier,
      isSequenceExpression,
      isSuper,
      thisExpression
    } = _t;
    function insertBefore(nodes_) {
      _removal._assertUnremoved.call(this);
      let nodes = _verifyNodeList.call(this, nodes_), {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration())
        return parentPath.insertBefore(nodes);
      if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init")
        return this.node && nodes.push(this.node), this.replaceExpressionWithStatements(nodes);
      if (Array.isArray(this.container))
        return _containerInsertBefore.call(this, nodes);
      if (this.isStatementOrBlock()) {
        let node = this.node, shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null), [blockPath] = this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
        return blockPath.unshiftContainer("body", nodes);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
    function _containerInsert(from, nodes) {
      updateSiblingKeys.call(this, from, nodes.length);
      let paths = [];
      this.container.splice(from, 0, ...nodes);
      for (let i = 0; i < nodes.length; i++) {
        var _this$context;
        let to = from + i, path = this.getSibling(to);
        paths.push(path), (_this$context = this.context) != null && _this$context.queue && _context.pushContext.call(path, this.context);
      }
      let contexts = _context._getQueueContexts.call(this);
      for (let path of paths) {
        _context.setScope.call(path), path.debug("Inserted.");
        for (let context of contexts)
          context.maybeQueue(path, !0);
      }
      return paths;
    }
    function _containerInsertBefore(nodes) {
      return _containerInsert.call(this, this.key, nodes);
    }
    function _containerInsertAfter(nodes) {
      return _containerInsert.call(this, this.key + 1, nodes);
    }
    var last = (arr) => arr[arr.length - 1];
    function isHiddenInSequenceExpression(path) {
      return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
    }
    function isAlmostConstantAssignment(node, scope) {
      if (!isAssignmentExpression(node) || !isIdentifier(node.left))
        return !1;
      let blockScope = scope.getBlockParent();
      return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
    }
    function insertAfter(nodes_) {
      if (_removal._assertUnremoved.call(this), this.isSequenceExpression())
        return last(this.get("expressions")).insertAfter(nodes_);
      let nodes = _verifyNodeList.call(this, nodes_), {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration())
        return parentPath.insertAfter(nodes.map((node) => isExpression(node) ? expressionStatement(node) : node));
      if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        let self2 = this;
        if (self2.node) {
          let node = self2.node, {
            scope
          } = this;
          if (scope.path.isPattern())
            return assertExpression(node), self2.replaceWith(callExpression(arrowFunctionExpression([], node), [])), self2.get("callee.body").insertAfter(nodes), [self2];
          if (isHiddenInSequenceExpression(self2))
            nodes.unshift(node);
          else if (isCallExpression(node) && isSuper(node.callee))
            nodes.unshift(node), nodes.push(thisExpression());
          else if (isAlmostConstantAssignment(node, scope))
            nodes.unshift(node), nodes.push(cloneNode(node.left));
          else if (scope.isPure(node, !0))
            nodes.push(node);
          else {
            parentPath.isMethod({
              computed: !0,
              key: node
            }) && (scope = scope.parent);
            let temp = scope.generateDeclaredUidIdentifier();
            nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node))), nodes.push(expressionStatement(cloneNode(temp)));
          }
        }
        return this.replaceExpressionWithStatements(nodes);
      } else {
        if (Array.isArray(this.container))
          return _containerInsertAfter.call(this, nodes);
        if (this.isStatementOrBlock()) {
          let node = this.node, shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null), [blockPath] = this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
          return blockPath.pushContainer("body", nodes);
        } else
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent) return;
      let paths = (0, _cache.getCachedPaths)(this);
      if (paths)
        for (let [, path] of paths)
          typeof path.key == "number" && path.container === this.container && path.key >= fromIndex && (path.key += incrementBy);
    }
    function _verifyNodeList(nodes) {
      if (!nodes)
        return [];
      Array.isArray(nodes) || (nodes = [nodes]);
      for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i], msg;
        if (node ? typeof node != "object" ? msg = "contains a non-object node" : node.type ? node instanceof _index.default && (msg = "has a NodePath when it expected a raw object") : msg = "without a type" : msg = "has falsy node", msg) {
          let type = Array.isArray(node) ? "array" : typeof node;
          throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
        }
      }
      return nodes;
    }
    function unshiftContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      let verifiedNodes = _verifyNodeList.call(this, nodes), container = this.node[listKey], path = _index.default.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: 0
      }).setContext(this.context);
      return _containerInsertBefore.call(path, verifiedNodes);
    }
    function pushContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      let verifiedNodes = _verifyNodeList.call(this, nodes), container = this.node[listKey];
      return _index.default.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: container.length
      }).setContext(this.context).replaceWithMultiple(verifiedNodes);
    }
    exports.hoist = function(scope = this.scope) {
      return new _hoister.default(this, scope).run();
    };
  }
});

// ../node_modules/@babel/traverse/lib/path/replacement.js
var require_replacement = __commonJS({
  "../node_modules/@babel/traverse/lib/path/replacement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports._replaceWith = _replaceWith;
    exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
    exports.replaceInline = replaceInline;
    exports.replaceWith = replaceWith;
    exports.replaceWithMultiple = replaceWithMultiple;
    exports.replaceWithSourceString = replaceWithSourceString;
    var _codeFrame = require_lib6(), _index = require_lib10(), _index2 = require_path(), _cache = require_cache(), _modification = require_modification(), _parser = require_lib5(), _t = require_lib4(), _context = require_context2(), {
      FUNCTION_TYPES,
      arrowFunctionExpression,
      assignmentExpression,
      awaitExpression,
      blockStatement,
      buildUndefinedNode,
      callExpression,
      cloneNode,
      conditionalExpression,
      expressionStatement,
      getBindingIdentifiers,
      identifier,
      inheritLeadingComments,
      inheritTrailingComments,
      inheritsComments,
      isBlockStatement,
      isEmptyStatement,
      isExpression,
      isExpressionStatement,
      isIfStatement,
      isProgram,
      isStatement,
      isVariableDeclaration,
      removeComments,
      returnStatement,
      sequenceExpression,
      validate,
      yieldExpression
    } = _t;
    function replaceWithMultiple(nodes) {
      var _getCachedPaths;
      _context.resync.call(this);
      let verifiedNodes = _modification._verifyNodeList.call(this, nodes);
      inheritLeadingComments(verifiedNodes[0], this.node), inheritTrailingComments(verifiedNodes[verifiedNodes.length - 1], this.node), (_getCachedPaths = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths.delete(this.node), this.node = this.container[this.key] = null;
      let paths = this.insertAfter(nodes);
      return this.node ? this.requeue() : this.remove(), paths;
    }
    function replaceWithSourceString(replacement) {
      _context.resync.call(this);
      let ast;
      try {
        replacement = `(${replacement})`, ast = (0, _parser.parse)(replacement);
      } catch (err) {
        let loc = err.loc;
        throw loc && (err.message += ` - make sure this is an expression.
` + (0, _codeFrame.codeFrameColumns)(replacement, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        }), err.code = "BABEL_REPLACE_SOURCE_ERROR"), err;
      }
      let expressionAST = ast.program.body[0].expression;
      return _index.default.removeProperties(expressionAST), this.replaceWith(expressionAST);
    }
    function replaceWith(replacementPath) {
      if (_context.resync.call(this), this.removed)
        throw new Error("You can't replace this node, we've already removed it");
      let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
      if (!replacement)
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      if (this.node === replacement)
        return [this];
      if (this.isProgram() && !isProgram(replacement))
        throw new Error("You can only replace a Program root node with another Program node");
      if (Array.isArray(replacement))
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      if (typeof replacement == "string")
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      let nodePath = "";
      if (this.isNodeType("Statement") && isExpression(replacement) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration() && (replacement = expressionStatement(replacement), nodePath = "expression"), this.isNodeType("Expression") && isStatement(replacement) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement))
        return this.replaceExpressionWithStatements([replacement]);
      let oldNode = this.node;
      return oldNode && (inheritsComments(replacement, oldNode), removeComments(oldNode)), _replaceWith.call(this, replacement), this.type = replacement.type, _context.setScope.call(this), this.requeue(), [nodePath ? this.get(nodePath) : this];
    }
    function _replaceWith(node) {
      var _getCachedPaths2;
      if (!this.container)
        throw new ReferenceError("Container is falsy");
      this.inList ? validate(this.parent, this.key, [node]) : validate(this.parent, this.key, node), this.debug(`Replace with ${node?.type}`), (_getCachedPaths2 = (0, _cache.getCachedPaths)(this)) == null || _getCachedPaths2.set(node, this).delete(this.node), this.node = node, this.container[this.key] = node;
    }
    function replaceExpressionWithStatements(nodes) {
      _context.resync.call(this);
      let declars = [], nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);
      if (nodesAsSingleExpression) {
        for (let id of declars) this.scope.push({
          id
        });
        return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
      }
      let functionParent = this.getFunctionParent(), isParentAsync = functionParent?.node.async, isParentGenerator = functionParent?.node.generator, container = arrowFunctionExpression([], blockStatement(nodes));
      this.replaceWith(callExpression(container, []));
      let callee = this.get("callee");
      callee.get("body").scope.hoistVariables((id) => this.scope.push({
        id
      }));
      let completionRecords = callee.getCompletionRecords();
      for (let path of completionRecords) {
        if (!path.isExpressionStatement()) continue;
        let loop = path.findParent((path2) => path2.isLoop());
        if (loop) {
          let uid = loop.getData("expressionReplacementReturnUid");
          uid ? uid = identifier(uid.name) : (uid = callee.scope.generateDeclaredUidIdentifier("ret"), callee.get("body").pushContainer("body", returnStatement(cloneNode(uid))), loop.setData("expressionReplacementReturnUid", uid)), path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
        } else
          path.replaceWith(returnStatement(path.node.expression));
      }
      callee.arrowFunctionToExpression();
      let newCallee = callee, needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES), needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
      return needToAwaitFunction && (newCallee.set("async", !0), needToYieldFunction || this.replaceWith(awaitExpression(this.node))), needToYieldFunction && (newCallee.set("generator", !0), this.replaceWith(yieldExpression(this.node, !0))), newCallee.get("body.body");
    }
    function gatherSequenceExpressions(nodes, declars) {
      let exprs = [], ensureLastUndefined = !0;
      for (let node of nodes)
        if (isEmptyStatement(node) || (ensureLastUndefined = !1), isExpression(node))
          exprs.push(node);
        else if (isExpressionStatement(node))
          exprs.push(node.expression);
        else if (isVariableDeclaration(node)) {
          if (node.kind !== "var") return;
          for (let declar of node.declarations) {
            let bindings = getBindingIdentifiers(declar);
            for (let key of Object.keys(bindings))
              declars.push(cloneNode(bindings[key]));
            declar.init && exprs.push(assignmentExpression("=", declar.id, declar.init));
          }
          ensureLastUndefined = !0;
        } else if (isIfStatement(node)) {
          let consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode(), alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode();
          if (!consequent || !alternate) return;
          exprs.push(conditionalExpression(node.test, consequent, alternate));
        } else if (isBlockStatement(node)) {
          let body = gatherSequenceExpressions(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if (isEmptyStatement(node))
          nodes.indexOf(node) === 0 && (ensureLastUndefined = !0);
        else
          return;
      return ensureLastUndefined && exprs.push(buildUndefinedNode()), exprs.length === 1 ? exprs[0] : sequenceExpression(exprs);
    }
    function replaceInline(nodes) {
      if (_context.resync.call(this), Array.isArray(nodes))
        if (Array.isArray(this.container)) {
          nodes = _modification._verifyNodeList.call(this, nodes);
          let paths = _modification._containerInsertAfter.call(this, nodes);
          return this.remove(), paths;
        } else
          return this.replaceWithMultiple(nodes);
      else
        return this.replaceWith(nodes);
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/evaluation.js
var require_evaluation = __commonJS({
  "../node_modules/@babel/traverse/lib/path/evaluation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.evaluate = evaluate;
    exports.evaluateTruthy = evaluateTruthy;
    var VALID_OBJECT_CALLEES = ["Number", "String", "Math"], VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], INVALID_METHODS = ["random"];
    function isValidObjectCallee(val) {
      return VALID_OBJECT_CALLEES.includes(val);
    }
    function isValidIdentifierCallee(val) {
      return VALID_IDENTIFIER_CALLEES.includes(val);
    }
    function isInvalidMethod(val) {
      return INVALID_METHODS.includes(val);
    }
    function evaluateTruthy() {
      let res = this.evaluate();
      if (res.confident) return !!res.value;
    }
    function deopt(path, state) {
      state.confident && (state.deoptPath = path, state.confident = !1);
    }
    var Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
    function evaluateCached(path, state) {
      let {
        node
      } = path, {
        seen
      } = state;
      if (seen.has(node)) {
        let existing = seen.get(node);
        if (existing.resolved)
          return existing.value;
        deopt(path, state);
        return;
      } else {
        let item = {
          resolved: !1
        };
        seen.set(node, item);
        let val = _evaluate(path, state);
        return state.confident && (item.resolved = !0, item.value = val), val;
      }
    }
    function _evaluate(path, state) {
      if (state.confident) {
        if (path.isSequenceExpression()) {
          let exprs = path.get("expressions");
          return evaluateCached(exprs[exprs.length - 1], state);
        }
        if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral())
          return path.node.value;
        if (path.isNullLiteral())
          return null;
        if (path.isTemplateLiteral())
          return evaluateQuasis(path, path.node.quasis, state);
        if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
          let object = path.get("tag.object"), {
            node: {
              name
            }
          } = object, property = path.get("tag.property");
          if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw")
            return evaluateQuasis(path, path.node.quasi.quasis, state, !0);
        }
        if (path.isConditionalExpression()) {
          let testResult = evaluateCached(path.get("test"), state);
          return state.confident ? evaluateCached(testResult ? path.get("consequent") : path.get("alternate"), state) : void 0;
        }
        if (path.isExpressionWrapper())
          return evaluateCached(path.get("expression"), state);
        if (path.isMemberExpression() && !path.parentPath.isCallExpression({
          callee: path.node
        })) {
          let property = path.get("property"), object = path.get("object");
          if (object.isLiteral()) {
            let value2 = object.node.value, type = typeof value2, key = null;
            if (path.node.computed) {
              if (key = evaluateCached(property, state), !state.confident) return;
            } else property.isIdentifier() && (key = property.node.name);
            if ((type === "number" || type === "string") && key != null && (typeof key == "number" || typeof key == "string"))
              return value2[key];
          }
        }
        if (path.isReferencedIdentifier()) {
          let binding = path.scope.getBinding(path.node.name);
          if (binding) {
            if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {
              deopt(binding.path, state);
              return;
            }
            let bindingPathScope = binding.path.scope;
            if (binding.kind === "var" && bindingPathScope !== binding.scope) {
              let hasUnsafeBlock = !bindingPathScope.path.parentPath.isBlockStatement();
              for (let scope = bindingPathScope.parent; scope; scope = scope.parent) {
                var _scope$path$parentPat;
                if (scope === path.scope) {
                  if (hasUnsafeBlock) {
                    deopt(binding.path, state);
                    return;
                  }
                  break;
                }
                (_scope$path$parentPat = scope.path.parentPath) != null && _scope$path$parentPat.isBlockStatement() && (hasUnsafeBlock = !0);
              }
            }
            if (binding.hasValue)
              return binding.value;
          }
          let name = path.node.name;
          if (Globals.has(name)) {
            if (!binding)
              return Globals.get(name);
            deopt(binding.path, state);
            return;
          }
          let resolved = path.resolve();
          if (resolved === path) {
            deopt(path, state);
            return;
          }
          let value2 = evaluateCached(resolved, state);
          if (typeof value2 == "object" && value2 !== null && binding.references > 1) {
            deopt(resolved, state);
            return;
          }
          return value2;
        }
        if (path.isUnaryExpression({
          prefix: !0
        })) {
          if (path.node.operator === "void")
            return;
          let argument = path.get("argument");
          if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass()))
            return "function";
          let arg = evaluateCached(argument, state);
          if (!state.confident) return;
          switch (path.node.operator) {
            case "!":
              return !arg;
            case "+":
              return +arg;
            case "-":
              return -arg;
            case "~":
              return ~arg;
            case "typeof":
              return typeof arg;
          }
        }
        if (path.isArrayExpression()) {
          let arr = [], elems = path.get("elements");
          for (let elem of elems) {
            let elemValue = elem.evaluate();
            if (elemValue.confident)
              arr.push(elemValue.value);
            else {
              deopt(elemValue.deopt, state);
              return;
            }
          }
          return arr;
        }
        if (path.isObjectExpression()) {
          let obj = {}, props = path.get("properties");
          for (let prop of props) {
            if (prop.isObjectMethod() || prop.isSpreadElement()) {
              deopt(prop, state);
              return;
            }
            let keyPath = prop.get("key"), key;
            if (prop.node.computed) {
              if (key = keyPath.evaluate(), !key.confident) {
                deopt(key.deopt, state);
                return;
              }
              key = key.value;
            } else keyPath.isIdentifier() ? key = keyPath.node.name : key = keyPath.node.value;
            let value2 = prop.get("value").evaluate();
            if (!value2.confident) {
              deopt(value2.deopt, state);
              return;
            }
            value2 = value2.value, obj[key] = value2;
          }
          return obj;
        }
        if (path.isLogicalExpression()) {
          let wasConfident = state.confident, left = evaluateCached(path.get("left"), state), leftConfident = state.confident;
          state.confident = wasConfident;
          let right = evaluateCached(path.get("right"), state), rightConfident = state.confident;
          switch (path.node.operator) {
            case "||":
              return state.confident = leftConfident && (!!left || rightConfident), state.confident ? left || right : void 0;
            case "&&":
              return state.confident = leftConfident && (!left || rightConfident), state.confident ? left && right : void 0;
            case "??":
              return state.confident = leftConfident && (left != null || rightConfident), state.confident ? left ?? right : void 0;
          }
        }
        if (path.isBinaryExpression()) {
          let left = evaluateCached(path.get("left"), state);
          if (!state.confident) return;
          let right = evaluateCached(path.get("right"), state);
          if (!state.confident) return;
          switch (path.node.operator) {
            case "-":
              return left - right;
            case "+":
              return left + right;
            case "/":
              return left / right;
            case "*":
              return left * right;
            case "%":
              return left % right;
            case "**":
              return Math.pow(left, right);
            case "<":
              return left < right;
            case ">":
              return left > right;
            case "<=":
              return left <= right;
            case ">=":
              return left >= right;
            case "==":
              return left == right;
            case "!=":
              return left != right;
            case "===":
              return left === right;
            case "!==":
              return left !== right;
            case "|":
              return left | right;
            case "&":
              return left & right;
            case "^":
              return left ^ right;
            case "<<":
              return left << right;
            case ">>":
              return left >> right;
            case ">>>":
              return left >>> right;
          }
        }
        if (path.isCallExpression()) {
          let callee = path.get("callee"), context, func;
          if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name)) && (func = global[callee.node.name]), callee.isMemberExpression()) {
            let object = callee.get("object"), property = callee.get("property");
            if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
              context = global[object.node.name];
              let key = property.node.name;
              hasOwnProperty.call(context, key) && (func = context[key]);
            }
            if (object.isLiteral() && property.isIdentifier()) {
              let type = typeof object.node.value;
              (type === "string" || type === "number") && (context = object.node.value, func = context[property.node.name]);
            }
          }
          if (func) {
            let args = path.get("arguments").map((arg) => evaluateCached(arg, state));
            return state.confident ? func.apply(context, args) : void 0;
          }
        }
        deopt(path, state);
      }
    }
    function evaluateQuasis(path, quasis, state, raw = !1) {
      let str = "", i = 0, exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");
      for (let elem of quasis) {
        if (!state.confident) break;
        str += raw ? elem.value.raw : elem.value.cooked;
        let expr = exprs[i++];
        expr && (str += String(evaluateCached(expr, state)));
      }
      if (state.confident)
        return str;
    }
    function evaluate() {
      let state = {
        confident: !0,
        deoptPath: null,
        seen: /* @__PURE__ */ new Map()
      }, value2 = evaluateCached(this, state);
      return state.confident || (value2 = void 0), {
        confident: state.confident,
        deopt: state.deoptPath,
        value: value2
      };
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/conversion.js
var require_conversion = __commonJS({
  "../node_modules/@babel/traverse/lib/path/conversion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.arrowFunctionToExpression = arrowFunctionToExpression;
    exports.ensureBlock = ensureBlock;
    exports.ensureFunctionName = ensureFunctionName;
    exports.splitExportDeclaration = splitExportDeclaration;
    exports.toComputedKey = toComputedKey;
    exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
    var _t = require_lib4(), _template = require_lib7(), _visitors = require_visitors(), _context = require_context2(), {
      arrowFunctionExpression,
      assignmentExpression,
      binaryExpression,
      blockStatement,
      callExpression,
      conditionalExpression,
      expressionStatement,
      identifier,
      isIdentifier,
      jsxIdentifier,
      logicalExpression,
      LOGICAL_OPERATORS,
      memberExpression,
      metaProperty,
      numericLiteral,
      objectExpression,
      restElement,
      returnStatement,
      sequenceExpression,
      spreadElement,
      stringLiteral,
      super: _super,
      thisExpression,
      toExpression,
      unaryExpression,
      toBindingIdentifierName,
      isFunction,
      isAssignmentPattern,
      isRestElement,
      getFunctionName,
      cloneNode,
      variableDeclaration,
      variableDeclarator,
      exportNamedDeclaration,
      exportSpecifier,
      inherits
    } = _t;
    function toComputedKey() {
      let key;
      if (this.isMemberExpression())
        key = this.node.property;
      else if (this.isProperty() || this.isMethod())
        key = this.node.key;
      else
        throw new ReferenceError("todo");
      return this.node.computed || isIdentifier(key) && (key = stringLiteral(key.name)), key;
    }
    function ensureBlock() {
      let body = this.get("body"), bodyNode = body.node;
      if (Array.isArray(body))
        throw new Error("Can't convert array path to a block statement");
      if (!bodyNode)
        throw new Error("Can't convert node without a body");
      if (body.isBlockStatement())
        return bodyNode;
      let statements = [], stringPath = "body", key, listKey;
      body.isStatement() ? (listKey = "body", key = 0, statements.push(body.node)) : (stringPath += ".body.0", this.isFunction() ? (key = "argument", statements.push(returnStatement(body.node))) : (key = "expression", statements.push(expressionStatement(body.node)))), this.node.body = blockStatement(statements);
      let parentPath = this.get(stringPath);
      return _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key), this.node;
    }
    exports.arrowFunctionToShadowed = function() {
      this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
    };
    function unwrapFunctionEnvironment() {
      if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
        throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
      hoistFunctionEnvironment(this);
    }
    function setType(path, type) {
      path.node.type = type;
    }
    function arrowFunctionToExpression({
      allowInsertArrow = !0,
      allowInsertArrowWithRest = allowInsertArrow,
      noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()
    } = {}) {
      if (!this.isArrowFunctionExpression())
        throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
      let self2 = this;
      if (!noNewArrows) {
        var _self$ensureFunctionN;
        self2 = (_self$ensureFunctionN = self2.ensureFunctionName(!1)) != null ? _self$ensureFunctionN : self2;
      }
      let {
        thisBinding,
        fnPath: fn
      } = hoistFunctionEnvironment(self2, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
      if (fn.ensureBlock(), setType(fn, "FunctionExpression"), !noNewArrows) {
        let checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
        return checkBinding && fn.parentPath.scope.push({
          id: checkBinding,
          init: objectExpression([])
        }), fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), identifier(checkBinding ? checkBinding.name : thisBinding)]))), fn.replaceWith(callExpression(memberExpression(fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()])), fn.get("callee.object");
      }
      return fn;
    }
    var getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        allSuperCalls
      }) {
        child.get("callee").isSuper() && allSuperCalls.push(child);
      }
    });
    function hoistFunctionEnvironment(fnPath, noNewArrows = !0, allowInsertArrow = !0, allowInsertArrowWithRest = !0) {
      let arrowParent, thisEnvFn = fnPath.findParent((p) => p.isArrowFunctionExpression() ? (arrowParent ?? (arrowParent = p), !1) : p.isFunction() || p.isProgram() || p.isClassProperty({
        static: !1
      }) || p.isClassPrivateProperty({
        static: !1
      })), inConstructor = thisEnvFn.isClassMethod({
        kind: "constructor"
      });
      if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty())
        if (arrowParent)
          thisEnvFn = arrowParent;
        else if (allowInsertArrow)
          fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), [])), thisEnvFn = fnPath.get("callee"), fnPath = thisEnvFn.get("body");
        else
          throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
      let {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      } = getScopeInformation(fnPath);
      if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow)
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        if (!allowInsertArrowWithRest)
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        let allSuperCalls = [];
        thisEnvFn.traverse(getSuperCallsVisitor, {
          allSuperCalls
        });
        let superBinding = getSuperBinding(thisEnvFn);
        allSuperCalls.forEach((superCall) => {
          let callee = identifier(superBinding);
          callee.loc = superCall.node.callee.loc, superCall.get("callee").replaceWith(callee);
        });
      }
      if (argumentsPaths.length > 0) {
        let argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
          let args = () => identifier("arguments");
          return thisEnvFn.scope.path.isProgram() ? conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args()) : args();
        });
        argumentsPaths.forEach((argumentsChild) => {
          let argsRef = identifier(argumentsBinding);
          argsRef.loc = argumentsChild.node.loc, argumentsChild.replaceWith(argsRef);
        });
      }
      if (newTargetPaths.length > 0) {
        let newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
        newTargetPaths.forEach((targetChild) => {
          let targetRef = identifier(newTargetBinding);
          targetRef.loc = targetChild.node.loc, targetChild.replaceWith(targetRef);
        });
      }
      if (superProps.length > 0) {
        if (!allowInsertArrow)
          throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []).forEach((superProp) => {
          let key = superProp.node.computed ? "" : superProp.get("property").node.name, superParentPath = superProp.parentPath, isAssignment = superParentPath.isAssignmentExpression({
            left: superProp.node
          }), isCall = superParentPath.isCallExpression({
            callee: superProp.node
          }), isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
            tag: superProp.node
          }), superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key), args = [];
          if (superProp.node.computed && args.push(superProp.get("property").node), isAssignment) {
            let value2 = superParentPath.node.right;
            args.push(value2);
          }
          let call = callExpression(identifier(superBinding), args);
          isCall ? (superParentPath.unshiftContainer("arguments", thisExpression()), superProp.replaceWith(memberExpression(call, identifier("call"))), thisPaths.push(superParentPath.get("arguments.0"))) : isAssignment ? superParentPath.replaceWith(call) : isTaggedTemplate ? (superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), !1), [thisExpression()])), thisPaths.push(superProp.get("arguments.0"))) : superProp.replaceWith(call);
        });
      }
      let thisBinding;
      return (thisPaths.length > 0 || !noNewArrows) && (thisBinding = getThisBinding(thisEnvFn, inConstructor), (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) && (thisPaths.forEach((thisChild) => {
        let thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
        thisRef.loc = thisChild.node.loc, thisChild.replaceWith(thisRef);
      }), noNewArrows || (thisBinding = null))), {
        thisBinding,
        fnPath
      };
    }
    function isLogicalOp(op) {
      return LOGICAL_OPERATORS.includes(op);
    }
    function standardizeSuperProperty(superProp) {
      if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
        let assignmentPath = superProp.parentPath, op = assignmentPath.node.operator.slice(0, -1), value2 = assignmentPath.node.right, isLogicalAssignment = isLogicalOp(op);
        if (superProp.node.computed) {
          let tmp = superProp.scope.generateDeclaredUidIdentifier("tmp"), {
            object,
            property
          } = superProp.node;
          assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), !0)), assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), !0), value2));
        } else {
          let object = superProp.node.object, property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression(object, property)), assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value2));
        }
        return isLogicalAssignment ? assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right)) : assignmentPath.node.operator = "=", [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
      } else if (superProp.parentPath.isUpdateExpression()) {
        let updateExpr = superProp.parentPath, tmp = superProp.scope.generateDeclaredUidIdentifier("tmp"), computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null, parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
        superProp.parentPath.node.prefix || parts.push(identifier(tmp.name)), updateExpr.replaceWith(sequenceExpression(parts));
        let left = updateExpr.get("expressions.0.right"), right = updateExpr.get("expressions.1.left");
        return [left, right];
      }
      return [superProp];
      function rightExpression(op, left, right) {
        return op === "=" ? assignmentExpression("=", left, right) : binaryExpression(op, left, right);
      }
    }
    function hasSuperClass(thisEnvFn) {
      return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
    }
    var assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        supers,
        thisBinding
      }) {
        child.get("callee").isSuper() && (supers.has(child.node) || (supers.add(child.node), child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))])));
      }
    });
    function getThisBinding(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", (thisBinding) => {
        if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
        thisEnvFn.traverse(assignSuperThisVisitor, {
          supers: /* @__PURE__ */ new WeakSet(),
          thisBinding
        });
      });
    }
    function getSuperBinding(thisEnvFn) {
      return getBinding(thisEnvFn, "supercall", () => {
        let argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
        return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
      });
    }
    function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
      return getBinding(thisEnvFn, `superprop_${isAssignment ? "set" : "get"}:${propName || ""}`, () => {
        let argsList = [], fnBody;
        if (propName)
          fnBody = memberExpression(_super(), identifier(propName));
        else {
          let method = thisEnvFn.scope.generateUidIdentifier("prop");
          argsList.unshift(method), fnBody = memberExpression(_super(), identifier(method.name), !0);
        }
        if (isAssignment) {
          let valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
          argsList.push(valueIdent), fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
        }
        return arrowFunctionExpression(argsList, fnBody);
      });
    }
    function getBinding(thisEnvFn, key, init) {
      let cacheKey = "binding:" + key, data = thisEnvFn.getData(cacheKey);
      if (!data) {
        let id = thisEnvFn.scope.generateUidIdentifier(key);
        data = id.name, thisEnvFn.setData(cacheKey, data), thisEnvFn.scope.push({
          id,
          init: init(data)
        });
      }
      return data;
    }
    var getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
      ThisExpression(child, {
        thisPaths
      }) {
        thisPaths.push(child);
      },
      JSXIdentifier(child, {
        thisPaths
      }) {
        child.node.name === "this" && (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        }) || thisPaths.push(child));
      },
      CallExpression(child, {
        superCalls
      }) {
        child.get("callee").isSuper() && superCalls.push(child);
      },
      MemberExpression(child, {
        superProps
      }) {
        child.get("object").isSuper() && superProps.push(child);
      },
      Identifier(child, {
        argumentsPaths
      }) {
        if (!child.isReferencedIdentifier({
          name: "arguments"
        })) return;
        let curr = child.scope;
        do {
          if (curr.hasOwnBinding("arguments")) {
            curr.rename("arguments");
            return;
          }
          if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression())
            break;
        } while (curr = curr.parent);
        argumentsPaths.push(child);
      },
      MetaProperty(child, {
        newTargetPaths
      }) {
        child.get("meta").isIdentifier({
          name: "new"
        }) && child.get("property").isIdentifier({
          name: "target"
        }) && newTargetPaths.push(child);
      }
    });
    function getScopeInformation(fnPath) {
      let thisPaths = [], argumentsPaths = [], newTargetPaths = [], superProps = [], superCalls = [];
      return fnPath.traverse(getScopeInformationVisitor, {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      }), {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      };
    }
    function splitExportDeclaration() {
      if (!this.isExportDeclaration() || this.isExportAllDeclaration())
        throw new Error("Only default and named export declarations can be split.");
      if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0)
        throw new Error("It doesn't make sense to split exported specifiers.");
      let declaration = this.get("declaration");
      if (this.isExportDefaultDeclaration()) {
        let standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration(), exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression(), scope = declaration.isScope() ? declaration.scope.parent : declaration.scope, id = declaration.node.id, needBindingRegistration = !1;
        id ? exportExpr && scope.hasBinding(id.name) && (needBindingRegistration = !0, id = scope.generateUidIdentifier(id.name)) : (needBindingRegistration = !0, id = scope.generateUidIdentifier("default"), (standaloneDeclaration || exportExpr) && (declaration.node.id = cloneNode(id)));
        let updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]), updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
        return this.insertAfter(updatedExportDeclaration), this.replaceWith(updatedDeclaration), needBindingRegistration && scope.registerDeclaration(this), this;
      } else if (this.get("specifiers").length > 0)
        throw new Error("It doesn't make sense to split exported specifiers.");
      let bindingIdentifiers = declaration.getOuterBindingIdentifiers(), specifiers = Object.keys(bindingIdentifiers).map((name) => exportSpecifier(identifier(name), identifier(name))), aliasDeclar = exportNamedDeclaration(null, specifiers);
      return this.insertAfter(aliasDeclar), this.replaceWith(declaration.node), this;
    }
    var refersOuterBindingVisitor = {
      "ReferencedIdentifier|BindingIdentifier"(path, state) {
        path.node.name === state.name && (state.needsRename = !0, path.stop());
      },
      Scope(path, state) {
        path.scope.hasOwnBinding(state.name) && path.skip();
      }
    };
    function ensureFunctionName(supportUnicodeId) {
      if (this.node.id) return this;
      let res = getFunctionName(this.node, this.parent);
      if (res == null) return this;
      let {
        name
      } = res;
      if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name) || name.startsWith("get ") || name.startsWith("set "))
        return null;
      name = toBindingIdentifierName(name.replace(/[/ ]/g, "_"));
      let id = identifier(name);
      inherits(id, res.originalNode);
      let state = {
        needsRename: !1,
        name
      }, {
        scope
      } = this, binding = scope.getOwnBinding(name);
      if (binding ? binding.kind === "param" && (state.needsRename = !0) : (scope.parent.hasBinding(name) || scope.hasGlobal(name)) && this.traverse(refersOuterBindingVisitor, state), !state.needsRename)
        return this.node.id = id, scope.getProgramParent().references[id.name] = !0, this;
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name))
        return scope.rename(id.name), this.node.id = id, scope.getProgramParent().references[id.name] = !0, this;
      if (!isFunction(this.node)) return null;
      let key = scope.generateUidIdentifier(id.name), params = [];
      for (let i = 0, len = getFunctionArity(this.node); i < len; i++)
        params.push(scope.generateUidIdentifier("x"));
      let call = _template.default.expression.ast`
    (function (${key}) {
      function ${id}(${params}) {
        return ${cloneNode(key)}.apply(this, arguments);
      }

      ${cloneNode(id)}.toString = function () {
        return ${cloneNode(key)}.toString();
      }

      return ${cloneNode(id)};
    })(${toExpression(this.node)})
  `;
      return this.replaceWith(call)[0].get("arguments.0");
    }
    function getFunctionArity(node) {
      let count = node.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
      return count === -1 ? node.params.length : count;
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/introspection.js
var require_introspection = __commonJS({
  "../node_modules/@babel/traverse/lib/path/introspection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports._resolve = _resolve;
    exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports.getSource = getSource;
    exports.isCompletionRecord = isCompletionRecord;
    exports.isConstantExpression = isConstantExpression;
    exports.isInStrictMode = isInStrictMode;
    exports.isNodeType = isNodeType;
    exports.isStatementOrBlock = isStatementOrBlock;
    exports.isStatic = isStatic;
    exports.matchesPattern = matchesPattern;
    exports.referencesImport = referencesImport;
    exports.resolve = resolve;
    exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    var _t = require_lib4(), {
      STATEMENT_OR_BLOCK_KEYS,
      VISITOR_KEYS,
      isBlockStatement,
      isExpression,
      isIdentifier,
      isLiteral,
      isStringLiteral,
      isType,
      matchesPattern: _matchesPattern
    } = _t;
    function matchesPattern(pattern, allowPartial) {
      return _matchesPattern(this.node, pattern, allowPartial);
    }
    exports.has = function(key) {
      var _this$node;
      let val = (_this$node = this.node) == null ? void 0 : _this$node[key];
      return val && Array.isArray(val) ? !!val.length : !!val;
    };
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    exports.is = exports.has, exports.isnt = function(key) {
      return !this.has(key);
    }, exports.equals = function(key, value2) {
      return this.node[key] === value2;
    };
    function isNodeType(type) {
      return isType(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? isBlockStatement(replacement) : this.isBlockStatement() ? isExpression(replacement) : !1;
    }
    function isCompletionRecord(allowInsideFunction) {
      let path = this, first = !0;
      do {
        let {
          type,
          container
        } = path;
        if (!first && (path.isFunction() || type === "StaticBlock"))
          return !!allowInsideFunction;
        if (first = !1, Array.isArray(container) && path.key !== container.length - 1)
          return !1;
      } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
      return !0;
    }
    function isStatementOrBlock() {
      return this.parentPath.isLabeledStatement() || isBlockStatement(this.container) ? !1 : STATEMENT_OR_BLOCK_KEYS.includes(this.key);
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          let object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return !1;
      }
      let binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module") return !1;
      let path = binding.path, parent = path.parentPath;
      if (!parent.isImportDeclaration()) return !1;
      if (parent.node.source.value === moduleSource) {
        if (!importName) return !0;
      } else
        return !1;
      return !!(path.isImportDefaultSpecifier() && importName === "default" || path.isImportNamespaceSpecifier() && importName === "*" || path.isImportSpecifier() && isIdentifier(path.node.imported, {
        name: importName
      }));
    }
    function getSource() {
      let node = this.node;
      if (node.end) {
        let code = this.hub.getCode();
        if (code) return code.slice(node.start, node.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path) {
      return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key) {
      switch (type) {
        case "LogicalExpression":
          return key === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";
        case "ForStatement":
          return key === "body" || key === "update";
        case "SwitchStatement":
          return key === "cases";
        case "TryStatement":
          return key === "handler";
        case "AssignmentPattern":
          return key === "right";
        case "OptionalMemberExpression":
          return key === "property";
        case "OptionalCallExpression":
          return key === "arguments";
        default:
          return !1;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        let path = paths[i];
        if (isExecutionUncertain(path.parent.type, path.parentKey))
          return !0;
      }
      return !1;
    }
    var SYMBOL_CHECKING = Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
    }
    function _guessExecutionStatusRelativeToCached(base, target, cache) {
      let funcParent = {
        this: getOuterFunction(base),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node)
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
      let paths = {
        target: target.getAncestry(),
        this: base.getAncestry()
      };
      if (paths.target.includes(base)) return "after";
      if (paths.this.includes(target)) return "before";
      let commonPath, commonIndex = {
        target: 0,
        this: 0
      };
      for (; !commonPath && commonIndex.this < paths.this.length; ) {
        let path = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path), commonIndex.target >= 0 ? commonPath = path : commonIndex.this++;
      }
      if (!commonPath)
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1))
        return "unknown";
      let divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container)
        return divergence.target.key > divergence.this.key ? "before" : "after";
      let keys = VISITOR_KEYS[commonPath.type], keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {
      if (target.isFunctionDeclaration()) {
        if (target.parentPath.isExportDeclaration())
          return "unknown";
      } else return _guessExecutionStatusRelativeToCached(base, target, cache) === "before" ? "before" : "unknown";
      let binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references) return "before";
      let referencePaths = binding.referencePaths, allStatus;
      for (let path of referencePaths) {
        if (!!path.find((path2) => path2.node === target.node)) continue;
        if (path.key !== "callee" || !path.parentPath.isCallExpression())
          return "unknown";
        let status = _guessExecutionStatusRelativeToCached(base, path, cache);
        if (allStatus && allStatus !== status)
          return "unknown";
        allStatus = status;
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {
      let nodeMap = cache.get(base.node), cached;
      if (!nodeMap)
        cache.set(base.node, nodeMap = /* @__PURE__ */ new Map());
      else if (cached = nodeMap.get(target.node))
        return cached === SYMBOL_CHECKING ? "unknown" : cached;
      nodeMap.set(target.node, SYMBOL_CHECKING);
      let result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
      return nodeMap.set(target.node, result), result;
    }
    function resolve(dangerous, resolved) {
      return _resolve.call(this, dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      var _resolved;
      if (!((_resolved = resolved) != null && _resolved.includes(this)))
        if (resolved = resolved || [], resolved.push(this), this.isVariableDeclarator()) {
          if (this.get("id").isIdentifier())
            return this.get("init").resolve(dangerous, resolved);
        } else if (this.isReferencedIdentifier()) {
          let binding = this.scope.getBinding(this.node.name);
          if (!binding || !binding.constant || binding.kind === "module") return;
          if (binding.path !== this) {
            let ret = binding.path.resolve(dangerous, resolved);
            return this.find((parent) => parent.node === ret.node) ? void 0 : ret;
          }
        } else {
          if (this.isTypeCastExpression())
            return this.get("expression").resolve(dangerous, resolved);
          if (dangerous && this.isMemberExpression()) {
            let targetKey = this.toComputedKey();
            if (!isLiteral(targetKey)) return;
            let targetName = targetKey.value, target = this.get("object").resolve(dangerous, resolved);
            if (target.isObjectExpression()) {
              let props = target.get("properties");
              for (let prop of props) {
                if (!prop.isProperty()) continue;
                let key = prop.get("key"), match = prop.isnt("computed") && key.isIdentifier({
                  name: targetName
                });
                if (match = match || key.isLiteral({
                  value: targetName
                }), match) return prop.get("value").resolve(dangerous, resolved);
              }
            } else if (target.isArrayExpression() && !isNaN(+targetName)) {
              let elem = target.get("elements")[targetName];
              if (elem) return elem.resolve(dangerous, resolved);
            }
          }
        }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        let binding = this.scope.getBinding(this.node.name);
        return binding ? binding.constant : !1;
      }
      if (this.isLiteral())
        return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((expression) => expression.isConstantExpression()) : !0;
      if (this.isUnaryExpression())
        return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
      if (this.isBinaryExpression()) {
        let {
          operator
        } = this.node;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
        name: "Symbol"
      }) && !this.scope.hasBinding("Symbol", {
        noGlobals: !0
      }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
        noGlobals: !0
      }) && this.get("arguments")[0].isStringLiteral() : !1;
    }
    function isInStrictMode() {
      return !!(this.isProgram() ? this : this.parentPath).find((path) => {
        if (path.isProgram({
          sourceType: "module"
        }) || path.isClass()) return !0;
        if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement())
          return !1;
        let body;
        if (path.isFunction())
          body = path.node.body;
        else if (path.isProgram())
          body = path.node;
        else
          return !1;
        for (let directive of body.directives)
          if (directive.value.value === "use strict")
            return !0;
        return !1;
      });
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/family.js
var require_family = __commonJS({
  "../node_modules/@babel/traverse/lib/path/family.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports._getKey = _getKey;
    exports._getPattern = _getPattern;
    exports.get = get;
    exports.getAllNextSiblings = getAllNextSiblings;
    exports.getAllPrevSiblings = getAllPrevSiblings;
    exports.getAssignmentIdentifiers = getAssignmentIdentifiers;
    exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
    exports.getBindingIdentifiers = getBindingIdentifiers;
    exports.getCompletionRecords = getCompletionRecords;
    exports.getNextSibling = getNextSibling;
    exports.getOpposite = getOpposite;
    exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
    exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
    exports.getPrevSibling = getPrevSibling;
    exports.getSibling = getSibling;
    var _index = require_path(), _t = require_lib4(), {
      getAssignmentIdentifiers: _getAssignmentIdentifiers,
      getBindingIdentifiers: _getBindingIdentifiers,
      getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
      numericLiteral,
      unaryExpression
    } = _t, NORMAL_COMPLETION = 0, BREAK_COMPLETION = 1;
    function NormalCompletion(path) {
      return {
        type: NORMAL_COMPLETION,
        path
      };
    }
    function BreakCompletion(path) {
      return {
        type: BREAK_COMPLETION,
        path
      };
    }
    function getOpposite() {
      return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
    }
    function addCompletionRecords(path, records, context) {
      return path && records.push(..._getCompletionRecords(path, context)), records;
    }
    function completionRecordForSwitch(cases, records, context) {
      let lastNormalCompletions = [];
      for (let i = 0; i < cases.length; i++) {
        let casePath = cases[i], caseCompletions = _getCompletionRecords(casePath, context), normalCompletions = [], breakCompletions = [];
        for (let c of caseCompletions)
          c.type === NORMAL_COMPLETION && normalCompletions.push(c), c.type === BREAK_COMPLETION && breakCompletions.push(c);
        normalCompletions.length && (lastNormalCompletions = normalCompletions), records.push(...breakCompletions);
      }
      return records.push(...lastNormalCompletions), records;
    }
    function normalCompletionToBreak(completions) {
      completions.forEach((c) => {
        c.type = BREAK_COMPLETION;
      });
    }
    function replaceBreakStatementInBreakCompletion(completions, reachable) {
      completions.forEach((c) => {
        c.path.isBreakStatement({
          label: null
        }) && (reachable ? c.path.replaceWith(unaryExpression("void", numericLiteral(0))) : c.path.remove());
      });
    }
    function getStatementListCompletion(paths, context) {
      let completions = [];
      if (context.canHaveBreak) {
        let lastNormalCompletions = [];
        for (let i = 0; i < paths.length; i++) {
          let path = paths[i], newContext = Object.assign({}, context, {
            inCaseClause: !1
          });
          path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak) ? newContext.shouldPopulateBreak = !0 : newContext.shouldPopulateBreak = !1;
          let statementCompletions = _getCompletionRecords(path, newContext);
          if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
            lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
              label: null
            })) ? (normalCompletionToBreak(lastNormalCompletions), completions.push(...lastNormalCompletions), lastNormalCompletions.some((c) => c.path.isDeclaration()) && (completions.push(...statementCompletions), context.shouldPreserveBreak || replaceBreakStatementInBreakCompletion(statementCompletions, !0)), context.shouldPreserveBreak || replaceBreakStatementInBreakCompletion(statementCompletions, !1)) : (completions.push(...statementCompletions), !context.shouldPopulateBreak && !context.shouldPreserveBreak && replaceBreakStatementInBreakCompletion(statementCompletions, !0));
            break;
          }
          if (i === paths.length - 1)
            completions.push(...statementCompletions);
          else {
            lastNormalCompletions = [];
            for (let i2 = 0; i2 < statementCompletions.length; i2++) {
              let c = statementCompletions[i2];
              c.type === BREAK_COMPLETION && completions.push(c), c.type === NORMAL_COMPLETION && lastNormalCompletions.push(c);
            }
          }
        }
      } else if (paths.length)
        for (let i = paths.length - 1; i >= 0; i--) {
          let pathCompletions = _getCompletionRecords(paths[i], context);
          if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration() && !pathCompletions[0].path.isEmptyStatement()) {
            completions.push(...pathCompletions);
            break;
          }
        }
      return completions;
    }
    function _getCompletionRecords(path, context) {
      let records = [];
      if (path.isIfStatement())
        records = addCompletionRecords(path.get("consequent"), records, context), records = addCompletionRecords(path.get("alternate"), records, context);
      else {
        if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement())
          return addCompletionRecords(path.get("body"), records, context);
        if (path.isProgram() || path.isBlockStatement())
          return getStatementListCompletion(path.get("body"), context);
        if (path.isFunction())
          return _getCompletionRecords(path.get("body"), context);
        if (path.isTryStatement())
          records = addCompletionRecords(path.get("block"), records, context), records = addCompletionRecords(path.get("handler"), records, context);
        else {
          if (path.isCatchClause())
            return addCompletionRecords(path.get("body"), records, context);
          if (path.isSwitchStatement())
            return completionRecordForSwitch(path.get("cases"), records, context);
          if (path.isSwitchCase())
            return getStatementListCompletion(path.get("consequent"), {
              canHaveBreak: !0,
              shouldPopulateBreak: !1,
              inCaseClause: !0,
              shouldPreserveBreak: context.shouldPreserveBreak
            });
          path.isBreakStatement() ? records.push(BreakCompletion(path)) : records.push(NormalCompletion(path));
        }
      }
      return records;
    }
    function getCompletionRecords(shouldPreserveBreak = !1) {
      return _getCompletionRecords(this, {
        canHaveBreak: !1,
        shouldPopulateBreak: !1,
        inCaseClause: !1,
        shouldPreserveBreak
      }).map((r) => r.path);
    }
    function getSibling(key) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key
      }).setContext(this.context);
    }
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    function getAllNextSiblings() {
      let _key = this.key, sibling = this.getSibling(++_key), siblings = [];
      for (; sibling.node; )
        siblings.push(sibling), sibling = this.getSibling(++_key);
      return siblings;
    }
    function getAllPrevSiblings() {
      let _key = this.key, sibling = this.getSibling(--_key), siblings = [];
      for (; sibling.node; )
        siblings.push(sibling), sibling = this.getSibling(--_key);
      return siblings;
    }
    function get(key, context = !0) {
      context === !0 && (context = this.context);
      let parts = key.split(".");
      return parts.length === 1 ? _getKey.call(this, key, context) : _getPattern.call(this, parts, context);
    }
    function _getKey(key, context) {
      let node = this.node, container = node[key];
      return Array.isArray(container) ? container.map((_, i) => _index.default.get({
        listKey: key,
        parentPath: this,
        parent: node,
        container,
        key: i
      }).setContext(context)) : _index.default.get({
        parentPath: this,
        parent: node,
        container: node,
        key
      }).setContext(context);
    }
    function _getPattern(parts, context) {
      let path = this;
      for (let part of parts)
        part === "." ? path = path.parentPath : Array.isArray(path) ? path = path[part] : path = path.get(part, context);
      return path;
    }
    function getAssignmentIdentifiers() {
      return _getAssignmentIdentifiers(this.node);
    }
    function getBindingIdentifiers(duplicates) {
      return _getBindingIdentifiers(this.node, duplicates);
    }
    function getOuterBindingIdentifiers(duplicates) {
      return _getOuterBindingIdentifiers(this.node, duplicates);
    }
    function getBindingIdentifierPaths(duplicates = !1, outerOnly = !1) {
      let search = [this], ids = /* @__PURE__ */ Object.create(null);
      for (; search.length; ) {
        let id = search.shift();
        if (!id || !id.node) continue;
        let keys = _getBindingIdentifiers.keys[id.node.type];
        if (id.isIdentifier()) {
          duplicates ? (ids[id.node.name] = ids[id.node.name] || []).push(id) : ids[id.node.name] = id;
          continue;
        }
        if (id.isExportDeclaration()) {
          let declaration = id.get("declaration");
          declaration.isDeclaration() && search.push(declaration);
          continue;
        }
        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search.push(id.get("id"));
            continue;
          }
          if (id.isFunctionExpression())
            continue;
        }
        if (keys)
          for (let i = 0; i < keys.length; i++) {
            let key = keys[i], child = id.get(key);
            Array.isArray(child) ? search.push(...child) : child.node && search.push(child);
          }
      }
      return ids;
    }
    function getOuterBindingIdentifierPaths(duplicates = !1) {
      return this.getBindingIdentifierPaths(duplicates, !0);
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/comments.js
var require_comments = __commonJS({
  "../node_modules/@babel/traverse/lib/path/comments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.addComment = addComment;
    exports.addComments = addComments;
    exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
    var _t = require_lib4(), {
      addComment: _addComment,
      addComments: _addComments
    } = _t;
    function shareCommentsWithSiblings() {
      if (typeof this.key == "string") return;
      let node = this.node;
      if (!node) return;
      let trailing = node.trailingComments, leading = node.leadingComments;
      if (!trailing && !leading) return;
      let prev = this.getSibling(this.key - 1), next = this.getSibling(this.key + 1), hasPrev = !!prev.node, hasNext = !!next.node;
      hasPrev && (leading && prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments)), trailing && !hasNext && prev.addComments("trailing", trailing)), hasNext && (trailing && next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments)), leading && !hasPrev && next.addComments("leading", leading));
    }
    function removeIfExisting(list, toRemove) {
      if (!(toRemove != null && toRemove.length)) return list;
      let set = new Set(toRemove);
      return list.filter((el) => !set.has(el));
    }
    function addComment(type, content, line) {
      _addComment(this.node, type, content, line);
    }
    function addComments(type, comments) {
      _addComments(this.node, type, comments);
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/index.js
var require_path = __commonJS({
  "../node_modules/@babel/traverse/lib/path/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;
    var virtualTypes = require_virtual_types(), _debug = require_src(), _index = require_lib10(), _index2 = require_scope(), _t = require_lib4(), t = _t, cache = require_cache(), _generator = require_lib9(), NodePath_ancestry = require_ancestry(), NodePath_inference = require_inference(), NodePath_replacement = require_replacement(), NodePath_evaluation = require_evaluation(), NodePath_conversion = require_conversion(), NodePath_introspection = require_introspection(), _context = require_context2(), NodePath_context = _context, NodePath_removal = require_removal(), NodePath_modification = require_modification(), NodePath_family = require_family(), NodePath_comments = require_comments(), NodePath_virtual_types_validator = require_virtual_types_validator(), {
      validate
    } = _t, debug = _debug("babel"), REMOVED = exports.REMOVED = 1, SHOULD_STOP = exports.SHOULD_STOP = 2, SHOULD_SKIP = exports.SHOULD_SKIP = 4, NodePath_Final = exports.default = class NodePath {
      constructor(hub, parent) {
        this.contexts = [], this.state = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this._store = null, this.parent = parent, this.hub = hub, this.data = null, this.context = null, this.scope = null;
      }
      get removed() {
        return (this._traverseFlags & 1) > 0;
      }
      set removed(v) {
        v ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
      }
      get shouldStop() {
        return (this._traverseFlags & 2) > 0;
      }
      set shouldStop(v) {
        v ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
      }
      get shouldSkip() {
        return (this._traverseFlags & 4) > 0;
      }
      set shouldSkip(v) {
        v ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
      }
      static get({
        hub,
        parentPath,
        parent,
        container,
        listKey,
        key
      }) {
        if (!hub && parentPath && (hub = parentPath.hub), !parent)
          throw new Error("To get a node path the parent needs to exist");
        let targetNode = container[key], paths = cache.getOrCreateCachedPaths(parent, parentPath), path = paths.get(targetNode);
        return path || (path = new NodePath(hub, parent), targetNode && paths.set(targetNode, path)), _context.setup.call(path, parentPath, container, listKey, key), path;
      }
      getScope(scope) {
        return this.isScope() ? new _index2.default(this) : scope;
      }
      setData(key, val) {
        return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[key] = val;
      }
      getData(key, def) {
        this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
        let val = this.data[key];
        return val === void 0 && def !== void 0 && (val = this.data[key] = def), val;
      }
      hasNode() {
        return this.node != null;
      }
      buildCodeFrameError(msg, Error2 = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error2);
      }
      traverse(visitor, state) {
        (0, _index.default)(this.node, visitor, this.scope, state, this);
      }
      set(key, node) {
        validate(this.node, key, node), this.node[key] = node;
      }
      getPathLocation() {
        let parts = [], path = this;
        do {
          let key = path.key;
          path.inList && (key = `${path.listKey}[${key}]`), parts.unshift(key);
        } while (path = path.parentPath);
        return parts.join(".");
      }
      debug(message) {
        debug.enabled && debug(`${this.getPathLocation()} ${this.type}: ${message}`);
      }
      toString() {
        return (0, _generator.default)(this.node).code;
      }
      get inList() {
        return !!this.listKey;
      }
      set inList(inList) {
        inList || (this.listKey = null);
      }
      get parentKey() {
        return this.listKey || this.key;
      }
    }, methods = {
      findParent: NodePath_ancestry.findParent,
      find: NodePath_ancestry.find,
      getFunctionParent: NodePath_ancestry.getFunctionParent,
      getStatementParent: NodePath_ancestry.getStatementParent,
      getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
      getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
      getAncestry: NodePath_ancestry.getAncestry,
      isAncestor: NodePath_ancestry.isAncestor,
      isDescendant: NodePath_ancestry.isDescendant,
      inType: NodePath_ancestry.inType,
      getTypeAnnotation: NodePath_inference.getTypeAnnotation,
      isBaseType: NodePath_inference.isBaseType,
      couldBeBaseType: NodePath_inference.couldBeBaseType,
      baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
      isGenericType: NodePath_inference.isGenericType,
      replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
      replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
      replaceWith: NodePath_replacement.replaceWith,
      replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
      replaceInline: NodePath_replacement.replaceInline,
      evaluateTruthy: NodePath_evaluation.evaluateTruthy,
      evaluate: NodePath_evaluation.evaluate,
      toComputedKey: NodePath_conversion.toComputedKey,
      ensureBlock: NodePath_conversion.ensureBlock,
      unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
      arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
      splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
      ensureFunctionName: NodePath_conversion.ensureFunctionName,
      matchesPattern: NodePath_introspection.matchesPattern,
      isStatic: NodePath_introspection.isStatic,
      isNodeType: NodePath_introspection.isNodeType,
      canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
      canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
      isCompletionRecord: NodePath_introspection.isCompletionRecord,
      isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
      referencesImport: NodePath_introspection.referencesImport,
      getSource: NodePath_introspection.getSource,
      willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
      _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
      resolve: NodePath_introspection.resolve,
      isConstantExpression: NodePath_introspection.isConstantExpression,
      isInStrictMode: NodePath_introspection.isInStrictMode,
      isDenylisted: NodePath_context.isDenylisted,
      visit: NodePath_context.visit,
      skip: NodePath_context.skip,
      skipKey: NodePath_context.skipKey,
      stop: NodePath_context.stop,
      setContext: NodePath_context.setContext,
      requeue: NodePath_context.requeue,
      requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
      remove: NodePath_removal.remove,
      insertBefore: NodePath_modification.insertBefore,
      insertAfter: NodePath_modification.insertAfter,
      unshiftContainer: NodePath_modification.unshiftContainer,
      pushContainer: NodePath_modification.pushContainer,
      getOpposite: NodePath_family.getOpposite,
      getCompletionRecords: NodePath_family.getCompletionRecords,
      getSibling: NodePath_family.getSibling,
      getPrevSibling: NodePath_family.getPrevSibling,
      getNextSibling: NodePath_family.getNextSibling,
      getAllNextSiblings: NodePath_family.getAllNextSiblings,
      getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
      get: NodePath_family.get,
      getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
      getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
      getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
      getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
      getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
      shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
      addComment: NodePath_comments.addComment,
      addComments: NodePath_comments.addComments
    };
    Object.assign(NodePath_Final.prototype, methods);
    NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion.arrowFunctionToShadowed, Object.assign(NodePath_Final.prototype, {
      has: NodePath_introspection.has,
      is: NodePath_introspection.is,
      isnt: NodePath_introspection.isnt,
      equals: NodePath_introspection.equals,
      hoist: NodePath_modification.hoist,
      updateSiblingKeys: NodePath_modification.updateSiblingKeys,
      call: NodePath_context.call,
      isBlacklisted: NodePath_context.isBlacklisted,
      setScope: NodePath_context.setScope,
      resync: NodePath_context.resync,
      popContext: NodePath_context.popContext,
      pushContext: NodePath_context.pushContext,
      setup: NodePath_context.setup,
      setKey: NodePath_context.setKey
    });
    NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo, NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo, Object.assign(NodePath_Final.prototype, {
      _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
      _replaceWith: NodePath_replacement._replaceWith,
      _resolve: NodePath_introspection._resolve,
      _call: NodePath_context._call,
      _resyncParent: NodePath_context._resyncParent,
      _resyncKey: NodePath_context._resyncKey,
      _resyncList: NodePath_context._resyncList,
      _resyncRemoved: NodePath_context._resyncRemoved,
      _getQueueContexts: NodePath_context._getQueueContexts,
      _removeFromScope: NodePath_removal._removeFromScope,
      _callRemovalHooks: NodePath_removal._callRemovalHooks,
      _remove: NodePath_removal._remove,
      _markRemoved: NodePath_removal._markRemoved,
      _assertUnremoved: NodePath_removal._assertUnremoved,
      _containerInsert: NodePath_modification._containerInsert,
      _containerInsertBefore: NodePath_modification._containerInsertBefore,
      _containerInsertAfter: NodePath_modification._containerInsertAfter,
      _verifyNodeList: NodePath_modification._verifyNodeList,
      _getKey: NodePath_family._getKey,
      _getPattern: NodePath_family._getPattern
    });
    for (let type of t.TYPES) {
      let typeKey = `is${type}`, fn = t[typeKey];
      NodePath_Final.prototype[typeKey] = function(opts) {
        return fn(this.node, opts);
      }, NodePath_Final.prototype[`assert${type}`] = function(opts) {
        if (!fn(this.node, opts))
          throw new TypeError(`Expected node path of type ${type}`);
      };
    }
    Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
    for (let type of Object.keys(virtualTypes))
      type[0] !== "_" && (t.TYPES.includes(type) || t.TYPES.push(type));
  }
});

// ../node_modules/@babel/traverse/lib/context.js
var require_context = __commonJS({
  "../node_modules/@babel/traverse/lib/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _index = require_path(), _t = require_lib4(), _context = require_context2(), {
      VISITOR_KEYS
    } = _t, TraversalContext = class {
      constructor(scope, opts, state, parentPath) {
        this.queue = null, this.priorityQueue = null, this.parentPath = parentPath, this.scope = scope, this.state = state, this.opts = opts;
      }
      shouldVisit(node) {
        let opts = this.opts;
        if (opts.enter || opts.exit || opts[node.type]) return !0;
        let keys = VISITOR_KEYS[node.type];
        if (!(keys != null && keys.length)) return !1;
        for (let key of keys)
          if (node[key])
            return !0;
        return !1;
      }
      create(node, container, key, listKey) {
        return _index.default.get({
          parentPath: this.parentPath,
          parent: node,
          container,
          key,
          listKey
        });
      }
      maybeQueue(path, notPriority) {
        this.queue && (notPriority ? this.queue.push(path) : this.priorityQueue.push(path));
      }
      visitMultiple(container, parent, listKey) {
        if (container.length === 0) return !1;
        let queue = [];
        for (let key = 0; key < container.length; key++) {
          let node = container[key];
          node && this.shouldVisit(node) && queue.push(this.create(parent, container, key, listKey));
        }
        return this.visitQueue(queue);
      }
      visitSingle(node, key) {
        return this.shouldVisit(node[key]) ? this.visitQueue([this.create(node, node, key)]) : !1;
      }
      visitQueue(queue) {
        this.queue = queue, this.priorityQueue = [];
        let visited = /* @__PURE__ */ new WeakSet(), stop = !1, visitIndex = 0;
        for (; visitIndex < queue.length; ) {
          let path = queue[visitIndex];
          if (visitIndex++, _context.resync.call(path), (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) && _context.pushContext.call(path, this), path.key === null) continue;
          let {
            node
          } = path;
          if (!visited.has(node)) {
            if (node && visited.add(node), path.visit()) {
              stop = !0;
              break;
            }
            if (this.priorityQueue.length && (stop = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = queue, stop))
              break;
          }
        }
        for (let i = 0; i < visitIndex; i++)
          _context.popContext.call(queue[i]);
        return this.queue = null, stop;
      }
      visit(node, key) {
        let nodes = node[key];
        return nodes ? Array.isArray(nodes) ? this.visitMultiple(nodes, node, key) : this.visitSingle(node, key) : !1;
      }
    };
    exports.default = TraversalContext;
  }
});

// ../node_modules/@babel/traverse/lib/traverse-node.js
var require_traverse_node = __commonJS({
  "../node_modules/@babel/traverse/lib/traverse-node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.traverseNode = traverseNode;
    var _context = require_context(), _index = require_path(), _t = require_lib4(), _context2 = require_context2(), {
      VISITOR_KEYS
    } = _t;
    function traverseNode(node, opts, scope, state, path, skipKeys, visitSelf) {
      let keys = VISITOR_KEYS[node.type];
      if (!keys) return !1;
      let context = new _context.default(scope, opts, state, path);
      if (visitSelf)
        return skipKeys != null && skipKeys[path.parentKey] ? !1 : context.visitQueue([path]);
      for (let key of keys)
        if (!(skipKeys != null && skipKeys[key]) && context.visit(node, key))
          return !0;
      return !1;
    }
  }
});

// ../node_modules/@babel/traverse/lib/path/context.js
var require_context2 = __commonJS({
  "../node_modules/@babel/traverse/lib/path/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports._call = _call;
    exports._getQueueContexts = _getQueueContexts;
    exports._resyncKey = _resyncKey;
    exports._resyncList = _resyncList;
    exports._resyncParent = _resyncParent;
    exports._resyncRemoved = _resyncRemoved;
    exports.call = call;
    exports.isDenylisted = isDenylisted;
    exports.popContext = popContext;
    exports.pushContext = pushContext;
    exports.requeue = requeue;
    exports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
    exports.resync = resync;
    exports.setContext = setContext;
    exports.setKey = setKey;
    exports.setScope = setScope;
    exports.setup = setup;
    exports.skip = skip;
    exports.skipKey = skipKey;
    exports.stop = stop;
    exports.visit = visit;
    var _traverseNode = require_traverse_node(), _index = require_path(), _removal = require_removal(), t = require_lib4();
    function call(key) {
      let opts = this.opts;
      if (this.debug(key), this.node && _call.call(this, opts[key]))
        return !0;
      if (this.node) {
        var _opts$this$node$type;
        return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key]);
      }
      return !1;
    }
    function _call(fns) {
      if (!fns) return !1;
      for (let fn of fns) {
        if (!fn) continue;
        let node = this.node;
        if (!node) return !0;
        let ret = fn.call(this.state, this, this.state);
        if (ret && typeof ret == "object" && typeof ret.then == "function")
          throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
        if (ret)
          throw new Error(`Unexpected return value from visitor method ${fn}`);
        if (this.node !== node || this._traverseFlags > 0) return !0;
      }
      return !1;
    }
    function isDenylisted() {
      var _this$opts$denylist;
      let denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
      return denylist?.includes(this.node.type);
    }
    exports.isBlacklisted = isDenylisted;
    function restoreContext(path, context) {
      path.context !== context && (path.context = context, path.state = context.state, path.opts = context.opts);
    }
    function visit() {
      var _this$opts$shouldSkip, _this$opts;
      if (!this.node || this.isDenylisted() || (_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this))
        return !1;
      let currentContext = this.context;
      return this.shouldSkip || call.call(this, "enter") ? (this.debug("Skip..."), this.shouldStop) : (restoreContext(this, currentContext), this.debug("Recursing into..."), this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), restoreContext(this, currentContext), call.call(this, "exit"), this.shouldStop);
    }
    function skip() {
      this.shouldSkip = !0;
    }
    function skipKey(key) {
      this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[key] = !0;
    }
    function stop() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
    }
    function setScope() {
      var _this$opts2, _this$scope;
      if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;
      let path = this.parentPath;
      ((this.key === "key" || this.listKey === "decorators") && path.isMethod() || this.key === "discriminant" && path.isSwitchStatement()) && (path = path.parentPath);
      let target;
      for (; path && !target; ) {
        var _path$opts;
        if ((_path$opts = path.opts) != null && _path$opts.noScope) return;
        target = path.scope, path = path.parentPath;
      }
      this.scope = this.getScope(target), (_this$scope = this.scope) == null || _this$scope.init();
    }
    function setContext(context) {
      return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, context && (this.context = context, this.state = context.state, this.opts = context.opts), setScope.call(this), this;
    }
    function resync() {
      this.removed || (_resyncParent.call(this), _resyncList.call(this), _resyncKey.call(this));
    }
    function _resyncParent() {
      this.parentPath && (this.parent = this.parentPath.node);
    }
    function _resyncKey() {
      if (this.container && this.node !== this.container[this.key]) {
        if (Array.isArray(this.container)) {
          for (let i = 0; i < this.container.length; i++)
            if (this.container[i] === this.node) {
              setKey.call(this, i);
              return;
            }
        } else
          for (let key of Object.keys(this.container))
            if (this.container[key] === this.node) {
              setKey.call(this, key);
              return;
            }
        this.key = null;
      }
    }
    function _resyncList() {
      if (!this.parent || !this.inList) return;
      let newContainer = this.parent[this.listKey];
      this.container !== newContainer && (this.container = newContainer || null);
    }
    function _resyncRemoved() {
      (this.key == null || !this.container || this.container[this.key] !== this.node) && _removal._markRemoved.call(this);
    }
    function popContext() {
      this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
    }
    function pushContext(context) {
      this.contexts.push(context), this.setContext(context);
    }
    function setup(parentPath, container, listKey, key) {
      this.listKey = listKey, this.container = container, this.parentPath = parentPath || this.parentPath, setKey.call(this, key);
    }
    function setKey(key) {
      var _this$node;
      this.key = key, this.node = this.container[this.key], this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
    }
    function requeue(pathToQueue = this) {
      if (pathToQueue.removed) return;
      let contexts = this.contexts;
      for (let context of contexts)
        context.maybeQueue(pathToQueue);
    }
    function requeueComputedKeyAndDecorators() {
      let {
        context,
        node
      } = this;
      if (!t.isPrivate(node) && node.computed && context.maybeQueue(this.get("key")), node.decorators)
        for (let decorator of this.get("decorators"))
          context.maybeQueue(decorator);
    }
    function _getQueueContexts() {
      let path = this, contexts = this.contexts;
      for (; !contexts.length && (path = path.parentPath, !!path); )
        contexts = path.contexts;
      return contexts;
    }
  }
});

// ../node_modules/@babel/traverse/lib/hub.js
var require_hub = __commonJS({
  "../node_modules/@babel/traverse/lib/hub.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var Hub = class {
      getCode() {
      }
      getScope() {
      }
      addHelper() {
        throw new Error("Helpers are not supported by the default hub.");
      }
      buildError(node, msg, Error2 = TypeError) {
        return new Error2(msg);
      }
    };
    exports.default = Hub;
  }
});

// ../node_modules/@babel/traverse/lib/index.js
var require_lib10 = __commonJS({
  "../node_modules/@babel/traverse/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "Hub", {
      enumerable: !0,
      get: function() {
        return _hub.default;
      }
    });
    Object.defineProperty(exports, "NodePath", {
      enumerable: !0,
      get: function() {
        return _index.default;
      }
    });
    Object.defineProperty(exports, "Scope", {
      enumerable: !0,
      get: function() {
        return _index2.default;
      }
    });
    exports.visitors = exports.default = void 0;
    require_context2();
    var visitors = require_visitors();
    exports.visitors = visitors;
    var _t = require_lib4(), cache = require_cache(), _traverseNode = require_traverse_node(), _index = require_path(), _index2 = require_scope(), _hub = require_hub(), {
      VISITOR_KEYS,
      removeProperties,
      traverseFast
    } = _t;
    function traverse2(parent, opts = {}, scope, state, parentPath, visitSelf) {
      if (parent) {
        if (!opts.noScope && !scope && parent.type !== "Program" && parent.type !== "File")
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        if (!parentPath && visitSelf)
          throw new Error("visitSelf can only be used when providing a NodePath.");
        VISITOR_KEYS[parent.type] && (visitors.explode(opts), (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, void 0, visitSelf));
      }
    }
    var _default = exports.default = traverse2;
    traverse2.visitors = visitors;
    traverse2.verify = visitors.verify;
    traverse2.explode = visitors.explode;
    traverse2.cheap = function(node, enter) {
      traverseFast(node, enter);
    };
    traverse2.node = function(node, opts, scope, state, path, skipKeys) {
      (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
    };
    traverse2.clearNode = function(node, opts) {
      removeProperties(node, opts);
    };
    traverse2.removeProperties = function(tree, opts) {
      return traverseFast(tree, traverse2.clearNode, opts), tree;
    };
    traverse2.hasType = function(tree, type, denylistTypes) {
      return denylistTypes != null && denylistTypes.includes(tree.type) ? !1 : tree.type === type ? !0 : traverseFast(tree, function(node) {
        if (denylistTypes != null && denylistTypes.includes(node.type))
          return traverseFast.skip;
        if (node.type === type)
          return traverseFast.stop;
      });
    };
    traverse2.cache = cache;
  }
});

// ../node_modules/@babel/helper-module-imports/lib/import-builder.js
var require_import_builder = __commonJS({
  "../node_modules/@babel/helper-module-imports/lib/import-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _assert = __require("assert"), _t = require_lib4(), {
      callExpression,
      cloneNode,
      expressionStatement,
      identifier,
      importDeclaration,
      importDefaultSpecifier,
      importNamespaceSpecifier,
      importSpecifier,
      memberExpression,
      stringLiteral,
      variableDeclaration,
      variableDeclarator
    } = _t, ImportBuilder = class {
      constructor(importedSource, scope, hub) {
        this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = scope, this._hub = hub, this._importedSource = importedSource;
      }
      done() {
        return {
          statements: this._statements,
          resultName: this._resultName
        };
      }
      import() {
        return this._statements.push(importDeclaration([], stringLiteral(this._importedSource))), this;
      }
      require() {
        return this._statements.push(expressionStatement(callExpression(identifier("require"), [stringLiteral(this._importedSource)]))), this;
      }
      namespace(name = "namespace") {
        let local = this._scope.generateUidIdentifier(name), statement = this._statements[this._statements.length - 1];
        return _assert(statement.type === "ImportDeclaration"), _assert(statement.specifiers.length === 0), statement.specifiers = [importNamespaceSpecifier(local)], this._resultName = cloneNode(local), this;
      }
      default(name) {
        let id = this._scope.generateUidIdentifier(name), statement = this._statements[this._statements.length - 1];
        return _assert(statement.type === "ImportDeclaration"), _assert(statement.specifiers.length === 0), statement.specifiers = [importDefaultSpecifier(id)], this._resultName = cloneNode(id), this;
      }
      named(name, importName) {
        if (importName === "default") return this.default(name);
        let id = this._scope.generateUidIdentifier(name), statement = this._statements[this._statements.length - 1];
        return _assert(statement.type === "ImportDeclaration"), _assert(statement.specifiers.length === 0), statement.specifiers = [importSpecifier(id, identifier(importName))], this._resultName = cloneNode(id), this;
      }
      var(name) {
        let id = this._scope.generateUidIdentifier(name), statement = this._statements[this._statements.length - 1];
        return statement.type !== "ExpressionStatement" && (_assert(this._resultName), statement = expressionStatement(this._resultName), this._statements.push(statement)), this._statements[this._statements.length - 1] = variableDeclaration("var", [variableDeclarator(id, statement.expression)]), this._resultName = cloneNode(id), this;
      }
      defaultInterop() {
        return this._interop(this._hub.addHelper("interopRequireDefault"));
      }
      wildcardInterop() {
        return this._interop(this._hub.addHelper("interopRequireWildcard"));
      }
      _interop(callee) {
        let statement = this._statements[this._statements.length - 1];
        return statement.type === "ExpressionStatement" ? statement.expression = callExpression(callee, [statement.expression]) : statement.type === "VariableDeclaration" ? (_assert(statement.declarations.length === 1), statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init])) : _assert.fail("Unexpected type."), this;
      }
      prop(name) {
        let statement = this._statements[this._statements.length - 1];
        return statement.type === "ExpressionStatement" ? statement.expression = memberExpression(statement.expression, identifier(name)) : statement.type === "VariableDeclaration" ? (_assert(statement.declarations.length === 1), statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name))) : _assert.fail("Unexpected type:" + statement.type), this;
      }
      read(name) {
        this._resultName = memberExpression(this._resultName, identifier(name));
      }
    };
    exports.default = ImportBuilder;
  }
});

// ../node_modules/@babel/helper-module-imports/lib/is-module.js
var require_is_module = __commonJS({
  "../node_modules/@babel/helper-module-imports/lib/is-module.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = isModule;
    function isModule(path) {
      return path.node.sourceType === "module";
    }
  }
});

// ../node_modules/@babel/helper-module-imports/lib/import-injector.js
var require_import_injector = __commonJS({
  "../node_modules/@babel/helper-module-imports/lib/import-injector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _assert = __require("assert"), _t = require_lib4(), _importBuilder = require_import_builder(), _isModule = require_is_module(), {
      identifier,
      importSpecifier,
      numericLiteral,
      sequenceExpression,
      isImportDeclaration
    } = _t, ImportInjector = class {
      constructor(path, importedSource, opts) {
        this._defaultOpts = {
          importedSource: null,
          importedType: "commonjs",
          importedInterop: "babel",
          importingInterop: "babel",
          ensureLiveReference: !1,
          ensureNoContext: !1,
          importPosition: "before"
        };
        let programPath = path.find((p) => p.isProgram());
        this._programPath = programPath, this._programScope = programPath.scope, this._hub = programPath.hub, this._defaultOpts = this._applyDefaults(importedSource, opts, !0);
      }
      addDefault(importedSourceIn, opts) {
        return this.addNamed("default", importedSourceIn, opts);
      }
      addNamed(importName, importedSourceIn, opts) {
        return _assert(typeof importName == "string"), this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
      }
      addNamespace(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
      }
      addSideEffect(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);
      }
      _applyDefaults(importedSource, opts, isInit = !1) {
        let newOpts;
        return typeof importedSource == "string" ? newOpts = Object.assign({}, this._defaultOpts, {
          importedSource
        }, opts) : (_assert(!opts, "Unexpected secondary arguments."), newOpts = Object.assign({}, this._defaultOpts, importedSource)), !isInit && opts && (opts.nameHint !== void 0 && (newOpts.nameHint = opts.nameHint), opts.blockHoist !== void 0 && (newOpts.blockHoist = opts.blockHoist)), newOpts;
      }
      _generateImport(opts, importName) {
        let isDefault = importName === "default", isNamed = !!importName && !isDefault, isNamespace = importName === null, {
          importedSource,
          importedType,
          importedInterop,
          importingInterop,
          ensureLiveReference,
          ensureNoContext,
          nameHint,
          importPosition,
          blockHoist
        } = opts, name = nameHint || importName, isMod = (0, _isModule.default)(this._programPath), isModuleForNode = isMod && importingInterop === "node", isModuleForBabel = isMod && importingInterop === "babel";
        if (importPosition === "after" && !isMod)
          throw new Error('"importPosition": "after" is only supported in modules');
        let builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
        if (importedType === "es6") {
          if (!isModuleForNode && !isModuleForBabel)
            throw new Error("Cannot import an ES6 module from CommonJS");
          builder.import(), isNamespace ? builder.namespace(nameHint || importedSource) : (isDefault || isNamed) && builder.named(name, importName);
        } else {
          if (importedType !== "commonjs")
            throw new Error(`Unexpected interopType "${importedType}"`);
          if (importedInterop === "babel")
            if (isModuleForNode) {
              name = name !== "default" ? name : importedSource;
              let es6Default = `${importedSource}$es6Default`;
              builder.import(), isNamespace ? builder.default(es6Default).var(name || importedSource).wildcardInterop() : isDefault ? ensureLiveReference ? builder.default(es6Default).var(name || importedSource).defaultInterop().read("default") : builder.default(es6Default).var(name).defaultInterop().prop(importName) : isNamed && builder.default(es6Default).read(importName);
            } else isModuleForBabel ? (builder.import(), isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName)) : (builder.require(), isNamespace ? builder.var(name || importedSource).wildcardInterop() : (isDefault || isNamed) && ensureLiveReference ? isDefault ? (name = name !== "default" ? name : importedSource, builder.var(name).read(importName), builder.defaultInterop()) : builder.var(importedSource).read(importName) : isDefault ? builder.var(name).defaultInterop().prop(importName) : isNamed && builder.var(name).prop(importName));
          else if (importedInterop === "compiled")
            isModuleForNode ? (builder.import(), isNamespace ? builder.default(name || importedSource) : (isDefault || isNamed) && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName)) : (builder.require(), isNamespace ? builder.var(name || importedSource) : (isDefault || isNamed) && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.prop(importName).var(name)));
          else if (importedInterop === "uncompiled") {
            if (isDefault && ensureLiveReference)
              throw new Error("No live reference for commonjs default");
            isModuleForNode ? (builder.import(), isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.named(name, importName)) : (builder.require(), isNamespace ? builder.var(name || importedSource) : isDefault ? builder.var(name) : isNamed && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.var(name).prop(importName)));
          } else
            throw new Error(`Unknown importedInterop "${importedInterop}".`);
        }
        let {
          statements,
          resultName
        } = builder.done();
        return this._insertStatements(statements, importPosition, blockHoist), (isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier" ? sequenceExpression([numericLiteral(0), resultName]) : resultName;
      }
      _insertStatements(statements, importPosition = "before", blockHoist = 3) {
        if (importPosition === "after") {
          if (this._insertStatementsAfter(statements)) return;
        } else if (this._insertStatementsBefore(statements, blockHoist)) return;
        this._programPath.unshiftContainer("body", statements);
      }
      _insertStatementsBefore(statements, blockHoist) {
        if (statements.length === 1 && isImportDeclaration(statements[0]) && isValueImport(statements[0])) {
          let firstImportDecl = this._programPath.get("body").find((p) => p.isImportDeclaration() && isValueImport(p.node));
          if (firstImportDecl?.node.source.value === statements[0].source.value && maybeAppendImportSpecifiers(firstImportDecl.node, statements[0]))
            return !0;
        }
        statements.forEach((node) => {
          node._blockHoist = blockHoist;
        });
        let targetPath = this._programPath.get("body").find((p) => {
          let val = p.node._blockHoist;
          return Number.isFinite(val) && val < 4;
        });
        return targetPath ? (targetPath.insertBefore(statements), !0) : !1;
      }
      _insertStatementsAfter(statements) {
        let statementsSet = new Set(statements), importDeclarations = /* @__PURE__ */ new Map();
        for (let statement of statements)
          if (isImportDeclaration(statement) && isValueImport(statement)) {
            let source = statement.source.value;
            importDeclarations.has(source) || importDeclarations.set(source, []), importDeclarations.get(source).push(statement);
          }
        let lastImportPath = null;
        for (let bodyStmt of this._programPath.get("body"))
          if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {
            lastImportPath = bodyStmt;
            let source = bodyStmt.node.source.value, newImports = importDeclarations.get(source);
            if (!newImports) continue;
            for (let decl of newImports)
              statementsSet.has(decl) && maybeAppendImportSpecifiers(bodyStmt.node, decl) && statementsSet.delete(decl);
          }
        return statementsSet.size === 0 ? !0 : (lastImportPath && lastImportPath.insertAfter(Array.from(statementsSet)), !!lastImportPath);
      }
    };
    exports.default = ImportInjector;
    function isValueImport(node) {
      return node.importKind !== "type" && node.importKind !== "typeof";
    }
    function hasNamespaceImport(node) {
      return node.specifiers.length === 1 && node.specifiers[0].type === "ImportNamespaceSpecifier" || node.specifiers.length === 2 && node.specifiers[1].type === "ImportNamespaceSpecifier";
    }
    function hasDefaultImport(node) {
      return node.specifiers.length > 0 && node.specifiers[0].type === "ImportDefaultSpecifier";
    }
    function maybeAppendImportSpecifiers(target, source) {
      return target.specifiers.length ? source.specifiers.length ? hasNamespaceImport(target) || hasNamespaceImport(source) ? !1 : (hasDefaultImport(source) && (hasDefaultImport(target) ? source.specifiers[0] = importSpecifier(source.specifiers[0].local, identifier("default")) : target.specifiers.unshift(source.specifiers.shift())), target.specifiers.push(...source.specifiers), !0) : !0 : (target.specifiers = source.specifiers, !0);
    }
  }
});

// ../node_modules/@babel/helper-module-imports/lib/index.js
var require_lib11 = __commonJS({
  "../node_modules/@babel/helper-module-imports/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "ImportInjector", {
      enumerable: !0,
      get: function() {
        return _importInjector.default;
      }
    });
    exports.addDefault = addDefault;
    exports.addNamed = addNamed;
    exports.addNamespace = addNamespace;
    exports.addSideEffect = addSideEffect;
    Object.defineProperty(exports, "isModule", {
      enumerable: !0,
      get: function() {
        return _isModule.default;
      }
    });
    var _importInjector = require_import_injector(), _isModule = require_is_module();
    function addDefault(path, importedSource, opts) {
      return new _importInjector.default(path).addDefault(importedSource, opts);
    }
    function addNamed(path, name, importedSource, opts) {
      return new _importInjector.default(path).addNamed(name, importedSource, opts);
    }
    function addNamespace(path, importedSource, opts) {
      return new _importInjector.default(path).addNamespace(importedSource, opts);
    }
    function addSideEffect(path, importedSource, opts) {
      return new _importInjector.default(path).addSideEffect(importedSource, opts);
    }
  }
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-this.js
var require_rewrite_this = __commonJS({
  "../node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = rewriteThis;
    var _core = require_lib27(), _traverse = require_lib10(), rewriteThisVisitor;
    function rewriteThis(programPath) {
      rewriteThisVisitor || (rewriteThisVisitor = _traverse.visitors.environmentVisitor({
        ThisExpression(path) {
          path.replaceWith(_core.types.unaryExpression("void", _core.types.numericLiteral(0), !0));
        }
      }), rewriteThisVisitor.noScope = !0), (0, _traverse.default)(programPath.node, rewriteThisVisitor);
    }
  }
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js
var require_rewrite_live_references = __commonJS({
  "../node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = rewriteLiveReferences;
    var _core = require_lib27();
    function isInType(path) {
      do
        switch (path.parent.type) {
          case "TSTypeAnnotation":
          case "TSTypeAliasDeclaration":
          case "TSTypeReference":
          case "TypeAnnotation":
          case "TypeAlias":
            return !0;
          case "ExportSpecifier":
            return path.parentPath.parent.exportKind === "type";
          default:
            if (path.parentPath.isStatement() || path.parentPath.isExpression())
              return !1;
        }
      while (path = path.parentPath);
    }
    function rewriteLiveReferences(programPath, metadata, wrapReference) {
      let imported = /* @__PURE__ */ new Map(), exported = /* @__PURE__ */ new Map(), requeueInParent = (path) => {
        programPath.requeue(path);
      };
      for (let [source, data] of metadata.source) {
        for (let [localName, importName] of data.imports)
          imported.set(localName, [source, importName, null]);
        for (let localName of data.importsNamespace)
          imported.set(localName, [source, null, localName]);
      }
      for (let [local, data] of metadata.local) {
        let exportMeta = exported.get(local);
        exportMeta || (exportMeta = [], exported.set(local, exportMeta)), exportMeta.push(...data.names);
      }
      let rewriteBindingInitVisitorState = {
        metadata,
        requeueInParent,
        scope: programPath.scope,
        exported
      };
      programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
      let rewriteReferencesVisitorState = {
        seen: /* @__PURE__ */ new WeakSet(),
        metadata,
        requeueInParent,
        scope: programPath.scope,
        imported,
        exported,
        buildImportReference([source, importName, localName], identNode) {
          let meta = metadata.source.get(source);
          if (meta.referenced = !0, localName) {
            if (meta.wrap) {
              var _wrapReference;
              identNode = (_wrapReference = wrapReference(identNode, meta.wrap)) != null ? _wrapReference : identNode;
            }
            return identNode;
          }
          let namespace = _core.types.identifier(meta.name);
          if (meta.wrap) {
            var _wrapReference2;
            namespace = (_wrapReference2 = wrapReference(namespace, meta.wrap)) != null ? _wrapReference2 : namespace;
          }
          if (importName === "default" && meta.interop === "node-default")
            return namespace;
          let computed = metadata.stringSpecifiers.has(importName);
          return _core.types.memberExpression(namespace, computed ? _core.types.stringLiteral(importName) : _core.types.identifier(importName), computed);
        }
      };
      programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
    }
    var rewriteBindingInitVisitor = {
      Scope(path) {
        path.skip();
      },
      ClassDeclaration(path) {
        let {
          requeueInParent,
          exported,
          metadata
        } = this, {
          id
        } = path.node;
        if (!id) throw new Error("Expected class to have a name");
        let localName = id.name, exportNames = exported.get(localName) || [];
        if (exportNames.length > 0) {
          let statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, _core.types.identifier(localName), path.scope));
          statement._blockHoist = path.node._blockHoist, requeueInParent(path.insertAfter(statement)[0]);
        }
      },
      VariableDeclaration(path) {
        let {
          requeueInParent,
          exported,
          metadata
        } = this, isVar = path.node.kind === "var";
        for (let decl of path.get("declarations")) {
          let {
            id
          } = decl.node, {
            init
          } = decl.node;
          if (_core.types.isIdentifier(id) && exported.has(id.name) && !_core.types.isArrowFunctionExpression(init) && (!_core.types.isFunctionExpression(init) || init.id) && (!_core.types.isClassExpression(init) || init.id)) {
            if (!init) {
              if (isVar)
                continue;
              init = path.scope.buildUndefinedNode();
            }
            decl.node.init = buildBindingExportAssignmentExpression(metadata, exported.get(id.name), init, path.scope), requeueInParent(decl.get("init"));
          } else
            for (let localName of Object.keys(decl.getOuterBindingIdentifiers()))
              if (exported.has(localName)) {
                let statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exported.get(localName), _core.types.identifier(localName), path.scope));
                statement._blockHoist = path.node._blockHoist, requeueInParent(path.insertAfter(statement)[0]);
              }
        }
      }
    }, buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope) => {
      let exportsObjectName = metadata.exportName;
      for (let currentScope = scope; currentScope != null; currentScope = currentScope.parent)
        currentScope.hasOwnBinding(exportsObjectName) && currentScope.rename(exportsObjectName);
      return (exportNames || []).reduce((expr, exportName) => {
        let {
          stringSpecifiers
        } = metadata, computed = stringSpecifiers.has(exportName);
        return _core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportsObjectName), computed ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), computed), expr);
      }, localExpr);
    }, buildImportThrow = (localName) => _core.template.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `, rewriteReferencesVisitor = {
      ReferencedIdentifier(path) {
        let {
          seen,
          buildImportReference,
          scope,
          imported,
          requeueInParent
        } = this;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        let localName = path.node.name, importData = imported.get(localName);
        if (importData) {
          if (isInType(path))
            throw path.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
          let localBinding = path.scope.getBinding(localName);
          if (scope.getBinding(localName) !== localBinding) return;
          let ref = buildImportReference(importData, path.node);
          if (ref.loc = path.node.loc, (path.parentPath.isCallExpression({
            callee: path.node
          }) || path.parentPath.isOptionalCallExpression({
            callee: path.node
          }) || path.parentPath.isTaggedTemplateExpression({
            tag: path.node
          })) && _core.types.isMemberExpression(ref))
            path.replaceWith(_core.types.sequenceExpression([_core.types.numericLiteral(0), ref]));
          else if (path.isJSXIdentifier() && _core.types.isMemberExpression(ref)) {
            let {
              object,
              property
            } = ref;
            path.replaceWith(_core.types.jsxMemberExpression(_core.types.jsxIdentifier(object.name), _core.types.jsxIdentifier(property.name)));
          } else
            path.replaceWith(ref);
          requeueInParent(path), path.skip();
        }
      },
      UpdateExpression(path) {
        let {
          scope,
          seen,
          imported,
          exported,
          requeueInParent,
          buildImportReference
        } = this;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        let arg = path.get("argument");
        if (arg.isMemberExpression()) return;
        let update = path.node;
        if (arg.isIdentifier()) {
          let localName = arg.node.name;
          if (scope.getBinding(localName) !== path.scope.getBinding(localName))
            return;
          let exportedNames = exported.get(localName), importData = imported.get(localName);
          if (exportedNames?.length > 0 || importData)
            if (importData)
              path.replaceWith(_core.types.assignmentExpression(update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName)));
            else if (update.prefix)
              path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.cloneNode(update), path.scope));
            else {
              let ref = scope.generateDeclaredUidIdentifier(localName);
              path.replaceWith(_core.types.sequenceExpression([_core.types.assignmentExpression("=", _core.types.cloneNode(ref), _core.types.cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.identifier(localName), path.scope), _core.types.cloneNode(ref)]));
            }
        }
        requeueInParent(path), path.skip();
      },
      AssignmentExpression: {
        exit(path) {
          let {
            scope,
            seen,
            imported,
            exported,
            requeueInParent,
            buildImportReference
          } = this;
          if (seen.has(path.node)) return;
          seen.add(path.node);
          let left = path.get("left");
          if (!left.isMemberExpression())
            if (left.isIdentifier()) {
              let localName = left.node.name;
              if (scope.getBinding(localName) !== path.scope.getBinding(localName))
                return;
              let exportedNames = exported.get(localName), importData = imported.get(localName);
              if (exportedNames?.length > 0 || importData) {
                let assignment = path.node;
                importData && (assignment.left = buildImportReference(importData, left.node), assignment.right = _core.types.sequenceExpression([assignment.right, buildImportThrow(localName)]));
                let {
                  operator
                } = assignment, newExpr;
                operator === "=" ? newExpr = assignment : operator === "&&=" || operator === "||=" || operator === "??=" ? newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.logicalExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right)) : newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.binaryExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right)), path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, newExpr, path.scope)), requeueInParent(path), path.skip();
              }
            } else {
              let ids = left.getOuterBindingIdentifiers(), programScopeIds = Object.keys(ids).filter((localName) => scope.getBinding(localName) === path.scope.getBinding(localName)), id = programScopeIds.find((localName) => imported.has(localName));
              id && (path.node.right = _core.types.sequenceExpression([path.node.right, buildImportThrow(id)]));
              let items = [];
              if (programScopeIds.forEach((localName) => {
                let exportedNames = exported.get(localName) || [];
                exportedNames.length > 0 && items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.identifier(localName), path.scope));
              }), items.length > 0) {
                let node = _core.types.sequenceExpression(items);
                path.parentPath.isExpressionStatement() && (node = _core.types.expressionStatement(node), node._blockHoist = path.parentPath.node._blockHoist);
                let statement = path.insertAfter(node)[0];
                requeueInParent(statement);
              }
            }
        }
      },
      ForXStatement(path) {
        let {
          scope,
          node
        } = path, {
          left
        } = node, {
          exported,
          imported,
          scope: programScope
        } = this;
        if (!_core.types.isVariableDeclaration(left)) {
          let didTransformExport = !1, importConstViolationName, loopBodyScope = path.get("body").scope;
          for (let name of Object.keys(_core.types.getOuterBindingIdentifiers(left)))
            programScope.getBinding(name) === scope.getBinding(name) && (exported.has(name) && (didTransformExport = !0, loopBodyScope.hasOwnBinding(name) && loopBodyScope.rename(name)), imported.has(name) && !importConstViolationName && (importConstViolationName = name));
          if (!didTransformExport && !importConstViolationName)
            return;
          path.ensureBlock();
          let bodyPath = path.get("body"), newLoopId = scope.generateUidIdentifierBasedOnNode(left);
          path.get("left").replaceWith(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(newLoopId))])), scope.registerDeclaration(path.get("left")), didTransformExport && bodyPath.unshiftContainer("body", _core.types.expressionStatement(_core.types.assignmentExpression("=", left, newLoopId))), importConstViolationName && bodyPath.unshiftContainer("body", _core.types.expressionStatement(buildImportThrow(importConstViolationName)));
        }
      }
    };
  }
});

// ../node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js
var require_normalize_and_load_metadata = __commonJS({
  "../node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = normalizeModuleAndLoadMetadata;
    exports.hasExports = hasExports;
    exports.isSideEffectImport = isSideEffectImport;
    exports.validateImportInteropOption = validateImportInteropOption;
    var _path = __require("path"), _helperValidatorIdentifier = require_lib2();
    function hasExports(metadata) {
      return metadata.hasExports;
    }
    function isSideEffectImport(source) {
      return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
    }
    function validateImportInteropOption(importInterop) {
      if (typeof importInterop != "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node")
        throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);
      return importInterop;
    }
    function resolveImportInterop(importInterop, source, filename) {
      return typeof importInterop == "function" ? validateImportInteropOption(importInterop(source, filename)) : importInterop;
    }
    function normalizeModuleAndLoadMetadata(programPath, exportName, {
      importInterop,
      initializeReexports = !1,
      getWrapperPayload,
      esNamespaceOnly = !1,
      filename
    }) {
      exportName || (exportName = programPath.scope.generateUidIdentifier("exports").name);
      let stringSpecifiers = /* @__PURE__ */ new Set();
      nameAnonymousExports(programPath);
      let {
        local,
        sources,
        hasExports: hasExports2
      } = getModuleMetadata(programPath, {
        initializeReexports,
        getWrapperPayload
      }, stringSpecifiers);
      removeImportExportDeclarations(programPath);
      for (let [source, metadata] of sources) {
        let {
          importsNamespace,
          imports
        } = metadata;
        if (importsNamespace.size > 0 && imports.size === 0) {
          let [nameOfnamespace] = importsNamespace;
          metadata.name = nameOfnamespace;
        }
        let resolvedInterop = resolveImportInterop(importInterop, source, filename);
        resolvedInterop === "none" ? metadata.interop = "none" : resolvedInterop === "node" && metadata.interop === "namespace" ? metadata.interop = "node-namespace" : resolvedInterop === "node" && metadata.interop === "default" ? metadata.interop = "node-default" : esNamespaceOnly && metadata.interop === "namespace" && (metadata.interop = "default");
      }
      return {
        exportName,
        exportNameListName: null,
        hasExports: hasExports2,
        local,
        source: sources,
        stringSpecifiers
      };
    }
    function getExportSpecifierName(path, stringSpecifiers) {
      if (path.isIdentifier())
        return path.node.name;
      if (path.isStringLiteral()) {
        let stringValue = path.node.value;
        return (0, _helperValidatorIdentifier.isIdentifierName)(stringValue) || stringSpecifiers.add(stringValue), stringValue;
      } else
        throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);
    }
    function assertExportSpecifier(path) {
      if (!path.isExportSpecifier())
        throw path.isExportNamespaceSpecifier() ? path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.") : path.buildCodeFrameError("Unexpected export specifier type");
    }
    function getModuleMetadata(programPath, {
      getWrapperPayload,
      initializeReexports
    }, stringSpecifiers) {
      let localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers), importNodes = /* @__PURE__ */ new Map(), sourceData = /* @__PURE__ */ new Map(), getData = (sourceNode, node) => {
        let source = sourceNode.value, data = sourceData.get(source);
        return data ? importNodes.get(source).push(node) : (data = {
          name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
          interop: "none",
          loc: null,
          imports: /* @__PURE__ */ new Map(),
          importsNamespace: /* @__PURE__ */ new Set(),
          reexports: /* @__PURE__ */ new Map(),
          reexportNamespace: /* @__PURE__ */ new Set(),
          reexportAll: null,
          wrap: null,
          get lazy() {
            return this.wrap === "lazy";
          },
          referenced: !1
        }, sourceData.set(source, data), importNodes.set(source, [node])), data;
      }, hasExports2 = !1;
      programPath.get("body").forEach((child) => {
        if (child.isImportDeclaration()) {
          let data = getData(child.node.source, child.node);
          data.loc || (data.loc = child.node.loc), child.get("specifiers").forEach((spec) => {
            if (spec.isImportDefaultSpecifier()) {
              let localName = spec.get("local").node.name;
              data.imports.set(localName, "default");
              let reexport = localData.get(localName);
              reexport && (localData.delete(localName), reexport.names.forEach((name) => {
                data.reexports.set(name, "default");
              }), data.referenced = !0);
            } else if (spec.isImportNamespaceSpecifier()) {
              let localName = spec.get("local").node.name;
              data.importsNamespace.add(localName);
              let reexport = localData.get(localName);
              reexport && (localData.delete(localName), reexport.names.forEach((name) => {
                data.reexportNamespace.add(name);
              }), data.referenced = !0);
            } else if (spec.isImportSpecifier()) {
              let importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers), localName = spec.get("local").node.name;
              data.imports.set(localName, importName);
              let reexport = localData.get(localName);
              reexport && (localData.delete(localName), reexport.names.forEach((name) => {
                data.reexports.set(name, importName);
              }), data.referenced = !0);
            }
          });
        } else if (child.isExportAllDeclaration()) {
          hasExports2 = !0;
          let data = getData(child.node.source, child.node);
          data.loc || (data.loc = child.node.loc), data.reexportAll = {
            loc: child.node.loc
          }, data.referenced = !0;
        } else if (child.isExportNamedDeclaration() && child.node.source) {
          hasExports2 = !0;
          let data = getData(child.node.source, child.node);
          data.loc || (data.loc = child.node.loc), child.get("specifiers").forEach((spec) => {
            assertExportSpecifier(spec);
            let importName = getExportSpecifierName(spec.get("local"), stringSpecifiers), exportName = getExportSpecifierName(spec.get("exported"), stringSpecifiers);
            if (data.reexports.set(exportName, importName), data.referenced = !0, exportName === "__esModule")
              throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
          });
        } else (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) && (hasExports2 = !0);
      });
      for (let metadata of sourceData.values()) {
        let needsDefault = !1, needsNamed = !1;
        metadata.importsNamespace.size > 0 && (needsDefault = !0, needsNamed = !0), metadata.reexportAll && (needsNamed = !0);
        for (let importName of metadata.imports.values())
          importName === "default" ? needsDefault = !0 : needsNamed = !0;
        for (let importName of metadata.reexports.values())
          importName === "default" ? needsDefault = !0 : needsNamed = !0;
        needsDefault && needsNamed ? metadata.interop = "namespace" : needsDefault && (metadata.interop = "default");
      }
      if (getWrapperPayload)
        for (let [source, metadata] of sourceData)
          metadata.wrap = getWrapperPayload(source, metadata, importNodes.get(source));
      return {
        hasExports: hasExports2,
        local: localData,
        sources: sourceData
      };
    }
    function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
      let bindingKindLookup = /* @__PURE__ */ new Map(), programScope = programPath.scope, programChildren = programPath.get("body");
      programChildren.forEach((child) => {
        let kind;
        if (child.isImportDeclaration())
          kind = "import";
        else {
          if (child.isExportDefaultDeclaration() && (child = child.get("declaration")), child.isExportNamedDeclaration()) {
            if (child.node.declaration)
              child = child.get("declaration");
            else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
              child.get("specifiers").forEach((spec) => {
                assertExportSpecifier(spec), bindingKindLookup.set(spec.get("local").node.name, "block");
              });
              return;
            }
          }
          if (child.isFunctionDeclaration())
            kind = "hoisted";
          else if (child.isClassDeclaration())
            kind = "block";
          else if (child.isVariableDeclaration({
            kind: "var"
          }))
            kind = "var";
          else if (child.isVariableDeclaration())
            kind = "block";
          else
            return;
        }
        Object.keys(child.getOuterBindingIdentifiers()).forEach((name) => {
          bindingKindLookup.set(name, kind);
        });
      });
      let localMetadata = /* @__PURE__ */ new Map(), getLocalMetadata = (idPath) => {
        let localName = idPath.node.name, metadata = localMetadata.get(localName);
        if (!metadata) {
          var _bindingKindLookup$ge, _programScope$getBind;
          let kind = (_bindingKindLookup$ge = bindingKindLookup.get(localName)) != null ? _bindingKindLookup$ge : (_programScope$getBind = programScope.getBinding(localName)) == null ? void 0 : _programScope$getBind.kind;
          if (kind === void 0)
            throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);
          metadata = {
            names: [],
            kind
          }, localMetadata.set(localName, metadata);
        }
        return metadata;
      };
      return programChildren.forEach((child) => {
        if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source))
          if (child.node.declaration) {
            let declaration = child.get("declaration"), ids = declaration.getOuterBindingIdentifierPaths();
            Object.keys(ids).forEach((name) => {
              if (name === "__esModule")
                throw declaration.buildCodeFrameError('Illegal export "__esModule".');
              getLocalMetadata(ids[name]).names.push(name);
            });
          } else
            child.get("specifiers").forEach((spec) => {
              let local = spec.get("local"), exported = spec.get("exported"), localMetadata2 = getLocalMetadata(local), exportName = getExportSpecifierName(exported, stringSpecifiers);
              if (exportName === "__esModule")
                throw exported.buildCodeFrameError('Illegal export "__esModule".');
              localMetadata2.names.push(exportName);
            });
        else if (child.isExportDefaultDeclaration()) {
          let declaration = child.get("declaration");
          if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration())
            getLocalMetadata(declaration.get("id")).names.push("default");
          else
            throw declaration.buildCodeFrameError("Unexpected default expression export.");
        }
      }), localMetadata;
    }
    function nameAnonymousExports(programPath) {
      programPath.get("body").forEach((child) => {
        if (child.isExportDefaultDeclaration()) {
          {
            var _child$splitExportDec;
            (_child$splitExportDec = child.splitExportDeclaration) != null || (child.splitExportDeclaration = require_lib10().NodePath.prototype.splitExportDeclaration);
          }
          child.splitExportDeclaration();
        }
      });
    }
    function removeImportExportDeclarations(programPath) {
      programPath.get("body").forEach((child) => {
        if (child.isImportDeclaration())
          child.remove();
        else if (child.isExportNamedDeclaration())
          child.node.declaration ? (child.node.declaration._blockHoist = child.node._blockHoist, child.replaceWith(child.node.declaration)) : child.remove();
        else if (child.isExportDefaultDeclaration()) {
          let declaration = child.get("declaration");
          if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration())
            declaration._blockHoist = child.node._blockHoist, child.replaceWith(declaration);
          else
            throw declaration.buildCodeFrameError("Unexpected default expression export.");
        } else child.isExportAllDeclaration() && child.remove();
      });
    }
  }
});

// ../node_modules/@babel/helper-module-transforms/lib/lazy-modules.js
var require_lazy_modules = __commonJS({
  "../node_modules/@babel/helper-module-transforms/lib/lazy-modules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.toGetWrapperPayload = toGetWrapperPayload;
    exports.wrapReference = wrapReference;
    var _core = require_lib27(), _normalizeAndLoadMetadata = require_normalize_and_load_metadata();
    function toGetWrapperPayload(lazy) {
      return (source, metadata) => {
        if (lazy === !1 || (0, _normalizeAndLoadMetadata.isSideEffectImport)(metadata) || metadata.reexportAll) return null;
        if (lazy === !0)
          return source.includes(".") ? null : "lazy";
        if (Array.isArray(lazy))
          return lazy.includes(source) ? "lazy" : null;
        if (typeof lazy == "function")
          return lazy(source) ? "lazy" : null;
        throw new Error(".lazy must be a boolean, string array, or function");
      };
    }
    function wrapReference(ref, payload) {
      return payload === "lazy" ? _core.types.callExpression(ref, []) : null;
    }
  }
});

// ../node_modules/@babel/helper-module-transforms/lib/dynamic-import.js
var require_dynamic_import = __commonJS({
  "../node_modules/@babel/helper-module-transforms/lib/dynamic-import.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.buildDynamicImport = buildDynamicImport;
    var _core = require_lib27();
    exports.getDynamicImportSource = function(node) {
      let [source] = node.arguments;
      return _core.types.isStringLiteral(source) || _core.types.isTemplateLiteral(source) ? source : _core.template.expression.ast`\`\${${source}}\``;
    };
    function buildDynamicImport(node, deferToThen, wrapWithPromise, builder) {
      let specifier = _core.types.isCallExpression(node) ? node.arguments[0] : node.source;
      if (_core.types.isStringLiteral(specifier) || _core.types.isTemplateLiteral(specifier) && specifier.quasis.length === 0)
        return deferToThen ? _core.template.expression.ast`
        Promise.resolve().then(() => ${builder(specifier)})
      ` : builder(specifier);
      let specifierToString = _core.types.isTemplateLiteral(specifier) ? _core.types.identifier("specifier") : _core.types.templateLiteral([_core.types.templateElement({
        raw: ""
      }), _core.types.templateElement({
        raw: ""
      })], [_core.types.identifier("specifier")]);
      return deferToThen ? _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${specifierToString}))
          .then(s => ${builder(_core.types.identifier("s"))})
      )(${specifier})
    ` : wrapWithPromise ? _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${builder(specifierToString)}))
      )(${specifier})
    ` : _core.template.expression.ast`
      (specifier => ${builder(specifierToString)})(${specifier})
    `;
    }
  }
});

// ../node_modules/@babel/helper-module-transforms/lib/get-module-name.js
var require_get_module_name = __commonJS({
  "../node_modules/@babel/helper-module-transforms/lib/get-module-name.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = getModuleName;
    {
      let originalGetModuleName = getModuleName;
      exports.default = getModuleName = function(rootOpts, pluginOpts) {
        var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;
        return originalGetModuleName(rootOpts, {
          moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId,
          moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds,
          getModuleId: (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId,
          moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot
        });
      };
    }
    function getModuleName(rootOpts, pluginOpts) {
      let {
        filename,
        filenameRelative = filename,
        sourceRoot = pluginOpts.moduleRoot
      } = rootOpts, {
        moduleId,
        moduleIds = !!moduleId,
        getModuleId,
        moduleRoot = sourceRoot
      } = pluginOpts;
      if (!moduleIds) return null;
      if (moduleId != null && !getModuleId)
        return moduleId;
      let moduleName = moduleRoot != null ? moduleRoot + "/" : "";
      if (filenameRelative) {
        let sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
        moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.\w*$/, "");
      }
      return moduleName = moduleName.replace(/\\/g, "/"), getModuleId && getModuleId(moduleName) || moduleName;
    }
  }
});

// ../node_modules/@babel/helper-module-transforms/lib/index.js
var require_lib12 = __commonJS({
  "../node_modules/@babel/helper-module-transforms/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "buildDynamicImport", {
      enumerable: !0,
      get: function() {
        return _dynamicImport.buildDynamicImport;
      }
    });
    exports.buildNamespaceInitStatements = buildNamespaceInitStatements;
    exports.ensureStatementsHoisted = ensureStatementsHoisted;
    Object.defineProperty(exports, "getModuleName", {
      enumerable: !0,
      get: function() {
        return _getModuleName.default;
      }
    });
    Object.defineProperty(exports, "hasExports", {
      enumerable: !0,
      get: function() {
        return _normalizeAndLoadMetadata.hasExports;
      }
    });
    Object.defineProperty(exports, "isModule", {
      enumerable: !0,
      get: function() {
        return _helperModuleImports.isModule;
      }
    });
    Object.defineProperty(exports, "isSideEffectImport", {
      enumerable: !0,
      get: function() {
        return _normalizeAndLoadMetadata.isSideEffectImport;
      }
    });
    exports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;
    Object.defineProperty(exports, "rewriteThis", {
      enumerable: !0,
      get: function() {
        return _rewriteThis.default;
      }
    });
    exports.wrapInterop = wrapInterop;
    var _assert = __require("assert"), _core = require_lib27(), _helperModuleImports = require_lib11(), _rewriteThis = require_rewrite_this(), _rewriteLiveReferences = require_rewrite_live_references(), _normalizeAndLoadMetadata = require_normalize_and_load_metadata(), Lazy = require_lazy_modules(), _dynamicImport = require_dynamic_import(), _getModuleName = require_get_module_name();
    exports.getDynamicImportSource = require_dynamic_import().getDynamicImportSource;
    function rewriteModuleStatementsAndPrepareHeader(path, {
      exportName,
      strict,
      allowTopLevelThis,
      strictMode,
      noInterop,
      importInterop = noInterop ? "none" : "babel",
      lazy,
      getWrapperPayload = Lazy.toGetWrapperPayload(lazy ?? !1),
      wrapReference = Lazy.wrapReference,
      esNamespaceOnly,
      filename,
      constantReexports = arguments[1].loose,
      enumerableModuleMeta = arguments[1].loose,
      noIncompleteNsImportDetection
    }) {
      (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop), _assert((0, _helperModuleImports.isModule)(path), "Cannot process module statements in a script"), path.node.sourceType = "script";
      let meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {
        importInterop,
        initializeReexports: constantReexports,
        getWrapperPayload,
        esNamespaceOnly,
        filename
      });
      allowTopLevelThis || (0, _rewriteThis.default)(path), (0, _rewriteLiveReferences.default)(path, meta, wrapReference), strictMode !== !1 && (path.node.directives.some((directive) => directive.value.value === "use strict") || path.unshiftContainer("directives", _core.types.directive(_core.types.directiveLiteral("use strict"))));
      let headers = [];
      (0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict && headers.push(buildESModuleHeader(meta, enumerableModuleMeta));
      let nameList = buildExportNameListDeclaration(path, meta);
      return nameList && (meta.exportNameListName = nameList.name, headers.push(nameList.statement)), headers.push(...buildExportInitializationStatements(path, meta, wrapReference, constantReexports, noIncompleteNsImportDetection)), {
        meta,
        headers
      };
    }
    function ensureStatementsHoisted(statements) {
      statements.forEach((header) => {
        header._blockHoist = 3;
      });
    }
    function wrapInterop(programPath, expr, type) {
      if (type === "none")
        return null;
      if (type === "node-namespace")
        return _core.types.callExpression(programPath.hub.addHelper("interopRequireWildcard"), [expr, _core.types.booleanLiteral(!0)]);
      if (type === "node-default")
        return null;
      let helper;
      if (type === "default")
        helper = "interopRequireDefault";
      else if (type === "namespace")
        helper = "interopRequireWildcard";
      else
        throw new Error(`Unknown interop: ${type}`);
      return _core.types.callExpression(programPath.hub.addHelper(helper), [expr]);
    }
    function buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = !1, wrapReference = Lazy.wrapReference) {
      var _wrapReference;
      let statements = [], srcNamespaceId = _core.types.identifier(sourceMetadata.name);
      for (let localName of sourceMetadata.importsNamespace)
        localName !== sourceMetadata.name && statements.push(_core.template.statement`var NAME = SOURCE;`({
          NAME: localName,
          SOURCE: _core.types.cloneNode(srcNamespaceId)
        }));
      let srcNamespace = (_wrapReference = wrapReference(srcNamespaceId, sourceMetadata.wrap)) != null ? _wrapReference : srcNamespaceId;
      constantReexports && statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, !0, wrapReference));
      for (let exportName of sourceMetadata.reexportNamespace)
        statements.push((_core.types.isIdentifier(srcNamespace) ? _core.template.statement`EXPORTS.NAME = NAMESPACE;` : _core.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({
          EXPORTS: metadata.exportName,
          NAME: exportName,
          NAMESPACE: _core.types.cloneNode(srcNamespace)
        }));
      if (sourceMetadata.reexportAll) {
        let statement = buildNamespaceReexport(metadata, _core.types.cloneNode(srcNamespace), constantReexports);
        statement.loc = sourceMetadata.reexportAll.loc, statements.push(statement);
      }
      return statements;
    }
    var ReexportTemplate = {
      constant: ({
        exports: exports2,
        exportName,
        namespaceImport
      }) => _core.template.statement.ast`
      ${exports2}.${exportName} = ${namespaceImport};
    `,
      constantComputed: ({
        exports: exports2,
        exportName,
        namespaceImport
      }) => _core.template.statement.ast`
      ${exports2}["${exportName}"] = ${namespaceImport};
    `,
      spec: ({
        exports: exports2,
        exportName,
        namespaceImport
      }) => _core.template.statement.ast`
      Object.defineProperty(${exports2}, "${exportName}", {
        enumerable: true,
        get: function() {
          return ${namespaceImport};
        },
      });
    `
    };
    function buildReexportsFromMeta(meta, metadata, constantReexports, wrapReference) {
      var _wrapReference2;
      let namespace = _core.types.identifier(metadata.name);
      namespace = (_wrapReference2 = wrapReference(namespace, metadata.wrap)) != null ? _wrapReference2 : namespace;
      let {
        stringSpecifiers
      } = meta;
      return Array.from(metadata.reexports, ([exportName, importName]) => {
        let namespaceImport = _core.types.cloneNode(namespace);
        importName === "default" && metadata.interop === "node-default" || (stringSpecifiers.has(importName) ? namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.stringLiteral(importName), !0) : namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.identifier(importName)));
        let astNodes = {
          exports: meta.exportName,
          exportName,
          namespaceImport
        };
        return constantReexports || _core.types.isIdentifier(namespaceImport) ? stringSpecifiers.has(exportName) ? ReexportTemplate.constantComputed(astNodes) : ReexportTemplate.constant(astNodes) : ReexportTemplate.spec(astNodes);
      });
    }
    function buildESModuleHeader(metadata, enumerableModuleMeta = !1) {
      return (enumerableModuleMeta ? _core.template.statement`
        EXPORTS.__esModule = true;
      ` : _core.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
        EXPORTS: metadata.exportName
      });
    }
    function buildNamespaceReexport(metadata, namespace, constantReexports) {
      return (constantReexports ? _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
        NAMESPACE: namespace,
        EXPORTS: metadata.exportName,
        VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _core.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
          EXPORTS_LIST: metadata.exportNameListName
        }) : null
      });
    }
    function buildExportNameListDeclaration(programPath, metadata) {
      let exportedVars = /* @__PURE__ */ Object.create(null);
      for (let data of metadata.local.values())
        for (let name2 of data.names)
          exportedVars[name2] = !0;
      let hasReexport = !1;
      for (let data of metadata.source.values()) {
        for (let exportName of data.reexports.keys())
          exportedVars[exportName] = !0;
        for (let exportName of data.reexportNamespace)
          exportedVars[exportName] = !0;
        hasReexport = hasReexport || !!data.reexportAll;
      }
      if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
      let name = programPath.scope.generateUidIdentifier("exportNames");
      return delete exportedVars.default, {
        name: name.name,
        statement: _core.types.variableDeclaration("var", [_core.types.variableDeclarator(name, _core.types.valueToNode(exportedVars))])
      };
    }
    function buildExportInitializationStatements(programPath, metadata, wrapReference, constantReexports = !1, noIncompleteNsImportDetection = !1) {
      let initStatements = [];
      for (let [localName, data] of metadata.local)
        if (data.kind !== "import") {
          if (data.kind === "hoisted")
            initStatements.push([data.names[0], buildInitStatement(metadata, data.names, _core.types.identifier(localName))]);
          else if (!noIncompleteNsImportDetection)
            for (let exportName of data.names)
              initStatements.push([exportName, null]);
        }
      for (let data of metadata.source.values()) {
        if (!constantReexports) {
          let reexportsStatements = buildReexportsFromMeta(metadata, data, !1, wrapReference), reexports = [...data.reexports.keys()];
          for (let i = 0; i < reexportsStatements.length; i++)
            initStatements.push([reexports[i], reexportsStatements[i]]);
        }
        if (!noIncompleteNsImportDetection)
          for (let exportName of data.reexportNamespace)
            initStatements.push([exportName, null]);
      }
      initStatements.sort(([a], [b]) => a < b ? -1 : b < a ? 1 : 0);
      let results = [];
      if (noIncompleteNsImportDetection)
        for (let [, initStatement] of initStatements)
          results.push(initStatement);
      else
        for (let i = 0; i < initStatements.length; i += 100) {
          let uninitializedExportNames = [];
          for (let j = 0; j < 100 && i + j < initStatements.length; j++) {
            let [exportName, initStatement] = initStatements[i + j];
            initStatement !== null ? (uninitializedExportNames.length > 0 && (results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode())), uninitializedExportNames = []), results.push(initStatement)) : uninitializedExportNames.push(exportName);
          }
          uninitializedExportNames.length > 0 && results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
        }
      return results;
    }
    var InitTemplate = {
      computed: ({
        exports: exports2,
        name,
        value: value2
      }) => _core.template.expression.ast`${exports2}["${name}"] = ${value2}`,
      default: ({
        exports: exports2,
        name,
        value: value2
      }) => _core.template.expression.ast`${exports2}.${name} = ${value2}`,
      define: ({
        exports: exports2,
        name,
        value: value2
      }) => _core.template.expression.ast`
      Object.defineProperty(${exports2}, "${name}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${name}"] = ${value2}`
    };
    function buildInitStatement(metadata, exportNames, initExpr) {
      let {
        stringSpecifiers,
        exportName: exports2
      } = metadata;
      return _core.types.expressionStatement(exportNames.reduce((value2, name) => {
        let params = {
          exports: exports2,
          name,
          value: value2
        };
        return name === "__proto__" ? InitTemplate.define(params) : stringSpecifiers.has(name) ? InitTemplate.computed(params) : InitTemplate.default(params);
      }, initExpr));
    }
  }
});

// ../node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs
var require_babel_7_helpers = __commonJS({
  "../node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs"(exports) {
    exports.getModuleName = () => require_lib12().getModuleName;
  }
});

// ../node_modules/@babel/core/lib/transformation/file/file.js
var require_file = __commonJS({
  "../node_modules/@babel/core/lib/transformation/file/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    function helpers() {
      let data = require_lib8();
      return helpers = function() {
        return data;
      }, data;
    }
    function _traverse() {
      let data = require_lib10();
      return _traverse = function() {
        return data;
      }, data;
    }
    function _codeFrame() {
      let data = require_lib6();
      return _codeFrame = function() {
        return data;
      }, data;
    }
    function _t() {
      let data = require_lib4();
      return _t = function() {
        return data;
      }, data;
    }
    function _semver() {
      let data = __require("semver");
      return _semver = function() {
        return data;
      }, data;
    }
    var _babel7Helpers = require_babel_7_helpers(), {
      cloneNode,
      interpreterDirective,
      traverseFast
    } = _t(), File2 = class {
      constructor(options, {
        code,
        ast,
        inputMap
      }) {
        this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = {
          file: this,
          getCode: () => this.code,
          getScope: () => this.scope,
          addHelper: this.addHelper.bind(this),
          buildError: this.buildCodeFrameError.bind(this)
        }, this.opts = options, this.code = code, this.ast = ast, this.inputMap = inputMap, this.path = _traverse().NodePath.get({
          hub: this.hub,
          parentPath: null,
          parent: this.ast,
          container: this.ast,
          key: "program"
        }).setContext(), this.scope = this.path.scope;
      }
      get shebang() {
        let {
          interpreter
        } = this.path.node;
        return interpreter ? interpreter.value : "";
      }
      set shebang(value2) {
        value2 ? this.path.get("interpreter").replaceWith(interpreterDirective(value2)) : this.path.get("interpreter").remove();
      }
      set(key, val) {
        if (key === "helpersNamespace")
          throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
        this._map.set(key, val);
      }
      get(key) {
        return this._map.get(key);
      }
      has(key) {
        return this._map.has(key);
      }
      availableHelper(name, versionRange) {
        if (helpers().isInternal(name)) return !1;
        let minVersion;
        try {
          minVersion = helpers().minVersion(name);
        } catch (err) {
          if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
          return !1;
        }
        return typeof versionRange != "string" ? !0 : (_semver().valid(versionRange) && (versionRange = `^${versionRange}`), !_semver().intersects(`<${minVersion}`, versionRange) && !_semver().intersects(">=8.0.0", versionRange));
      }
      addHelper(name) {
        if (helpers().isInternal(name))
          throw new Error("Cannot use internal helper " + name);
        return this._addHelper(name);
      }
      _addHelper(name) {
        let declar = this.declarations[name];
        if (declar) return cloneNode(declar);
        let generator = this.get("helperGenerator");
        if (generator) {
          let res = generator(name);
          if (res) return res;
        }
        helpers().minVersion(name);
        let uid = this.declarations[name] = this.scope.generateUidIdentifier(name), dependencies = {};
        for (let dep of helpers().getDependencies(name))
          dependencies[dep] = this._addHelper(dep);
        let {
          nodes,
          globals
        } = helpers().get(name, (dep) => dependencies[dep], uid.name, Object.keys(this.scope.getAllBindings()));
        globals.forEach((name2) => {
          this.path.scope.hasBinding(name2, !0) && this.path.scope.rename(name2);
        }), nodes.forEach((node) => {
          node._compact = !0;
        });
        let added = this.path.unshiftContainer("body", nodes);
        for (let path of added)
          path.isVariableDeclaration() && this.scope.registerDeclaration(path);
        return uid;
      }
      buildCodeFrameError(node, msg, _Error = SyntaxError) {
        let loc = node?.loc;
        if (!loc && node) {
          traverseFast(node, function(node2) {
            if (node2.loc)
              return loc = node2.loc, traverseFast.stop;
          });
          let txt = "This is an error on an internal node. Probably an internal error.";
          loc && (txt += " Location has been estimated."), msg += ` (${txt})`;
        }
        if (loc) {
          let {
            highlightCode = !0
          } = this.opts;
          msg += `
` + (0, _codeFrame().codeFrameColumns)(this.code, {
            start: {
              line: loc.start.line,
              column: loc.start.column + 1
            },
            end: loc.end && loc.start.line === loc.end.line ? {
              line: loc.end.line,
              column: loc.end.column + 1
            } : void 0
          }, {
            highlightCode
          });
        }
        return new _Error(msg);
      }
    };
    exports.default = File2;
    File2.prototype.addImport = function() {
      throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
    }, File2.prototype.addTemplateObject = function() {
      throw new Error("This function has been moved into the template literal transform itself.");
    }, File2.prototype.getModuleName = function() {
      return _babel7Helpers.getModuleName()(this.opts, this.opts);
    };
  }
});

// ../node_modules/@babel/core/lib/tools/build-external-helpers.js
var require_build_external_helpers = __commonJS({
  "../node_modules/@babel/core/lib/tools/build-external-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = _default;
    function helpers() {
      let data = require_lib8();
      return helpers = function() {
        return data;
      }, data;
    }
    function _generator() {
      let data = require_lib9();
      return _generator = function() {
        return data;
      }, data;
    }
    function _template() {
      let data = require_lib7();
      return _template = function() {
        return data;
      }, data;
    }
    function _t() {
      let data = require_lib4();
      return _t = function() {
        return data;
      }, data;
    }
    var {
      arrayExpression,
      assignmentExpression,
      binaryExpression,
      blockStatement,
      callExpression,
      cloneNode,
      conditionalExpression,
      exportNamedDeclaration,
      exportSpecifier,
      expressionStatement,
      functionExpression,
      identifier,
      memberExpression,
      objectExpression,
      program,
      stringLiteral,
      unaryExpression,
      variableDeclaration,
      variableDeclarator
    } = _t(), buildUmdWrapper = (replacements) => _template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements);
    function buildGlobal(allowlist) {
      let namespace = identifier("babelHelpers"), body = [], container = functionExpression(null, [identifier("global")], blockStatement(body)), tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
      return body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression("=", memberExpression(identifier("global"), namespace), objectExpression([])))])), buildHelpers(body, namespace, allowlist), tree;
    }
    function buildModule(allowlist) {
      let body = [], refs = buildHelpers(body, null, allowlist);
      return body.unshift(exportNamedDeclaration(null, Object.keys(refs).map((name) => exportSpecifier(cloneNode(refs[name]), identifier(name))))), program(body, [], "module");
    }
    function buildUmd(allowlist) {
      let namespace = identifier("babelHelpers"), body = [];
      return body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier("global"))])), buildHelpers(body, namespace, allowlist), program([buildUmdWrapper({
        FACTORY_PARAMETERS: identifier("global"),
        BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace), objectExpression([])),
        COMMON_ARGUMENTS: identifier("exports"),
        AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]),
        FACTORY_BODY: body,
        UMD_ROOT: identifier("this")
      })]);
    }
    function buildVar(allowlist) {
      let namespace = identifier("babelHelpers"), body = [];
      body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression([]))]));
      let tree = program(body);
      return buildHelpers(body, namespace, allowlist), body.push(expressionStatement(namespace)), tree;
    }
    function buildHelpers(body, namespace, allowlist) {
      let getHelperReference = (name) => namespace ? memberExpression(namespace, identifier(name)) : identifier(`_${name}`), refs = {};
      return helpers().list.forEach(function(name) {
        if (allowlist && !allowlist.includes(name)) return;
        let ref = refs[name] = getHelperReference(name), {
          nodes
        } = helpers().get(name, getHelperReference, namespace ? null : `_${name}`, [], namespace ? (ast, exportName, mapExportBindingAssignments) => {
          mapExportBindingAssignments((node) => assignmentExpression("=", ref, node)), ast.body.push(expressionStatement(assignmentExpression("=", ref, identifier(exportName))));
        } : null);
        body.push(...nodes);
      }), refs;
    }
    function _default(allowlist, outputType = "global") {
      let tree, build = {
        global: buildGlobal,
        module: buildModule,
        umd: buildUmd,
        var: buildVar
      }[outputType];
      if (build)
        tree = build(allowlist);
      else
        throw new Error(`Unsupported output type ${outputType}`);
      return (0, _generator().default)(tree).code;
    }
  }
});

// ../node_modules/gensync/index.js
var require_gensync = __commonJS({
  "../node_modules/gensync/index.js"(exports, module) {
    "use strict";
    var GENSYNC_START = Symbol.for("gensync:v1:start"), GENSYNC_SUSPEND = Symbol.for("gensync:v1:suspend"), GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START", GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND", GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR", GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY", GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
    module.exports = Object.assign(
      function(optsOrFn) {
        let genFn = optsOrFn;
        return typeof optsOrFn != "function" ? genFn = newGenerator(optsOrFn) : genFn = wrapGenerator(optsOrFn), Object.assign(genFn, makeFunctionAPI(genFn));
      },
      {
        all: buildOperation({
          name: "all",
          arity: 1,
          sync: function(args) {
            return Array.from(args[0]).map((item) => evaluateSync(item));
          },
          async: function(args, resolve, reject) {
            let items = Array.from(args[0]);
            if (items.length === 0) {
              Promise.resolve().then(() => resolve([]));
              return;
            }
            let count = 0, results = items.map(() => {
            });
            items.forEach((item, i) => {
              evaluateAsync(
                item,
                (val) => {
                  results[i] = val, count += 1, count === results.length && resolve(results);
                },
                reject
              );
            });
          }
        }),
        race: buildOperation({
          name: "race",
          arity: 1,
          sync: function(args) {
            let items = Array.from(args[0]);
            if (items.length === 0)
              throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
            return evaluateSync(items[0]);
          },
          async: function(args, resolve, reject) {
            let items = Array.from(args[0]);
            if (items.length === 0)
              throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
            for (let item of items)
              evaluateAsync(item, resolve, reject);
          }
        })
      }
    );
    function makeFunctionAPI(genFn) {
      return {
        sync: function(...args) {
          return evaluateSync(genFn.apply(this, args));
        },
        async: function(...args) {
          return new Promise((resolve, reject) => {
            evaluateAsync(genFn.apply(this, args), resolve, reject);
          });
        },
        errback: function(...args) {
          let cb = args.pop();
          if (typeof cb != "function")
            throw makeError(
              "Asynchronous function called without callback",
              GENSYNC_ERRBACK_NO_CALLBACK
            );
          let gen;
          try {
            gen = genFn.apply(this, args);
          } catch (err) {
            cb(err);
            return;
          }
          evaluateAsync(gen, (val) => cb(void 0, val), (err) => cb(err));
        }
      };
    }
    function assertTypeof(type, name, value2, allowUndefined) {
      if (typeof value2 === type || allowUndefined && typeof value2 > "u")
        return;
      let msg;
      throw allowUndefined ? msg = `Expected opts.${name} to be either a ${type}, or undefined.` : msg = `Expected opts.${name} to be a ${type}.`, makeError(msg, GENSYNC_OPTIONS_ERROR);
    }
    function makeError(msg, code) {
      return Object.assign(new Error(msg), { code });
    }
    function newGenerator({ name, arity, sync, async, errback }) {
      if (assertTypeof(
        "string",
        "name",
        name,
        !0
        /* allowUndefined */
      ), assertTypeof(
        "number",
        "arity",
        arity,
        !0
        /* allowUndefined */
      ), assertTypeof("function", "sync", sync), assertTypeof(
        "function",
        "async",
        async,
        !0
        /* allowUndefined */
      ), assertTypeof(
        "function",
        "errback",
        errback,
        !0
        /* allowUndefined */
      ), async && errback)
        throw makeError(
          "Expected one of either opts.async or opts.errback, but got _both_.",
          GENSYNC_OPTIONS_ERROR
        );
      if (typeof name != "string") {
        let fnName;
        errback && errback.name && errback.name !== "errback" && (fnName = errback.name), async && async.name && async.name !== "async" && (fnName = async.name.replace(/Async$/, "")), sync && sync.name && sync.name !== "sync" && (fnName = sync.name.replace(/Sync$/, "")), typeof fnName == "string" && (name = fnName);
      }
      return typeof arity != "number" && (arity = sync.length), buildOperation({
        name,
        arity,
        sync: function(args) {
          return sync.apply(this, args);
        },
        async: function(args, resolve, reject) {
          async ? async.apply(this, args).then(resolve, reject) : errback ? errback.call(this, ...args, (err, value2) => {
            err == null ? resolve(value2) : reject(err);
          }) : resolve(sync.apply(this, args));
        }
      });
    }
    function wrapGenerator(genFn) {
      return setFunctionMetadata(genFn.name, genFn.length, function(...args) {
        return genFn.apply(this, args);
      });
    }
    function buildOperation({ name, arity, sync, async }) {
      return setFunctionMetadata(name, arity, function* (...args) {
        let resume = yield GENSYNC_START;
        if (!resume)
          return sync.call(this, args);
        let result;
        try {
          async.call(
            this,
            args,
            (value2) => {
              result || (result = { value: value2 }, resume());
            },
            (err) => {
              result || (result = { err }, resume());
            }
          );
        } catch (err) {
          result = { err }, resume();
        }
        if (yield GENSYNC_SUSPEND, result.hasOwnProperty("err"))
          throw result.err;
        return result.value;
      });
    }
    function evaluateSync(gen) {
      let value2;
      for (; !({ value: value2 } = gen.next()).done; )
        assertStart(value2, gen);
      return value2;
    }
    function evaluateAsync(gen, resolve, reject) {
      (function step() {
        try {
          let value2;
          for (; !({ value: value2 } = gen.next()).done; ) {
            assertStart(value2, gen);
            let sync = !0, didSyncResume = !1, out = gen.next(() => {
              sync ? didSyncResume = !0 : step();
            });
            if (sync = !1, assertSuspend(out, gen), !didSyncResume)
              return;
          }
          return resolve(value2);
        } catch (err) {
          return reject(err);
        }
      })();
    }
    function assertStart(value2, gen) {
      value2 !== GENSYNC_START && throwError(
        gen,
        makeError(
          `Got unexpected yielded value in gensync generator: ${JSON.stringify(
            value2
          )}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,
          GENSYNC_EXPECTED_START
        )
      );
    }
    function assertSuspend({ value: value2, done }, gen) {
      !done && value2 === GENSYNC_SUSPEND || throwError(
        gen,
        makeError(
          done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(
            value2
          )}. If you get this, it is probably a gensync bug.`,
          GENSYNC_EXPECTED_SUSPEND
        )
      );
    }
    function throwError(gen, err) {
      throw gen.throw && gen.throw(err), err;
    }
    function setFunctionMetadata(name, arity, fn) {
      if (typeof name == "string") {
        let nameDesc = Object.getOwnPropertyDescriptor(fn, "name");
        (!nameDesc || nameDesc.configurable) && Object.defineProperty(
          fn,
          "name",
          Object.assign(nameDesc || {}, {
            configurable: !0,
            value: name
          })
        );
      }
      if (typeof arity == "number") {
        let lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");
        (!lengthDesc || lengthDesc.configurable) && Object.defineProperty(
          fn,
          "length",
          Object.assign(lengthDesc || {}, {
            configurable: !0,
            value: arity
          })
        );
      }
      return fn;
    }
  }
});

// ../node_modules/@babel/core/lib/gensync-utils/async.js
var require_async = __commonJS({
  "../node_modules/@babel/core/lib/gensync-utils/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.forwardAsync = forwardAsync;
    exports.isAsync = void 0;
    exports.isThenable = isThenable;
    exports.maybeAsync = maybeAsync;
    exports.waitFor = exports.onFirstPause = void 0;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var runGenerator = _gensync()(function* (item) {
      return yield* item;
    }), isAsync = exports.isAsync = _gensync()({
      sync: () => !1,
      errback: (cb) => cb(null, !0)
    });
    function maybeAsync(fn, message) {
      return _gensync()({
        sync(...args) {
          let result = fn.apply(this, args);
          if (isThenable(result)) throw new Error(message);
          return result;
        },
        async(...args) {
          return Promise.resolve(fn.apply(this, args));
        }
      });
    }
    var withKind = _gensync()({
      sync: (cb) => cb("sync"),
      async: (function() {
        var _ref = _asyncToGenerator(function* (cb) {
          return cb("async");
        });
        return function(_x) {
          return _ref.apply(this, arguments);
        };
      })()
    });
    function forwardAsync(action, cb) {
      let g = _gensync()(action);
      return withKind((kind) => {
        let adapted = g[kind];
        return cb(adapted);
      });
    }
    var onFirstPause = exports.onFirstPause = _gensync()({
      name: "onFirstPause",
      arity: 2,
      sync: function(item) {
        return runGenerator.sync(item);
      },
      errback: function(item, firstPause, cb) {
        let completed = !1;
        runGenerator.errback(item, (err, value2) => {
          completed = !0, cb(err, value2);
        }), completed || firstPause();
      }
    }), waitFor = exports.waitFor = _gensync()({
      sync: (x) => x,
      async: (function() {
        var _ref2 = _asyncToGenerator(function* (x) {
          return x;
        });
        return function(_x2) {
          return _ref2.apply(this, arguments);
        };
      })()
    });
    function isThenable(val) {
      return !!val && (typeof val == "object" || typeof val == "function") && !!val.then && typeof val.then == "function";
    }
  }
});

// ../node_modules/@babel/core/lib/config/util.js
var require_util2 = __commonJS({
  "../node_modules/@babel/core/lib/config/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.isIterableIterator = isIterableIterator;
    exports.mergeOptions = mergeOptions;
    function mergeOptions(target, source) {
      for (let k of Object.keys(source))
        if ((k === "parserOpts" || k === "generatorOpts" || k === "assumptions") && source[k]) {
          let parserOpts = source[k], targetObj = target[k] || (target[k] = {});
          mergeDefaultFields(targetObj, parserOpts);
        } else {
          let val = source[k];
          val !== void 0 && (target[k] = val);
        }
    }
    function mergeDefaultFields(target, source) {
      for (let k of Object.keys(source)) {
        let val = source[k];
        val !== void 0 && (target[k] = val);
      }
    }
    function isIterableIterator(value2) {
      return !!value2 && typeof value2.next == "function" && typeof value2[Symbol.iterator] == "function";
    }
  }
});

// ../node_modules/@babel/core/lib/config/caching.js
var require_caching = __commonJS({
  "../node_modules/@babel/core/lib/config/caching.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.assertSimpleType = assertSimpleType;
    exports.makeStrongCache = makeStrongCache;
    exports.makeStrongCacheSync = makeStrongCacheSync;
    exports.makeWeakCache = makeWeakCache;
    exports.makeWeakCacheSync = makeWeakCacheSync;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var _async = require_async(), _util = require_util2(), synchronize = (gen) => _gensync()(gen).sync;
    function* genTrue() {
      return !0;
    }
    function makeWeakCache(handler) {
      return makeCachedFunction(WeakMap, handler);
    }
    function makeWeakCacheSync(handler) {
      return synchronize(makeWeakCache(handler));
    }
    function makeStrongCache(handler) {
      return makeCachedFunction(Map, handler);
    }
    function makeStrongCacheSync(handler) {
      return synchronize(makeStrongCache(handler));
    }
    function makeCachedFunction(CallCache, handler) {
      let callCacheSync = new CallCache(), callCacheAsync = new CallCache(), futureCache = new CallCache();
      return function* (arg, data) {
        let asyncContext = yield* (0, _async.isAsync)(), callCache = asyncContext ? callCacheAsync : callCacheSync, cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);
        if (cached.valid) return cached.value;
        let cache = new CacheConfigurator(data), handlerResult = handler(arg, cache), finishLock, value2;
        return (0, _util.isIterableIterator)(handlerResult) ? value2 = yield* (0, _async.onFirstPause)(handlerResult, () => {
          finishLock = setupAsyncLocks(cache, futureCache, arg);
        }) : value2 = handlerResult, updateFunctionCache(callCache, cache, arg, value2), finishLock && (futureCache.delete(arg), finishLock.release(value2)), value2;
      };
    }
    function* getCachedValue(cache, arg, data) {
      let cachedValue = cache.get(arg);
      if (cachedValue) {
        for (let {
          value: value2,
          valid
        } of cachedValue)
          if (yield* valid(data)) return {
            valid: !0,
            value: value2
          };
      }
      return {
        valid: !1,
        value: null
      };
    }
    function* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {
      let cached = yield* getCachedValue(callCache, arg, data);
      if (cached.valid)
        return cached;
      if (asyncContext) {
        let cached2 = yield* getCachedValue(futureCache, arg, data);
        if (cached2.valid)
          return {
            valid: !0,
            value: yield* (0, _async.waitFor)(cached2.value.promise)
          };
      }
      return {
        valid: !1,
        value: null
      };
    }
    function setupAsyncLocks(config, futureCache, arg) {
      let finishLock = new Lock();
      return updateFunctionCache(futureCache, config, arg, finishLock), finishLock;
    }
    function updateFunctionCache(cache, config, arg, value2) {
      config.configured() || config.forever();
      let cachedValue = cache.get(arg);
      switch (config.deactivate(), config.mode()) {
        case "forever":
          cachedValue = [{
            value: value2,
            valid: genTrue
          }], cache.set(arg, cachedValue);
          break;
        case "invalidate":
          cachedValue = [{
            value: value2,
            valid: config.validator()
          }], cache.set(arg, cachedValue);
          break;
        case "valid":
          cachedValue ? cachedValue.push({
            value: value2,
            valid: config.validator()
          }) : (cachedValue = [{
            value: value2,
            valid: config.validator()
          }], cache.set(arg, cachedValue));
      }
    }
    var CacheConfigurator = class {
      constructor(data) {
        this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0, this._data = data;
      }
      simple() {
        return makeSimpleConfigurator(this);
      }
      mode() {
        return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
      }
      forever() {
        if (!this._active)
          throw new Error("Cannot change caching after evaluation has completed.");
        if (this._never)
          throw new Error("Caching has already been configured with .never()");
        this._forever = !0, this._configured = !0;
      }
      never() {
        if (!this._active)
          throw new Error("Cannot change caching after evaluation has completed.");
        if (this._forever)
          throw new Error("Caching has already been configured with .forever()");
        this._never = !0, this._configured = !0;
      }
      using(handler) {
        if (!this._active)
          throw new Error("Cannot change caching after evaluation has completed.");
        if (this._never || this._forever)
          throw new Error("Caching has already been configured with .never or .forever()");
        this._configured = !0;
        let key = handler(this._data), fn = (0, _async.maybeAsync)(handler, "You appear to be using an async cache handler, but Babel has been called synchronously");
        return (0, _async.isThenable)(key) ? key.then((key2) => (this._pairs.push([key2, fn]), key2)) : (this._pairs.push([key, fn]), key);
      }
      invalidate(handler) {
        return this._invalidate = !0, this.using(handler);
      }
      validator() {
        let pairs = this._pairs;
        return function* (data) {
          for (let [key, fn] of pairs)
            if (key !== (yield* fn(data))) return !1;
          return !0;
        };
      }
      deactivate() {
        this._active = !1;
      }
      configured() {
        return this._configured;
      }
    };
    function makeSimpleConfigurator(cache) {
      function cacheFn(val) {
        if (typeof val == "boolean") {
          val ? cache.forever() : cache.never();
          return;
        }
        return cache.using(() => assertSimpleType(val()));
      }
      return cacheFn.forever = () => cache.forever(), cacheFn.never = () => cache.never(), cacheFn.using = (cb) => cache.using(() => assertSimpleType(cb())), cacheFn.invalidate = (cb) => cache.invalidate(() => assertSimpleType(cb())), cacheFn;
    }
    function assertSimpleType(value2) {
      if ((0, _async.isThenable)(value2))
        throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
      if (value2 != null && typeof value2 != "string" && typeof value2 != "boolean" && typeof value2 != "number")
        throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
      return value2;
    }
    var Lock = class {
      constructor() {
        this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((resolve) => {
          this._resolve = resolve;
        });
      }
      release(value2) {
        this.released = !0, this._resolve(value2);
      }
    };
  }
});

// ../node_modules/@babel/core/lib/gensync-utils/fs.js
var require_fs = __commonJS({
  "../node_modules/@babel/core/lib/gensync-utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.stat = exports.readFile = void 0;
    function _fs() {
      let data = __require("fs");
      return _fs = function() {
        return data;
      }, data;
    }
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var readFile = exports.readFile = _gensync()({
      sync: _fs().readFileSync,
      errback: _fs().readFile
    }), stat = exports.stat = _gensync()({
      sync: _fs().statSync,
      errback: _fs().stat
    });
  }
});

// ../node_modules/@babel/core/lib/config/files/utils.js
var require_utils2 = __commonJS({
  "../node_modules/@babel/core/lib/config/files/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.makeStaticFileCache = makeStaticFileCache;
    var _caching = require_caching(), fs = require_fs();
    function _fs2() {
      let data = __require("fs");
      return _fs2 = function() {
        return data;
      }, data;
    }
    function makeStaticFileCache(fn) {
      return (0, _caching.makeStrongCache)(function* (filepath, cache) {
        return cache.invalidate(() => fileMtime(filepath)) === null ? null : fn(filepath, yield* fs.readFile(filepath, "utf8"));
      });
    }
    function fileMtime(filepath) {
      if (!_fs2().existsSync(filepath)) return null;
      try {
        return +_fs2().statSync(filepath).mtime;
      } catch (e) {
        if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
      }
      return null;
    }
  }
});

// ../node_modules/@babel/core/lib/errors/rewrite-stack-trace.js
var require_rewrite_stack_trace = __commonJS({
  "../node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.beginHiddenCallStack = beginHiddenCallStack;
    exports.endHiddenCallStack = endHiddenCallStack;
    exports.expectedError = expectedError;
    exports.injectVirtualStackFrame = injectVirtualStackFrame;
    var _Object$getOwnPropert, ErrorToString = Function.call.bind(Error.prototype.toString), SUPPORTED = !!Error.captureStackTrace && ((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : _Object$getOwnPropert.writable) === !0, START_HIDING = "startHiding - secret - don't use this - v1", STOP_HIDING = "stopHiding - secret - don't use this - v1", expectedErrors = /* @__PURE__ */ new WeakSet(), virtualFrames = /* @__PURE__ */ new WeakMap();
    function CallSite(filename) {
      return /* @__PURE__ */ Object.create({
        isNative: () => !1,
        isConstructor: () => !1,
        isToplevel: () => !0,
        getFileName: () => filename,
        getLineNumber: () => {
        },
        getColumnNumber: () => {
        },
        getFunctionName: () => {
        },
        getMethodName: () => {
        },
        getTypeName: () => {
        },
        toString: () => filename
      });
    }
    function injectVirtualStackFrame(error, filename) {
      if (!SUPPORTED) return;
      let frames = virtualFrames.get(error);
      return frames || virtualFrames.set(error, frames = []), frames.push(CallSite(filename)), error;
    }
    function expectedError(error) {
      if (SUPPORTED)
        return expectedErrors.add(error), error;
    }
    function beginHiddenCallStack(fn) {
      return SUPPORTED ? Object.defineProperty(function(...args) {
        return setupPrepareStackTrace(), fn(...args);
      }, "name", {
        value: STOP_HIDING
      }) : fn;
    }
    function endHiddenCallStack(fn) {
      return SUPPORTED ? Object.defineProperty(function(...args) {
        return fn(...args);
      }, "name", {
        value: START_HIDING
      }) : fn;
    }
    function setupPrepareStackTrace() {
      setupPrepareStackTrace = () => {
      };
      let {
        prepareStackTrace = defaultPrepareStackTrace
      } = Error, MIN_STACK_TRACE_LIMIT = 50;
      Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, MIN_STACK_TRACE_LIMIT)), Error.prepareStackTrace = function(err, trace) {
        let newTrace = [], status = expectedErrors.has(err) ? "hiding" : "unknown";
        for (let i = 0; i < trace.length; i++) {
          let name = trace[i].getFunctionName();
          if (name === START_HIDING)
            status = "hiding";
          else if (name === STOP_HIDING) {
            if (status === "hiding")
              status = "showing", virtualFrames.has(err) && newTrace.unshift(...virtualFrames.get(err));
            else if (status === "unknown") {
              newTrace = trace;
              break;
            }
          } else status !== "hiding" && newTrace.push(trace[i]);
        }
        return prepareStackTrace(err, newTrace);
      };
    }
    function defaultPrepareStackTrace(err, trace) {
      return trace.length === 0 ? ErrorToString(err) : `${ErrorToString(err)}
    at ${trace.join(`
    at `)}`;
    }
  }
});

// ../node_modules/@babel/core/lib/errors/config-error.js
var require_config_error = __commonJS({
  "../node_modules/@babel/core/lib/errors/config-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _rewriteStackTrace = require_rewrite_stack_trace(), ConfigError = class extends Error {
      constructor(message, filename) {
        super(message), (0, _rewriteStackTrace.expectedError)(this), filename && (0, _rewriteStackTrace.injectVirtualStackFrame)(this, filename);
      }
    };
    exports.default = ConfigError;
  }
});

// ../node_modules/@babel/core/lib/config/files/package.js
var require_package = __commonJS({
  "../node_modules/@babel/core/lib/config/files/package.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.findPackageData = findPackageData;
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    var _utils = require_utils2(), _configError = require_config_error(), PACKAGE_FILENAME = "package.json", readConfigPackage = (0, _utils.makeStaticFileCache)((filepath, content) => {
      let options;
      try {
        options = JSON.parse(content);
      } catch (err) {
        throw new _configError.default(`Error while parsing JSON - ${err.message}`, filepath);
      }
      if (!options) throw new Error(`${filepath}: No config detected`);
      if (typeof options != "object")
        throw new _configError.default(`Config returned typeof ${typeof options}`, filepath);
      if (Array.isArray(options))
        throw new _configError.default("Expected config object but found array", filepath);
      return {
        filepath,
        dirname: _path().dirname(filepath),
        options
      };
    });
    function* findPackageData(filepath) {
      let pkg = null, directories = [], isPackage = !0, dirname = _path().dirname(filepath);
      for (; !pkg && _path().basename(dirname) !== "node_modules"; ) {
        directories.push(dirname), pkg = yield* readConfigPackage(_path().join(dirname, PACKAGE_FILENAME));
        let nextLoc = _path().dirname(dirname);
        if (dirname === nextLoc) {
          isPackage = !1;
          break;
        }
        dirname = nextLoc;
      }
      return {
        filepath,
        directories,
        pkg,
        isPackage
      };
    }
  }
});

// ../node_modules/@babel/core/lib/config/helpers/config-api.js
var require_config_api = __commonJS({
  "../node_modules/@babel/core/lib/config/helpers/config-api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.makeConfigAPI = makeConfigAPI;
    exports.makePluginAPI = makePluginAPI;
    exports.makePresetAPI = makePresetAPI;
    function _semver() {
      let data = __require("semver");
      return _semver = function() {
        return data;
      }, data;
    }
    var _index = require_lib27(), _caching = require_caching();
    function makeConfigAPI(cache) {
      let env = (value2) => cache.using((data) => value2 === void 0 ? data.envName : typeof value2 == "function" ? (0, _caching.assertSimpleType)(value2(data.envName)) : (Array.isArray(value2) ? value2 : [value2]).some((entry) => {
        if (typeof entry != "string")
          throw new Error("Unexpected non-string value");
        return entry === data.envName;
      })), caller = (cb) => cache.using((data) => (0, _caching.assertSimpleType)(cb(data.caller)));
      return {
        version: _index.version,
        cache: cache.simple(),
        env,
        async: () => !1,
        caller,
        assertVersion
      };
    }
    function makePresetAPI(cache, externalDependencies) {
      let targets = () => JSON.parse(cache.using((data) => JSON.stringify(data.targets))), addExternalDependency = (ref) => {
        externalDependencies.push(ref);
      };
      return Object.assign({}, makeConfigAPI(cache), {
        targets,
        addExternalDependency
      });
    }
    function makePluginAPI(cache, externalDependencies) {
      let assumption = (name) => cache.using((data) => data.assumptions[name]);
      return Object.assign({}, makePresetAPI(cache, externalDependencies), {
        assumption
      });
    }
    function assertVersion(range) {
      if (typeof range == "number") {
        if (!Number.isInteger(range))
          throw new Error("Expected string or integer value.");
        range = `^${range}.0.0-0`;
      }
      if (typeof range != "string")
        throw new Error("Expected string or integer value.");
      if (range === "*" || _semver().satisfies(_index.version, range)) return;
      let limit = Error.stackTraceLimit;
      typeof limit == "number" && limit < 25 && (Error.stackTraceLimit = 25);
      let err = new Error(`Requires Babel "${range}", but was loaded with "${_index.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
      throw typeof limit == "number" && (Error.stackTraceLimit = limit), Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version: _index.version,
        range
      });
    }
  }
});

// ../node_modules/@babel/core/lib/config/helpers/deep-array.js
var require_deep_array = __commonJS({
  "../node_modules/@babel/core/lib/config/helpers/deep-array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.finalize = finalize;
    exports.flattenToSet = flattenToSet;
    function finalize(deepArr) {
      return Object.freeze(deepArr);
    }
    function flattenToSet(arr) {
      let result = /* @__PURE__ */ new Set(), stack = [arr];
      for (; stack.length > 0; )
        for (let el of stack.pop())
          Array.isArray(el) ? stack.push(el) : result.add(el);
      return result;
    }
  }
});

// ../node_modules/@babel/core/lib/config/plugin.js
var require_plugin = __commonJS({
  "../node_modules/@babel/core/lib/config/plugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _deepArray = require_deep_array(), Plugin = class {
      constructor(plugin, options, key, externalDependencies = (0, _deepArray.finalize)([])) {
        this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = plugin.name || key, this.manipulateOptions = plugin.manipulateOptions, this.post = plugin.post, this.pre = plugin.pre, this.visitor = plugin.visitor || {}, this.parserOverride = plugin.parserOverride, this.generatorOverride = plugin.generatorOverride, this.options = options, this.externalDependencies = externalDependencies;
      }
    };
    exports.default = Plugin;
  }
});

// ../node_modules/@babel/core/lib/gensync-utils/functional.js
var require_functional = __commonJS({
  "../node_modules/@babel/core/lib/gensync-utils/functional.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.once = once;
    var _async = require_async();
    function once(fn) {
      let result, resultP, promiseReferenced = !1;
      return function* () {
        if (!result) {
          if (resultP)
            return promiseReferenced = !0, yield* (0, _async.waitFor)(resultP);
          if (yield* (0, _async.isAsync)()) {
            let resolve, reject;
            resultP = new Promise((res, rej) => {
              resolve = res, reject = rej;
            });
            try {
              result = {
                ok: !0,
                value: yield* fn()
              }, resultP = null, promiseReferenced && resolve(result.value);
            } catch (error) {
              result = {
                ok: !1,
                value: error
              }, resultP = null, promiseReferenced && reject(error);
            }
          } else
            try {
              result = {
                ok: !0,
                value: yield* fn()
              };
            } catch (error) {
              result = {
                ok: !1,
                value: error
              };
            }
        }
        if (result.ok) return result.value;
        throw result.value;
      };
    }
  }
});

// ../node_modules/baseline-browser-mapping/dist/index.cjs
var require_dist = __commonJS({
  "../node_modules/baseline-browser-mapping/dist/index.cjs"(exports) {
    "use strict";
    var s = { chrome: { releases: [["1", "2008-12-11", "r", "w", "528"], ["2", "2009-05-21", "r", "w", "530"], ["3", "2009-09-15", "r", "w", "532"], ["4", "2010-01-25", "r", "w", "532.5"], ["5", "2010-05-25", "r", "w", "533"], ["6", "2010-09-02", "r", "w", "534.3"], ["7", "2010-10-19", "r", "w", "534.7"], ["8", "2010-12-02", "r", "w", "534.10"], ["9", "2011-02-03", "r", "w", "534.13"], ["10", "2011-03-08", "r", "w", "534.16"], ["11", "2011-04-27", "r", "w", "534.24"], ["12", "2011-06-07", "r", "w", "534.30"], ["13", "2011-08-02", "r", "w", "535.1"], ["14", "2011-09-16", "r", "w", "535.1"], ["15", "2011-10-25", "r", "w", "535.2"], ["16", "2011-12-13", "r", "w", "535.7"], ["17", "2012-02-08", "r", "w", "535.11"], ["18", "2012-03-28", "r", "w", "535.19"], ["19", "2012-05-15", "r", "w", "536.5"], ["20", "2012-06-26", "r", "w", "536.10"], ["21", "2012-07-31", "r", "w", "537.1"], ["22", "2012-09-25", "r", "w", "537.4"], ["23", "2012-11-06", "r", "w", "537.11"], ["24", "2013-01-10", "r", "w", "537.17"], ["25", "2013-02-21", "r", "w", "537.22"], ["26", "2013-03-26", "r", "w", "537.31"], ["27", "2013-05-21", "r", "w", "537.36"], ["28", "2013-07-09", "r", "b", "28"], ["29", "2013-08-20", "r", "b", "29"], ["30", "2013-10-01", "r", "b", "30"], ["31", "2013-11-12", "r", "b", "31"], ["32", "2014-01-14", "r", "b", "32"], ["33", "2014-02-20", "r", "b", "33"], ["34", "2014-04-08", "r", "b", "34"], ["35", "2014-05-20", "r", "b", "35"], ["36", "2014-07-16", "r", "b", "36"], ["37", "2014-08-26", "r", "b", "37"], ["38", "2014-10-07", "r", "b", "38"], ["39", "2014-11-18", "r", "b", "39"], ["40", "2015-01-21", "r", "b", "40"], ["41", "2015-03-03", "r", "b", "41"], ["42", "2015-04-14", "r", "b", "42"], ["43", "2015-05-19", "r", "b", "43"], ["44", "2015-07-21", "r", "b", "44"], ["45", "2015-09-01", "r", "b", "45"], ["46", "2015-10-13", "r", "b", "46"], ["47", "2015-12-01", "r", "b", "47"], ["48", "2016-01-20", "r", "b", "48"], ["49", "2016-03-02", "r", "b", "49"], ["50", "2016-04-13", "r", "b", "50"], ["51", "2016-05-25", "r", "b", "51"], ["52", "2016-07-20", "r", "b", "52"], ["53", "2016-08-31", "r", "b", "53"], ["54", "2016-10-12", "r", "b", "54"], ["55", "2016-12-01", "r", "b", "55"], ["56", "2017-01-25", "r", "b", "56"], ["57", "2017-03-09", "r", "b", "57"], ["58", "2017-04-19", "r", "b", "58"], ["59", "2017-06-05", "r", "b", "59"], ["60", "2017-07-25", "r", "b", "60"], ["61", "2017-09-05", "r", "b", "61"], ["62", "2017-10-17", "r", "b", "62"], ["63", "2017-12-06", "r", "b", "63"], ["64", "2018-01-23", "r", "b", "64"], ["65", "2018-03-06", "r", "b", "65"], ["66", "2018-04-17", "r", "b", "66"], ["67", "2018-05-29", "r", "b", "67"], ["68", "2018-07-24", "r", "b", "68"], ["69", "2018-09-04", "r", "b", "69"], ["70", "2018-10-16", "r", "b", "70"], ["71", "2018-12-04", "r", "b", "71"], ["72", "2019-01-29", "r", "b", "72"], ["73", "2019-03-12", "r", "b", "73"], ["74", "2019-04-23", "r", "b", "74"], ["75", "2019-06-04", "r", "b", "75"], ["76", "2019-07-30", "r", "b", "76"], ["77", "2019-09-10", "r", "b", "77"], ["78", "2019-10-22", "r", "b", "78"], ["79", "2019-12-10", "r", "b", "79"], ["80", "2020-02-04", "r", "b", "80"], ["81", "2020-04-07", "r", "b", "81"], ["83", "2020-05-19", "r", "b", "83"], ["84", "2020-07-27", "r", "b", "84"], ["85", "2020-08-25", "r", "b", "85"], ["86", "2020-10-20", "r", "b", "86"], ["87", "2020-11-17", "r", "b", "87"], ["88", "2021-01-19", "r", "b", "88"], ["89", "2021-03-02", "r", "b", "89"], ["90", "2021-04-13", "r", "b", "90"], ["91", "2021-05-25", "r", "b", "91"], ["92", "2021-07-20", "r", "b", "92"], ["93", "2021-08-31", "r", "b", "93"], ["94", "2021-09-21", "r", "b", "94"], ["95", "2021-10-19", "r", "b", "95"], ["96", "2021-11-15", "r", "b", "96"], ["97", "2022-01-04", "r", "b", "97"], ["98", "2022-02-01", "r", "b", "98"], ["99", "2022-03-01", "r", "b", "99"], ["100", "2022-03-29", "r", "b", "100"], ["101", "2022-04-26", "r", "b", "101"], ["102", "2022-05-24", "r", "b", "102"], ["103", "2022-06-21", "r", "b", "103"], ["104", "2022-08-02", "r", "b", "104"], ["105", "2022-09-02", "r", "b", "105"], ["106", "2022-09-27", "r", "b", "106"], ["107", "2022-10-25", "r", "b", "107"], ["108", "2022-11-29", "r", "b", "108"], ["109", "2023-01-10", "r", "b", "109"], ["110", "2023-02-07", "r", "b", "110"], ["111", "2023-03-07", "r", "b", "111"], ["112", "2023-04-04", "r", "b", "112"], ["113", "2023-05-02", "r", "b", "113"], ["114", "2023-05-30", "r", "b", "114"], ["115", "2023-07-18", "r", "b", "115"], ["116", "2023-08-15", "r", "b", "116"], ["117", "2023-09-12", "r", "b", "117"], ["118", "2023-10-10", "r", "b", "118"], ["119", "2023-10-31", "r", "b", "119"], ["120", "2023-12-05", "r", "b", "120"], ["121", "2024-01-23", "r", "b", "121"], ["122", "2024-02-20", "r", "b", "122"], ["123", "2024-03-19", "r", "b", "123"], ["124", "2024-04-16", "r", "b", "124"], ["125", "2024-05-14", "r", "b", "125"], ["126", "2024-06-11", "r", "b", "126"], ["127", "2024-07-23", "r", "b", "127"], ["128", "2024-08-20", "r", "b", "128"], ["129", "2024-09-17", "r", "b", "129"], ["130", "2024-10-15", "r", "b", "130"], ["131", "2024-11-12", "r", "b", "131"], ["132", "2025-01-14", "r", "b", "132"], ["133", "2025-02-04", "r", "b", "133"], ["134", "2025-03-04", "r", "b", "134"], ["135", "2025-04-01", "r", "b", "135"], ["136", "2025-04-29", "r", "b", "136"], ["137", "2025-05-27", "r", "b", "137"], ["138", "2025-06-24", "r", "b", "138"], ["139", "2025-08-05", "r", "b", "139"], ["140", "2025-09-02", "r", "b", "140"], ["141", "2025-09-30", "r", "b", "141"], ["142", "2025-10-28", "c", "b", "142"], ["143", "2025-12-02", "b", "b", "143"], ["144", "2026-01-13", "n", "b", "144"], ["145", null, "p", "b", "145"]] }, chrome_android: { releases: [["18", "2012-06-27", "r", "w", "535.19"], ["25", "2013-02-27", "r", "w", "537.22"], ["26", "2013-04-03", "r", "w", "537.31"], ["27", "2013-05-22", "r", "w", "537.36"], ["28", "2013-07-10", "r", "b", "28"], ["29", "2013-08-21", "r", "b", "29"], ["30", "2013-10-02", "r", "b", "30"], ["31", "2013-11-14", "r", "b", "31"], ["32", "2014-01-15", "r", "b", "32"], ["33", "2014-02-26", "r", "b", "33"], ["34", "2014-04-02", "r", "b", "34"], ["35", "2014-05-20", "r", "b", "35"], ["36", "2014-07-16", "r", "b", "36"], ["37", "2014-09-03", "r", "b", "37"], ["38", "2014-10-08", "r", "b", "38"], ["39", "2014-11-12", "r", "b", "39"], ["40", "2015-01-21", "r", "b", "40"], ["41", "2015-03-11", "r", "b", "41"], ["42", "2015-04-15", "r", "b", "42"], ["43", "2015-05-27", "r", "b", "43"], ["44", "2015-07-29", "r", "b", "44"], ["45", "2015-09-01", "r", "b", "45"], ["46", "2015-10-14", "r", "b", "46"], ["47", "2015-12-02", "r", "b", "47"], ["48", "2016-01-26", "r", "b", "48"], ["49", "2016-03-09", "r", "b", "49"], ["50", "2016-04-13", "r", "b", "50"], ["51", "2016-06-08", "r", "b", "51"], ["52", "2016-07-27", "r", "b", "52"], ["53", "2016-09-07", "r", "b", "53"], ["54", "2016-10-19", "r", "b", "54"], ["55", "2016-12-06", "r", "b", "55"], ["56", "2017-02-01", "r", "b", "56"], ["57", "2017-03-16", "r", "b", "57"], ["58", "2017-04-25", "r", "b", "58"], ["59", "2017-06-06", "r", "b", "59"], ["60", "2017-08-01", "r", "b", "60"], ["61", "2017-09-05", "r", "b", "61"], ["62", "2017-10-24", "r", "b", "62"], ["63", "2017-12-05", "r", "b", "63"], ["64", "2018-01-23", "r", "b", "64"], ["65", "2018-03-06", "r", "b", "65"], ["66", "2018-04-17", "r", "b", "66"], ["67", "2018-05-31", "r", "b", "67"], ["68", "2018-07-24", "r", "b", "68"], ["69", "2018-09-04", "r", "b", "69"], ["70", "2018-10-17", "r", "b", "70"], ["71", "2018-12-04", "r", "b", "71"], ["72", "2019-01-29", "r", "b", "72"], ["73", "2019-03-12", "r", "b", "73"], ["74", "2019-04-24", "r", "b", "74"], ["75", "2019-06-04", "r", "b", "75"], ["76", "2019-07-30", "r", "b", "76"], ["77", "2019-09-10", "r", "b", "77"], ["78", "2019-10-22", "r", "b", "78"], ["79", "2019-12-17", "r", "b", "79"], ["80", "2020-02-04", "r", "b", "80"], ["81", "2020-04-07", "r", "b", "81"], ["83", "2020-05-19", "r", "b", "83"], ["84", "2020-07-27", "r", "b", "84"], ["85", "2020-08-25", "r", "b", "85"], ["86", "2020-10-20", "r", "b", "86"], ["87", "2020-11-17", "r", "b", "87"], ["88", "2021-01-19", "r", "b", "88"], ["89", "2021-03-02", "r", "b", "89"], ["90", "2021-04-13", "r", "b", "90"], ["91", "2021-05-25", "r", "b", "91"], ["92", "2021-07-20", "r", "b", "92"], ["93", "2021-08-31", "r", "b", "93"], ["94", "2021-09-21", "r", "b", "94"], ["95", "2021-10-19", "r", "b", "95"], ["96", "2021-11-15", "r", "b", "96"], ["97", "2022-01-04", "r", "b", "97"], ["98", "2022-02-01", "r", "b", "98"], ["99", "2022-03-01", "r", "b", "99"], ["100", "2022-03-29", "r", "b", "100"], ["101", "2022-04-26", "r", "b", "101"], ["102", "2022-05-24", "r", "b", "102"], ["103", "2022-06-21", "r", "b", "103"], ["104", "2022-08-02", "r", "b", "104"], ["105", "2022-09-02", "r", "b", "105"], ["106", "2022-09-27", "r", "b", "106"], ["107", "2022-10-25", "r", "b", "107"], ["108", "2022-11-29", "r", "b", "108"], ["109", "2023-01-10", "r", "b", "109"], ["110", "2023-02-07", "r", "b", "110"], ["111", "2023-03-07", "r", "b", "111"], ["112", "2023-04-04", "r", "b", "112"], ["113", "2023-05-02", "r", "b", "113"], ["114", "2023-05-30", "r", "b", "114"], ["115", "2023-07-21", "r", "b", "115"], ["116", "2023-08-15", "r", "b", "116"], ["117", "2023-09-12", "r", "b", "117"], ["118", "2023-10-10", "r", "b", "118"], ["119", "2023-10-31", "r", "b", "119"], ["120", "2023-12-05", "r", "b", "120"], ["121", "2024-01-23", "r", "b", "121"], ["122", "2024-02-20", "r", "b", "122"], ["123", "2024-03-19", "r", "b", "123"], ["124", "2024-04-16", "r", "b", "124"], ["125", "2024-05-14", "r", "b", "125"], ["126", "2024-06-11", "r", "b", "126"], ["127", "2024-07-23", "r", "b", "127"], ["128", "2024-08-20", "r", "b", "128"], ["129", "2024-09-17", "r", "b", "129"], ["130", "2024-10-15", "r", "b", "130"], ["131", "2024-11-12", "r", "b", "131"], ["132", "2025-01-14", "r", "b", "132"], ["133", "2025-02-04", "r", "b", "133"], ["134", "2025-03-04", "r", "b", "134"], ["135", "2025-04-01", "r", "b", "135"], ["136", "2025-04-29", "r", "b", "136"], ["137", "2025-05-27", "r", "b", "137"], ["138", "2025-06-24", "r", "b", "138"], ["139", "2025-08-05", "r", "b", "139"], ["140", "2025-09-02", "r", "b", "140"], ["141", "2025-09-30", "r", "b", "141"], ["142", "2025-10-28", "c", "b", "142"], ["143", "2025-12-02", "b", "b", "143"], ["144", "2026-01-13", "n", "b", "144"], ["145", null, "p", "b", "145"]] }, edge: { releases: [["12", "2015-07-29", "r", null, "12"], ["13", "2015-11-12", "r", null, "13"], ["14", "2016-08-02", "r", null, "14"], ["15", "2017-04-05", "r", null, "15"], ["16", "2017-10-17", "r", null, "16"], ["17", "2018-04-30", "r", null, "17"], ["18", "2018-10-02", "r", null, "18"], ["79", "2020-01-15", "r", "b", "79"], ["80", "2020-02-07", "r", "b", "80"], ["81", "2020-04-13", "r", "b", "81"], ["83", "2020-05-21", "r", "b", "83"], ["84", "2020-07-16", "r", "b", "84"], ["85", "2020-08-27", "r", "b", "85"], ["86", "2020-10-09", "r", "b", "86"], ["87", "2020-11-19", "r", "b", "87"], ["88", "2021-01-21", "r", "b", "88"], ["89", "2021-03-04", "r", "b", "89"], ["90", "2021-04-15", "r", "b", "90"], ["91", "2021-05-27", "r", "b", "91"], ["92", "2021-07-22", "r", "b", "92"], ["93", "2021-09-02", "r", "b", "93"], ["94", "2021-09-24", "r", "b", "94"], ["95", "2021-10-21", "r", "b", "95"], ["96", "2021-11-19", "r", "b", "96"], ["97", "2022-01-06", "r", "b", "97"], ["98", "2022-02-03", "r", "b", "98"], ["99", "2022-03-03", "r", "b", "99"], ["100", "2022-04-01", "r", "b", "100"], ["101", "2022-04-28", "r", "b", "101"], ["102", "2022-05-31", "r", "b", "102"], ["103", "2022-06-23", "r", "b", "103"], ["104", "2022-08-05", "r", "b", "104"], ["105", "2022-09-01", "r", "b", "105"], ["106", "2022-10-03", "r", "b", "106"], ["107", "2022-10-27", "r", "b", "107"], ["108", "2022-12-05", "r", "b", "108"], ["109", "2023-01-12", "r", "b", "109"], ["110", "2023-02-09", "r", "b", "110"], ["111", "2023-03-13", "r", "b", "111"], ["112", "2023-04-06", "r", "b", "112"], ["113", "2023-05-05", "r", "b", "113"], ["114", "2023-06-02", "r", "b", "114"], ["115", "2023-07-21", "r", "b", "115"], ["116", "2023-08-21", "r", "b", "116"], ["117", "2023-09-15", "r", "b", "117"], ["118", "2023-10-13", "r", "b", "118"], ["119", "2023-11-02", "r", "b", "119"], ["120", "2023-12-07", "r", "b", "120"], ["121", "2024-01-25", "r", "b", "121"], ["122", "2024-02-23", "r", "b", "122"], ["123", "2024-03-22", "r", "b", "123"], ["124", "2024-04-18", "r", "b", "124"], ["125", "2024-05-17", "r", "b", "125"], ["126", "2024-06-13", "r", "b", "126"], ["127", "2024-07-25", "r", "b", "127"], ["128", "2024-08-22", "r", "b", "128"], ["129", "2024-09-19", "r", "b", "129"], ["130", "2024-10-17", "r", "b", "130"], ["131", "2024-11-14", "r", "b", "131"], ["132", "2025-01-17", "r", "b", "132"], ["133", "2025-02-06", "r", "b", "133"], ["134", "2025-03-06", "r", "b", "134"], ["135", "2025-04-04", "r", "b", "135"], ["136", "2025-05-01", "r", "b", "136"], ["137", "2025-05-29", "r", "b", "137"], ["138", "2025-06-26", "r", "b", "138"], ["139", "2025-08-07", "r", "b", "139"], ["140", "2025-09-05", "r", "b", "140"], ["141", "2025-10-03", "r", "b", "141"], ["142", "2025-10-31", "c", "b", "142"], ["143", "2025-12-04", "b", "b", "143"], ["144", "2026-01-15", "n", "b", "144"], ["145", "2026-02-12", "p", "b", "145"]] }, firefox: { releases: [["1", "2004-11-09", "r", "g", "1.7"], ["2", "2006-10-24", "r", "g", "1.8.1"], ["3", "2008-06-17", "r", "g", "1.9"], ["4", "2011-03-22", "r", "g", "2"], ["5", "2011-06-21", "r", "g", "5"], ["6", "2011-08-16", "r", "g", "6"], ["7", "2011-09-27", "r", "g", "7"], ["8", "2011-11-08", "r", "g", "8"], ["9", "2011-12-20", "r", "g", "9"], ["10", "2012-01-31", "r", "g", "10"], ["11", "2012-03-13", "r", "g", "11"], ["12", "2012-04-24", "r", "g", "12"], ["13", "2012-06-05", "r", "g", "13"], ["14", "2012-07-17", "r", "g", "14"], ["15", "2012-08-28", "r", "g", "15"], ["16", "2012-10-09", "r", "g", "16"], ["17", "2012-11-20", "r", "g", "17"], ["18", "2013-01-08", "r", "g", "18"], ["19", "2013-02-19", "r", "g", "19"], ["20", "2013-04-02", "r", "g", "20"], ["21", "2013-05-14", "r", "g", "21"], ["22", "2013-06-25", "r", "g", "22"], ["23", "2013-08-06", "r", "g", "23"], ["24", "2013-09-17", "r", "g", "24"], ["25", "2013-10-29", "r", "g", "25"], ["26", "2013-12-10", "r", "g", "26"], ["27", "2014-02-04", "r", "g", "27"], ["28", "2014-03-18", "r", "g", "28"], ["29", "2014-04-29", "r", "g", "29"], ["30", "2014-06-10", "r", "g", "30"], ["31", "2014-07-22", "r", "g", "31"], ["32", "2014-09-02", "r", "g", "32"], ["33", "2014-10-14", "r", "g", "33"], ["34", "2014-12-01", "r", "g", "34"], ["35", "2015-01-13", "r", "g", "35"], ["36", "2015-02-24", "r", "g", "36"], ["37", "2015-03-31", "r", "g", "37"], ["38", "2015-05-12", "r", "g", "38"], ["39", "2015-07-02", "r", "g", "39"], ["40", "2015-08-11", "r", "g", "40"], ["41", "2015-09-22", "r", "g", "41"], ["42", "2015-11-03", "r", "g", "42"], ["43", "2015-12-15", "r", "g", "43"], ["44", "2016-01-26", "r", "g", "44"], ["45", "2016-03-08", "r", "g", "45"], ["46", "2016-04-26", "r", "g", "46"], ["47", "2016-06-07", "r", "g", "47"], ["48", "2016-08-02", "r", "g", "48"], ["49", "2016-09-20", "r", "g", "49"], ["50", "2016-11-15", "r", "g", "50"], ["51", "2017-01-24", "r", "g", "51"], ["52", "2017-03-07", "r", "g", "52"], ["53", "2017-04-19", "r", "g", "53"], ["54", "2017-06-13", "r", "g", "54"], ["55", "2017-08-08", "r", "g", "55"], ["56", "2017-09-28", "r", "g", "56"], ["57", "2017-11-14", "r", "g", "57"], ["58", "2018-01-23", "r", "g", "58"], ["59", "2018-03-13", "r", "g", "59"], ["60", "2018-05-09", "r", "g", "60"], ["61", "2018-06-26", "r", "g", "61"], ["62", "2018-09-05", "r", "g", "62"], ["63", "2018-10-23", "r", "g", "63"], ["64", "2018-12-11", "r", "g", "64"], ["65", "2019-01-29", "r", "g", "65"], ["66", "2019-03-19", "r", "g", "66"], ["67", "2019-05-21", "r", "g", "67"], ["68", "2019-07-09", "r", "g", "68"], ["69", "2019-09-03", "r", "g", "69"], ["70", "2019-10-22", "r", "g", "70"], ["71", "2019-12-10", "r", "g", "71"], ["72", "2020-01-07", "r", "g", "72"], ["73", "2020-02-11", "r", "g", "73"], ["74", "2020-03-10", "r", "g", "74"], ["75", "2020-04-07", "r", "g", "75"], ["76", "2020-05-05", "r", "g", "76"], ["77", "2020-06-02", "r", "g", "77"], ["78", "2020-06-30", "r", "g", "78"], ["79", "2020-07-28", "r", "g", "79"], ["80", "2020-08-25", "r", "g", "80"], ["81", "2020-09-22", "r", "g", "81"], ["82", "2020-10-20", "r", "g", "82"], ["83", "2020-11-17", "r", "g", "83"], ["84", "2020-12-15", "r", "g", "84"], ["85", "2021-01-26", "r", "g", "85"], ["86", "2021-02-23", "r", "g", "86"], ["87", "2021-03-23", "r", "g", "87"], ["88", "2021-04-19", "r", "g", "88"], ["89", "2021-06-01", "r", "g", "89"], ["90", "2021-07-13", "r", "g", "90"], ["91", "2021-08-10", "r", "g", "91"], ["92", "2021-09-07", "r", "g", "92"], ["93", "2021-10-05", "r", "g", "93"], ["94", "2021-11-02", "r", "g", "94"], ["95", "2021-12-07", "r", "g", "95"], ["96", "2022-01-11", "r", "g", "96"], ["97", "2022-02-08", "r", "g", "97"], ["98", "2022-03-08", "r", "g", "98"], ["99", "2022-04-05", "r", "g", "99"], ["100", "2022-05-03", "r", "g", "100"], ["101", "2022-05-31", "r", "g", "101"], ["102", "2022-06-28", "r", "g", "102"], ["103", "2022-07-26", "r", "g", "103"], ["104", "2022-08-23", "r", "g", "104"], ["105", "2022-09-20", "r", "g", "105"], ["106", "2022-10-18", "r", "g", "106"], ["107", "2022-11-15", "r", "g", "107"], ["108", "2022-12-13", "r", "g", "108"], ["109", "2023-01-17", "r", "g", "109"], ["110", "2023-02-14", "r", "g", "110"], ["111", "2023-03-14", "r", "g", "111"], ["112", "2023-04-11", "r", "g", "112"], ["113", "2023-05-09", "r", "g", "113"], ["114", "2023-06-06", "r", "g", "114"], ["115", "2023-07-04", "r", "g", "115"], ["116", "2023-08-01", "r", "g", "116"], ["117", "2023-08-29", "r", "g", "117"], ["118", "2023-09-26", "r", "g", "118"], ["119", "2023-10-24", "r", "g", "119"], ["120", "2023-11-21", "r", "g", "120"], ["121", "2023-12-19", "r", "g", "121"], ["122", "2024-01-23", "r", "g", "122"], ["123", "2024-02-20", "r", "g", "123"], ["124", "2024-03-19", "r", "g", "124"], ["125", "2024-04-16", "r", "g", "125"], ["126", "2024-05-14", "r", "g", "126"], ["127", "2024-06-11", "r", "g", "127"], ["128", "2024-07-09", "r", "g", "128"], ["129", "2024-08-06", "r", "g", "129"], ["130", "2024-09-03", "r", "g", "130"], ["131", "2024-10-01", "r", "g", "131"], ["132", "2024-10-29", "r", "g", "132"], ["133", "2024-11-26", "r", "g", "133"], ["134", "2025-01-07", "r", "g", "134"], ["135", "2025-02-04", "r", "g", "135"], ["136", "2025-03-04", "r", "g", "136"], ["137", "2025-04-01", "r", "g", "137"], ["138", "2025-04-29", "r", "g", "138"], ["139", "2025-05-27", "r", "g", "139"], ["140", "2025-06-24", "e", "g", "140"], ["141", "2025-07-22", "r", "g", "141"], ["142", "2025-08-19", "r", "g", "142"], ["143", "2025-09-16", "r", "g", "143"], ["144", "2025-10-14", "r", "g", "144"], ["145", "2025-11-11", "c", "g", "145"], ["146", "2025-12-09", "b", "g", "146"], ["147", "2026-01-13", "n", "g", "147"], ["148", "2026-02-24", "p", "g", "148"], ["1.5", "2005-11-29", "r", "g", "1.8"], ["3.5", "2009-06-30", "r", "g", "1.9.1"], ["3.6", "2010-01-21", "r", "g", "1.9.2"]] }, firefox_android: { releases: [["4", "2011-03-29", "r", "g", "2"], ["5", "2011-06-21", "r", "g", "5"], ["6", "2011-08-16", "r", "g", "6"], ["7", "2011-09-27", "r", "g", "7"], ["8", "2011-11-08", "r", "g", "8"], ["9", "2011-12-21", "r", "g", "9"], ["10", "2012-01-31", "r", "g", "10"], ["14", "2012-06-26", "r", "g", "14"], ["15", "2012-08-28", "r", "g", "15"], ["16", "2012-10-09", "r", "g", "16"], ["17", "2012-11-20", "r", "g", "17"], ["18", "2013-01-08", "r", "g", "18"], ["19", "2013-02-19", "r", "g", "19"], ["20", "2013-04-02", "r", "g", "20"], ["21", "2013-05-14", "r", "g", "21"], ["22", "2013-06-25", "r", "g", "22"], ["23", "2013-08-06", "r", "g", "23"], ["24", "2013-09-17", "r", "g", "24"], ["25", "2013-10-29", "r", "g", "25"], ["26", "2013-12-10", "r", "g", "26"], ["27", "2014-02-04", "r", "g", "27"], ["28", "2014-03-18", "r", "g", "28"], ["29", "2014-04-29", "r", "g", "29"], ["30", "2014-06-10", "r", "g", "30"], ["31", "2014-07-22", "r", "g", "31"], ["32", "2014-09-02", "r", "g", "32"], ["33", "2014-10-14", "r", "g", "33"], ["34", "2014-12-01", "r", "g", "34"], ["35", "2015-01-13", "r", "g", "35"], ["36", "2015-02-27", "r", "g", "36"], ["37", "2015-03-31", "r", "g", "37"], ["38", "2015-05-12", "r", "g", "38"], ["39", "2015-07-02", "r", "g", "39"], ["40", "2015-08-11", "r", "g", "40"], ["41", "2015-09-22", "r", "g", "41"], ["42", "2015-11-03", "r", "g", "42"], ["43", "2015-12-15", "r", "g", "43"], ["44", "2016-01-26", "r", "g", "44"], ["45", "2016-03-08", "r", "g", "45"], ["46", "2016-04-26", "r", "g", "46"], ["47", "2016-06-07", "r", "g", "47"], ["48", "2016-08-02", "r", "g", "48"], ["49", "2016-09-20", "r", "g", "49"], ["50", "2016-11-15", "r", "g", "50"], ["51", "2017-01-24", "r", "g", "51"], ["52", "2017-03-07", "r", "g", "52"], ["53", "2017-04-19", "r", "g", "53"], ["54", "2017-06-13", "r", "g", "54"], ["55", "2017-08-08", "r", "g", "55"], ["56", "2017-09-28", "r", "g", "56"], ["57", "2017-11-28", "r", "g", "57"], ["58", "2018-01-22", "r", "g", "58"], ["59", "2018-03-13", "r", "g", "59"], ["60", "2018-05-09", "r", "g", "60"], ["61", "2018-06-26", "r", "g", "61"], ["62", "2018-09-05", "r", "g", "62"], ["63", "2018-10-23", "r", "g", "63"], ["64", "2018-12-11", "r", "g", "64"], ["65", "2019-01-29", "r", "g", "65"], ["66", "2019-03-19", "r", "g", "66"], ["67", "2019-05-21", "r", "g", "67"], ["68", "2019-07-09", "r", "g", "68"], ["79", "2020-07-28", "r", "g", "79"], ["80", "2020-08-31", "r", "g", "80"], ["81", "2020-09-22", "r", "g", "81"], ["82", "2020-10-20", "r", "g", "82"], ["83", "2020-11-17", "r", "g", "83"], ["84", "2020-12-15", "r", "g", "84"], ["85", "2021-01-26", "r", "g", "85"], ["86", "2021-02-23", "r", "g", "86"], ["87", "2021-03-23", "r", "g", "87"], ["88", "2021-04-19", "r", "g", "88"], ["89", "2021-06-01", "r", "g", "89"], ["90", "2021-07-13", "r", "g", "90"], ["91", "2021-08-10", "r", "g", "91"], ["92", "2021-09-07", "r", "g", "92"], ["93", "2021-10-05", "r", "g", "93"], ["94", "2021-11-02", "r", "g", "94"], ["95", "2021-12-07", "r", "g", "95"], ["96", "2022-01-11", "r", "g", "96"], ["97", "2022-02-08", "r", "g", "97"], ["98", "2022-03-08", "r", "g", "98"], ["99", "2022-04-05", "r", "g", "99"], ["100", "2022-05-03", "r", "g", "100"], ["101", "2022-05-31", "r", "g", "101"], ["102", "2022-06-28", "r", "g", "102"], ["103", "2022-07-26", "r", "g", "103"], ["104", "2022-08-23", "r", "g", "104"], ["105", "2022-09-20", "r", "g", "105"], ["106", "2022-10-18", "r", "g", "106"], ["107", "2022-11-15", "r", "g", "107"], ["108", "2022-12-13", "r", "g", "108"], ["109", "2023-01-17", "r", "g", "109"], ["110", "2023-02-14", "r", "g", "110"], ["111", "2023-03-14", "r", "g", "111"], ["112", "2023-04-11", "r", "g", "112"], ["113", "2023-05-09", "r", "g", "113"], ["114", "2023-06-06", "r", "g", "114"], ["115", "2023-07-04", "r", "g", "115"], ["116", "2023-08-01", "r", "g", "116"], ["117", "2023-08-29", "r", "g", "117"], ["118", "2023-09-26", "r", "g", "118"], ["119", "2023-10-24", "r", "g", "119"], ["120", "2023-11-21", "r", "g", "120"], ["121", "2023-12-19", "r", "g", "121"], ["122", "2024-01-23", "r", "g", "122"], ["123", "2024-02-20", "r", "g", "123"], ["124", "2024-03-19", "r", "g", "124"], ["125", "2024-04-16", "r", "g", "125"], ["126", "2024-05-14", "r", "g", "126"], ["127", "2024-06-11", "r", "g", "127"], ["128", "2024-07-09", "r", "g", "128"], ["129", "2024-08-06", "r", "g", "129"], ["130", "2024-09-03", "r", "g", "130"], ["131", "2024-10-01", "r", "g", "131"], ["132", "2024-10-29", "r", "g", "132"], ["133", "2024-11-26", "r", "g", "133"], ["134", "2025-01-07", "r", "g", "134"], ["135", "2025-02-04", "r", "g", "135"], ["136", "2025-03-04", "r", "g", "136"], ["137", "2025-04-01", "r", "g", "137"], ["138", "2025-04-29", "r", "g", "138"], ["139", "2025-05-27", "r", "g", "139"], ["140", "2025-06-24", "e", "g", "140"], ["141", "2025-07-22", "r", "g", "141"], ["142", "2025-08-19", "r", "g", "142"], ["143", "2025-09-16", "r", "g", "143"], ["144", "2025-10-14", "r", "g", "144"], ["145", "2025-11-11", "c", "g", "145"], ["146", "2025-12-09", "b", "g", "146"], ["147", "2026-01-13", "n", "g", "147"], ["148", "2026-02-24", "p", "g", "148"]] }, opera: { releases: [["2", "1996-07-14", "r", null, null], ["3", "1997-12-01", "r", null, null], ["4", "2000-06-28", "r", null, null], ["5", "2000-12-06", "r", null, null], ["6", "2001-12-18", "r", null, null], ["7", "2003-01-28", "r", "p", "1"], ["8", "2005-04-19", "r", "p", "1"], ["9", "2006-06-20", "r", "p", "2"], ["10", "2009-09-01", "r", "p", "2.2"], ["11", "2010-12-16", "r", "p", "2.7"], ["12", "2012-06-14", "r", "p", "2.10"], ["15", "2013-07-02", "r", "b", "28"], ["16", "2013-08-27", "r", "b", "29"], ["17", "2013-10-08", "r", "b", "30"], ["18", "2013-11-19", "r", "b", "31"], ["19", "2014-01-28", "r", "b", "32"], ["20", "2014-03-04", "r", "b", "33"], ["21", "2014-05-06", "r", "b", "34"], ["22", "2014-06-03", "r", "b", "35"], ["23", "2014-07-22", "r", "b", "36"], ["24", "2014-09-02", "r", "b", "37"], ["25", "2014-10-15", "r", "b", "38"], ["26", "2014-12-03", "r", "b", "39"], ["27", "2015-01-27", "r", "b", "40"], ["28", "2015-03-10", "r", "b", "41"], ["29", "2015-04-28", "r", "b", "42"], ["30", "2015-06-09", "r", "b", "43"], ["31", "2015-08-04", "r", "b", "44"], ["32", "2015-09-15", "r", "b", "45"], ["33", "2015-10-27", "r", "b", "46"], ["34", "2015-12-08", "r", "b", "47"], ["35", "2016-02-02", "r", "b", "48"], ["36", "2016-03-15", "r", "b", "49"], ["37", "2016-05-04", "r", "b", "50"], ["38", "2016-06-08", "r", "b", "51"], ["39", "2016-08-02", "r", "b", "52"], ["40", "2016-09-20", "r", "b", "53"], ["41", "2016-10-25", "r", "b", "54"], ["42", "2016-12-13", "r", "b", "55"], ["43", "2017-02-07", "r", "b", "56"], ["44", "2017-03-21", "r", "b", "57"], ["45", "2017-05-10", "r", "b", "58"], ["46", "2017-06-22", "r", "b", "59"], ["47", "2017-08-09", "r", "b", "60"], ["48", "2017-09-27", "r", "b", "61"], ["49", "2017-11-08", "r", "b", "62"], ["50", "2018-01-04", "r", "b", "63"], ["51", "2018-02-07", "r", "b", "64"], ["52", "2018-03-22", "r", "b", "65"], ["53", "2018-05-10", "r", "b", "66"], ["54", "2018-06-28", "r", "b", "67"], ["55", "2018-08-16", "r", "b", "68"], ["56", "2018-09-25", "r", "b", "69"], ["57", "2018-11-28", "r", "b", "70"], ["58", "2019-01-23", "r", "b", "71"], ["60", "2019-04-09", "r", "b", "73"], ["62", "2019-06-27", "r", "b", "75"], ["63", "2019-08-20", "r", "b", "76"], ["64", "2019-10-07", "r", "b", "77"], ["65", "2019-11-13", "r", "b", "78"], ["66", "2020-01-07", "r", "b", "79"], ["67", "2020-03-03", "r", "b", "80"], ["68", "2020-04-22", "r", "b", "81"], ["69", "2020-06-24", "r", "b", "83"], ["70", "2020-07-27", "r", "b", "84"], ["71", "2020-09-15", "r", "b", "85"], ["72", "2020-10-21", "r", "b", "86"], ["73", "2020-12-09", "r", "b", "87"], ["74", "2021-02-02", "r", "b", "88"], ["75", "2021-03-24", "r", "b", "89"], ["76", "2021-04-28", "r", "b", "90"], ["77", "2021-06-09", "r", "b", "91"], ["78", "2021-08-03", "r", "b", "92"], ["79", "2021-09-14", "r", "b", "93"], ["80", "2021-10-05", "r", "b", "94"], ["81", "2021-11-04", "r", "b", "95"], ["82", "2021-12-02", "r", "b", "96"], ["83", "2022-01-19", "r", "b", "97"], ["84", "2022-02-16", "r", "b", "98"], ["85", "2022-03-23", "r", "b", "99"], ["86", "2022-04-20", "r", "b", "100"], ["87", "2022-05-17", "r", "b", "101"], ["88", "2022-06-08", "r", "b", "102"], ["89", "2022-07-07", "r", "b", "103"], ["90", "2022-08-18", "r", "b", "104"], ["91", "2022-09-14", "r", "b", "105"], ["92", "2022-10-19", "r", "b", "106"], ["93", "2022-11-17", "r", "b", "107"], ["94", "2022-12-15", "r", "b", "108"], ["95", "2023-02-01", "r", "b", "109"], ["96", "2023-02-22", "r", "b", "110"], ["97", "2023-03-22", "r", "b", "111"], ["98", "2023-04-20", "r", "b", "112"], ["99", "2023-05-16", "r", "b", "113"], ["100", "2023-06-29", "r", "b", "114"], ["101", "2023-07-26", "r", "b", "115"], ["102", "2023-08-23", "r", "b", "116"], ["103", "2023-10-03", "r", "b", "117"], ["104", "2023-10-23", "r", "b", "118"], ["105", "2023-11-14", "r", "b", "119"], ["106", "2023-12-19", "r", "b", "120"], ["107", "2024-02-07", "r", "b", "121"], ["108", "2024-03-05", "r", "b", "122"], ["109", "2024-03-27", "r", "b", "123"], ["110", "2024-05-14", "r", "b", "124"], ["111", "2024-06-12", "r", "b", "125"], ["112", "2024-07-11", "r", "b", "126"], ["113", "2024-08-22", "r", "b", "127"], ["114", "2024-09-25", "r", "b", "128"], ["115", "2024-11-27", "r", "b", "130"], ["116", "2025-01-08", "r", "b", "131"], ["117", "2025-02-13", "r", "b", "132"], ["118", "2025-04-15", "r", "b", "133"], ["119", "2025-05-13", "r", "b", "134"], ["120", "2025-07-02", "r", "b", "135"], ["121", "2025-08-27", "r", "b", "137"], ["122", "2025-09-11", "r", "b", "138"], ["123", "2025-10-28", "c", "b", "139"], ["124", null, "b", "b", "140"], ["125", null, "n", "b", "141"], ["10.1", "2009-11-23", "r", "p", "2.2"], ["10.5", "2010-03-02", "r", "p", "2.5"], ["10.6", "2010-07-01", "r", "p", "2.6"], ["11.1", "2011-04-12", "r", "p", "2.8"], ["11.5", "2011-06-28", "r", "p", "2.9"], ["11.6", "2011-12-06", "r", "p", "2.10"], ["12.1", "2012-11-20", "r", "p", "2.12"], ["3.5", "1998-11-18", "r", null, null], ["3.6", "1999-05-06", "r", null, null], ["5.1", "2001-04-10", "r", null, null], ["7.1", "2003-04-11", "r", "p", "1"], ["7.2", "2003-09-23", "r", "p", "1"], ["7.5", "2004-05-12", "r", "p", "1"], ["8.5", "2005-09-20", "r", "p", "1"], ["9.1", "2006-12-18", "r", "p", "2"], ["9.2", "2007-04-11", "r", "p", "2"], ["9.5", "2008-06-12", "r", "p", "2.1"], ["9.6", "2008-10-08", "r", "p", "2.1"]] }, opera_android: { releases: [["11", "2011-03-22", "r", "p", "2.7"], ["12", "2012-02-25", "r", "p", "2.10"], ["14", "2013-05-21", "r", "w", "537.31"], ["15", "2013-07-08", "r", "b", "28"], ["16", "2013-09-18", "r", "b", "29"], ["18", "2013-11-20", "r", "b", "31"], ["19", "2014-01-28", "r", "b", "32"], ["20", "2014-03-06", "r", "b", "33"], ["21", "2014-04-22", "r", "b", "34"], ["22", "2014-06-17", "r", "b", "35"], ["24", "2014-09-10", "r", "b", "37"], ["25", "2014-10-16", "r", "b", "38"], ["26", "2014-12-02", "r", "b", "39"], ["27", "2015-01-29", "r", "b", "40"], ["28", "2015-03-10", "r", "b", "41"], ["29", "2015-04-28", "r", "b", "42"], ["30", "2015-06-10", "r", "b", "43"], ["32", "2015-09-23", "r", "b", "45"], ["33", "2015-11-03", "r", "b", "46"], ["34", "2015-12-16", "r", "b", "47"], ["35", "2016-02-04", "r", "b", "48"], ["36", "2016-03-31", "r", "b", "49"], ["37", "2016-06-16", "r", "b", "50"], ["41", "2016-10-25", "r", "b", "54"], ["42", "2017-01-21", "r", "b", "55"], ["43", "2017-09-27", "r", "b", "59"], ["44", "2017-12-11", "r", "b", "60"], ["45", "2018-02-15", "r", "b", "61"], ["46", "2018-05-14", "r", "b", "63"], ["47", "2018-07-23", "r", "b", "66"], ["48", "2018-11-08", "r", "b", "69"], ["49", "2018-12-07", "r", "b", "70"], ["50", "2019-02-18", "r", "b", "71"], ["51", "2019-03-21", "r", "b", "72"], ["52", "2019-05-17", "r", "b", "73"], ["53", "2019-07-11", "r", "b", "74"], ["54", "2019-10-18", "r", "b", "76"], ["55", "2019-12-03", "r", "b", "77"], ["56", "2020-02-06", "r", "b", "78"], ["57", "2020-03-30", "r", "b", "80"], ["58", "2020-05-13", "r", "b", "81"], ["59", "2020-06-30", "r", "b", "83"], ["60", "2020-09-23", "r", "b", "85"], ["61", "2020-12-07", "r", "b", "86"], ["62", "2021-02-16", "r", "b", "87"], ["63", "2021-04-16", "r", "b", "89"], ["64", "2021-05-25", "r", "b", "91"], ["65", "2021-10-20", "r", "b", "92"], ["66", "2021-12-15", "r", "b", "94"], ["67", "2022-01-31", "r", "b", "96"], ["68", "2022-03-30", "r", "b", "99"], ["69", "2022-05-09", "r", "b", "100"], ["70", "2022-06-29", "r", "b", "102"], ["71", "2022-09-16", "r", "b", "104"], ["72", "2022-10-21", "r", "b", "106"], ["73", "2023-01-17", "r", "b", "108"], ["74", "2023-03-13", "r", "b", "110"], ["75", "2023-05-17", "r", "b", "112"], ["76", "2023-06-26", "r", "b", "114"], ["77", "2023-08-31", "r", "b", "115"], ["78", "2023-10-23", "r", "b", "117"], ["79", "2023-12-06", "r", "b", "119"], ["80", "2024-01-25", "r", "b", "120"], ["81", "2024-03-14", "r", "b", "122"], ["82", "2024-05-02", "r", "b", "124"], ["83", "2024-06-25", "r", "b", "126"], ["84", "2024-08-26", "r", "b", "127"], ["85", "2024-10-29", "r", "b", "128"], ["86", "2024-12-02", "r", "b", "130"], ["87", "2025-01-22", "r", "b", "132"], ["88", "2025-03-19", "r", "b", "134"], ["89", "2025-04-29", "r", "b", "135"], ["90", "2025-06-18", "r", "b", "137"], ["91", "2025-08-19", "r", "b", "139"], ["92", "2025-10-08", "c", "b", "140"], ["10.1", "2010-11-09", "r", "p", "2.5"], ["11.1", "2011-06-30", "r", "p", "2.8"], ["11.5", "2011-10-12", "r", "p", "2.9"], ["12.1", "2012-10-09", "r", "p", "2.11"]] }, safari: { releases: [["1", "2003-06-23", "r", "w", "85"], ["2", "2005-04-29", "r", "w", "412"], ["3", "2007-10-26", "r", "w", "523.10"], ["4", "2009-06-08", "r", "w", "530.17"], ["5", "2010-06-07", "r", "w", "533.16"], ["6", "2012-07-25", "r", "w", "536.25"], ["7", "2013-10-22", "r", "w", "537.71"], ["8", "2014-10-16", "r", "w", "538.35"], ["9", "2015-09-30", "r", "w", "601.1.56"], ["10", "2016-09-20", "r", "w", "602.1.50"], ["11", "2017-09-19", "r", "w", "604.2.4"], ["12", "2018-09-17", "r", "w", "606.1.36"], ["13", "2019-09-19", "r", "w", "608.2.11"], ["14", "2020-09-16", "r", "w", "610.1.28"], ["15", "2021-09-20", "r", "w", "612.1.27"], ["16", "2022-09-12", "r", "w", "614.1.25"], ["17", "2023-09-18", "r", "w", "616.1.27"], ["18", "2024-09-16", "r", "w", "619.1.26"], ["26", "2025-09-15", "r", "w", "622.1.22"], ["1.1", "2003-10-24", "r", "w", "100"], ["1.2", "2004-02-02", "r", "w", "125"], ["1.3", "2005-04-15", "r", "w", "312"], ["10.1", "2017-03-27", "r", "w", "603.2.1"], ["11.1", "2018-04-12", "r", "w", "605.1.33"], ["12.1", "2019-03-25", "r", "w", "607.1.40"], ["13.1", "2020-03-24", "r", "w", "609.1.20"], ["14.1", "2021-04-26", "r", "w", "611.1.21"], ["15.1", "2021-10-25", "r", "w", "612.2.9"], ["15.2", "2021-12-13", "r", "w", "612.3.6"], ["15.3", "2022-01-26", "r", "w", "612.4.9"], ["15.4", "2022-03-14", "r", "w", "613.1.17"], ["15.5", "2022-05-16", "r", "w", "613.2.7"], ["15.6", "2022-07-20", "r", "w", "613.3.9"], ["16.1", "2022-10-24", "r", "w", "614.2.9"], ["16.2", "2022-12-13", "r", "w", "614.3.7"], ["16.3", "2023-01-23", "r", "w", "614.4.6"], ["16.4", "2023-03-27", "r", "w", "615.1.26"], ["16.5", "2023-05-18", "r", "w", "615.2.9"], ["16.6", "2023-07-24", "r", "w", "615.3.12"], ["17.1", "2023-10-25", "r", "w", "616.2.9"], ["17.2", "2023-12-11", "r", "w", "617.1.17"], ["17.3", "2024-01-22", "r", "w", "617.2.4"], ["17.4", "2024-03-05", "r", "w", "618.1.15"], ["17.5", "2024-05-13", "r", "w", "618.2.12"], ["17.6", "2024-07-29", "r", "w", "618.3.11"], ["18.1", "2024-10-28", "r", "w", "619.2.8"], ["18.2", "2024-12-11", "r", "w", "620.1.16"], ["18.3", "2025-01-27", "r", "w", "620.2.4"], ["18.4", "2025-03-31", "r", "w", "621.1.15"], ["18.5", "2025-05-12", "r", "w", "621.2.5"], ["18.6", "2025-07-29", "r", "w", "621.3.11"], ["26.1", "2025-11-03", "c", "w", "622.2.11"], ["26.2", null, "b", "w", "623.1.12"], ["3.1", "2008-03-18", "r", "w", "525.13"], ["5.1", "2011-07-20", "r", "w", "534.48"], ["9.1", "2016-03-21", "r", "w", "601.5.17"]] }, safari_ios: { releases: [["1", "2007-06-29", "r", "w", "522.11"], ["2", "2008-07-11", "r", "w", "525.18"], ["3", "2009-06-17", "r", "w", "528.18"], ["4", "2010-06-21", "r", "w", "532.9"], ["5", "2011-10-12", "r", "w", "534.46"], ["6", "2012-09-10", "r", "w", "536.26"], ["7", "2013-09-18", "r", "w", "537.51"], ["8", "2014-09-17", "r", "w", "600.1.4"], ["9", "2015-09-16", "r", "w", "601.1.56"], ["10", "2016-09-13", "r", "w", "602.1.50"], ["11", "2017-09-19", "r", "w", "604.2.4"], ["12", "2018-09-17", "r", "w", "606.1.36"], ["13", "2019-09-19", "r", "w", "608.2.11"], ["14", "2020-09-16", "r", "w", "610.1.28"], ["15", "2021-09-20", "r", "w", "612.1.27"], ["16", "2022-09-12", "r", "w", "614.1.25"], ["17", "2023-09-18", "r", "w", "616.1.27"], ["18", "2024-09-16", "r", "w", "619.1.26"], ["26", "2025-09-15", "r", "w", "622.1.22"], ["10.3", "2017-03-27", "r", "w", "603.2.1"], ["11.3", "2018-03-29", "r", "w", "605.1.33"], ["12.2", "2019-03-25", "r", "w", "607.1.40"], ["13.4", "2020-03-24", "r", "w", "609.1.20"], ["14.5", "2021-04-26", "r", "w", "611.1.21"], ["15.1", "2021-10-25", "r", "w", "612.2.9"], ["15.2", "2021-12-13", "r", "w", "612.3.6"], ["15.3", "2022-01-26", "r", "w", "612.4.9"], ["15.4", "2022-03-14", "r", "w", "613.1.17"], ["15.5", "2022-05-16", "r", "w", "613.2.7"], ["15.6", "2022-07-20", "r", "w", "613.3.9"], ["16.1", "2022-10-24", "r", "w", "614.2.9"], ["16.2", "2022-12-13", "r", "w", "614.3.7"], ["16.3", "2023-01-23", "r", "w", "614.4.6"], ["16.4", "2023-03-27", "r", "w", "615.1.26"], ["16.5", "2023-05-18", "r", "w", "615.2.9"], ["16.6", "2023-07-24", "r", "w", "615.3.12"], ["17.1", "2023-10-25", "r", "w", "616.2.9"], ["17.2", "2023-12-11", "r", "w", "617.1.17"], ["17.3", "2024-01-22", "r", "w", "617.2.4"], ["17.4", "2024-03-05", "r", "w", "618.1.15"], ["17.5", "2024-05-13", "r", "w", "618.2.12"], ["17.6", "2024-07-29", "r", "w", "618.3.11"], ["18.1", "2024-10-28", "r", "w", "619.2.8"], ["18.2", "2024-12-11", "r", "w", "620.1.16"], ["18.3", "2025-01-27", "r", "w", "620.2.4"], ["18.4", "2025-03-31", "r", "w", "621.1.15"], ["18.5", "2025-05-12", "r", "w", "621.2.5"], ["18.6", "2025-07-29", "r", "w", "621.3.11"], ["26.1", "2025-11-03", "c", "w", "622.2.11"], ["26.2", null, "b", "w", "623.1.12"], ["3.2", "2010-04-03", "r", "w", "531.21"], ["4.2", "2010-11-22", "r", "w", "533.17"], ["9.3", "2016-03-21", "r", "w", "601.5.17"]] }, samsunginternet_android: { releases: [["1.0", "2013-04-27", "r", "w", "535.19"], ["1.5", "2013-09-25", "r", "b", "28"], ["1.6", "2014-04-11", "r", "b", "28"], ["10.0", "2019-08-22", "r", "b", "71"], ["10.2", "2019-10-09", "r", "b", "71"], ["11.0", "2019-12-05", "r", "b", "75"], ["11.2", "2020-03-22", "r", "b", "75"], ["12.0", "2020-06-19", "r", "b", "79"], ["12.1", "2020-07-07", "r", "b", "79"], ["13.0", "2020-12-02", "r", "b", "83"], ["13.2", "2021-01-20", "r", "b", "83"], ["14.0", "2021-04-17", "r", "b", "87"], ["14.2", "2021-06-25", "r", "b", "87"], ["15.0", "2021-08-13", "r", "b", "90"], ["16.0", "2021-11-25", "r", "b", "92"], ["16.2", "2022-03-06", "r", "b", "92"], ["17.0", "2022-05-04", "r", "b", "96"], ["18.0", "2022-08-08", "r", "b", "99"], ["18.1", "2022-09-09", "r", "b", "99"], ["19.0", "2022-11-01", "r", "b", "102"], ["19.1", "2022-11-08", "r", "b", "102"], ["2.0", "2014-10-17", "r", "b", "34"], ["2.1", "2015-01-07", "r", "b", "34"], ["20.0", "2023-02-10", "r", "b", "106"], ["21.0", "2023-05-19", "r", "b", "110"], ["22.0", "2023-07-14", "r", "b", "111"], ["23.0", "2023-10-18", "r", "b", "115"], ["24.0", "2024-01-25", "r", "b", "117"], ["25.0", "2024-04-24", "r", "b", "121"], ["26.0", "2024-06-07", "r", "b", "122"], ["27.0", "2024-11-06", "r", "b", "125"], ["28.0", "2025-04-02", "c", "b", "130"], ["29.0", null, "b", "b", "136"], ["3.0", "2015-04-10", "r", "b", "38"], ["3.2", "2015-08-24", "r", "b", "38"], ["4.0", "2016-03-11", "r", "b", "44"], ["4.2", "2016-08-02", "r", "b", "44"], ["5.0", "2016-12-15", "r", "b", "51"], ["5.2", "2017-04-21", "r", "b", "51"], ["5.4", "2017-05-17", "r", "b", "51"], ["6.0", "2017-08-23", "r", "b", "56"], ["6.2", "2017-10-26", "r", "b", "56"], ["6.4", "2018-02-19", "r", "b", "56"], ["7.0", "2018-03-16", "r", "b", "59"], ["7.2", "2018-06-20", "r", "b", "59"], ["7.4", "2018-09-12", "r", "b", "59"], ["8.0", "2018-07-18", "r", "b", "63"], ["8.2", "2018-12-21", "r", "b", "63"], ["9.0", "2018-09-15", "r", "b", "67"], ["9.2", "2019-04-02", "r", "b", "67"], ["9.4", "2019-07-25", "r", "b", "67"]] }, webview_android: { releases: [["1", "2008-09-23", "r", "w", "523.12"], ["2", "2009-10-26", "r", "w", "530.17"], ["3", "2011-02-22", "r", "w", "534.13"], ["4", "2011-10-18", "r", "w", "534.30"], ["37", "2014-09-03", "r", "b", "37"], ["38", "2014-10-08", "r", "b", "38"], ["39", "2014-11-12", "r", "b", "39"], ["40", "2015-01-21", "r", "b", "40"], ["41", "2015-03-11", "r", "b", "41"], ["42", "2015-04-15", "r", "b", "42"], ["43", "2015-05-27", "r", "b", "43"], ["44", "2015-07-29", "r", "b", "44"], ["45", "2015-09-01", "r", "b", "45"], ["46", "2015-10-14", "r", "b", "46"], ["47", "2015-12-02", "r", "b", "47"], ["48", "2016-01-26", "r", "b", "48"], ["49", "2016-03-09", "r", "b", "49"], ["50", "2016-04-13", "r", "b", "50"], ["51", "2016-06-08", "r", "b", "51"], ["52", "2016-07-27", "r", "b", "52"], ["53", "2016-09-07", "r", "b", "53"], ["54", "2016-10-19", "r", "b", "54"], ["55", "2016-12-06", "r", "b", "55"], ["56", "2017-02-01", "r", "b", "56"], ["57", "2017-03-16", "r", "b", "57"], ["58", "2017-04-25", "r", "b", "58"], ["59", "2017-06-06", "r", "b", "59"], ["60", "2017-08-01", "r", "b", "60"], ["61", "2017-09-05", "r", "b", "61"], ["62", "2017-10-24", "r", "b", "62"], ["63", "2017-12-05", "r", "b", "63"], ["64", "2018-01-23", "r", "b", "64"], ["65", "2018-03-06", "r", "b", "65"], ["66", "2018-04-17", "r", "b", "66"], ["67", "2018-05-31", "r", "b", "67"], ["68", "2018-07-24", "r", "b", "68"], ["69", "2018-09-04", "r", "b", "69"], ["70", "2018-10-17", "r", "b", "70"], ["71", "2018-12-04", "r", "b", "71"], ["72", "2019-01-29", "r", "b", "72"], ["73", "2019-03-12", "r", "b", "73"], ["74", "2019-04-24", "r", "b", "74"], ["75", "2019-06-04", "r", "b", "75"], ["76", "2019-07-30", "r", "b", "76"], ["77", "2019-09-10", "r", "b", "77"], ["78", "2019-10-22", "r", "b", "78"], ["79", "2019-12-17", "r", "b", "79"], ["80", "2020-02-04", "r", "b", "80"], ["81", "2020-04-07", "r", "b", "81"], ["83", "2020-05-19", "r", "b", "83"], ["84", "2020-07-27", "r", "b", "84"], ["85", "2020-08-25", "r", "b", "85"], ["86", "2020-10-20", "r", "b", "86"], ["87", "2020-11-17", "r", "b", "87"], ["88", "2021-01-19", "r", "b", "88"], ["89", "2021-03-02", "r", "b", "89"], ["90", "2021-04-13", "r", "b", "90"], ["91", "2021-05-25", "r", "b", "91"], ["92", "2021-07-20", "r", "b", "92"], ["93", "2021-08-31", "r", "b", "93"], ["94", "2021-09-21", "r", "b", "94"], ["95", "2021-10-19", "r", "b", "95"], ["96", "2021-11-15", "r", "b", "96"], ["97", "2022-01-04", "r", "b", "97"], ["98", "2022-02-01", "r", "b", "98"], ["99", "2022-03-01", "r", "b", "99"], ["100", "2022-03-29", "r", "b", "100"], ["101", "2022-04-26", "r", "b", "101"], ["102", "2022-05-24", "r", "b", "102"], ["103", "2022-06-21", "r", "b", "103"], ["104", "2022-08-02", "r", "b", "104"], ["105", "2022-09-02", "r", "b", "105"], ["106", "2022-09-27", "r", "b", "106"], ["107", "2022-10-25", "r", "b", "107"], ["108", "2022-11-29", "r", "b", "108"], ["109", "2023-01-10", "r", "b", "109"], ["110", "2023-02-07", "r", "b", "110"], ["111", "2023-03-01", "r", "b", "111"], ["112", "2023-04-04", "r", "b", "112"], ["113", "2023-05-02", "r", "b", "113"], ["114", "2023-05-30", "r", "b", "114"], ["115", "2023-07-21", "r", "b", "115"], ["116", "2023-08-15", "r", "b", "116"], ["117", "2023-09-12", "r", "b", "117"], ["118", "2023-10-10", "r", "b", "118"], ["119", "2023-10-31", "r", "b", "119"], ["120", "2023-12-05", "r", "b", "120"], ["121", "2024-01-23", "r", "b", "121"], ["122", "2024-02-20", "r", "b", "122"], ["123", "2024-03-19", "r", "b", "123"], ["124", "2024-04-16", "r", "b", "124"], ["125", "2024-05-14", "r", "b", "125"], ["126", "2024-06-11", "r", "b", "126"], ["127", "2024-07-23", "r", "b", "127"], ["128", "2024-08-20", "r", "b", "128"], ["129", "2024-09-17", "r", "b", "129"], ["130", "2024-10-15", "r", "b", "130"], ["131", "2024-11-12", "r", "b", "131"], ["132", "2025-01-14", "r", "b", "132"], ["133", "2025-02-04", "r", "b", "133"], ["134", "2025-03-04", "r", "b", "134"], ["135", "2025-04-01", "r", "b", "135"], ["136", "2025-04-29", "r", "b", "136"], ["137", "2025-05-27", "r", "b", "137"], ["138", "2025-06-24", "r", "b", "138"], ["139", "2025-08-05", "r", "b", "139"], ["140", "2025-09-02", "r", "b", "140"], ["141", "2025-09-30", "r", "b", "141"], ["142", "2025-10-28", "c", "b", "142"], ["143", "2025-12-02", "b", "b", "143"], ["144", "2026-01-13", "n", "b", "144"], ["145", null, "p", "b", "145"], ["1.5", "2009-04-27", "r", "w", "525.20"], ["2.2", "2010-05-20", "r", "w", "533.1"], ["4.4", "2013-12-09", "r", "b", "30"], ["4.4.3", "2014-06-02", "r", "b", "33"]] } }, a = { ya_android: { releases: [["1.0", "u", "u", "b", "25"], ["1.5", "u", "u", "b", "22"], ["1.6", "u", "u", "b", "25"], ["1.7", "u", "u", "b", "25"], ["1.20", "u", "u", "b", "25"], ["2.5", "u", "u", "b", "25"], ["3.2", "u", "u", "b", "25"], ["4.6", "u", "u", "b", "25"], ["5.3", "u", "u", "b", "25"], ["5.4", "u", "u", "b", "25"], ["7.4", "u", "u", "b", "25"], ["9.6", "u", "u", "b", "25"], ["10.5", "u", "u", "b", "25"], ["11.4", "u", "u", "b", "25"], ["11.5", "u", "u", "b", "25"], ["12.7", "u", "u", "b", "25"], ["13.9", "u", "u", "b", "28"], ["13.10", "u", "u", "b", "28"], ["13.11", "u", "u", "b", "28"], ["13.12", "u", "u", "b", "30"], ["14.2", "u", "u", "b", "32"], ["14.4", "u", "u", "b", "33"], ["14.5", "u", "u", "b", "34"], ["14.7", "u", "u", "b", "35"], ["14.8", "u", "u", "b", "36"], ["14.10", "u", "u", "b", "37"], ["14.12", "u", "u", "b", "38"], ["15.2", "u", "u", "b", "40"], ["15.4", "u", "u", "b", "41"], ["15.6", "u", "u", "b", "42"], ["15.7", "u", "u", "b", "43"], ["15.9", "u", "u", "b", "44"], ["15.10", "u", "u", "b", "45"], ["15.12", "u", "u", "b", "46"], ["16.2", "u", "u", "b", "47"], ["16.3", "u", "u", "b", "47"], ["16.4", "u", "u", "b", "49"], ["16.6", "u", "u", "b", "50"], ["16.7", "u", "u", "b", "51"], ["16.9", "u", "u", "b", "52"], ["16.10", "u", "u", "b", "53"], ["16.11", "u", "u", "b", "54"], ["17.1", "u", "u", "b", "55"], ["17.3", "u", "u", "b", "56"], ["17.4", "u", "u", "b", "57"], ["17.6", "u", "u", "b", "58"], ["17.7", "u", "u", "b", "59"], ["17.9", "u", "u", "b", "60"], ["17.10", "u", "u", "b", "61"], ["17.11", "u", "u", "b", "62"], ["18.1", "u", "u", "b", "63"], ["18.2", "u", "u", "b", "63"], ["18.3", "u", "u", "b", "64"], ["18.4", "u", "u", "b", "65"], ["18.6", "u", "u", "b", "66"], ["18.7", "u", "u", "b", "67"], ["18.9", "u", "u", "b", "68"], ["18.10", "u", "u", "b", "69"], ["18.11", "u", "u", "b", "70"], ["19.1", "u", "u", "b", "71"], ["19.3", "u", "u", "b", "72"], ["19.4", "u", "u", "b", "73"], ["19.5", "u", "u", "b", "75"], ["19.6", "u", "u", "b", "75"], ["19.7", "u", "u", "b", "75"], ["19.9", "u", "u", "b", "76"], ["19.10", "u", "u", "b", "77"], ["19.11", "u", "u", "b", "78"], ["19.12", "u", "u", "b", "78"], ["20.2", "u", "u", "b", "79"], ["20.3", "u", "u", "b", "80"], ["20.4", "u", "u", "b", "81"], ["20.6", "u", "u", "b", "81"], ["20.7", "u", "u", "b", "83"], ["20.8", "2020-09-02", "u", "b", "84"], ["20.9", "2020-09-27", "u", "b", "85"], ["20.11", "2020-11-11", "u", "b", "86"], ["20.12", "2020-12-20", "u", "b", "87"], ["21.1", "2021-12-31", "u", "b", "88"], ["21.2", "u", "u", "b", "88"], ["21.3", "2021-04-04", "u", "b", "89"], ["21.5", "u", "u", "b", "90"], ["21.6", "2021-09-28", "u", "b", "91"], ["21.8", "2021-09-28", "u", "b", "92"], ["21.9", "2021-09-29", "u", "b", "93"], ["21.11", "2021-10-29", "u", "b", "94"], ["22.1", "2021-12-31", "u", "b", "96"], ["22.3", "2022-03-25", "u", "b", "98"], ["22.4", "u", "u", "b", "92"], ["22.5", "2022-05-20", "u", "b", "100"], ["22.7", "2022-07-07", "u", "b", "102"], ["22.8", "u", "u", "b", "104"], ["22.9", "2022-08-27", "u", "b", "104"], ["22.11", "2022-11-11", "u", "b", "106"], ["23.1", "2023-01-10", "u", "b", "108"], ["23.3", "2023-03-26", "u", "b", "110"], ["23.5", "2023-05-19", "u", "b", "112"], ["23.7", "2023-07-06", "u", "b", "114"], ["23.9", "2023-09-13", "u", "b", "116"], ["23.11", "2023-11-15", "u", "b", "118"], ["24.1", "2024-01-18", "u", "b", "120"], ["24.2", "2024-03-25", "u", "b", "120"], ["24.4", "2024-03-27", "u", "b", "122"], ["24.6", "2024-06-04", "u", "b", "124"], ["24.7", "2024-07-18", "u", "b", "126"], ["24.9", "2024-10-01", "u", "b", "126"], ["24.10", "2024-10-11", "u", "b", "128"], ["24.12", "2024-11-30", "u", "b", "130"], ["25.2", "2025-04-24", "u", "b", "132"], ["25.3", "2025-04-23", "u", "b", "132"], ["25.4", "2025-04-23", "u", "b", "134"], ["25.6", "2025-09-04", "u", "b", "136"], ["25.8", "2025-08-30", "u", "b", "138"], ["25.10", "2025-10-09", "u", "b", "140"]] }, uc_android: { releases: [["10.5", "u", "u", "b", "31"], ["10.7", "u", "u", "b", "31"], ["10.8", "u", "u", "b", "31"], ["10.10", "u", "u", "b", "31"], ["11.0", "u", "u", "b", "31"], ["11.1", "u", "u", "b", "40"], ["11.2", "u", "u", "b", "40"], ["11.3", "u", "u", "b", "40"], ["11.4", "u", "u", "b", "40"], ["11.5", "u", "u", "b", "40"], ["11.6", "u", "u", "b", "57"], ["11.8", "u", "u", "b", "57"], ["11.9", "u", "u", "b", "57"], ["12.0", "u", "u", "b", "57"], ["12.1", "u", "u", "b", "57"], ["12.2", "u", "u", "b", "57"], ["12.3", "u", "u", "b", "57"], ["12.4", "u", "u", "b", "57"], ["12.5", "u", "u", "b", "57"], ["12.6", "u", "u", "b", "57"], ["12.7", "u", "u", "b", "57"], ["12.8", "u", "u", "b", "57"], ["12.9", "u", "u", "b", "57"], ["12.10", "u", "u", "b", "57"], ["12.11", "u", "u", "b", "57"], ["12.12", "u", "u", "b", "57"], ["12.13", "u", "u", "b", "57"], ["12.14", "u", "u", "b", "57"], ["13.0", "u", "u", "b", "57"], ["13.1", "u", "u", "b", "57"], ["13.2", "u", "u", "b", "57"], ["13.3", "2020-09-09", "u", "b", "78"], ["13.4", "2021-09-28", "u", "b", "78"], ["13.5", "2023-08-25", "u", "b", "78"], ["13.6", "2023-12-17", "u", "b", "78"], ["13.7", "2023-06-24", "u", "b", "78"], ["13.8", "2022-04-30", "u", "b", "78"], ["13.9", "2022-05-18", "u", "b", "78"], ["15.0", "2022-08-24", "u", "b", "78"], ["15.1", "2022-11-11", "u", "b", "78"], ["15.2", "2023-04-23", "u", "b", "78"], ["15.3", "2023-03-17", "u", "b", "100"], ["15.4", "2023-10-25", "u", "b", "100"], ["15.5", "2023-08-22", "u", "b", "100"], ["16.0", "2023-08-24", "u", "b", "100"], ["16.1", "2023-10-15", "u", "b", "100"], ["16.2", "2023-12-09", "u", "b", "100"], ["16.3", "2024-03-08", "u", "b", "100"], ["16.4", "2024-10-03", "u", "b", "100"], ["16.5", "2024-05-30", "u", "b", "100"], ["16.6", "2024-07-23", "u", "b", "100"], ["17.0", "2024-08-24", "u", "b", "100"], ["17.1", "2024-09-26", "u", "b", "100"], ["17.2", "2024-11-29", "u", "b", "100"], ["17.3", "2025-01-07", "u", "b", "100"], ["17.4", "2025-02-26", "u", "b", "100"], ["17.5", "2025-04-08", "u", "b", "100"], ["17.6", "2025-05-15", "u", "b", "123"], ["17.7", "2025-06-11", "u", "b", "123"], ["17.8", "2025-07-30", "u", "b", "123"], ["18.0", "2025-08-17", "u", "b", "123"], ["18.1", "2025-10-04", "u", "b", "123"], ["18.2", "2025-11-04", "u", "b", "123"]] }, qq_android: { releases: [["6.0", "u", "u", "b", "37"], ["6.1", "u", "u", "b", "37"], ["6.2", "u", "u", "b", "37"], ["6.3", "u", "u", "b", "37"], ["6.4", "u", "u", "b", "37"], ["6.6", "u", "u", "b", "37"], ["6.7", "u", "u", "b", "37"], ["6.8", "u", "u", "b", "37"], ["6.9", "u", "u", "b", "37"], ["7.0", "u", "u", "b", "37"], ["7.1", "u", "u", "b", "37"], ["7.2", "u", "u", "b", "37"], ["7.3", "u", "u", "b", "37"], ["7.4", "u", "u", "b", "37"], ["7.5", "u", "u", "b", "37"], ["7.6", "u", "u", "b", "37"], ["7.7", "u", "u", "b", "37"], ["7.8", "u", "u", "b", "37"], ["7.9", "u", "u", "b", "37"], ["8.0", "u", "u", "b", "37"], ["8.1", "u", "u", "b", "57"], ["8.2", "u", "u", "b", "57"], ["8.3", "u", "u", "b", "57"], ["8.4", "u", "u", "b", "57"], ["8.5", "u", "u", "b", "57"], ["8.6", "u", "u", "b", "57"], ["8.7", "u", "u", "b", "57"], ["8.8", "u", "u", "b", "57"], ["8.9", "u", "u", "b", "57"], ["9.1", "u", "u", "b", "57"], ["9.6", "u", "u", "b", "66"], ["9.7", "u", "u", "b", "66"], ["9.8", "u", "u", "b", "66"], ["10.0", "u", "u", "b", "66"], ["10.1", "u", "u", "b", "66"], ["10.2", "u", "u", "b", "66"], ["10.3", "u", "u", "b", "66"], ["10.4", "u", "u", "b", "66"], ["10.5", "u", "u", "b", "66"], ["10.7", "2020-09-09", "u", "b", "66"], ["10.9", "2020-11-22", "u", "b", "77"], ["11.0", "u", "u", "b", "77"], ["11.2", "2021-01-30", "u", "b", "77"], ["11.3", "2021-03-31", "u", "b", "77"], ["11.7", "2021-11-02", "u", "b", "89"], ["11.9", "u", "u", "b", "89"], ["12.0", "2021-11-04", "u", "b", "89"], ["12.1", "2021-11-05", "u", "b", "89"], ["12.2", "2021-12-07", "u", "b", "89"], ["12.5", "2022-04-07", "u", "b", "89"], ["12.7", "2022-05-21", "u", "b", "89"], ["12.8", "2022-06-30", "u", "b", "89"], ["12.9", "2022-07-26", "u", "b", "89"], ["13.0", "2022-08-15", "u", "b", "89"], ["13.1", "2022-09-10", "u", "b", "89"], ["13.2", "2022-10-26", "u", "b", "89"], ["13.3", "2022-11-09", "u", "b", "89"], ["13.4", "2023-04-26", "u", "b", "98"], ["13.5", "2023-02-06", "u", "b", "98"], ["13.6", "2023-02-09", "u", "b", "98"], ["13.7", "2023-04-21", "u", "b", "98"], ["13.8", "2023-04-21", "u", "b", "98"], ["14.0", "2023-12-12", "u", "b", "98"], ["14.1", "2023-07-16", "u", "b", "98"], ["14.2", "2023-10-14", "u", "b", "109"], ["14.3", "2023-09-13", "u", "b", "109"], ["14.4", "2023-10-31", "u", "b", "109"], ["14.5", "2023-11-12", "u", "b", "109"], ["14.6", "2023-12-24", "u", "b", "109"], ["14.7", "2024-01-18", "u", "b", "109"], ["14.8", "2024-03-04", "u", "b", "109"], ["14.9", "2024-04-09", "u", "b", "109"], ["15.0", "2024-04-17", "u", "b", "109"], ["15.1", "2024-05-18", "u", "b", "109"], ["15.2", "2024-10-24", "u", "b", "109"], ["15.3", "2024-07-28", "u", "b", "109"], ["15.4", "2024-09-07", "u", "b", "109"], ["15.5", "2024-09-24", "u", "b", "109"], ["15.6", "2024-10-24", "u", "b", "109"], ["15.7", "2024-12-03", "u", "b", "109"], ["15.8", "2024-12-11", "u", "b", "109"], ["15.9", "2025-02-01", "u", "b", "109"], ["19.1", "2025-07-08", "u", "b", "121"], ["19.2", "2025-07-15", "u", "b", "121"], ["19.3", "2025-08-31", "u", "b", "121"], ["19.4", "2025-09-20", "u", "b", "121"], ["19.5", "2025-10-23", "u", "b", "121"], ["19.6", "2025-11-17", "u", "b", "121"]] }, kai_os: { releases: [["1.0", "2017-03-01", "u", "g", "37"], ["2.0", "2017-07-01", "u", "g", "48"], ["2.5", "2017-07-01", "u", "g", "48"], ["3.0", "2021-09-01", "u", "g", "84"], ["3.1", "2022-03-01", "u", "g", "84"], ["4.0", "2025-05-01", "u", "g", "123"]] }, facebook_android: { releases: [["66", "u", "u", "b", "48"], ["68", "u", "u", "b", "48"], ["74", "u", "u", "b", "50"], ["75", "u", "u", "b", "50"], ["76", "u", "u", "b", "50"], ["77", "u", "u", "b", "50"], ["78", "u", "u", "b", "50"], ["79", "u", "u", "b", "50"], ["80", "u", "u", "b", "51"], ["81", "u", "u", "b", "51"], ["82", "u", "u", "b", "51"], ["83", "u", "u", "b", "51"], ["84", "u", "u", "b", "51"], ["86", "u", "u", "b", "51"], ["87", "u", "u", "b", "52"], ["88", "u", "u", "b", "52"], ["89", "u", "u", "b", "52"], ["90", "u", "u", "b", "52"], ["91", "u", "u", "b", "52"], ["92", "u", "u", "b", "52"], ["93", "u", "u", "b", "52"], ["94", "u", "u", "b", "52"], ["95", "u", "u", "b", "53"], ["96", "u", "u", "b", "53"], ["97", "u", "u", "b", "53"], ["98", "u", "u", "b", "53"], ["99", "u", "u", "b", "53"], ["100", "u", "u", "b", "54"], ["101", "u", "u", "b", "54"], ["103", "u", "u", "b", "54"], ["104", "u", "u", "b", "54"], ["105", "u", "u", "b", "54"], ["106", "u", "u", "b", "55"], ["107", "u", "u", "b", "55"], ["108", "u", "u", "b", "55"], ["109", "u", "u", "b", "55"], ["110", "u", "u", "b", "55"], ["111", "u", "u", "b", "55"], ["112", "u", "u", "b", "56"], ["113", "u", "u", "b", "56"], ["114", "u", "u", "b", "56"], ["115", "u", "u", "b", "56"], ["116", "u", "u", "b", "56"], ["117", "u", "u", "b", "57"], ["118", "u", "u", "b", "57"], ["119", "u", "u", "b", "57"], ["120", "u", "u", "b", "57"], ["121", "u", "u", "b", "57"], ["122", "u", "u", "b", "58"], ["123", "u", "u", "b", "58"], ["124", "u", "u", "b", "58"], ["125", "u", "u", "b", "58"], ["126", "u", "u", "b", "58"], ["127", "u", "u", "b", "58"], ["128", "u", "u", "b", "58"], ["129", "u", "u", "b", "58"], ["130", "u", "u", "b", "59"], ["131", "u", "u", "b", "59"], ["132", "u", "u", "b", "59"], ["133", "u", "u", "b", "59"], ["134", "u", "u", "b", "59"], ["135", "u", "u", "b", "59"], ["136", "u", "u", "b", "59"], ["137", "u", "u", "b", "59"], ["138", "u", "u", "b", "60"], ["140", "u", "u", "b", "60"], ["142", "u", "u", "b", "61"], ["143", "u", "u", "b", "61"], ["144", "u", "u", "b", "61"], ["145", "u", "u", "b", "61"], ["146", "u", "u", "b", "61"], ["147", "u", "u", "b", "61"], ["148", "u", "u", "b", "61"], ["149", "u", "u", "b", "62"], ["150", "u", "u", "b", "62"], ["151", "u", "u", "b", "62"], ["152", "u", "u", "b", "62"], ["153", "u", "u", "b", "63"], ["154", "u", "u", "b", "63"], ["155", "u", "u", "b", "63"], ["156", "u", "u", "b", "63"], ["157", "u", "u", "b", "64"], ["158", "u", "u", "b", "64"], ["159", "u", "u", "b", "64"], ["160", "u", "u", "b", "64"], ["161", "u", "u", "b", "64"], ["162", "u", "u", "b", "64"], ["163", "u", "u", "b", "65"], ["164", "u", "u", "b", "65"], ["165", "u", "u", "b", "65"], ["166", "u", "u", "b", "65"], ["167", "u", "u", "b", "65"], ["168", "u", "u", "b", "65"], ["169", "u", "u", "b", "66"], ["170", "u", "u", "b", "66"], ["171", "u", "u", "b", "66"], ["172", "u", "u", "b", "66"], ["173", "u", "u", "b", "66"], ["174", "u", "u", "b", "66"], ["175", "u", "u", "b", "67"], ["176", "u", "u", "b", "67"], ["177", "u", "u", "b", "67"], ["178", "u", "u", "b", "67"], ["180", "u", "u", "b", "67"], ["181", "u", "u", "b", "67"], ["182", "u", "u", "b", "67"], ["183", "u", "u", "b", "68"], ["184", "u", "u", "b", "68"], ["185", "u", "u", "b", "68"], ["186", "u", "u", "b", "68"], ["187", "u", "u", "b", "68"], ["188", "u", "u", "b", "68"], ["202", "u", "u", "b", "71"], ["227", "u", "u", "b", "75"], ["228", "u", "u", "b", "75"], ["229", "u", "u", "b", "75"], ["230", "u", "u", "b", "75"], ["231", "u", "u", "b", "75"], ["233", "u", "u", "b", "76"], ["235", "u", "u", "b", "76"], ["236", "u", "u", "b", "76"], ["237", "u", "u", "b", "76"], ["238", "u", "u", "b", "76"], ["240", "u", "u", "b", "77"], ["241", "u", "u", "b", "77"], ["242", "u", "u", "b", "77"], ["243", "u", "u", "b", "77"], ["244", "u", "u", "b", "78"], ["245", "u", "u", "b", "78"], ["246", "u", "u", "b", "78"], ["247", "u", "u", "b", "78"], ["248", "u", "u", "b", "78"], ["249", "u", "u", "b", "78"], ["250", "u", "u", "b", "78"], ["251", "u", "u", "b", "79"], ["252", "u", "u", "b", "79"], ["253", "u", "u", "b", "79"], ["254", "u", "u", "b", "79"], ["255", "u", "u", "b", "79"], ["256", "u", "u", "b", "80"], ["257", "u", "u", "b", "80"], ["258", "u", "u", "b", "80"], ["259", "u", "u", "b", "80"], ["260", "u", "u", "b", "80"], ["261", "u", "u", "b", "80"], ["262", "u", "u", "b", "80"], ["263", "u", "u", "b", "80"], ["264", "u", "u", "b", "80"], ["265", "u", "u", "b", "80"], ["266", "u", "u", "b", "81"], ["267", "u", "u", "b", "81"], ["268", "u", "u", "b", "81"], ["269", "u", "u", "b", "81"], ["270", "u", "u", "b", "81"], ["271", "u", "u", "b", "81"], ["272", "u", "u", "b", "83"], ["273", "u", "u", "b", "83"], ["274", "u", "u", "b", "83"], ["275", "u", "u", "b", "83"], ["297", "2020-12-02", "u", "b", "86"], ["348", "2021-12-19", "u", "b", "96"], ["399", "2023-02-04", "u", "b", "109"], ["400", "2023-02-10", "u", "b", "109"], ["420", "2023-06-28", "u", "b", "114"], ["430", "2023-09-03", "u", "b", "116"], ["434", "2023-10-05", "u", "b", "117"], ["436", "2023-10-13", "u", "b", "117"], ["437", "u", "u", "b", "118"], ["438", "2023-10-28", "u", "b", "118"], ["439", "2023-11-11", "u", "b", "119"], ["440", "2023-11-12", "u", "b", "119"], ["441", "2023-11-20", "u", "b", "119"], ["442", "2023-11-29", "u", "b", "119"], ["443", "2023-12-07", "u", "b", "120"], ["444", "2023-12-13", "u", "b", "120"], ["445", "2023-12-21", "u", "b", "120"], ["446", "2024-01-06", "u", "b", "120"], ["447", "2024-01-12", "u", "b", "120"], ["448", "2024-01-29", "u", "b", "121"], ["449", "2024-02-02", "u", "b", "121"], ["450", "2024-02-05", "u", "b", "121"], ["451", "2024-02-17", "u", "b", "121"], ["452", "2024-02-25", "u", "b", "122"], ["453", "2024-02-28", "u", "b", "122"], ["454", "2024-03-04", "u", "b", "122"], ["465", "2024-07-07", "u", "b", "126"], ["466", "u", "u", "b", "126"], ["469", "u", "u", "b", "126"], ["471", "2024-07-10", "u", "b", "126"], ["472", "2024-07-11", "u", "b", "126"], ["474", "2024-07-30", "u", "b", "127"], ["475", "2024-08-01", "u", "b", "127"], ["476", "2024-08-09", "u", "b", "127"], ["477", "2024-08-16", "u", "b", "127"], ["478", "2024-08-21", "u", "b", "128"], ["479", "2024-08-31", "u", "b", "128"], ["480", "2024-09-07", "u", "b", "128"], ["481", "2024-09-14", "u", "b", "128"], ["482", "2024-09-20", "u", "b", "129"], ["483", "2024-09-27", "u", "b", "129"], ["484", "2024-10-04", "u", "b", "129"], ["485", "2024-10-11", "u", "b", "129"], ["486", "2024-10-18", "u", "b", "130"], ["487", "2024-10-26", "u", "b", "130"], ["488", "2024-11-02", "u", "b", "130"], ["489", "2024-11-09", "u", "b", "130"], ["494", "2024-12-26", "u", "b", "131"], ["497", "2025-01-26", "u", "b", "132"], ["503", "2025-03-12", "u", "b", "134"], ["514", "2025-05-28", "u", "b", "136"], ["515", "2025-05-31", "u", "b", "137"]] }, instagram_android: { releases: [["23", "u", "u", "b", "62"], ["24", "u", "u", "b", "62"], ["25", "u", "u", "b", "62"], ["26", "u", "u", "b", "63"], ["27", "u", "u", "b", "63"], ["28", "u", "u", "b", "63"], ["29", "u", "u", "b", "63"], ["30", "u", "u", "b", "63"], ["31", "u", "u", "b", "64"], ["32", "u", "u", "b", "64"], ["33", "u", "u", "b", "64"], ["34", "u", "u", "b", "64"], ["35", "u", "u", "b", "65"], ["36", "u", "u", "b", "65"], ["37", "u", "u", "b", "65"], ["38", "u", "u", "b", "65"], ["39", "u", "u", "b", "65"], ["40", "u", "u", "b", "65"], ["41", "u", "u", "b", "65"], ["42", "u", "u", "b", "66"], ["43", "u", "u", "b", "66"], ["44", "u", "u", "b", "66"], ["45", "u", "u", "b", "66"], ["46", "u", "u", "b", "66"], ["47", "u", "u", "b", "66"], ["48", "u", "u", "b", "67"], ["49", "u", "u", "b", "67"], ["50", "u", "u", "b", "67"], ["51", "u", "u", "b", "67"], ["52", "u", "u", "b", "67"], ["53", "u", "u", "b", "67"], ["54", "u", "u", "b", "67"], ["55", "u", "u", "b", "67"], ["56", "u", "u", "b", "68"], ["57", "u", "u", "b", "68"], ["58", "u", "u", "b", "68"], ["59", "u", "u", "b", "68"], ["60", "u", "u", "b", "68"], ["61", "u", "u", "b", "68"], ["65", "u", "u", "b", "69"], ["66", "u", "u", "b", "69"], ["68", "u", "u", "b", "69"], ["72", "u", "u", "b", "70"], ["74", "u", "u", "b", "71"], ["75", "u", "u", "b", "71"], ["79", "u", "u", "b", "71"], ["81", "u", "u", "b", "72"], ["82", "u", "u", "b", "72"], ["83", "u", "u", "b", "72"], ["84", "u", "u", "b", "73"], ["86", "u", "u", "b", "73"], ["95", "u", "u", "b", "74"], ["96", "u", "u", "b", "80"], ["97", "u", "u", "b", "80"], ["98", "u", "u", "b", "80"], ["103", "u", "u", "b", "80"], ["104", "u", "u", "b", "80"], ["117", "u", "u", "b", "80"], ["118", "u", "u", "b", "80"], ["119", "u", "u", "b", "80"], ["120", "u", "u", "b", "80"], ["121", "u", "u", "b", "80"], ["127", "u", "u", "b", "80"], ["128", "u", "u", "b", "80"], ["129", "u", "u", "b", "80"], ["130", "u", "u", "b", "80"], ["131", "u", "u", "b", "80"], ["132", "u", "u", "b", "80"], ["133", "u", "u", "b", "80"], ["134", "u", "u", "b", "80"], ["135", "u", "u", "b", "80"], ["136", "u", "u", "b", "80"], ["137", "u", "u", "b", "81"], ["138", "u", "u", "b", "81"], ["139", "u", "u", "b", "81"], ["140", "u", "u", "b", "81"], ["141", "u", "u", "b", "81"], ["142", "u", "u", "b", "81"], ["143", "u", "u", "b", "83"], ["144", "u", "u", "b", "83"], ["145", "u", "u", "b", "83"], ["146", "u", "u", "b", "83"], ["153", "u", "u", "b", "84"], ["163", "u", "u", "b", "92"], ["164", "u", "u", "b", "92"], ["230", "u", "u", "b", "92"], ["258", "2022-11-04", "u", "b", "106"], ["259", "2022-11-04", "u", "b", "106"], ["279", "2023-12-31", "u", "b", "109"], ["281", "u", "u", "b", "109"], ["288", "u", "u", "b", "114"], ["289", "2023-12-21", "u", "b", "114"], ["290", "2023-12-30", "u", "b", "114"], ["292", "u", "u", "b", "115"], ["295", "u", "u", "b", "115"], ["296", "u", "u", "b", "115"], ["297", "u", "u", "b", "115"], ["298", "2024-01-11", "u", "b", "115"], ["299", "u", "u", "b", "115"], ["300", "u", "u", "b", "116"], ["301", "2024-01-12", "u", "b", "116"], ["302", "u", "u", "b", "117"], ["303", "u", "u", "b", "117"], ["304", "u", "u", "b", "117"], ["305", "u", "u", "b", "117"], ["306", "2024-01-17", "u", "b", "118"], ["307", "u", "u", "b", "118"], ["308", "2024-01-19", "u", "b", "118"], ["309", "u", "u", "b", "119"], ["310", "u", "u", "b", "119"], ["311", "u", "u", "b", "120"], ["312", "u", "u", "b", "120"], ["313", "u", "u", "b", "120"], ["314", "u", "u", "b", "120"], ["315", "2024-01-19", "u", "b", "120"], ["316", "2024-01-25", "u", "b", "120"], ["317", "2024-02-03", "u", "b", "121"], ["318", "2024-02-16", "u", "b", "121"], ["320", "2024-03-04", "u", "b", "121"], ["321", "2024-03-07", "u", "b", "122"], ["338", "2024-07-06", "u", "b", "126"], ["346", "2024-09-01", "u", "b", "127"], ["347", "2024-09-11", "u", "b", "127"], ["349", "2024-09-20", "u", "b", "128"], ["355", "2024-11-06", "u", "b", "130"], ["366", "u", "u", "b", "132"], ["367", "2025-02-15", "u", "b", "132"], ["378", "2025-05-03", "u", "b", "135"], ["381", "2025-06-19", "u", "b", "137"], ["382", "2025-06-19", "u", "b", "137"], ["383", "2025-06-18", "u", "b", "137"], ["384", "2025-06-16", "u", "b", "137"], ["385", "2025-06-27", "u", "b", "137"], ["387", "2025-07-09", "u", "b", "137"], ["390", "2025-07-26", "u", "b", "138"], ["392", "2025-08-12", "u", "b", "138"], ["394", "2025-08-26", "u", "b", "139"], ["395", "2025-09-13", "u", "b", "139"], ["396", "2025-09-20", "u", "b", "139"], ["397", "2025-09-19", "u", "b", "139"], ["399", "2025-09-28", "u", "b", "140"], ["400", "2025-10-06", "u", "b", "141"], ["401", "2025-10-08", "u", "b", "141"], ["404", "2025-10-31", "u", "b", "141"], ["406", "2025-11-16", "u", "b", "141"]] } }, c = [["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "4", s: "4", si: "3.2" }], ["2019-03-25", { c: "66", ca: "66", e: "16", f: "57", fa: "57", s: "12.1", si: "12.2" }], ["2019-03-25", { c: "66", ca: "66", e: "16", f: "57", fa: "57", s: "12.1", si: "12.2" }], ["2024-03-19", { c: "116", ca: "116", e: "116", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2025-06-26", { c: "138", ca: "138", e: "138", f: "118", fa: "118", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "17", ca: "18", e: "12", f: "5", fa: "5", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-04-16", { c: "123", ca: "123", e: "123", f: "125", fa: "125", s: "17.4", si: "17.4" }], ["2020-01-15", { c: "37", ca: "37", e: "79", f: "27", fa: "27", s: "9.1", si: "9.3" }], ["2024-07-09", { c: "77", ca: "77", e: "79", f: "128", fa: "128", s: "17.4", si: "17.4" }], ["2016-06-07", { c: "32", ca: "30", e: "12", f: "47", fa: "47", s: "8", si: "8" }], ["2023-07-04", { c: "112", ca: "112", e: "112", f: "115", fa: "115", s: "16", si: "16" }], ["2015-09-30", { c: "43", ca: "43", e: "12", f: "16", fa: "16", s: "9", si: "9" }], ["2022-03-14", { c: "84", ca: "84", e: "84", f: "80", fa: "80", s: "15.4", si: "15.4" }], ["2023-10-24", { c: "103", ca: "103", e: "103", f: "119", fa: "119", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-03-14", { c: "92", ca: "92", e: "92", f: "90", fa: "90", s: "15.4", si: "15.4" }], ["2023-07-04", { c: "110", ca: "110", e: "110", f: "115", fa: "115", s: "16", si: "16" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "34", fa: "34", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "37", fa: "37", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "37", fa: "37", s: "10", si: "10" }], ["2022-08-23", { c: "97", ca: "97", e: "97", f: "104", fa: "104", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "69", ca: "69", e: "79", f: "62", fa: "62", s: "12", si: "12" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "38", fa: "38", s: "10", si: "10" }], ["2024-01-25", { c: "121", ca: "121", e: "121", f: "115", fa: "115", s: "16.4", si: "16.4" }], ["2024-03-05", { c: "117", ca: "117", e: "117", f: "119", fa: "119", s: "17.4", si: "17.4" }], ["2016-09-20", { c: "47", ca: "47", e: "14", f: "43", fa: "43", s: "10", si: "10" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "5" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3", fa: "4", s: "4", si: "3.2" }], ["2018-05-09", { c: "66", ca: "66", e: "14", f: "60", fa: "60", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "38", fa: "38", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2021-09-20", { c: "88", ca: "88", e: "88", f: "89", fa: "89", s: "15", si: "15" }], ["2017-04-05", { c: "55", ca: "55", e: "15", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2024-06-11", { c: "76", ca: "76", e: "79", f: "127", fa: "127", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "63", ca: "63", e: "79", f: "57", fa: "57", s: "12", si: "12" }], ["2020-01-15", { c: "63", ca: "63", e: "79", f: "57", fa: "57", s: "12", si: "12" }], ["2025-04-01", { c: "133", ca: "133", e: "133", f: "137", fa: "137", s: "18.4", si: "18.4" }], ["2025-11-11", { c: "87", ca: "89", e: "87", f: "145", fa: "145", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "3" }], ["2021-04-26", { c: "66", ca: "66", e: "79", f: "76", fa: "79", s: "14.1", si: "14.5" }], ["2023-02-09", { c: "110", ca: "110", e: "110", f: "86", fa: "86", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "4", si: "3.2" }], ["2020-01-15", { c: "54", ca: "54", e: "79", f: "63", fa: "63", s: "10.1", si: "10.3" }], ["2024-01-26", { c: "85", ca: "85", e: "121", f: "93", fa: "93", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-03-14", { c: "37", ca: "37", e: "79", f: "47", fa: "47", s: "15.4", si: "15.4" }], ["2024-09-16", { c: "76", ca: "76", e: "79", f: "103", fa: "103", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "3.6", fa: "4", s: "1.3", si: "1" }], ["2022-03-14", { c: "1", ca: "18", e: "12", f: "25", fa: "25", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "35", ca: "59", e: "79", f: "30", fa: "54", s: "8", si: "8" }], ["2015-07-29", { c: "21", ca: "25", e: "12", f: "22", fa: "22", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "3.6", fa: "4", s: "1.3", si: "1" }], ["2015-07-29", { c: "21", ca: "25", e: "12", f: "22", fa: "22", s: "5.1", si: "4" }], ["2015-07-29", { c: "25", ca: "25", e: "12", f: "13", fa: "14", s: "7", si: "7" }], ["2016-09-20", { c: "30", ca: "30", e: "12", f: "49", fa: "49", s: "8", si: "8" }], ["2015-07-29", { c: "21", ca: "25", e: "12", f: "9", fa: "18", s: "5.1", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2016-09-20", { c: "30", ca: "30", e: "12", f: "4", fa: "4", s: "10", si: "10" }], ["2020-01-15", { c: "16", ca: "18", e: "79", f: "10", fa: "10", s: "6", si: "6" }], ["2015-07-29", { c: "\u226415", ca: "18", e: "12", f: "10", fa: "10", s: "\u22644", si: "\u22643.2" }], ["2018-04-12", { c: "39", ca: "42", e: "14", f: "31", fa: "31", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1.5", fa: "4", s: "4", si: "3.2" }], ["2020-09-16", { c: "67", ca: "67", e: "79", f: "68", fa: "68", s: "14", si: "14" }], ["2021-09-20", { c: "67", ca: "67", e: "79", f: "68", fa: "68", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2017-02-01", { c: "56", ca: "56", e: "12", f: "50", fa: "50", s: "9.1", si: "9.3" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "14", s: "1", si: "3" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "5" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "29", fa: "29", s: "5.1", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2022-03-14", { c: "54", ca: "54", e: "79", f: "38", fa: "38", s: "15.4", si: "15.4" }], ["2017-09-19", { c: "50", ca: "51", e: "15", f: "44", fa: "44", s: "11", si: "11" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "26", ca: "28", e: "12", f: "16", fa: "16", s: "7", si: "7" }], ["2023-06-06", { c: "110", ca: "110", e: "110", f: "114", fa: "114", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1.5", fa: "4", s: "2", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1.5", fa: "4", s: "2", si: "1" }], ["2024-09-16", { c: "99", ca: "99", e: "99", f: "28", fa: "28", s: "18", si: "18" }], ["2023-04-11", { c: "99", ca: "99", e: "99", f: "112", fa: "112", s: "16.4", si: "16.4" }], ["2023-12-11", { c: "99", ca: "99", e: "99", f: "113", fa: "113", s: "17.2", si: "17.2" }], ["2023-04-11", { c: "99", ca: "99", e: "99", f: "112", fa: "112", s: "16.4", si: "16.4" }], ["2023-12-11", { c: "118", ca: "118", e: "118", f: "97", fa: "97", s: "17.2", si: "17.2" }], ["2020-01-15", { c: "51", ca: "51", e: "79", f: "43", fa: "43", s: "11", si: "11" }], ["2020-01-15", { c: "57", ca: "57", e: "79", f: "53", fa: "53", s: "11.1", si: "11.3" }], ["2022-03-14", { c: "99", ca: "99", e: "99", f: "97", fa: "97", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "49", ca: "49", e: "79", f: "47", fa: "47", s: "9", si: "9" }], ["2015-07-29", { c: "27", ca: "27", e: "12", f: "1", fa: "4", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2015-09-22", { c: "4", ca: "18", e: "12", f: "41", fa: "41", s: "5", si: "4.2" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1.5", fa: "4", s: "4", si: "4" }], ["2024-03-05", { c: "105", ca: "105", e: "105", f: "106", fa: "106", s: "17.4", si: "17.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2016-03-08", { c: "42", ca: "42", e: "13", f: "45", fa: "45", s: "9", si: "9" }], ["2023-09-18", { c: "117", ca: "117", e: "117", f: "63", fa: "63", s: "17", si: "17" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "71", fa: "79", s: "13.1", si: "13" }], ["2020-01-15", { c: "55", ca: "55", e: "79", f: "49", fa: "49", s: "12.1", si: "12.2" }], ["2023-11-02", { c: "119", ca: "119", e: "119", f: "54", fa: "54", s: "13.1", si: "13.4" }], ["2017-03-27", { c: "41", ca: "41", e: "12", f: "22", fa: "22", s: "10.1", si: "10.3" }], ["2025-03-31", { c: "121", ca: "121", e: "121", f: "127", fa: "127", s: "18.4", si: "18.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "15", si: "15" }], ["2023-02-14", { c: "58", ca: "58", e: "79", f: "110", fa: "110", s: "10", si: "10" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "16.2", si: "16.2" }], ["2022-02-03", { c: "98", ca: "98", e: "98", f: "96", fa: "96", s: "13", si: "13" }], ["2020-01-15", { c: "53", ca: "53", e: "79", f: "31", fa: "31", s: "11.1", si: "11.3" }], ["2017-03-07", { c: "50", ca: "50", e: "12", f: "52", fa: "52", s: "9", si: "9" }], ["2020-07-28", { c: "50", ca: "50", e: "12", f: "71", fa: "79", s: "9", si: "9" }], ["2025-08-19", { c: "137", ca: "137", e: "137", f: "142", fa: "142", s: "17", si: "17" }], ["2017-04-19", { c: "26", ca: "26", e: "12", f: "53", fa: "53", s: "7", si: "7" }], ["2023-05-09", { c: "80", ca: "80", e: "80", f: "113", fa: "113", s: "16.4", si: "16.4" }], ["2020-11-17", { c: "69", ca: "69", e: "79", f: "83", fa: "83", s: "12.1", si: "12.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "4", fa: "4", s: "3", si: "1" }], ["2018-12-11", { c: "40", ca: "40", e: "18", f: "51", fa: "64", s: "10.1", si: "10.3" }], ["2023-03-27", { c: "73", ca: "73", e: "79", f: "101", fa: "101", s: "16.4", si: "16.4" }], ["2022-03-14", { c: "52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-09-12", { c: "105", ca: "105", e: "105", f: "101", fa: "101", s: "16", si: "16" }], ["2023-09-18", { c: "83", ca: "83", e: "83", f: "107", fa: "107", s: "17", si: "17" }], ["2022-03-14", { c: "52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-03-14", { c: "52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-03-14", { c: "52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-07-26", { c: "52", ca: "52", e: "79", f: "103", fa: "103", s: "15.4", si: "15.4" }], ["2023-02-14", { c: "105", ca: "105", e: "105", f: "110", fa: "110", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-09-15", { c: "108", ca: "108", e: "108", f: "130", fa: "130", s: "26", si: "26" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "4", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2025-03-04", { c: "51", ca: "51", e: "12", f: "136", fa: "136", s: "5.1", si: "5" }], ["2024-09-16", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "3.2" }], ["2023-12-11", { c: "85", ca: "85", e: "85", f: "68", fa: "68", s: "17.2", si: "17.2" }], ["2023-09-18", { c: "91", ca: "91", e: "91", f: "33", fa: "33", s: "17", si: "17" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "25", s: "3", si: "1" }], ["2023-12-11", { c: "59", ca: "59", e: "79", f: "98", fa: "98", s: "17.2", si: "17.2" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "60", fa: "60", s: "13", si: "13" }], ["2016-08-02", { c: "25", ca: "25", e: "14", f: "23", fa: "23", s: "7", si: "7" }], ["2020-01-15", { c: "46", ca: "46", e: "79", f: "31", fa: "31", s: "10.1", si: "10.3" }], ["2015-09-30", { c: "28", ca: "28", e: "12", f: "22", fa: "22", s: "9", si: "9" }], ["2020-01-15", { c: "61", ca: "61", e: "79", f: "55", fa: "55", s: "11", si: "11" }], ["2015-07-29", { c: "16", ca: "18", e: "12", f: "4", fa: "4", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1.5", fa: "4", s: "4", si: "3.2" }], ["2017-04-05", { c: "49", ca: "49", e: "15", f: "31", fa: "31", s: "9.1", si: "9.3" }], ["2017-10-24", { c: "62", ca: "62", e: "14", f: "22", fa: "22", s: "10", si: "10" }], ["2015-07-29", { c: "\u22644", ca: "18", e: "12", f: "\u22642", fa: "4", s: "\u22643.1", si: "\u22642" }], ["2015-07-29", { c: "7", ca: "18", e: "12", f: "6", fa: "6", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-02-20", { c: "111", ca: "111", e: "111", f: "123", fa: "123", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "4", si: "5" }], ["2020-01-15", { c: "10", ca: "18", e: "79", f: "4", fa: "4", s: "5", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "55", fa: "55", s: "11.1", si: "11.3" }], ["2020-01-15", { c: "12", ca: "18", e: "79", f: "49", fa: "49", s: "6", si: "6" }], ["2025-09-16", { c: "131", ca: "131", e: "131", f: "143", fa: "143", s: "18.4", si: "18.4" }], ["2024-09-03", { c: "120", ca: "120", e: "120", f: "130", fa: "130", s: "17.2", si: "17.2" }], ["2023-09-18", { c: "31", ca: "31", e: "12", f: "6", fa: "6", s: "17", si: "4.2" }], ["2015-07-29", { c: "15", ca: "18", e: "12", f: "1", fa: "4", s: "6", si: "6" }], ["2022-03-14", { c: "37", ca: "37", e: "79", f: "98", fa: "98", s: "15.4", si: "15.4" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "49", fa: "49", s: "16.4", si: "16.4" }], ["2023-08-01", { c: "17", ca: "18", e: "79", f: "116", fa: "116", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "58", ca: "58", e: "79", f: "53", fa: "53", s: "13", si: "13" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["\u22642017-04-05", { c: "1", ca: "18", e: "\u226415", f: "3", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "61", ca: "61", e: "79", f: "33", fa: "33", s: "11", si: "11" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "1", fa: "4", s: "4", si: "3.2" }], ["2016-03-21", { c: "31", ca: "31", e: "12", f: "12", fa: "14", s: "9.1", si: "9.3" }], ["2019-09-19", { c: "14", ca: "18", e: "18", f: "20", fa: "20", s: "10.1", si: "13" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "3.2" }], ["2022-05-03", { c: "98", ca: "98", e: "98", f: "100", fa: "100", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "43", ca: "43", e: "79", f: "46", fa: "46", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "1.5", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2019-03-25", { c: "42", ca: "42", e: "13", f: "38", fa: "38", s: "12.1", si: "12.2" }], ["2021-11-02", { c: "77", ca: "77", e: "79", f: "94", fa: "94", s: "13.1", si: "13.4" }], ["2021-09-20", { c: "93", ca: "93", e: "93", f: "91", fa: "91", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "118", fa: "118", s: "15.4", si: "15.4" }], ["2017-03-27", { c: "52", ca: "52", e: "14", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2018-04-30", { c: "38", ca: "38", e: "17", f: "47", fa: "35", s: "9", si: "9" }], ["2021-09-20", { c: "56", ca: "56", e: "79", f: "51", fa: "51", s: "15", si: "15" }], ["2020-09-16", { c: "63", ca: "63", e: "17", f: "47", fa: "36", s: "14", si: "14" }], ["2020-02-07", { c: "40", ca: "40", e: "80", f: "58", fa: "28", s: "9", si: "9" }], ["2016-06-07", { c: "34", ca: "34", e: "12", f: "47", fa: "47", s: "9.1", si: "9.3" }], ["2017-03-27", { c: "42", ca: "42", e: "14", f: "39", fa: "39", s: "10.1", si: "10.3" }], ["2024-10-29", { c: "103", ca: "103", e: "103", f: "132", fa: "132", s: "17.2", si: "17.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "8", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "5" }], ["2020-01-15", { c: "38", ca: "38", e: "79", f: "28", fa: "28", s: "10.1", si: "10.3" }], ["2021-04-26", { c: "89", ca: "89", e: "89", f: "82", fa: "82", s: "14.1", si: "14.5" }], ["2016-09-07", { c: "53", ca: "53", e: "12", f: "35", fa: "35", s: "9.1", si: "9.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-11-02", { c: "46", ca: "46", e: "79", f: "94", fa: "94", s: "11", si: "11" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-09-30", { c: "29", ca: "29", e: "12", f: "20", fa: "20", s: "9", si: "9" }], ["2021-04-26", { c: "84", ca: "84", e: "84", f: "63", fa: "63", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-04-04", { c: "135", ca: "135", e: "135", f: "129", fa: "129", s: "18.2", si: "18.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "24", fa: "24", s: "3.1", si: "2" }], ["2022-03-14", { c: "86", ca: "86", e: "86", f: "85", fa: "85", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "58", fa: "58", s: "11.1", si: "11.3" }], ["2016-09-20", { c: "36", ca: "36", e: "14", f: "39", fa: "39", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-09-07", { c: "56", ca: "56", e: "79", f: "92", fa: "92", s: "11", si: "11" }], ["2017-04-05", { c: "48", ca: "48", e: "15", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "33", ca: "33", e: "79", f: "32", fa: "32", s: "9", si: "9" }], ["2020-01-15", { c: "35", ca: "35", e: "79", f: "41", fa: "41", s: "10", si: "10" }], ["2020-03-24", { c: "79", ca: "79", e: "17", f: "62", fa: "62", s: "13.1", si: "13.4" }], ["2022-11-15", { c: "101", ca: "101", e: "101", f: "107", fa: "107", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-07-25", { c: "127", ca: "127", e: "127", f: "118", fa: "118", s: "17", si: "17" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-01-06", { c: "97", ca: "97", e: "97", f: "34", fa: "34", s: "9", si: "9" }], ["2023-03-27", { c: "97", ca: "97", e: "97", f: "111", fa: "111", s: "16.4", si: "16.4" }], ["2023-03-27", { c: "97", ca: "97", e: "97", f: "111", fa: "111", s: "16.4", si: "16.4" }], ["2023-03-27", { c: "97", ca: "97", e: "97", f: "111", fa: "111", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-03-13", { c: "111", ca: "111", e: "111", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "52", ca: "52", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "63", ca: "63", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "34", ca: "34", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "52", ca: "52", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2018-09-05", { c: "62", ca: "62", e: "17", f: "62", fa: "62", s: "11", si: "11" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-09-12", { c: "89", ca: "89", e: "79", f: "89", fa: "89", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2023-03-27", { c: "77", ca: "77", e: "79", f: "98", fa: "98", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-27", { c: "35", ca: "35", e: "12", f: "29", fa: "32", s: "10.1", si: "10.3" }], ["2016-09-20", { c: "39", ca: "39", e: "13", f: "26", fa: "26", s: "10", si: "10" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "3.5", fa: "4", s: "5", si: "\u22643" }], ["2015-07-29", { c: "11", ca: "18", e: "12", f: "3.5", fa: "4", s: "5.1", si: "5" }], ["2024-09-16", { c: "125", ca: "125", e: "125", f: "128", fa: "128", s: "18", si: "18" }], ["2020-01-15", { c: "71", ca: "71", e: "79", f: "65", fa: "65", s: "12.1", si: "12.2" }], ["2024-06-11", { c: "111", ca: "111", e: "111", f: "127", fa: "127", s: "16.2", si: "16.2" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "3.6", fa: "4", s: "7", si: "7" }], ["2017-10-17", { c: "57", ca: "57", e: "16", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2022-10-27", { c: "107", ca: "107", e: "107", f: "66", fa: "66", s: "16", si: "16" }], ["2022-03-14", { c: "37", ca: "37", e: "15", f: "48", fa: "48", s: "15.4", si: "15.4" }], ["2023-12-19", { c: "105", ca: "105", e: "105", f: "121", fa: "121", s: "15.4", si: "15.4" }], ["2020-03-24", { c: "74", ca: "74", e: "79", f: "67", fa: "67", s: "13.1", si: "13.4" }], ["2015-07-29", { c: "16", ca: "18", e: "12", f: "11", fa: "14", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4" }], ["2020-01-15", { c: "54", ca: "54", e: "79", f: "63", fa: "63", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2020-01-15", { c: "65", ca: "65", e: "79", f: "52", fa: "52", s: "12.1", si: "12.2" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-09-30", { c: "41", ca: "41", e: "12", f: "36", fa: "36", s: "9", si: "9" }], ["2024-09-16", { c: "87", ca: "87", e: "87", f: "88", fa: "88", s: "18", si: "18" }], ["2022-04-28", { c: "101", ca: "101", e: "101", f: "96", fa: "96", s: "15", si: "15" }], ["2023-09-18", { c: "106", ca: "106", e: "106", f: "98", fa: "98", s: "17", si: "17" }], ["2023-09-18", { c: "88", ca: "55", e: "88", f: "43", fa: "43", s: "17", si: "17" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-10-03", { c: "106", ca: "106", e: "106", f: "97", fa: "97", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "17", fa: "17", s: "5", si: "4" }], ["2020-01-15", { c: "20", ca: "25", e: "79", f: "25", fa: "25", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-04-13", { c: "81", ca: "81", e: "81", f: "26", fa: "26", s: "13.1", si: "13.4" }], ["2021-10-05", { c: "41", ca: "41", e: "79", f: "93", fa: "93", s: "10", si: "10" }], ["2023-09-18", { c: "113", ca: "113", e: "113", f: "89", fa: "89", s: "17", si: "17" }], ["2020-01-15", { c: "66", ca: "66", e: "79", f: "50", fa: "50", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-03-27", { c: "89", ca: "89", e: "89", f: "108", fa: "108", s: "16.4", si: "16.4" }], ["2020-01-15", { c: "39", ca: "39", e: "79", f: "51", fa: "51", s: "10", si: "10" }], ["2021-09-20", { c: "58", ca: "58", e: "79", f: "51", fa: "51", s: "15", si: "15" }], ["2022-08-05", { c: "104", ca: "104", e: "104", f: "72", fa: "79", s: "14.1", si: "14.5" }], ["2023-04-11", { c: "102", ca: "102", e: "102", f: "112", fa: "112", s: "15.5", si: "15.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-11-12", { c: "1", ca: "18", e: "13", f: "19", fa: "19", s: "1.2", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "3.6", fa: "4", s: "3", si: "1" }], ["2021-04-26", { c: "20", ca: "25", e: "12", f: "57", fa: "57", s: "14.1", si: "5" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "3" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "6", fa: "6", s: "3.1", si: "2" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3", fa: "4", s: "4", si: "3" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3.6", fa: "4", s: "4", si: "3.2" }], ["2025-08-19", { c: "13", ca: "132", e: "13", f: "50", fa: "142", s: "11.1", si: "18.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "7", ca: "18", e: "12", f: "29", fa: "29", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-16", { c: "4", ca: "57", e: "12", f: "23", fa: "52", s: "3.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-12-07", { c: "66", ca: "66", e: "79", f: "95", fa: "79", s: "12.1", si: "12.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2018-12-11", { c: "41", ca: "41", e: "12", f: "64", fa: "64", s: "9", si: "9" }], ["2019-03-25", { c: "58", ca: "58", e: "16", f: "55", fa: "55", s: "12.1", si: "12.2" }], ["2017-09-28", { c: "24", ca: "25", e: "12", f: "29", fa: "56", s: "10", si: "10" }], ["2021-04-26", { c: "81", ca: "81", e: "81", f: "86", fa: "86", s: "14.1", si: "14.5" }], ["2025-03-04", { c: "129", ca: "129", e: "129", f: "136", fa: "136", s: "16.4", si: "16.4" }], ["2021-04-26", { c: "72", ca: "72", e: "79", f: "78", fa: "79", s: "14.1", si: "14.5" }], ["2020-09-16", { c: "74", ca: "74", e: "79", f: "75", fa: "79", s: "14", si: "14" }], ["2019-09-19", { c: "63", ca: "63", e: "18", f: "58", fa: "58", s: "13", si: "13" }], ["2020-09-16", { c: "71", ca: "71", e: "79", f: "76", fa: "79", s: "14", si: "14" }], ["2024-04-16", { c: "87", ca: "87", e: "87", f: "125", fa: "125", s: "14.1", si: "14.5" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "82", fa: "82", s: "14", si: "14" }], ["2018-04-12", { c: "55", ca: "55", e: "15", f: "52", fa: "52", s: "11.1", si: "11.3" }], ["2020-01-15", { c: "41", ca: "41", e: "79", f: "36", fa: "36", s: "8", si: "8" }], ["2025-03-31", { c: "122", ca: "122", e: "122", f: "131", fa: "131", s: "18.4", si: "18.4" }], ["2015-07-29", { c: "38", ca: "38", e: "12", f: "13", fa: "14", s: "7", si: "7" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "1", fa: "4", s: "5", si: "4.2" }], ["2018-05-09", { c: "61", ca: "61", e: "16", f: "60", fa: "60", s: "11", si: "11" }], ["2023-06-06", { c: "80", ca: "80", e: "80", f: "114", fa: "114", s: "15", si: "15" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "4" }], ["2025-04-29", { c: "123", ca: "123", e: "123", f: "138", fa: "138", s: "17.2", si: "17.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "6", fa: "6", s: "1.2", si: "1" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "48", ca: "48", e: "79", f: "50", fa: "50", s: "11", si: "11" }], ["2016-09-20", { c: "49", ca: "49", e: "14", f: "44", fa: "44", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-11-21", { c: "109", ca: "109", e: "109", f: "120", fa: "120", s: "16.4", si: "16.4" }], ["2024-05-13", { c: "123", ca: "123", e: "123", f: "120", fa: "120", s: "17.5", si: "17.5" }], ["2020-07-28", { c: "83", ca: "83", e: "83", f: "69", fa: "79", s: "13", si: "13" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-11", { c: "113", ca: "113", e: "113", f: "112", fa: "112", s: "17.2", si: "17.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2025-09-15", { c: "46", ca: "46", e: "79", f: "127", fa: "127", s: "5", si: "26" }], ["2020-01-15", { c: "46", ca: "46", e: "79", f: "39", fa: "39", s: "11.1", si: "11.3" }], ["2021-01-26", { c: "50", ca: "50", e: "79", f: "85", fa: "85", s: "11.1", si: "11.3" }], ["2020-01-15", { c: "65", ca: "65", e: "79", f: "50", fa: "50", s: "9", si: "9" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-19", { c: "77", ca: "77", e: "79", f: "121", fa: "121", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "6", s: "4", si: "3.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-09-16", { c: "85", ca: "85", e: "85", f: "79", fa: "79", s: "14", si: "14" }], ["2021-09-20", { c: "89", ca: "89", e: "89", f: "66", fa: "66", s: "15", si: "15" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "21", fa: "21", s: "7", si: "7" }], ["2015-07-29", { c: "38", ca: "38", e: "12", f: "13", fa: "14", s: "8", si: "8" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "7", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "5" }], ["2020-01-15", { c: "24", ca: "25", e: "79", f: "35", fa: "35", s: "7", si: "7" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "53", fa: "53", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "9", ca: "18", e: "12", f: "6", fa: "6", s: "5.1", si: "5" }], ["2023-01-12", { c: "109", ca: "109", e: "109", f: "4", fa: "4", s: "5.1", si: "5" }], ["2022-04-28", { c: "101", ca: "101", e: "101", f: "63", fa: "63", s: "15.4", si: "15.4" }], ["2017-09-19", { c: "53", ca: "53", e: "12", f: "36", fa: "36", s: "11", si: "11" }], ["2020-02-04", { c: "80", ca: "80", e: "12", f: "42", fa: "42", s: "8", si: "12.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2023-03-27", { c: "104", ca: "104", e: "104", f: "102", fa: "102", s: "16.4", si: "16.4" }], ["2021-04-26", { c: "49", ca: "49", e: "79", f: "25", fa: "25", s: "14.1", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2023-03-27", { c: "60", ca: "60", e: "18", f: "57", fa: "57", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2018-10-02", { c: "6", ca: "18", e: "18", f: "56", fa: "56", s: "6", si: "10.3" }], ["2020-07-28", { c: "79", ca: "79", e: "79", f: "75", fa: "79", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "46", ca: "46", e: "79", f: "66", fa: "66", s: "11", si: "11" }], ["2015-07-29", { c: "18", ca: "18", e: "12", f: "1", fa: "4", s: "1.3", si: "1" }], ["2020-01-15", { c: "41", ca: "41", e: "79", f: "32", fa: "32", s: "8", si: "8" }], ["2020-01-15", { c: "\u226479", ca: "\u226479", e: "79", f: "\u226423", fa: "\u226423", s: "\u22649.1", si: "\u22649.3" }], ["2022-09-02", { c: "105", ca: "105", e: "105", f: "103", fa: "103", s: "15.6", si: "15.6" }], ["2023-09-18", { c: "66", ca: "66", e: "79", f: "115", fa: "115", s: "17", si: "17" }], ["2022-09-12", { c: "55", ca: "55", e: "79", f: "72", fa: "79", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-07", { c: "50", ca: "50", e: "12", f: "52", fa: "52", s: "9", si: "9" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "14", fa: "14", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2021-10-25", { c: "57", ca: "57", e: "12", f: "58", fa: "58", s: "15", si: "15.1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-11", { c: "120", ca: "120", e: "120", f: "117", fa: "117", s: "17.2", si: "17.2" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "84", fa: "84", s: "9", si: "9" }], ["2023-03-27", { c: "20", ca: "42", e: "14", f: "22", fa: "22", s: "7", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "2" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "9", si: "9" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "2" }], ["2020-09-16", { c: "85", ca: "85", e: "85", f: "79", fa: "79", s: "14", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-07-28", { c: "75", ca: "75", e: "79", f: "70", fa: "79", s: "13", si: "13" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2020-01-15", { c: "32", ca: "32", e: "79", f: "36", fa: "36", s: "10", si: "10" }], ["2022-03-14", { c: "93", ca: "93", e: "93", f: "92", fa: "92", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "32", ca: "32", e: "79", f: "36", fa: "36", s: "10", si: "10" }], ["2015-07-29", { c: "24", ca: "25", e: "12", f: "24", fa: "24", s: "8", si: "8" }], ["2021-04-26", { c: "80", ca: "80", e: "80", f: "71", fa: "79", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "10", fa: "10", s: "8", si: "8" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "6", fa: "6", s: "8", si: "8" }], ["2015-07-29", { c: "29", ca: "29", e: "12", f: "24", fa: "24", s: "8", si: "8" }], ["2016-08-02", { c: "27", ca: "27", e: "14", f: "29", fa: "29", s: "8", si: "8" }], ["2018-04-30", { c: "24", ca: "25", e: "17", f: "25", fa: "25", s: "8", si: "9" }], ["2021-04-26", { c: "35", ca: "35", e: "12", f: "25", fa: "25", s: "14.1", si: "14.5" }], ["2023-03-27", { c: "69", ca: "69", e: "79", f: "105", fa: "105", s: "16.4", si: "16.4" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1.5", fa: "4", s: "4", si: "3.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "2", si: "1" }], ["\u22642020-03-24", { c: "\u226480", ca: "\u226480", e: "\u226480", f: "1.5", fa: "4", s: "\u226413.1", si: "\u226413.4" }], ["2020-01-15", { c: "66", ca: "66", e: "79", f: "58", fa: "58", s: "11.1", si: "11.3" }], ["2023-03-27", { c: "108", ca: "109", e: "108", f: "111", fa: "111", s: "16.4", si: "16.4" }], ["2023-03-27", { c: "94", ca: "94", e: "94", f: "88", fa: "88", s: "16.4", si: "16.4" }], ["2017-04-05", { c: "1", ca: "18", e: "15", f: "1.5", fa: "4", s: "1.2", si: "1" }], ["\u22642018-10-02", { c: "10", ca: "18", e: "\u226418", f: "4", fa: "4", s: "7", si: "7" }], ["2023-09-18", { c: "113", ca: "113", e: "113", f: "66", fa: "66", s: "17", si: "17" }], ["2022-09-12", { c: "90", ca: "90", e: "90", f: "81", fa: "81", s: "16", si: "16" }], ["2020-03-24", { c: "68", ca: "68", e: "79", f: "61", fa: "61", s: "13.1", si: "13.4" }], ["2018-10-02", { c: "23", ca: "25", e: "18", f: "49", fa: "49", s: "7", si: "7" }], ["2022-09-12", { c: "63", ca: "63", e: "18", f: "59", fa: "59", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2019-01-29", { c: "50", ca: "50", e: "12", f: "65", fa: "65", s: "10", si: "10" }], ["2024-12-11", { c: "15", ca: "18", e: "79", f: "95", fa: "95", s: "18.2", si: "18.2" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "1.5", fa: "4", s: "5", si: "4" }], ["2015-07-29", { c: "33", ca: "33", e: "12", f: "18", fa: "18", s: "7", si: "7" }], ["2021-04-26", { c: "60", ca: "60", e: "79", f: "84", fa: "84", s: "14.1", si: "14.5" }], ["2025-09-15", { c: "124", ca: "124", e: "124", f: "128", fa: "128", s: "26", si: "26" }], ["2023-03-27", { c: "94", ca: "94", e: "94", f: "99", fa: "99", s: "16.4", si: "16.4" }], ["2015-09-16", { c: "6", ca: "18", e: "12", f: "7", fa: "7", s: "8", si: "9" }], ["2022-09-12", { c: "44", ca: "44", e: "79", f: "46", fa: "46", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2016-03-21", { c: "38", ca: "38", e: "13", f: "38", fa: "38", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "57", ca: "57", e: "79", f: "51", fa: "51", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "47", ca: "47", e: "79", f: "51", fa: "51", s: "9", si: "9" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3.6", fa: "4", s: "4", si: "3.2" }], ["2020-07-28", { c: "55", ca: "55", e: "12", f: "59", fa: "79", s: "13", si: "13" }], ["2025-01-27", { c: "116", ca: "116", e: "116", f: "125", fa: "125", s: "17", si: "18.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3", fa: "4", s: "4", si: "3.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "76", ca: "76", e: "79", f: "67", fa: "67", s: "12.1", si: "13" }], ["2022-05-31", { c: "96", ca: "96", e: "96", f: "101", fa: "101", s: "14.1", si: "14.5" }], ["2020-01-15", { c: "74", ca: "74", e: "79", f: "63", fa: "64", s: "10.1", si: "10.3" }], ["2023-12-11", { c: "73", ca: "73", e: "79", f: "78", fa: "79", s: "17.2", si: "17.2" }], ["2023-12-11", { c: "86", ca: "86", e: "86", f: "101", fa: "101", s: "17.2", si: "17.2" }], ["2023-06-06", { c: "1", ca: "18", e: "12", f: "1", fa: "114", s: "1.1", si: "1" }], ["2025-05-01", { c: "136", ca: "136", e: "136", f: "97", fa: "97", s: "15.4", si: "15.4" }], ["2019-09-19", { c: "63", ca: "63", e: "12", f: "6", fa: "6", s: "13", si: "13" }], ["2015-07-29", { c: "6", ca: "18", e: "12", f: "6", fa: "6", s: "6", si: "7" }], ["2015-07-29", { c: "32", ca: "32", e: "12", f: "29", fa: "29", s: "8", si: "8" }], ["2020-07-28", { c: "76", ca: "76", e: "79", f: "71", fa: "79", s: "13", si: "13" }], ["2020-09-16", { c: "85", ca: "85", e: "85", f: "79", fa: "79", s: "14", si: "14" }], ["2018-10-02", { c: "63", ca: "63", e: "18", f: "58", fa: "58", s: "11.1", si: "11.3" }], ["2025-01-07", { c: "128", ca: "128", e: "128", f: "134", fa: "134", s: "18.2", si: "18.2" }], ["2024-03-05", { c: "119", ca: "119", e: "119", f: "121", fa: "121", s: "17.4", si: "17.4" }], ["2016-09-20", { c: "49", ca: "49", e: "12", f: "18", fa: "18", s: "10", si: "10" }], ["2023-03-27", { c: "50", ca: "50", e: "17", f: "44", fa: "48", s: "16", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2020-03-24", { c: "63", ca: "63", e: "79", f: "49", fa: "49", s: "13.1", si: "13.4" }], ["2020-07-28", { c: "71", ca: "71", e: "79", f: "69", fa: "79", s: "12.1", si: "12.2" }], ["2021-04-26", { c: "87", ca: "87", e: "87", f: "70", fa: "79", s: "14.1", si: "14.5" }], ["2020-07-28", { c: "1", ca: "18", e: "13", f: "78", fa: "79", s: "4", si: "3.2" }], ["2024-01-23", { c: "119", ca: "119", e: "119", f: "122", fa: "122", s: "17.2", si: "17.2" }], ["2021-09-20", { c: "85", ca: "85", e: "85", f: "87", fa: "87", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-05-01", { c: "136", ca: "136", e: "136", f: "134", fa: "134", s: "18.2", si: "18.2" }], ["2024-07-09", { c: "85", ca: "85", e: "85", f: "128", fa: "128", s: "16.4", si: "16.4" }], ["2024-09-16", { c: "125", ca: "125", e: "125", f: "128", fa: "128", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.6", fa: "4", s: "5", si: "4" }], ["2015-07-29", { c: "24", ca: "25", e: "12", f: "23", fa: "23", s: "7", si: "7" }], ["2023-03-27", { c: "69", ca: "69", e: "79", f: "99", fa: "99", s: "16.4", si: "16.4" }], ["2024-10-29", { c: "83", ca: "83", e: "83", f: "132", fa: "132", s: "15.4", si: "15.4" }], ["2025-05-27", { c: "134", ca: "134", e: "134", f: "139", fa: "139", s: "18.4", si: "18.4" }], ["2024-07-09", { c: "111", ca: "111", e: "111", f: "128", fa: "128", s: "16.4", si: "16.4" }], ["2020-07-28", { c: "64", ca: "64", e: "79", f: "69", fa: "79", s: "13.1", si: "13.4" }], ["2022-09-12", { c: "68", ca: "68", e: "79", f: "62", fa: "62", s: "16", si: "16" }], ["2018-10-23", { c: "1", ca: "18", e: "12", f: "63", fa: "63", s: "3", si: "1" }], ["2023-03-27", { c: "54", ca: "54", e: "17", f: "45", fa: "45", s: "16.4", si: "16.4" }], ["2017-09-19", { c: "29", ca: "29", e: "12", f: "35", fa: "35", s: "11", si: "11" }], ["2020-07-27", { c: "84", ca: "84", e: "84", f: "67", fa: "67", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "65", ca: "65", e: "79", f: "52", fa: "52", s: "12.1", si: "12.2" }], ["2023-11-21", { c: "111", ca: "111", e: "111", f: "120", fa: "120", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-05-17", { c: "125", ca: "125", e: "125", f: "118", fa: "118", s: "17.2", si: "17.2" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "38", fa: "38", s: "5", si: "4.2" }], ["2024-12-11", { c: "128", ca: "128", e: "128", f: "38", fa: "38", s: "18.2", si: "18.2" }], ["2024-12-11", { c: "84", ca: "84", e: "84", f: "38", fa: "38", s: "18.2", si: "18.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "69", ca: "69", e: "79", f: "65", fa: "65", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "27", ca: "27", e: "79", f: "32", fa: "32", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-03-27", { c: "38", ca: "39", e: "79", f: "43", fa: "43", s: "16.4", si: "16.4" }], ["2025-03-31", { c: "84", ca: "84", e: "84", f: "126", fa: "126", s: "16.4", si: "18.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "113", fa: "113", s: "17", si: "17" }], ["2022-03-14", { c: "61", ca: "61", e: "79", f: "36", fa: "36", s: "15.4", si: "15.4" }], ["2020-09-16", { c: "61", ca: "61", e: "79", f: "36", fa: "36", s: "14", si: "14" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "1", fa: "4", s: "3", si: "1" }], ["2020-01-15", { c: "69", ca: "69", e: "79", f: "68", fa: "68", s: "11", si: "11" }], ["2024-10-01", { c: "80", ca: "80", e: "80", f: "131", fa: "131", s: "16.1", si: "16.1" }], ["2024-12-11", { c: "94", ca: "94", e: "94", f: "97", fa: "97", s: "18.2", si: "18.2" }], ["2024-12-11", { c: "121", ca: "121", e: "121", f: "64", fa: "64", s: "18.2", si: "18.2" }], ["2023-10-13", { c: "118", ca: "118", e: "118", f: "118", fa: "118", s: "17", si: "17" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-07", { c: "11", ca: "18", e: "12", f: "52", fa: "52", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2020-01-15", { c: "6", ca: "18", e: "79", f: "6", fa: "45", s: "5", si: "5" }], ["2023-03-27", { c: "65", ca: "65", e: "79", f: "61", fa: "61", s: "16.4", si: "16.4" }], ["2018-04-30", { c: "45", ca: "45", e: "17", f: "44", fa: "44", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "38", ca: "38", e: "12", f: "13", fa: "14", s: "8", si: "8" }], ["2024-06-11", { c: "122", ca: "122", e: "122", f: "127", fa: "127", s: "17", si: "17" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "5" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "5" }], ["2020-01-15", { c: "53", ca: "53", e: "79", f: "63", fa: "63", s: "10", si: "10" }], ["2020-07-28", { c: "73", ca: "73", e: "79", f: "72", fa: "79", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "37", ca: "37", e: "79", f: "62", fa: "62", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "37", ca: "37", e: "79", f: "54", fa: "54", s: "10.1", si: "10.3" }], ["2021-12-13", { c: "68", ca: "89", e: "79", f: "79", fa: "79", s: "15.2", si: "15.2" }], ["2020-01-15", { c: "53", ca: "53", e: "79", f: "63", fa: "63", s: "10", si: "10" }], ["2023-03-27", { c: "92", ca: "92", e: "92", f: "92", fa: "92", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "19", ca: "25", e: "79", f: "4", fa: "4", s: "6", si: "6" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "2" }], ["2020-01-15", { c: "18", ca: "18", e: "79", f: "55", fa: "55", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2018-09-05", { c: "33", ca: "33", e: "14", f: "49", fa: "62", s: "7", si: "7" }], ["2017-11-28", { c: "9", ca: "47", e: "12", f: "2", fa: "57", s: "5.1", si: "5" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "55", fa: "55", s: "11.1", si: "11.3" }], ["2017-03-27", { c: "38", ca: "38", e: "13", f: "38", fa: "38", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "70", ca: "70", e: "79", f: "3", fa: "4", s: "10.1", si: "10.3" }], ["2024-08-06", { c: "117", ca: "117", e: "117", f: "129", fa: "129", s: "17.5", si: "17.5" }], ["2024-05-17", { c: "125", ca: "125", e: "125", f: "126", fa: "126", s: "17.4", si: "17.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-09-16", { c: "77", ca: "77", e: "79", f: "65", fa: "65", s: "14", si: "14" }], ["2019-09-19", { c: "56", ca: "56", e: "16", f: "59", fa: "59", s: "13", si: "13" }], ["2023-12-05", { c: "119", ca: "120", e: "85", f: "65", fa: "65", s: "11.1", si: "11.3" }], ["2023-09-18", { c: "61", ca: "61", e: "79", f: "57", fa: "57", s: "17", si: "17" }], ["2022-06-28", { c: "67", ca: "67", e: "79", f: "102", fa: "102", s: "14.1", si: "14.5" }], ["2022-03-14", { c: "92", ca: "92", e: "92", f: "90", fa: "90", s: "15.4", si: "15.4" }], ["2015-09-30", { c: "41", ca: "41", e: "12", f: "29", fa: "29", s: "9", si: "9" }], ["2015-09-30", { c: "41", ca: "41", e: "12", f: "40", fa: "40", s: "9", si: "9" }], ["2020-01-15", { c: "73", ca: "73", e: "79", f: "67", fa: "67", s: "13", si: "13" }], ["2016-09-20", { c: "34", ca: "34", e: "12", f: "31", fa: "31", s: "10", si: "10" }], ["2017-04-05", { c: "57", ca: "57", e: "15", f: "48", fa: "48", s: "10", si: "10" }], ["2015-09-30", { c: "41", ca: "41", e: "12", f: "34", fa: "34", s: "9", si: "9" }], ["2015-09-30", { c: "41", ca: "36", e: "12", f: "24", fa: "24", s: "9", si: "9" }], ["2020-08-27", { c: "85", ca: "85", e: "85", f: "77", fa: "79", s: "13.1", si: "13.4" }], ["2015-09-30", { c: "41", ca: "36", e: "12", f: "17", fa: "17", s: "9", si: "9" }], ["2020-01-15", { c: "66", ca: "66", e: "79", f: "61", fa: "61", s: "12", si: "12" }], ["2023-10-24", { c: "111", ca: "111", e: "111", f: "119", fa: "119", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2022-03-14", { c: "98", ca: "98", e: "98", f: "94", fa: "94", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2023-09-15", { c: "117", ca: "117", e: "117", f: "71", fa: "79", s: "16", si: "16" }], ["2015-09-30", { c: "28", ca: "28", e: "12", f: "22", fa: "22", s: "9", si: "9" }], ["2016-09-20", { c: "2", ca: "18", e: "12", f: "49", fa: "49", s: "4", si: "3.2" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "3", fa: "4", s: "3", si: "2" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "3", fa: "4", s: "6", si: "6" }], ["2015-09-30", { c: "38", ca: "38", e: "12", f: "36", fa: "36", s: "9", si: "9" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-08-10", { c: "42", ca: "42", e: "79", f: "91", fa: "91", s: "13.1", si: "13.4" }], ["2018-10-02", { c: "1", ca: "18", e: "18", f: "1.5", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1.3", si: "2" }], ["2024-12-11", { c: "89", ca: "89", e: "89", f: "131", fa: "131", s: "18.2", si: "18.2" }], ["2015-11-12", { c: "26", ca: "26", e: "13", f: "22", fa: "22", s: "8", si: "8" }], ["2020-01-15", { c: "62", ca: "62", e: "79", f: "53", fa: "53", s: "11", si: "11" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-09-12", { c: "47", ca: "47", e: "12", f: "49", fa: "49", s: "16", si: "16" }], ["2022-03-14", { c: "48", ca: "48", e: "79", f: "48", fa: "48", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-03-03", { c: "99", ca: "99", e: "99", f: "46", fa: "46", s: "7", si: "7" }], ["2020-01-15", { c: "38", ca: "38", e: "79", f: "19", fa: "19", s: "10.1", si: "10.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-09-16", { c: "48", ca: "48", e: "79", f: "41", fa: "41", s: "14", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "7", fa: "7", s: "1.3", si: "1" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3.5", fa: "4", s: "1.1", si: "1" }], ["2017-04-05", { c: "4", ca: "18", e: "15", f: "49", fa: "49", s: "3", si: "2" }], ["2015-07-29", { c: "23", ca: "25", e: "12", f: "31", fa: "31", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-11-19", { c: "87", ca: "87", e: "87", f: "70", fa: "79", s: "12.1", si: "12.2" }], ["2020-07-28", { c: "33", ca: "33", e: "12", f: "74", fa: "79", s: "12.1", si: "12.2" }], ["2024-03-19", { c: "114", ca: "114", e: "114", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2024-05-13", { c: "114", ca: "114", e: "114", f: "121", fa: "121", s: "17.5", si: "17.5" }], ["2024-10-17", { c: "130", ca: "130", e: "130", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2024-03-19", { c: "114", ca: "114", e: "114", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2024-10-17", { c: "130", ca: "130", e: "130", f: "121", fa: "121", s: "17.5", si: "17.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643" }], ["2017-10-24", { c: "62", ca: "62", e: "14", f: "22", fa: "22", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2019-09-19", { c: "36", ca: "36", e: "12", f: "52", fa: "52", s: "13", si: "9.3" }], ["2024-03-05", { c: "114", ca: "114", e: "114", f: "122", fa: "122", s: "17.4", si: "17.4" }], ["2024-04-16", { c: "118", ca: "118", e: "118", f: "125", fa: "125", s: "13.1", si: "13.4" }], ["2015-09-30", { c: "36", ca: "36", e: "12", f: "16", fa: "16", s: "9", si: "9" }], ["2022-03-14", { c: "36", ca: "36", e: "12", f: "16", fa: "16", s: "15.4", si: "15.4" }], ["2024-08-06", { c: "117", ca: "117", e: "117", f: "129", fa: "129", s: "17.4", si: "17.4" }], ["2015-09-30", { c: "26", ca: "26", e: "12", f: "16", fa: "16", s: "9", si: "9" }], ["2023-03-14", { c: "19", ca: "25", e: "79", f: "111", fa: "111", s: "6", si: "6" }], ["2023-03-13", { c: "111", ca: "111", e: "111", f: "108", fa: "108", s: "15.4", si: "15.4" }], ["2023-07-21", { c: "115", ca: "115", e: "115", f: "70", fa: "79", s: "15", si: "15" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "38", fa: "38", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "37", fa: "37", s: "10", si: "10" }], ["2015-07-29", { c: "7", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-09-05", { c: "140", ca: "140", e: "140", f: "133", fa: "133", s: "18.2", si: "18.2" }], ["2015-09-30", { c: "44", ca: "44", e: "12", f: "40", fa: "40", s: "9", si: "9" }], ["2016-03-21", { c: "41", ca: "41", e: "13", f: "27", fa: "27", s: "9.1", si: "9.3" }], ["2023-09-18", { c: "113", ca: "113", e: "113", f: "102", fa: "102", s: "17", si: "17" }], ["2018-04-30", { c: "44", ca: "44", e: "17", f: "48", fa: "48", s: "10.1", si: "10.3" }], ["2015-07-29", { c: "32", ca: "32", e: "12", f: "19", fa: "19", s: "7", si: "7" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "115", fa: "115", s: "17", si: "17" }], ["2025-09-15", { c: "95", ca: "95", e: "95", f: "142", fa: "142", s: "26", si: "26" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "2", si: "1" }], ["2023-11-21", { c: "72", ca: "72", e: "79", f: "120", fa: "120", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "5" }], ["2023-11-02", { c: "119", ca: "119", e: "119", f: "88", fa: "88", s: "16.5", si: "16.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-04-18", { c: "124", ca: "124", e: "124", f: "120", fa: "120", s: "17.4", si: "17.4" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "3" }], ["2025-10-14", { c: "125", ca: "125", e: "125", f: "144", fa: "144", s: "18.2", si: "18.2" }], ["2025-10-14", { c: "111", ca: "111", e: "111", f: "144", fa: "144", s: "18", si: "18" }], ["2022-12-05", { c: "108", ca: "108", e: "108", f: "101", fa: "101", s: "15.4", si: "15.4" }], ["2017-10-17", { c: "26", ca: "26", e: "16", f: "19", fa: "19", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1.3", si: "1" }], ["2021-08-10", { c: "61", ca: "61", e: "79", f: "91", fa: "68", s: "13", si: "13" }], ["2017-10-17", { c: "57", ca: "57", e: "16", f: "52", fa: "52", s: "11", si: "11" }], ["2021-04-26", { c: "85", ca: "85", e: "85", f: "78", fa: "79", s: "14.1", si: "14.5" }], ["2021-10-25", { c: "75", ca: "75", e: "79", f: "78", fa: "79", s: "15.1", si: "15.1" }], ["2022-05-03", { c: "95", ca: "95", e: "95", f: "100", fa: "100", s: "15.2", si: "15.2" }], ["2024-03-05", { c: "114", ca: "114", e: "114", f: "112", fa: "112", s: "17.4", si: "17.4" }], ["2024-12-11", { c: "119", ca: "119", e: "119", f: "120", fa: "120", s: "18.2", si: "18.2" }], ["2020-10-20", { c: "86", ca: "86", e: "86", f: "78", fa: "79", s: "13.1", si: "13.4" }], ["2020-03-24", { c: "69", ca: "69", e: "79", f: "62", fa: "62", s: "13.1", si: "13.4" }], ["2021-10-25", { c: "75", ca: "75", e: "18", f: "64", fa: "64", s: "15.1", si: "15.1" }], ["2021-11-19", { c: "96", ca: "96", e: "96", f: "79", fa: "79", s: "15.1", si: "15.1" }], ["2021-04-26", { c: "69", ca: "69", e: "18", f: "62", fa: "62", s: "14.1", si: "14.5" }], ["2023-03-27", { c: "91", ca: "91", e: "91", f: "89", fa: "89", s: "16.4", si: "16.4" }], ["2024-12-11", { c: "112", ca: "112", e: "112", f: "121", fa: "121", s: "18.2", si: "18.2" }], ["2021-12-13", { c: "74", ca: "88", e: "79", f: "79", fa: "79", s: "15.2", si: "15.2" }], ["2024-09-16", { c: "119", ca: "119", e: "119", f: "120", fa: "120", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "4", si: "3.2" }], ["2021-04-26", { c: "84", ca: "84", e: "84", f: "79", fa: "79", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "36", ca: "36", e: "12", f: "6", fa: "6", s: "8", si: "8" }], ["2015-09-30", { c: "36", ca: "36", e: "12", f: "34", fa: "34", s: "9", si: "9" }], ["2020-09-16", { c: "84", ca: "84", e: "84", f: "75", fa: "79", s: "14", si: "14" }], ["2021-04-26", { c: "35", ca: "35", e: "12", f: "25", fa: "25", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "37", ca: "37", e: "12", f: "34", fa: "34", s: "11", si: "11" }], ["2022-03-14", { c: "69", ca: "69", e: "79", f: "96", fa: "96", s: "15.4", si: "15.4" }], ["2021-09-07", { c: "67", ca: "70", e: "18", f: "60", fa: "92", s: "13", si: "13" }], ["2023-10-24", { c: "85", ca: "85", e: "85", f: "119", fa: "119", s: "16", si: "16" }], ["2015-07-29", { c: "9", ca: "25", e: "12", f: "4", fa: "4", s: "5.1", si: "8" }], ["2021-09-20", { c: "63", ca: "63", e: "17", f: "30", fa: "30", s: "14", si: "15" }], ["2024-10-29", { c: "104", ca: "104", e: "104", f: "132", fa: "132", s: "16.4", si: "16.4" }], ["2020-01-15", { c: "47", ca: "47", e: "79", f: "53", fa: "53", s: "12", si: "12" }], ["2017-04-19", { c: "33", ca: "33", e: "12", f: "53", fa: "53", s: "9.1", si: "9.3" }], ["2020-09-16", { c: "47", ca: "47", e: "79", f: "56", fa: "56", s: "14", si: "14" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "22", fa: "22", s: "8", si: "8" }], ["2018-04-30", { c: "26", ca: "26", e: "17", f: "22", fa: "22", s: "8", si: "8" }], ["2022-12-13", { c: "100", ca: "100", e: "100", f: "108", fa: "108", s: "16", si: "16" }], ["2021-09-20", { c: "56", ca: "58", e: "79", f: "51", fa: "51", s: "15", si: "15" }], ["2024-10-29", { c: "104", ca: "104", e: "104", f: "132", fa: "132", s: "16.4", si: "16.4" }], ["2020-09-16", { c: "9", ca: "18", e: "18", f: "65", fa: "65", s: "14", si: "14" }], ["2020-01-15", { c: "56", ca: "56", e: "79", f: "22", fa: "24", s: "11", si: "11" }], ["2025-10-03", { c: "141", ca: "141", e: "141", f: "117", fa: "117", s: "15.4", si: "15.4" }], ["2023-05-09", { c: "76", ca: "76", e: "79", f: "113", fa: "113", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "58", ca: "58", e: "79", f: "44", fa: "44", s: "11", si: "11" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "11", fa: "14", s: "5", si: "4.2" }], ["2015-07-29", { c: "23", ca: "25", e: "12", f: "31", fa: "31", s: "6", si: "8" }], ["2020-01-15", { c: "23", ca: "25", e: "79", f: "31", fa: "31", s: "6", si: "8" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "82", fa: "82", s: "14", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-03-19", { c: "114", ca: "114", e: "114", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "36", ca: "36", e: "79", f: "36", fa: "36", s: "9.1", si: "9.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-09-30", { c: "44", ca: "44", e: "12", f: "15", fa: "15", s: "9", si: "9" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-27", { c: "48", ca: "48", e: "12", f: "41", fa: "41", s: "10.1", si: "10.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "3", fa: "4", s: "1", si: "1" }], ["2024-05-14", { c: "1", ca: "18", e: "12", f: "126", fa: "126", s: "3.1", si: "3" }]];
    1763388641376 < (/* @__PURE__ */ new Date()).setMonth((/* @__PURE__ */ new Date()).getMonth() - 2) && console.warn("[baseline-browser-mapping] The data in this module is over two months old.  To ensure accurate Baseline data, please update: `npm i baseline-browser-mapping@latest -D`");
    var r = c, f = { w: "WebKit", g: "Gecko", p: "Presto", b: "Blink" }, e = { r: "retired", c: "current", b: "beta", n: "nightly", p: "planned", u: "unknown", e: "esr" }, b = (s2) => {
      let a2 = {};
      return Object.entries(s2).forEach(([s3, c2]) => {
        if (c2.releases) {
          a2[s3] || (a2[s3] = { releases: {} });
          let r2 = a2[s3].releases;
          c2.releases.forEach((s4) => {
            r2[s4[0]] = { version: s4[0], release_date: s4[1] == "u" ? "unknown" : s4[1], status: e[s4[2]], engine: s4[3] ? f[s4[3]] : void 0, engine_version: s4[4] };
          });
        }
      }), a2;
    }, u = (() => {
      let s2 = [];
      return r.forEach((a2) => {
        var c2;
        s2.push({ status: { baseline_low_date: a2[0], support: (c2 = a2[1], { chrome: c2.c, chrome_android: c2.ca, edge: c2.e, firefox: c2.f, firefox_android: c2.fa, safari: c2.s, safari_ios: c2.si }) } });
      }), s2;
    })(), i = b(s), n = b(a), g = ["chrome", "chrome_android", "edge", "firefox", "firefox_android", "safari", "safari_ios"], o = Object.entries(i).filter(([s2]) => g.includes(s2)), t = ["webview_android", "samsunginternet_android", "opera_android", "opera"], l = [...Object.entries(i).filter(([s2]) => t.includes(s2)), ...Object.entries(n)], w = ["current", "esr", "retired", "unknown", "beta", "nightly"], d = !1, p = (s2) => {
      s2.includeDownstreamBrowsers === !1 && s2.includeKaiOS === !0 && (console.log(new Error("KaiOS is a downstream browser and can only be included if you include other downstream browsers. Please ensure you use `includeDownstreamBrowsers: true`.")), process.exit(1));
    }, v = (s2) => s2 && s2.startsWith("\u2264") ? s2.slice(1) : s2, _ = (s2, a2) => {
      if (s2 === a2) return 0;
      let [c2 = 0, r2 = 0] = s2.split(".", 2).map(Number), [f2 = 0, e2 = 0] = a2.split(".", 2).map(Number);
      if (isNaN(c2) || isNaN(r2)) throw new Error(`Invalid version: ${s2}`);
      if (isNaN(f2) || isNaN(e2)) throw new Error(`Invalid version: ${a2}`);
      return c2 !== f2 ? c2 > f2 ? 1 : -1 : r2 !== e2 ? r2 > e2 ? 1 : -1 : 0;
    }, h = (s2) => {
      let a2 = [];
      return s2.forEach((s3) => {
        let c2 = o.find((a3) => a3[0] === s3.browser);
        c2 && Object.entries(c2[1].releases).filter(([, s4]) => w.includes(s4.status)).sort((s4, a3) => _(s4[0], a3[0])).forEach(([c3, r2]) => !!w.includes(r2.status) && _(c3, s3.version) === 1 && (a2.push({ browser: s3.browser, version: c3, release_date: r2.release_date ? r2.release_date : "unknown" }), !0));
      }), a2;
    }, m = (s2, a2 = !1) => {
      if (s2.getFullYear() < 2015 && !d && console.warn(new Error("There are no browser versions compatible with Baseline before 2015.  You may receive unexpected results.")), s2.getFullYear() < 2002) throw new Error("None of the browsers in the core set were released before 2002.  Please use a date after 2002.");
      if (s2.getFullYear() > (/* @__PURE__ */ new Date()).getFullYear()) throw new Error("There are no browser versions compatible with Baseline in the future");
      let c2 = ((s3) => u.filter((a3) => a3.status.baseline_low_date && new Date(a3.status.baseline_low_date) <= s3).map((s4) => ({ baseline_low_date: s4.status.baseline_low_date, support: s4.status.support })))(s2), r2 = ((s3) => {
        let a3 = {};
        return Object.entries(o).forEach(([, s4]) => {
          a3[s4[0]] = { browser: s4[0], version: "0", release_date: "" };
        }), s3.forEach((s4) => {
          Object.entries(s4.support).forEach((c3) => {
            let r3 = c3[0], f2 = v(c3[1]);
            a3[r3] && _(f2, v(a3[r3].version)) === 1 && (a3[r3] = { browser: r3, version: f2, release_date: s4.baseline_low_date });
          });
        }), Object.values(a3);
      })(c2);
      return a2 ? [...r2, ...h(r2)].sort((s3, a3) => s3.browser < a3.browser ? -1 : s3.browser > a3.browser ? 1 : _(s3.version, a3.version)) : r2;
    }, y = (s2 = [], a2 = !0, c2 = !1) => {
      let r2 = (a3) => {
        var c3;
        return s2 && s2.length > 0 ? (c3 = s2.filter((s3) => s3.browser === a3).sort((s3, a4) => _(s3.version, a4.version))[0]) === null || c3 === void 0 ? void 0 : c3.version : void 0;
      }, f2 = r2("chrome"), e2 = r2("firefox");
      if (!f2 && !e2) throw new Error("There are no browser versions compatible with Baseline before Chrome and Firefox");
      let b2 = [];
      return l.filter(([s3]) => !(s3 === "kai_os" && !c2)).forEach(([s3, c3]) => {
        var r3;
        if (!c3.releases) return;
        let u2 = Object.entries(c3.releases).filter(([, s4]) => {
          let { engine: a3, engine_version: c4 } = s4;
          return !(!a3 || !c4) && (a3 === "Blink" && f2 ? _(c4, f2) >= 0 : !(a3 !== "Gecko" || !e2) && _(c4, e2) >= 0);
        }).sort((s4, a3) => _(s4[0], a3[0]));
        for (let c4 = 0; c4 < u2.length; c4++) {
          let f3 = u2[c4];
          if (f3) {
            let [c5, e3] = f3, u3 = { browser: s3, version: c5, release_date: (r3 = e3.release_date) !== null && r3 !== void 0 ? r3 : "unknown" };
            if (e3.engine && e3.engine_version && (u3.engine = e3.engine, u3.engine_version = e3.engine_version), b2.push(u3), !a2) break;
          }
        }
      }), b2;
    };
    function O(s2) {
      var a2, c2, r2, f2, e2;
      let b2 = s2 ?? {}, u2 = { listAllCompatibleVersions: (a2 = b2.listAllCompatibleVersions) !== null && a2 !== void 0 && a2, includeDownstreamBrowsers: (c2 = b2.includeDownstreamBrowsers) !== null && c2 !== void 0 && c2, widelyAvailableOnDate: (r2 = b2.widelyAvailableOnDate) !== null && r2 !== void 0 ? r2 : void 0, targetYear: (f2 = b2.targetYear) !== null && f2 !== void 0 ? f2 : void 0, includeKaiOS: (e2 = b2.includeKaiOS) !== null && e2 !== void 0 && e2 }, i2 = /* @__PURE__ */ new Date();
      p(u2), u2.widelyAvailableOnDate || u2.targetYear ? u2.targetYear && u2.widelyAvailableOnDate ? (console.log(new Error("You cannot use targetYear and widelyAvailableOnDate at the same time.  Please remove one of these options and try again.")), process.exit(1)) : u2.widelyAvailableOnDate ? i2 = new Date(u2.widelyAvailableOnDate) : u2.targetYear && (i2 = /* @__PURE__ */ new Date(`${u2.targetYear}-12-31`)) : i2 = /* @__PURE__ */ new Date(), (u2.widelyAvailableOnDate || u2.targetYear === void 0) && i2.setMonth(i2.getMonth() - 30);
      let n2 = m(i2, u2.listAllCompatibleVersions);
      return u2.includeDownstreamBrowsers === !1 ? n2 : [...n2, ...y(n2, u2.listAllCompatibleVersions, u2.includeKaiOS)];
    }
    exports.getAllVersions = function(s2) {
      var a2, c2, r2, f2;
      d = !0;
      let e2 = s2 ?? {}, b2 = { outputFormat: (a2 = e2.outputFormat) !== null && a2 !== void 0 ? a2 : "array", includeDownstreamBrowsers: (c2 = e2.includeDownstreamBrowsers) !== null && c2 !== void 0 && c2, useSupports: (r2 = e2.useSupports) !== null && r2 !== void 0 && r2, includeKaiOS: (f2 = e2.includeKaiOS) !== null && f2 !== void 0 && f2 };
      p(b2);
      let u2 = (/* @__PURE__ */ new Date()).getFullYear() + 1, i2 = [...Array(u2).keys()].slice(2002), n2 = {};
      i2.forEach((s3) => {
        n2[s3] = {}, O({ targetYear: s3 }).forEach((a3) => {
          n2[s3] && (n2[s3][a3.browser] = a3);
        });
      });
      let o2 = O({}), t2 = {};
      o2.forEach((s3) => {
        t2[s3.browser] = s3;
      });
      let l2 = /* @__PURE__ */ new Date();
      l2.setMonth(l2.getMonth() + 30);
      let w2 = O({ widelyAvailableOnDate: l2.toISOString().slice(0, 10) }), v2 = {};
      w2.forEach((s3) => {
        v2[s3.browser] = s3;
      });
      let h2 = O({ targetYear: 2002, listAllCompatibleVersions: !0 }), m2 = [];
      if (g.forEach((s3) => {
        var a3, c3, r3, f3;
        let e3 = h2.filter((a4) => a4.browser == s3).sort((s4, a4) => _(s4.version, a4.version)), g2 = (c3 = (a3 = t2[s3]) === null || a3 === void 0 ? void 0 : a3.version) !== null && c3 !== void 0 ? c3 : "0", o3 = (f3 = (r3 = v2[s3]) === null || r3 === void 0 ? void 0 : r3.version) !== null && f3 !== void 0 ? f3 : "0";
        i2.forEach((a4) => {
          var c4;
          if (n2[a4]) {
            let r4 = ((c4 = n2[a4][s3]) !== null && c4 !== void 0 ? c4 : { version: "0" }).version, f4 = e3.findIndex((s4) => _(s4.version, r4) === 0);
            (a4 === u2 - 1 ? e3 : e3.slice(0, f4)).forEach((s4) => {
              let c5 = _(s4.version, g2) >= 0, r5 = _(s4.version, o3) >= 0, f5 = Object.assign(Object.assign({}, s4), { year: a4 <= 2015 ? "pre_baseline" : a4 - 1 });
              b2.useSupports ? (c5 && (f5.supports = "widely"), r5 && (f5.supports = "newly")) : f5 = Object.assign(Object.assign({}, f5), { wa_compatible: c5 }), m2.push(f5);
            }), e3 = e3.slice(f4, e3.length);
          }
        });
      }), b2.includeDownstreamBrowsers && y(m2, !0, b2.includeKaiOS).forEach((s3) => {
        let a3 = m2.find((a4) => a4.browser === "chrome" && a4.version === s3.engine_version);
        a3 && (b2.useSupports ? m2.push(Object.assign(Object.assign({}, s3), { year: a3.year, supports: a3.supports })) : m2.push(Object.assign(Object.assign({}, s3), { year: a3.year, wa_compatible: a3.wa_compatible })));
      }), m2.sort((s3, a3) => {
        if (s3.year === "pre_baseline" && a3.year !== "pre_baseline") return -1;
        if (a3.year === "pre_baseline" && s3.year !== "pre_baseline") return 1;
        if (s3.year !== "pre_baseline" && a3.year !== "pre_baseline") {
          if (s3.year < a3.year) return -1;
          if (s3.year > a3.year) return 1;
        }
        return s3.browser < a3.browser ? -1 : s3.browser > a3.browser ? 1 : _(s3.version, a3.version);
      }), b2.outputFormat === "object") {
        let s3 = {};
        return m2.forEach((a3) => {
          s3[a3.browser] || (s3[a3.browser] = {});
          let c3 = { year: a3.year, release_date: a3.release_date, engine: a3.engine, engine_version: a3.engine_version };
          s3[a3.browser][a3.version] = b2.useSupports ? a3.supports ? Object.assign(Object.assign({}, c3), { supports: a3.supports }) : c3 : Object.assign(Object.assign({}, c3), { wa_compatible: a3.wa_compatible });
        }), s3 ?? {};
      }
      if (b2.outputFormat === "csv") {
        let s3 = `"browser","version","year","${b2.useSupports ? "supports" : "wa_compatible"}","release_date","engine","engine_version"`;
        return m2.forEach((a3) => {
          var c3, r3, f3, e3;
          let u3 = { browser: a3.browser, version: a3.version, year: a3.year, release_date: (c3 = a3.release_date) !== null && c3 !== void 0 ? c3 : "NULL", engine: (r3 = a3.engine) !== null && r3 !== void 0 ? r3 : "NULL", engine_version: (f3 = a3.engine_version) !== null && f3 !== void 0 ? f3 : "NULL" };
          u3 = b2.useSupports ? Object.assign(Object.assign({}, u3), { supports: (e3 = a3.supports) !== null && e3 !== void 0 ? e3 : "" }) : Object.assign(Object.assign({}, u3), { wa_compatible: a3.wa_compatible }), s3 += `
"${u3.browser}","${u3.version}","${u3.year}","${b2.useSupports ? u3.supports : u3.wa_compatible}","${u3.release_date}","${u3.engine}","${u3.engine_version}"`;
        }), s3;
      }
      return m2;
    }, exports.getCompatibleVersions = O;
  }
});

// ../node_modules/node-releases/data/processed/envs.json
var require_envs = __commonJS({
  "../node_modules/node-releases/data/processed/envs.json"(exports, module) {
    module.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.3.8.0" }, { name: "nodejs", version: "0.3.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.5.1.0" }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: !1, security: !1, v8: "3.1.2.0" }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: !1, security: !1, v8: "3.1.8.25" }, { name: "nodejs", version: "0.6.0", date: "2011-11-04", lts: !1, security: !1, v8: "3.6.6.6" }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: !1, security: !1, v8: "3.8.6.0" }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: !1, security: !1, v8: "3.11.10.10" }, { name: "nodejs", version: "0.9.0", date: "2012-07-20", lts: !1, security: !1, v8: "3.11.10.15" }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: !1, security: !1, v8: "3.14.5.8" }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: !1, security: !1, v8: "3.17.13.0" }, { name: "nodejs", version: "0.12.0", date: "2015-02-06", lts: !1, security: !1, v8: "3.28.73.0" }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: !1, security: !1, v8: "4.5.103.30" }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: !1, security: !1, v8: "4.5.103.33" }, { name: "nodejs", version: "4.2.0", date: "2015-10-12", lts: "Argon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Argon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: !1, v8: "4.5.103.37" }, { name: "nodejs", version: "4.6.0", date: "2016-09-27", lts: "Argon", security: !0, v8: "4.5.103.37" }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: !1, v8: "4.5.103.43" }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: !1, v8: "4.5.103.45" }, { name: "nodejs", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: !0, v8: "4.5.103.53" }, { name: "nodejs", version: "5.0.0", date: "2015-10-29", lts: !1, security: !1, v8: "4.6.85.28" }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.3.0", date: "2015-12-15", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.6.0", date: "2016-02-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.9.0", date: "2016-03-16", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.12.0", date: "2016-06-23", lts: !1, security: !1, v8: "4.6.85.32" }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: !1, security: !1, v8: "5.0.71.35" }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: !1, security: !1, v8: "5.0.71.35" }, { name: "nodejs", version: "6.2.0", date: "2016-05-17", lts: !1, security: !1, v8: "5.0.71.47" }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: !1, security: !1, v8: "5.0.71.52" }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: !1, security: !1, v8: "5.0.71.60" }, { name: "nodejs", version: "6.5.0", date: "2016-08-26", lts: !1, security: !1, v8: "5.1.281.81" }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: !1, security: !1, v8: "5.1.281.83" }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: !1, security: !0, v8: "5.1.281.83" }, { name: "nodejs", version: "6.8.0", date: "2016-10-12", lts: !1, security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron", security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: !1, v8: "5.1.281.93" }, { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: !1, v8: "5.1.281.102" }, { name: "nodejs", version: "6.12.0", date: "2017-11-06", lts: "Boron", security: !1, v8: "5.1.281.108" }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Boron", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "6.16.0", date: "2018-12-26", lts: "Boron", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: !1, security: !1, v8: "5.4.500.36" }, { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: !1, security: !1, v8: "5.4.500.36" }, { name: "nodejs", version: "7.2.0", date: "2016-11-22", lts: !1, security: !1, v8: "5.4.500.43" }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: !1, security: !1, v8: "5.4.500.45" }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: !1, security: !1, v8: "5.4.500.45" }, { name: "nodejs", version: "7.5.0", date: "2017-01-31", lts: !1, security: !1, v8: "5.4.500.48" }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: !1, security: !1, v8: "5.5.372.40" }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: !1, security: !1, v8: "5.5.372.41" }, { name: "nodejs", version: "7.8.0", date: "2017-03-29", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "8.0.0", date: "2017-05-30", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "8.3.0", date: "2017-08-08", lts: !1, security: !1, v8: "6.0.286.52" }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: !1, security: !1, v8: "6.0.286.52" }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "8.6.0", date: "2017-09-26", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: !1, security: !1, v8: "6.1.534.42" }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: !1, security: !1, v8: "6.1.534.42" }, { name: "nodejs", version: "8.9.0", date: "2017-10-31", lts: "Carbon", security: !1, v8: "6.1.534.46" }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "Carbon", security: !1, v8: "6.2.414.50" }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: !0, v8: "6.2.414.50" }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: !1, v8: "6.2.414.66" }, { name: "nodejs", version: "8.13.0", date: "2018-11-20", lts: "Carbon", security: !1, v8: "6.2.414.72" }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "Carbon", security: !0, v8: "6.2.414.72" }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: !1, v8: "6.2.414.75" }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: !1, v8: "6.2.414.77" }, { name: "nodejs", version: "8.17.0", date: "2019-12-17", lts: "Carbon", security: !0, v8: "6.2.414.78" }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: !1, security: !1, v8: "6.2.414.32" }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: !1, security: !1, v8: "6.2.414.32" }, { name: "nodejs", version: "9.2.0", date: "2017-11-14", lts: !1, security: !1, v8: "6.2.414.44" }, { name: "nodejs", version: "9.3.0", date: "2017-12-12", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.6.0", date: "2018-02-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.9.0", date: "2018-03-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: !1, security: !0, v8: "6.2.414.46" }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "10.0.0", date: "2018-04-24", lts: !1, security: !1, v8: "6.6.346.24" }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: !1, security: !1, v8: "6.6.346.27" }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "10.3.0", date: "2018-05-29", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: !1, security: !1, v8: "6.7.288.43" }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "10.6.0", date: "2018-07-04", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: !1, security: !1, v8: "6.7.288.49" }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: !1, security: !1, v8: "6.7.288.49" }, { name: "nodejs", version: "10.9.0", date: "2018-08-15", lts: !1, security: !1, v8: "6.8.275.24" }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: !1, security: !1, v8: "6.8.275.30" }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.12.0", date: "2018-10-10", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.13.0", date: "2018-10-30", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.17.0", date: "2019-10-22", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.21.0", date: "2020-06-02", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "11.0.0", date: "2018-10-23", lts: !1, security: !1, v8: "7.0.276.28" }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: !1, security: !1, v8: "7.0.276.32" }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.3.0", date: "2018-11-27", lts: !1, security: !0, v8: "7.0.276.38" }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.6.0", date: "2018-12-26", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.9.0", date: "2019-01-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.12.0", date: "2019-03-14", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.13.0", date: "2019-03-28", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "12.0.0", date: "2019-04-23", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "12.3.0", date: "2019-05-21", lts: !1, security: !1, v8: "7.4.288.27" }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: !1, security: !1, v8: "7.4.288.27" }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "12.6.0", date: "2019-07-03", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "12.9.0", date: "2019-08-20", lts: !1, security: !1, v8: "7.6.303.29" }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: !1, security: !1, v8: "7.6.303.29" }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: !1, security: !1, v8: "7.7.299.11" }, { name: "nodejs", version: "12.12.0", date: "2019-10-11", lts: !1, security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.13.0", date: "2019-10-21", lts: "Erbium", security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: !0, v8: "7.7.299.13" }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: !0, v8: "7.7.299.13" }, { name: "nodejs", version: "12.16.0", date: "2020-02-11", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: !0, v8: "7.8.279.23" }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.20.0", date: "2020-11-24", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "Erbium", security: !0, v8: "7.8.279.23" }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13.1.0", date: "2019-11-05", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: !1, security: !1, v8: "7.9.317.23" }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.4.0", date: "2019-12-17", lts: !1, security: !0, v8: "7.9.317.25" }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.7.0", date: "2020-01-21", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: !1, security: !0, v8: "7.9.317.25" }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.10.0", date: "2020-03-04", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.13.0", date: "2020-04-14", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.14.0", date: "2020-04-29", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: !1, security: !1, v8: "8.1.307.30" }, { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.2.0", date: "2020-05-05", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: !1, security: !0, v8: "8.1.307.31" }, { name: "nodejs", version: "14.5.0", date: "2020-06-30", lts: !1, security: !1, v8: "8.3.110.9" }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.8.0", date: "2020-08-11", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.11.0", date: "2020-09-15", lts: !1, security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.12.0", date: "2020-09-22", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.15.0", date: "2020-10-27", lts: "Fermium", security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "Fermium", security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "14.19.0", date: "2022-02-01", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "Fermium", security: !0, v8: "8.4.371.23" }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: !1, security: !1, v8: "8.6.395.16" }, { name: "nodejs", version: "15.1.0", date: "2020-11-04", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.4.0", date: "2020-12-09", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.7.0", date: "2021-01-25", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.10.0", date: "2021-02-23", lts: !1, security: !0, v8: "8.6.395.17" }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.13.0", date: "2021-03-31", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.14.0", date: "2021-04-06", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: !1, security: !1, v8: "9.0.257.17" }, { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: !1, security: !1, v8: "9.0.257.24" }, { name: "nodejs", version: "16.2.0", date: "2021-05-19", lts: !1, security: !1, v8: "9.0.257.25" }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: !1, security: !1, v8: "9.0.257.25" }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: !1, security: !1, v8: "9.1.269.36" }, { name: "nodejs", version: "16.5.0", date: "2021-07-14", lts: !1, security: !1, v8: "9.1.269.38" }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: !1, security: !0, v8: "9.2.230.21" }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "16.8.0", date: "2021-08-25", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: !1, security: !1, v8: "9.3.345.16" }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: !1, security: !1, v8: "9.3.345.19" }, { name: "nodejs", version: "16.11.0", date: "2021-10-08", lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.12.0", date: "2021-10-20", lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "16.15.0", date: "2022-04-26", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "Gallium", security: !0, v8: "9.4.146.24" }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "16.19.0", date: "2022-12-13", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "16.20.0", date: "2023-03-28", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: !1, security: !1, v8: "9.5.172.21" }, { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: !1, security: !1, v8: "9.5.172.25" }, { name: "nodejs", version: "17.2.0", date: "2021-11-30", lts: !1, security: !1, v8: "9.6.180.14" }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.5.0", date: "2022-02-10", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.8.0", date: "2022-03-22", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "18.1.0", date: "2022-05-03", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "18.4.0", date: "2022-06-16", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: !1, security: !0, v8: "10.2.154.4" }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.7.0", date: "2022-07-26", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.8.0", date: "2022-08-24", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.11.0", date: "2022-10-13", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydrogen", security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: !1, v8: "10.2.154.23" }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: !1, v8: "10.2.154.23" }, { name: "nodejs", version: "18.15.0", date: "2023-03-05", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.16.0", date: "2023-04-12", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.17.0", date: "2023-07-18", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.18.0", date: "2023-09-18", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.19.0", date: "2023-11-29", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.20.0", date: "2024-03-26", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "19.0.0", date: "2022-10-17", lts: !1, security: !1, v8: "10.7.193.13" }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: !1, security: !1, v8: "10.7.193.20" }, { name: "nodejs", version: "19.2.0", date: "2022-11-29", lts: !1, security: !1, v8: "10.8.168.20" }, { name: "nodejs", version: "19.3.0", date: "2022-12-14", lts: !1, security: !1, v8: "10.8.168.21" }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.6.0", date: "2023-02-01", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.7.0", date: "2023-02-21", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.8.0", date: "2023-03-14", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.9.0", date: "2023-04-10", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "20.0.0", date: "2023-04-17", lts: !1, security: !1, v8: "11.3.244.4" }, { name: "nodejs", version: "20.1.0", date: "2023-05-03", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.2.0", date: "2023-05-16", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.3.0", date: "2023-06-08", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.4.0", date: "2023-07-04", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.5.0", date: "2023-07-19", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.6.0", date: "2023-08-23", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.7.0", date: "2023-09-18", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.8.0", date: "2023-09-28", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.9.0", date: "2023-10-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.10.0", date: "2023-11-22", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.11.0", date: "2024-01-09", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.12.0", date: "2024-03-26", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.13.0", date: "2024-05-07", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.14.0", date: "2024-05-28", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.15.0", date: "2024-06-20", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.16.0", date: "2024-07-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.17.0", date: "2024-08-21", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.18.0", date: "2024-10-03", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.19.0", date: "2025-03-13", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "21.0.0", date: "2023-10-17", lts: !1, security: !1, v8: "11.8.172.13" }, { name: "nodejs", version: "21.1.0", date: "2023-10-24", lts: !1, security: !1, v8: "11.8.172.15" }, { name: "nodejs", version: "21.2.0", date: "2023-11-14", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.3.0", date: "2023-11-30", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.4.0", date: "2023-12-05", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.5.0", date: "2023-12-19", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.6.0", date: "2024-01-14", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.7.0", date: "2024-03-06", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "22.0.0", date: "2024-04-24", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs", version: "22.1.0", date: "2024-05-02", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs", version: "22.2.0", date: "2024-05-15", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs", version: "22.3.0", date: "2024-06-11", lts: !1, security: !1, v8: "12.4.254.20" }, { name: "nodejs", version: "22.4.0", date: "2024-07-02", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.5.0", date: "2024-07-17", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.6.0", date: "2024-08-06", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.7.0", date: "2024-08-21", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.8.0", date: "2024-09-03", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.9.0", date: "2024-09-17", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.10.0", date: "2024-10-16", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.11.0", date: "2024-10-29", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.12.0", date: "2024-12-02", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.13.0", date: "2025-01-06", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.14.0", date: "2025-02-11", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.15.0", date: "2025-04-22", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.16.0", date: "2025-05-20", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.17.0", date: "2025-06-24", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.18.0", date: "2025-07-31", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.19.0", date: "2025-08-28", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.20.0", date: "2025-09-24", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.21.0", date: "2025-10-20", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "23.0.0", date: "2024-10-16", lts: !1, security: !1, v8: "12.9.202.26" }, { name: "nodejs", version: "23.1.0", date: "2024-10-24", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.2.0", date: "2024-11-11", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.3.0", date: "2024-11-20", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.4.0", date: "2024-12-10", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.5.0", date: "2024-12-19", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.6.0", date: "2025-01-07", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.7.0", date: "2025-01-30", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.8.0", date: "2025-02-13", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.9.0", date: "2025-02-26", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.10.0", date: "2025-03-13", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.11.0", date: "2025-04-01", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "24.0.0", date: "2025-05-06", lts: !1, security: !1, v8: "13.6.233.8" }, { name: "nodejs", version: "24.1.0", date: "2025-05-20", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.2.0", date: "2025-06-09", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.3.0", date: "2025-06-24", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.4.0", date: "2025-07-09", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.5.0", date: "2025-07-31", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.6.0", date: "2025-08-14", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.7.0", date: "2025-08-27", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.8.0", date: "2025-09-10", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.9.0", date: "2025-09-25", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.10.0", date: "2025-10-08", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.11.0", date: "2025-10-28", lts: "Krypton", security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "25.0.0", date: "2025-10-15", lts: !1, security: !1, v8: "14.1.146.11" }, { name: "nodejs", version: "25.1.0", date: "2025-10-28", lts: !1, security: !1, v8: "14.1.146.11" }];
  }
});

// ../node_modules/caniuse-lite/data/browsers.js
var require_browsers = __commonJS({
  "../node_modules/caniuse-lite/data/browsers.js"(exports, module) {
    module.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
  }
});

// ../node_modules/caniuse-lite/dist/unpacker/browsers.js
var require_browsers2 = __commonJS({
  "../node_modules/caniuse-lite/dist/unpacker/browsers.js"(exports, module) {
    module.exports.browsers = require_browsers();
  }
});

// ../node_modules/caniuse-lite/data/browserVersions.js
var require_browserVersions = __commonJS({
  "../node_modules/caniuse-lite/data/browserVersions.js"(exports, module) {
    module.exports = { 0: "117", 1: "118", 2: "119", 3: "120", 4: "121", 5: "122", 6: "20", 7: "21", 8: "22", 9: "23", A: "10", B: "11", C: "12", D: "7", E: "8", F: "9", G: "15", H: "80", I: "142", J: "4", K: "6", L: "13", M: "14", N: "16", O: "17", P: "18", Q: "79", R: "81", S: "83", T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "107", r: "108", s: "109", t: "110", u: "111", v: "112", w: "113", x: "114", y: "115", z: "116", AB: "24", BB: "25", CB: "26", DB: "27", EB: "28", FB: "29", GB: "123", HB: "124", IB: "125", JB: "126", KB: "127", LB: "128", MB: "129", NB: "130", OB: "131", PB: "132", QB: "133", RB: "134", SB: "135", TB: "136", UB: "137", VB: "138", WB: "139", XB: "140", YB: "141", ZB: "5", aB: "19", bB: "30", cB: "31", dB: "32", eB: "33", fB: "34", gB: "35", hB: "36", iB: "37", jB: "38", kB: "39", lB: "40", mB: "41", nB: "42", oB: "43", pB: "44", qB: "45", rB: "46", sB: "47", tB: "48", uB: "49", vB: "50", wB: "51", xB: "52", yB: "53", zB: "54", "0B": "55", "1B": "56", "2B": "57", "3B": "58", "4B": "60", "5B": "62", "6B": "63", "7B": "64", "8B": "65", "9B": "66", AC: "67", BC: "68", CC: "69", DC: "70", EC: "71", FC: "72", GC: "73", HC: "74", IC: "75", JC: "76", KC: "77", LC: "78", MC: "144", NC: "11.1", OC: "12.1", PC: "15.5", QC: "16.0", RC: "17.0", SC: "18.0", TC: "3", UC: "59", VC: "61", WC: "82", XC: "143", YC: "145", ZC: "3.2", aC: "10.1", bC: "15.2-15.3", cC: "15.4", dC: "16.1", eC: "16.2", fC: "16.3", gC: "16.4", hC: "16.5", iC: "17.1", jC: "17.2", kC: "17.3", lC: "17.4", mC: "17.5", nC: "18.1", oC: "18.2", pC: "18.3", qC: "18.4", rC: "18.5-18.6", sC: "26.0", tC: "26.1", uC: "11.5", vC: "4.2-4.3", wC: "5.5", xC: "2", yC: "146", zC: "147", "0C": "148", "1C": "3.5", "2C": "3.6", "3C": "3.1", "4C": "5.1", "5C": "6.1", "6C": "7.1", "7C": "9.1", "8C": "13.1", "9C": "14.1", AD: "15.1", BD: "15.6", CD: "16.6", DD: "17.6", ED: "26.2", FD: "TP", GD: "9.5-9.6", HD: "10.0-10.1", ID: "10.5", JD: "10.6", KD: "11.6", LD: "4.0-4.1", MD: "5.0-5.1", ND: "6.0-6.1", OD: "7.0-7.1", PD: "8.1-8.4", QD: "9.0-9.2", RD: "9.3", SD: "10.0-10.2", TD: "10.3", UD: "11.0-11.2", VD: "11.3-11.4", WD: "12.0-12.1", XD: "12.2-12.5", YD: "13.0-13.1", ZD: "13.2", aD: "13.3", bD: "13.4-13.7", cD: "14.0-14.4", dD: "14.5-14.8", eD: "15.0-15.1", fD: "15.6-15.8", gD: "16.6-16.7", hD: "17.6-17.7", iD: "all", jD: "2.1", kD: "2.2", lD: "2.3", mD: "4.1", nD: "4.4", oD: "4.4.3-4.4.4", pD: "5.0-5.4", qD: "6.2-6.4", rD: "7.2-7.4", sD: "8.2", tD: "9.2", uD: "11.1-11.2", vD: "12.0", wD: "13.0", xD: "14.0", yD: "15.0", zD: "19.0", "0D": "14.9", "1D": "13.52", "2D": "2.5", "3D": "3.0-3.1" };
  }
});

// ../node_modules/caniuse-lite/dist/unpacker/browserVersions.js
var require_browserVersions2 = __commonJS({
  "../node_modules/caniuse-lite/dist/unpacker/browserVersions.js"(exports, module) {
    module.exports.browserVersions = require_browserVersions();
  }
});

// ../node_modules/caniuse-lite/data/agents.js
var require_agents = __commonJS({
  "../node_modules/caniuse-lite/data/agents.js"(exports, module) {
    module.exports = { A: { A: { K: 0, D: 0, E: 0.0216515, F: 0.0649546, A: 0, B: 0.28147, wC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "wC", "K", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { wC: 962323200, K: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { 0: 0, 1: 0, 2: 0, 3: 0.029844, 4: 0.019896, 5: 0.014922, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, Q: 0, H: 0, R: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 9948e-6, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 0.034818, t: 0, u: 0, v: 0, w: 0, x: 0.019896, y: 0, z: 0, GB: 0, HB: 0, IB: 0, JB: 9948e-6, KB: 4974e-6, LB: 4974e-6, MB: 4974e-6, NB: 4974e-6, OB: 0.019896, PB: 9948e-6, QB: 9948e-6, RB: 0.02487, SB: 0.014922, TB: 0.014922, UB: 0.014922, VB: 0.034818, WB: 0.054714, XB: 0.731178, YB: 3.18336, I: 9948e-6 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "L", "M", "G", "N", "O", "P", "Q", "H", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "I", "", "", ""], E: "Edge", F: { 0: 1694649600, 1: 1697155200, 2: 1698969600, 3: 1701993600, 4: 1706227200, 5: 1708732800, C: 1438128e3, L: 1447286400, M: 1470096e3, G: 1491868800, N: 1508198400, O: 1525046400, P: 1542067200, Q: 1579046400, H: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600, o: 1661990400, p: 1664755200, q: 1666915200, r: 1670198400, s: 1673481600, t: 1675900800, u: 1678665600, v: 1680825600, w: 1683158400, x: 1685664e3, y: 1689897600, z: 1692576e3, GB: 1711152e3, HB: 1713398400, IB: 1715990400, JB: 1718841600, KB: 1721865600, LB: 1724371200, MB: 1726704e3, NB: 1729123200, OB: 1731542400, PB: 1737417600, QB: 1740614400, RB: 1741219200, SB: 1743984e3, TB: 1746316800, UB: 1748476800, VB: 1750896e3, WB: 1754611200, XB: 1756944e3, YB: 1759363200, I: 1761868800 }, D: { C: "ms", L: "ms", M: "ms", G: "ms", N: "ms", O: "ms", P: "ms" } }, C: { A: { 0: 0, 1: 0.104454, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, xC: 0, TC: 0, J: 0, ZB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0.029844, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, aB: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0.094506, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 9948e-6, yB: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, UC: 0, "4B": 0, VC: 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0, AC: 0, BC: 0, CC: 0, DC: 0, EC: 0, FC: 0, GC: 0, HC: 0, IC: 0, JC: 0, KC: 0, LC: 4974e-6, Q: 0, H: 0, R: 0, WC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 0, t: 0, u: 0, v: 0, w: 0, x: 0, y: 0.139272, z: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0.044766, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0.054714, RB: 4974e-6, SB: 9948e-6, TB: 9948e-6, UB: 9948e-6, VB: 4974e-6, WB: 4974e-6, XB: 0.04974, YB: 0.014922, I: 0.034818, XC: 0.651594, MC: 0.57201, YC: 0, yC: 0, zC: 0, "0C": 0, "1C": 0, "2C": 0 }, B: "moz", C: ["xC", "TC", "1C", "2C", "J", "ZB", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "aB", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "UC", "4B", "VC", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "KC", "LC", "Q", "H", "R", "WC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "I", "XC", "MC", "YC", "yC", "zC", "0C"], E: "Firefox", F: { 0: 1693267200, 1: 1695686400, 2: 1698105600, 3: 1700524800, 4: 1702944e3, 5: 1705968e3, 6: 1361232e3, 7: 1364860800, 8: 1368489600, 9: 1372118400, xC: 1161648e3, TC: 1213660800, "1C": 124632e4, "2C": 1264032e3, J: 1300752e3, ZB: 1308614400, K: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, L: 1335225600, M: 1338854400, G: 1342483200, N: 1346112e3, O: 1349740800, P: 1353628800, aB: 1357603200, AB: 1375747200, BB: 1379376e3, CB: 1386633600, DB: 1391472e3, EB: 1395100800, FB: 1398729600, bB: 1402358400, cB: 1405987200, dB: 1409616e3, eB: 1413244800, fB: 1417392e3, gB: 1421107200, hB: 1424736e3, iB: 1428278400, jB: 1431475200, kB: 1435881600, lB: 1439251200, mB: 144288e4, nB: 1446508800, oB: 1450137600, pB: 1453852800, qB: 1457395200, rB: 1461628800, sB: 1465257600, tB: 1470096e3, uB: 1474329600, vB: 1479168e3, wB: 1485216e3, xB: 1488844800, yB: 149256e4, zB: 1497312e3, "0B": 1502150400, "1B": 1506556800, "2B": 1510617600, "3B": 1516665600, UC: 1520985600, "4B": 1525824e3, VC: 1529971200, "5B": 1536105600, "6B": 1540252800, "7B": 1544486400, "8B": 154872e4, "9B": 1552953600, AC: 1558396800, BC: 1562630400, CC: 1567468800, DC: 1571788800, EC: 1575331200, FC: 1578355200, GC: 1581379200, HC: 1583798400, IC: 1586304e3, JC: 1588636800, KC: 1591056e3, LC: 1593475200, Q: 1595894400, H: 1598313600, R: 1600732800, WC: 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200, l: 1656374400, m: 1658793600, n: 1661212800, o: 1663632e3, p: 1666051200, q: 1668470400, r: 1670889600, s: 1673913600, t: 1676332800, u: 1678752e3, v: 1681171200, w: 1683590400, x: 1686009600, y: 1688428800, z: 1690848e3, GB: 1708387200, HB: 1710806400, IB: 1713225600, JB: 1715644800, KB: 1718064e3, LB: 1720483200, MB: 1722902400, NB: 1725321600, OB: 1727740800, PB: 173016e4, QB: 1732579200, RB: 1736208e3, SB: 1738627200, TB: 1741046400, UB: 1743465600, VB: 1745884800, WB: 1748304e3, XB: 1750723200, YB: 1753142400, I: 1755561600, XC: 1757980800, MC: 17604e5, YC: 1762819200, yC: null, zC: null, "0C": null } }, D: { A: { 0: 0.089532, 1: 0.144246, 2: 0.039792, 3: 0.09948, 4: 0.094506, 5: 0.114402, 6: 0, 7: 0, 8: 0, 9: 0, J: 0, ZB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, aB: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 4974e-6, lB: 4974e-6, mB: 9948e-6, nB: 4974e-6, oB: 4974e-6, pB: 4974e-6, qB: 9948e-6, rB: 4974e-6, sB: 9948e-6, tB: 0.014922, uB: 0.014922, vB: 4974e-6, wB: 4974e-6, xB: 9948e-6, yB: 9948e-6, zB: 4974e-6, "0B": 9948e-6, "1B": 9948e-6, "2B": 9948e-6, "3B": 9948e-6, UC: 4974e-6, "4B": 4974e-6, VC: 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0.014922, AC: 0, BC: 0, CC: 9948e-6, DC: 0.014922, EC: 0, FC: 0, GC: 0, HC: 0, IC: 0, JC: 0, KC: 0.019896, LC: 0, Q: 0.064662, H: 4974e-6, R: 0.039792, S: 0.039792, T: 0, U: 4974e-6, V: 9948e-6, W: 0.029844, X: 4974e-6, Y: 0, Z: 0, a: 0.019896, b: 0.019896, c: 9948e-6, d: 0, e: 0, f: 0, g: 9948e-6, h: 0.039792, i: 0.014922, j: 4974e-6, k: 9948e-6, l: 9948e-6, m: 0.069636, n: 0.029844, o: 0.154194, p: 0.034818, q: 0.014922, r: 0.019896, s: 0.586932, t: 0.114402, u: 0.07461, v: 2.08908, w: 0.04974, x: 0.179064, y: 0.014922, z: 0.054714, GB: 0.054714, HB: 0.059688, IB: 3.33755, JB: 6.13792, KB: 0.07461, LB: 0.114402, MB: 0.084558, NB: 1.33303, OB: 0.159168, PB: 0.094506, QB: 0.054714, RB: 2.59643, SB: 0.064662, TB: 0.079584, UB: 0.253674, VB: 0.437712, WB: 0.681438, XB: 4.47163, YB: 9.4506, I: 0.134298, XC: 9948e-6, MC: 0, YC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "J", "ZB", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "aB", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "UC", "4B", "VC", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "KC", "LC", "Q", "H", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "I", "XC", "MC", "YC"], E: "Chrome", F: { 0: 1694476800, 1: 1696896e3, 2: 1698710400, 3: 1701993600, 4: 1705968e3, 5: 1708387200, 6: 133704e4, 7: 1340668800, 8: 1343692800, 9: 1348531200, J: 1264377600, ZB: 1274745600, K: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, L: 1312243200, M: 1316131200, G: 1316131200, N: 1319500800, O: 1323734400, P: 1328659200, aB: 1332892800, AB: 1352246400, BB: 1357862400, CB: 1361404800, DB: 1364428800, EB: 1369094400, FB: 1374105600, bB: 1376956800, cB: 1384214400, dB: 1389657600, eB: 1392940800, fB: 1397001600, gB: 1400544e3, hB: 1405468800, iB: 1409011200, jB: 141264e4, kB: 1416268800, lB: 1421798400, mB: 1425513600, nB: 1429401600, oB: 143208e4, pB: 1437523200, qB: 1441152e3, rB: 1444780800, sB: 1449014400, tB: 1453248e3, uB: 1456963200, vB: 1460592e3, wB: 1464134400, xB: 1469059200, yB: 1472601600, zB: 1476230400, "0B": 1480550400, "1B": 1485302400, "2B": 1489017600, "3B": 149256e4, UC: 1496707200, "4B": 1500940800, VC: 1504569600, "5B": 1508198400, "6B": 1512518400, "7B": 1516752e3, "8B": 1520294400, "9B": 1523923200, AC: 1527552e3, BC: 1532390400, CC: 1536019200, DC: 1539648e3, EC: 1543968e3, FC: 154872e4, GC: 1552348800, HC: 1555977600, IC: 1559606400, JC: 1564444800, KC: 1568073600, LC: 1571702400, Q: 1575936e3, H: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, q: 1666656e3, r: 166968e4, s: 1673308800, t: 1675728e3, u: 1678147200, v: 1680566400, w: 1682985600, x: 1685404800, y: 1689724800, z: 1692057600, GB: 1710806400, HB: 1713225600, IB: 1715644800, JB: 1718064e3, KB: 1721174400, LB: 1724112e3, MB: 1726531200, NB: 1728950400, OB: 1731369600, PB: 1736812800, QB: 1738627200, RB: 1741046400, SB: 1743465600, TB: 1745884800, UB: 1748304e3, VB: 1750723200, WB: 1754352e3, XB: 1756771200, YB: 1759190400, I: 1761609600, XC: null, MC: null, YC: null } }, E: { A: { J: 0, ZB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, L: 0, M: 9948e-6, G: 0, "3C": 0, ZC: 0, "4C": 0, "5C": 0, "6C": 0, "7C": 0, aC: 0, NC: 0, OC: 0, "8C": 0.019896, "9C": 0.02487, AD: 0.014922, bC: 0, cC: 4974e-6, PC: 4974e-6, BD: 0.084558, QC: 0, dC: 9948e-6, eC: 9948e-6, fC: 0.019896, gC: 9948e-6, hC: 9948e-6, CD: 0.12435, RC: 4974e-6, iC: 0.089532, jC: 9948e-6, kC: 9948e-6, lC: 0.019896, mC: 0.034818, DD: 0.12435, SC: 0.014922, nC: 0.02487, oC: 0.014922, pC: 0.04974, qC: 0.029844, rC: 0.114402, sC: 0.308388, tC: 9948e-6, ED: 0, FD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "3C", "ZC", "J", "ZB", "4C", "K", "5C", "D", "6C", "E", "F", "7C", "A", "aC", "B", "NC", "C", "OC", "L", "8C", "M", "9C", "G", "AD", "bC", "cC", "PC", "BD", "QC", "dC", "eC", "fC", "gC", "hC", "CD", "RC", "iC", "jC", "kC", "lC", "mC", "DD", "SC", "nC", "oC", "pC", "qC", "rC", "sC", "tC", "ED", "FD", ""], E: "Safari", F: { "3C": 1205798400, ZC: 1226534400, J: 1244419200, ZB: 1275868800, "4C": 131112e4, K: 1343174400, "5C": 13824e5, D: 13824e5, "6C": 1410998400, E: 1413417600, F: 1443657600, "7C": 1458518400, A: 1474329600, aC: 1490572800, B: 1505779200, NC: 1522281600, C: 1537142400, OC: 1553472e3, L: 1568851200, "8C": 1585008e3, M: 1600214400, "9C": 1619395200, G: 1632096e3, AD: 1635292800, bC: 1639353600, cC: 1647216e3, PC: 1652745600, BD: 1658275200, QC: 1662940800, dC: 1666569600, eC: 1670889600, fC: 1674432e3, gC: 1679875200, hC: 1684368e3, CD: 1690156800, RC: 1695686400, iC: 1698192e3, jC: 1702252800, kC: 1705881600, lC: 1709596800, mC: 1715558400, DD: 1722211200, SC: 1726444800, nC: 1730073600, oC: 1733875200, pC: 1737936e3, qC: 1743379200, rC: 1747008e3, sC: 1757894400, tC: 1762128e3, ED: null, FD: null } }, F: { A: { 0: 0, 1: 0, 2: 0, 3: 0.069636, 4: 0.084558, 5: 0.701334, 6: 0, 7: 0, 8: 0, 9: 0, F: 0, B: 0, C: 0, G: 0, N: 0, O: 0, P: 0, aB: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0, AC: 0, BC: 0, CC: 0, DC: 0, EC: 0, FC: 0, GC: 0, HC: 0, IC: 0, JC: 0, KC: 0, LC: 0, Q: 0, H: 0, R: 0, WC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0.02487, b: 0.044766, c: 0, d: 0, e: 0.02487, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 0, t: 0, u: 0, v: 0, w: 0, x: 0, y: 0, z: 0, GD: 0, HD: 0, ID: 0, JD: 0, NC: 0, uC: 0, KD: 0, OC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "GD", "HD", "ID", "JD", "B", "NC", "uC", "KD", "C", "OC", "G", "N", "O", "P", "aB", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "KC", "LC", "Q", "H", "R", "WC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "", "", ""], E: "Opera", F: { 0: 1739404800, 1: 1744675200, 2: 1747094400, 3: 1751414400, 4: 1756339200, 5: 1757548800, 6: 1393891200, 7: 1399334400, 8: 1401753600, 9: 1405987200, F: 1150761600, GD: 1223424e3, HD: 1251763200, ID: 1267488e3, JD: 1277942400, B: 1292457600, NC: 1302566400, uC: 1309219200, KD: 1323129600, C: 1323129600, OC: 1352073600, G: 1372723200, N: 1377561600, O: 1381104e3, P: 1386288e3, aB: 1390867200, AB: 1409616e3, BB: 1413331200, CB: 1417132800, DB: 1422316800, EB: 1425945600, FB: 1430179200, bB: 1433808e3, cB: 1438646400, dB: 1442448e3, eB: 1445904e3, fB: 1449100800, gB: 1454371200, hB: 1457308800, iB: 146232e4, jB: 1465344e3, kB: 1470096e3, lB: 1474329600, mB: 1477267200, nB: 1481587200, oB: 1486425600, pB: 1490054400, qB: 1494374400, rB: 1498003200, sB: 1502236800, tB: 1506470400, uB: 1510099200, vB: 1515024e3, wB: 1517961600, xB: 1521676800, yB: 1525910400, zB: 1530144e3, "0B": 1534982400, "1B": 1537833600, "2B": 1543363200, "3B": 1548201600, "4B": 1554768e3, "5B": 1561593600, "6B": 1566259200, "7B": 1570406400, "8B": 1573689600, "9B": 1578441600, AC: 1583971200, BC: 1587513600, CC: 1592956800, DC: 1595894400, EC: 1600128e3, FC: 1603238400, GC: 161352e4, HC: 1612224e3, IC: 1616544e3, JC: 1619568e3, KC: 1623715200, LC: 1627948800, Q: 1631577600, H: 1633392e3, R: 1635984e3, WC: 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800, n: 169992e4, o: 169992e4, p: 1702944e3, q: 1707264e3, r: 1710115200, s: 1711497600, t: 1716336e3, u: 1719273600, v: 1721088e3, w: 1724284800, x: 1727222400, y: 1732665600, z: 1736294400 }, D: { F: "o", B: "o", C: "o", GD: "o", HD: "o", ID: "o", JD: "o", NC: "o", uC: "o", KD: "o", OC: "o" } }, G: { A: { E: 0, ZC: 0, LD: 0, vC: 108483e-8, MD: 0, ND: 433931e-8, OD: 325448e-8, PD: 0, QD: 0, RD: 976344e-8, SD: 108483e-8, TD: 0.0184421, UD: 0.273376, VD: 650896e-8, WD: 216965e-8, XD: 0.0531565, YD: 0, ZD: 542413e-8, aD: 216965e-8, bD: 867861e-8, cD: 0.0184421, dD: 0.0195269, eD: 0.0184421, bC: 0.0141027, cC: 0.0162724, PC: 0.0184421, fD: 0.240832, QC: 0.0325448, dC: 0.0607503, eC: 0.03146, fC: 0.056411, gC: 0.0141027, hC: 0.024951, gD: 0.322194, RC: 0.0227814, iC: 0.0347145, jC: 0.024951, kC: 0.0368841, lC: 0.0650896, mC: 0.111737, hD: 0.28097, SC: 0.0640048, nC: 0.132349, oC: 0.0715986, pC: 0.229983, qC: 0.118246, rC: 6.02947, sC: 0.744191, tC: 0.0271207 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "ZC", "LD", "vC", "MD", "ND", "OD", "E", "PD", "QD", "RD", "SD", "TD", "UD", "VD", "WD", "XD", "YD", "ZD", "aD", "bD", "cD", "dD", "eD", "bC", "cC", "PC", "fD", "QC", "dC", "eC", "fC", "gC", "hC", "gD", "RC", "iC", "jC", "kC", "lC", "mC", "hD", "SC", "nC", "oC", "pC", "qC", "rC", "sC", "tC", "", ""], E: "Safari on iOS", F: { ZC: 1270252800, LD: 1283904e3, vC: 1299628800, MD: 1331078400, ND: 1359331200, OD: 1394409600, E: 1410912e3, PD: 1413763200, QD: 1442361600, RD: 1458518400, SD: 1473724800, TD: 1490572800, UD: 1505779200, VD: 1522281600, WD: 1537142400, XD: 1553472e3, YD: 1568851200, ZD: 1572220800, aD: 1580169600, bD: 1585008e3, cD: 1600214400, dD: 1619395200, eD: 1632096e3, bC: 1639353600, cC: 1647216e3, PC: 1652659200, fD: 1658275200, QC: 1662940800, dC: 1666569600, eC: 1670889600, fC: 1674432e3, gC: 1679875200, hC: 1684368e3, gD: 1690156800, RC: 1694995200, iC: 1698192e3, jC: 1702252800, kC: 1705881600, lC: 1709596800, mC: 1715558400, hD: 1722211200, SC: 1726444800, nC: 1730073600, oC: 1733875200, pC: 1737936e3, qC: 1743379200, rC: 1747008e3, sC: 1757894400, tC: null } }, H: { A: { iD: 0.03 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "iD", "", "", ""], E: "Opera Mini", F: { iD: 1426464e3 } }, I: { A: { TC: 0, J: 0, I: 0.486936, jD: 0, kD: 0, lD: 0, mD: 0, vC: 975238e-10, nD: 0, oD: 243809e-9 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "jD", "kD", "lD", "TC", "J", "mD", "vC", "nD", "oD", "I", "", "", ""], E: "Android Browser", F: { jD: 1256515200, kD: 1274313600, lD: 1291593600, TC: 1298332800, J: 1318896e3, mD: 1341792e3, vC: 1374624e3, nD: 1386547200, oD: 1401667200, I: 1761609600 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, H: 0.739131, NC: 0, uC: 0, OC: 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "NC", "uC", "C", "OC", "H", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, NC: 1314835200, uC: 1318291200, C: 1330300800, OC: 1349740800, H: 1709769600 }, D: { H: "webkit" } }, L: { A: { I: 39.0274 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "", "", ""], E: "Chrome for Android", F: { I: 1761609600 } }, M: { A: { MC: 0.291566 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "MC", "", "", ""], E: "Firefox for Android", F: { MC: 17604e5 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { PC: 0.547943 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "PC", "", "", ""], E: "UC Browser for Android", F: { PC: 1710115200 }, D: { PC: "webkit" } }, P: { A: { 6: 0, 7: 0.0108816, 8: 0.0108816, 9: 0.0217632, J: 0, AB: 0.0217632, BB: 0.0217632, CB: 0.0435265, DB: 0.0544081, EB: 1.4799, FB: 0.119698, pD: 0, qD: 0, rD: 0, sD: 0, tD: 0, aC: 0, uD: 0, vD: 0, wD: 0, xD: 0, yD: 0, QC: 0, RC: 0, SC: 0, zD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "J", "pD", "qD", "rD", "sD", "tD", "aC", "uD", "vD", "wD", "xD", "yD", "QC", "RC", "SC", "zD", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "", "", ""], E: "Samsung Internet", F: { 6: 1677369600, 7: 1684454400, 8: 1689292800, 9: 1697587200, J: 1461024e3, pD: 1481846400, qD: 1509408e3, rD: 1528329600, sD: 1546128e3, tD: 1554163200, aC: 1567900800, uD: 1582588800, vD: 1593475200, wD: 1605657600, xD: 1618531200, yD: 1629072e3, QC: 1640736e3, RC: 1651708800, SC: 1659657600, zD: 1667260800, AB: 1711497600, BB: 1715126400, CB: 1717718400, DB: 1725667200, EB: 1746057600, FB: 1761264e3 } }, Q: { A: { "0D": 0.135729 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0D", "", "", ""], E: "QQ Browser", F: { "0D": 1710288e3 } }, R: { A: { "1D": 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "1D", "", "", ""], E: "Baidu Browser", F: { "1D": 1710201600 } }, S: { A: { "2D": 0.015081, "3D": 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "2D", "3D", "", "", ""], E: "KaiOS Browser", F: { "2D": 1527811200, "3D": 1631664e3 } } };
  }
});

// ../node_modules/caniuse-lite/dist/unpacker/agents.js
var require_agents2 = __commonJS({
  "../node_modules/caniuse-lite/dist/unpacker/agents.js"(exports, module) {
    "use strict";
    var browsers = require_browsers2().browsers, versions = require_browserVersions2().browserVersions, agentsData = require_agents();
    function unpackBrowserVersions(versionsData) {
      return Object.keys(versionsData).reduce((usage, version) => (usage[versions[version]] = versionsData[version], usage), {});
    }
    module.exports.agents = Object.keys(agentsData).reduce((map, key) => {
      let versionsData = agentsData[key];
      return map[browsers[key]] = Object.keys(versionsData).reduce((data, entry) => (entry === "A" ? data.usage_global = unpackBrowserVersions(versionsData[entry]) : entry === "C" ? data.versions = versionsData[entry].reduce((list, version) => (version === "" ? list.push(null) : list.push(versions[version]), list), []) : entry === "D" ? data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]) : entry === "E" ? data.browser = versionsData[entry] : entry === "F" ? data.release_date = Object.keys(versionsData[entry]).reduce(
        (map2, key2) => (map2[versions[key2]] = versionsData[entry][key2], map2),
        {}
      ) : data.prefix = versionsData[entry], data), {}), map;
    }, {});
  }
});

// ../node_modules/electron-to-chromium/versions.js
var require_versions = __commonJS({
  "../node_modules/electron-to-chromium/versions.js"(exports, module) {
    module.exports = {
      "0.20": "39",
      "0.21": "41",
      "0.22": "41",
      "0.23": "41",
      "0.24": "41",
      "0.25": "42",
      "0.26": "42",
      "0.27": "43",
      "0.28": "43",
      "0.29": "43",
      "0.30": "44",
      "0.31": "45",
      "0.32": "45",
      "0.33": "45",
      "0.34": "45",
      "0.35": "45",
      "0.36": "47",
      "0.37": "49",
      "1.0": "49",
      "1.1": "50",
      "1.2": "51",
      "1.3": "52",
      "1.4": "53",
      "1.5": "54",
      "1.6": "56",
      "1.7": "58",
      "1.8": "59",
      "2.0": "61",
      "2.1": "61",
      "3.0": "66",
      "3.1": "66",
      "4.0": "69",
      "4.1": "69",
      "4.2": "69",
      "5.0": "73",
      "6.0": "76",
      "6.1": "76",
      "7.0": "78",
      "7.1": "78",
      "7.2": "78",
      "7.3": "78",
      "8.0": "80",
      "8.1": "80",
      "8.2": "80",
      "8.3": "80",
      "8.4": "80",
      "8.5": "80",
      "9.0": "83",
      "9.1": "83",
      "9.2": "83",
      "9.3": "83",
      "9.4": "83",
      "10.0": "85",
      "10.1": "85",
      "10.2": "85",
      "10.3": "85",
      "10.4": "85",
      "11.0": "87",
      "11.1": "87",
      "11.2": "87",
      "11.3": "87",
      "11.4": "87",
      "11.5": "87",
      "12.0": "89",
      "12.1": "89",
      "12.2": "89",
      "13.0": "91",
      "13.1": "91",
      "13.2": "91",
      "13.3": "91",
      "13.4": "91",
      "13.5": "91",
      "13.6": "91",
      "14.0": "93",
      "14.1": "93",
      "14.2": "93",
      "15.0": "94",
      "15.1": "94",
      "15.2": "94",
      "15.3": "94",
      "15.4": "94",
      "15.5": "94",
      "16.0": "96",
      "16.1": "96",
      "16.2": "96",
      "17.0": "98",
      "17.1": "98",
      "17.2": "98",
      "17.3": "98",
      "17.4": "98",
      "18.0": "100",
      "18.1": "100",
      "18.2": "100",
      "18.3": "100",
      "19.0": "102",
      "19.1": "102",
      "20.0": "104",
      "20.1": "104",
      "20.2": "104",
      "20.3": "104",
      "21.0": "106",
      "21.1": "106",
      "21.2": "106",
      "21.3": "106",
      "21.4": "106",
      "22.0": "108",
      "22.1": "108",
      "22.2": "108",
      "22.3": "108",
      "23.0": "110",
      "23.1": "110",
      "23.2": "110",
      "23.3": "110",
      "24.0": "112",
      "24.1": "112",
      "24.2": "112",
      "24.3": "112",
      "24.4": "112",
      "24.5": "112",
      "24.6": "112",
      "24.7": "112",
      "24.8": "112",
      "25.0": "114",
      "25.1": "114",
      "25.2": "114",
      "25.3": "114",
      "25.4": "114",
      "25.5": "114",
      "25.6": "114",
      "25.7": "114",
      "25.8": "114",
      "25.9": "114",
      "26.0": "116",
      "26.1": "116",
      "26.2": "116",
      "26.3": "116",
      "26.4": "116",
      "26.5": "116",
      "26.6": "116",
      "27.0": "118",
      "27.1": "118",
      "27.2": "118",
      "27.3": "118",
      "28.0": "120",
      "28.1": "120",
      "28.2": "120",
      "28.3": "120",
      "29.0": "122",
      "29.1": "122",
      "29.2": "122",
      "29.3": "122",
      "29.4": "122",
      "30.0": "124",
      "30.1": "124",
      "30.2": "124",
      "30.3": "124",
      "30.4": "124",
      "30.5": "124",
      "31.0": "126",
      "31.1": "126",
      "31.2": "126",
      "31.3": "126",
      "31.4": "126",
      "31.5": "126",
      "31.6": "126",
      "31.7": "126",
      "32.0": "128",
      "32.1": "128",
      "32.2": "128",
      "32.3": "128",
      "33.0": "130",
      "33.1": "130",
      "33.2": "130",
      "33.3": "130",
      "33.4": "130",
      "34.0": "132",
      "34.1": "132",
      "34.2": "132",
      "34.3": "132",
      "34.4": "132",
      "34.5": "132",
      "35.0": "134",
      "35.1": "134",
      "35.2": "134",
      "35.3": "134",
      "35.4": "134",
      "35.5": "134",
      "35.6": "134",
      "35.7": "134",
      "36.0": "136",
      "36.1": "136",
      "36.2": "136",
      "36.3": "136",
      "36.4": "136",
      "36.5": "136",
      "36.6": "136",
      "36.7": "136",
      "36.8": "136",
      "36.9": "136",
      "37.0": "138",
      "37.1": "138",
      "37.2": "138",
      "37.3": "138",
      "37.4": "138",
      "37.5": "138",
      "37.6": "138",
      "37.7": "138",
      "37.8": "138",
      "37.9": "138",
      "37.10": "138",
      "38.0": "140",
      "38.1": "140",
      "38.2": "140",
      "38.3": "140",
      "38.4": "140",
      "38.5": "140",
      "38.6": "140",
      "38.7": "140",
      "39.0": "142",
      "39.1": "142",
      "39.2": "142",
      "40.0": "144"
    };
  }
});

// ../node_modules/node-releases/data/release-schedule/release-schedule.json
var require_release_schedule = __commonJS({
  "../node_modules/node-releases/data/release-schedule/release-schedule.json"(exports, module) {
    module.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Argon" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Dubnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Gallium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "Iron" }, v21: { start: "2023-10-17", maintenance: "2024-04-01", end: "2024-06-01" }, v22: { start: "2024-04-24", lts: "2024-10-29", maintenance: "2025-10-21", end: "2027-04-30", codename: "Jod" }, v23: { start: "2024-10-16", maintenance: "2025-04-01", end: "2025-06-01" }, v24: { start: "2025-05-06", lts: "2025-10-28", maintenance: "2026-10-20", end: "2028-04-30", codename: "Krypton" }, v25: { start: "2025-10-15", maintenance: "2026-04-01", end: "2026-06-01" }, v26: { start: "2026-04-22", lts: "2026-10-28", maintenance: "2027-10-20", end: "2029-04-30", codename: "" } };
  }
});

// ../node_modules/browserslist/error.js
var require_error = __commonJS({
  "../node_modules/browserslist/error.js"(exports, module) {
    function BrowserslistError(message) {
      this.name = "BrowserslistError", this.message = message, this.browserslist = !0, Error.captureStackTrace && Error.captureStackTrace(this, BrowserslistError);
    }
    BrowserslistError.prototype = Error.prototype;
    module.exports = BrowserslistError;
  }
});

// ../node_modules/caniuse-lite/dist/lib/statuses.js
var require_statuses = __commonJS({
  "../node_modules/caniuse-lite/dist/lib/statuses.js"(exports, module) {
    module.exports = {
      1: "ls",
      // WHATWG Living Standard
      2: "rec",
      // W3C Recommendation
      3: "pr",
      // W3C Proposed Recommendation
      4: "cr",
      // W3C Candidate Recommendation
      5: "wd",
      // W3C Working Draft
      6: "other",
      // Non-W3C, but reputable
      7: "unoff"
      // Unofficial, Editor's Draft or W3C "Note"
    };
  }
});

// ../node_modules/caniuse-lite/dist/lib/supported.js
var require_supported = __commonJS({
  "../node_modules/caniuse-lite/dist/lib/supported.js"(exports, module) {
    module.exports = {
      y: 1,
      n: 2,
      a: 4,
      p: 8,
      u: 16,
      x: 32,
      d: 64
    };
  }
});

// ../node_modules/caniuse-lite/dist/unpacker/feature.js
var require_feature = __commonJS({
  "../node_modules/caniuse-lite/dist/unpacker/feature.js"(exports, module) {
    "use strict";
    var statuses = require_statuses(), supported = require_supported(), browsers = require_browsers2().browsers, versions = require_browserVersions2().browserVersions, MATH2LOG = Math.log(2);
    function unpackSupport(cipher) {
      let stats = Object.keys(supported).reduce((list, support) => (cipher & supported[support] && list.push(support), list), []), notes = cipher >> 7, notesArray = [];
      for (; notes; ) {
        let note = Math.floor(Math.log(notes) / MATH2LOG) + 1;
        notesArray.unshift(`#${note}`), notes -= Math.pow(2, note - 1);
      }
      return stats.concat(notesArray).join(" ");
    }
    function unpackFeature(packed) {
      let unpacked = {
        status: statuses[packed.B],
        title: packed.C,
        shown: packed.D
      };
      return unpacked.stats = Object.keys(packed.A).reduce((browserStats, key) => {
        let browser = packed.A[key];
        return browserStats[browsers[key]] = Object.keys(browser).reduce(
          (stats, support) => {
            let packedVersions = browser[support].split(" "), unpacked2 = unpackSupport(support);
            return packedVersions.forEach((v) => stats[versions[v]] = unpacked2), stats;
          },
          {}
        ), browserStats;
      }, {}), unpacked;
    }
    module.exports = unpackFeature;
    module.exports.default = unpackFeature;
  }
});

// ../node_modules/caniuse-lite/dist/unpacker/region.js
var require_region = __commonJS({
  "../node_modules/caniuse-lite/dist/unpacker/region.js"(exports, module) {
    "use strict";
    var browsers = require_browsers2().browsers;
    function unpackRegion(packed) {
      return Object.keys(packed).reduce((list, browser) => {
        let data = packed[browser];
        return list[browsers[browser]] = Object.keys(data).reduce((memo, key) => {
          let stats = data[key];
          return key === "_" ? stats.split(" ").forEach((version) => memo[version] = null) : memo[key] = stats, memo;
        }, {}), list;
      }, {});
    }
    module.exports = unpackRegion;
    module.exports.default = unpackRegion;
  }
});

// ../node_modules/browserslist/node.js
var require_node2 = __commonJS({
  "../node_modules/browserslist/node.js"(exports, module) {
    var feature = require_feature().default, region = require_region().default, fs = __require("fs"), path = __require("path"), BrowserslistError = require_error(), IS_SECTION = /^\s*\[(.+)]\s*$/, CONFIG_PATTERN = /^browserslist-config-/, SCOPED_CONFIG__PATTERN = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/, FORMAT = "Browserslist config should be a string or an array of strings with browser queries", PATHTYPE_UNKNOWN = "unknown", PATHTYPE_DIR = "directory", PATHTYPE_FILE = "file", dataTimeChecked = !1, statCache = {}, configPathCache = {}, parseConfigCache = {};
    function checkExtend(name) {
      var use = " Use `dangerousExtend` option to disable.";
      if (!CONFIG_PATTERN.test(name) && !SCOPED_CONFIG__PATTERN.test(name))
        throw new BrowserslistError(
          "Browserslist config needs `browserslist-config-` prefix. " + use
        );
      if (name.replace(/^@[^/]+\//, "").indexOf(".") !== -1)
        throw new BrowserslistError(
          "`.` not allowed in Browserslist config name. " + use
        );
      if (name.indexOf("node_modules") !== -1)
        throw new BrowserslistError(
          "`node_modules` not allowed in Browserslist config." + use
        );
    }
    function getPathType(filepath) {
      var stats;
      try {
        stats = fs.existsSync(filepath) && fs.statSync(filepath);
      } catch (err) {
        if (err.code !== "ENOENT" && err.code !== "EACCES" && err.code !== "ERR_ACCESS_DENIED")
          throw err;
      }
      return stats && stats.isDirectory() ? PATHTYPE_DIR : stats && stats.isFile() ? PATHTYPE_FILE : PATHTYPE_UNKNOWN;
    }
    function isFile(file) {
      return getPathType(file) === PATHTYPE_FILE;
    }
    function isDirectory(dir) {
      return getPathType(dir) === PATHTYPE_DIR;
    }
    function eachParent(file, callback, cache) {
      var loc = path.resolve(file), pathsForCacheResult = [], result;
      do {
        if (!pathInRoot(loc))
          break;
        if (cache && loc in cache) {
          result = cache[loc];
          break;
        }
        if (pathsForCacheResult.push(loc), !!isDirectory(loc)) {
          var locResult = callback(loc);
          if (typeof locResult < "u") {
            result = locResult;
            break;
          }
        }
      } while (loc !== (loc = path.dirname(loc)));
      return cache && !process.env.BROWSERSLIST_DISABLE_CACHE && pathsForCacheResult.forEach(function(cachePath) {
        cache[cachePath] = result;
      }), result;
    }
    function pathInRoot(p) {
      if (!process.env.BROWSERSLIST_ROOT_PATH) return !0;
      var rootPath = path.resolve(process.env.BROWSERSLIST_ROOT_PATH);
      return path.relative(rootPath, p).substring(0, 2) !== "..";
    }
    function check(section) {
      if (Array.isArray(section)) {
        for (var i = 0; i < section.length; i++)
          if (typeof section[i] != "string")
            throw new BrowserslistError(FORMAT);
      } else if (typeof section != "string")
        throw new BrowserslistError(FORMAT);
    }
    function pickEnv(config, opts) {
      if (typeof config != "object") return config;
      var name;
      if (typeof opts.env == "string" ? name = opts.env : process.env.BROWSERSLIST_ENV ? name = process.env.BROWSERSLIST_ENV : process.env.NODE_ENV ? name = process.env.NODE_ENV : name = "production", opts.throwOnMissing && name && name !== "defaults" && !config[name])
        throw new BrowserslistError(
          "Missing config for Browserslist environment `" + name + "`"
        );
      return config[name] || config.defaults;
    }
    function parsePackage(file) {
      var text = fs.readFileSync(file).toString().replace(/^\uFEFF/m, ""), list;
      if (text.indexOf('"browserslist"') >= 0)
        list = JSON.parse(text).browserslist;
      else if (text.indexOf('"browserlist"') >= 0) {
        var config = JSON.parse(text);
        if (config.browserlist && !config.browserslist)
          throw new BrowserslistError(
            "`browserlist` key instead of `browserslist` in " + file
          );
      }
      (Array.isArray(list) || typeof list == "string") && (list = { defaults: list });
      for (var i in list)
        check(list[i]);
      return list;
    }
    function parsePackageOrReadConfig(file) {
      if (file in parseConfigCache)
        return parseConfigCache[file];
      var isPackage = path.basename(file) === "package.json", result = isPackage ? parsePackage(file) : module.exports.readConfig(file);
      return process.env.BROWSERSLIST_DISABLE_CACHE || (parseConfigCache[file] = result), result;
    }
    function latestReleaseTime(agents) {
      var latest = 0;
      for (var name in agents) {
        var dates = agents[name].releaseDate || {};
        for (var key in dates)
          latest < dates[key] && (latest = dates[key]);
      }
      return latest * 1e3;
    }
    function getMonthsPassed(date) {
      var now = /* @__PURE__ */ new Date(), past = new Date(date), years = now.getFullYear() - past.getFullYear(), months = now.getMonth() - past.getMonth();
      return years * 12 + months;
    }
    function normalizeStats(data, stats) {
      if (data || (data = {}), stats && "dataByBrowser" in stats && (stats = stats.dataByBrowser), typeof stats == "object") {
        var normalized = {};
        for (var i in stats) {
          var versions = Object.keys(stats[i]);
          if (versions.length === 1 && data[i] && data[i].versions.length === 1) {
            var normal = data[i].versions[0];
            normalized[i] = {}, normalized[i][normal] = stats[i][versions[0]];
          } else
            normalized[i] = stats[i];
        }
        return normalized;
      }
    }
    function normalizeUsageData(usageData, data) {
      for (var browser in usageData) {
        var browserUsage = usageData[browser];
        if ("0" in browserUsage) {
          var versions = data[browser].versions;
          browserUsage[versions[versions.length - 1]] = browserUsage[0], delete browserUsage[0];
        }
      }
    }
    module.exports = {
      loadQueries: function(ctx, name) {
        !ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && checkExtend(name);
        var queries = __require(__require.resolve(name, { paths: [".", ctx.path] }));
        if (typeof queries == "object" && queries !== null && queries.__esModule && (queries = queries.default), queries) {
          if (Array.isArray(queries))
            return queries;
          if (typeof queries == "object")
            return queries.defaults || (queries.defaults = []), pickEnv(queries, ctx, name);
        }
        throw new BrowserslistError(
          "`" + name + "` config exports not an array of queries or an object of envs"
        );
      },
      loadStat: function(ctx, name, data) {
        !ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && checkExtend(name);
        var stats = __require(
          // Use forward slashes for module paths, also on Windows.
          __require.resolve(path.posix.join(name, "browserslist-stats.json"), {
            paths: ["."]
          })
        );
        return normalizeStats(data, stats);
      },
      getStat: function(opts, data) {
        var stats;
        if (opts.stats ? stats = opts.stats : process.env.BROWSERSLIST_STATS ? stats = process.env.BROWSERSLIST_STATS : opts.path && path.resolve && fs.existsSync && (stats = eachParent(
          opts.path,
          function(dir) {
            var file = path.join(dir, "browserslist-stats.json");
            return isFile(file) ? file : void 0;
          },
          statCache
        )), typeof stats == "string")
          try {
            stats = JSON.parse(fs.readFileSync(stats));
          } catch {
            throw new BrowserslistError("Can't read " + stats);
          }
        return normalizeStats(data, stats);
      },
      loadConfig: function(opts) {
        if (process.env.BROWSERSLIST)
          return process.env.BROWSERSLIST;
        if (opts.config || process.env.BROWSERSLIST_CONFIG) {
          var file = opts.config || process.env.BROWSERSLIST_CONFIG;
          return pickEnv(parsePackageOrReadConfig(file), opts);
        } else return opts.path ? pickEnv(module.exports.findConfig(opts.path), opts) : void 0;
      },
      loadCountry: function(usage, country, data) {
        var code = country.replace(/[^\w-]/g, "");
        if (!usage[code]) {
          var compressed;
          try {
            compressed = __require("caniuse-lite/data/regions/" + code + ".js");
          } catch {
            throw new BrowserslistError("Unknown region name `" + code + "`.");
          }
          var usageData = region(compressed);
          normalizeUsageData(usageData, data), usage[country] = {};
          for (var i in usageData)
            for (var j in usageData[i])
              usage[country][i + " " + j] = usageData[i][j];
        }
      },
      loadFeature: function(features, name) {
        if (name = name.replace(/[^\w-]/g, ""), !features[name]) {
          var compressed;
          try {
            compressed = __require("caniuse-lite/data/features/" + name + ".js");
          } catch {
            throw new BrowserslistError("Unknown feature name `" + name + "`.");
          }
          var stats = feature(compressed).stats;
          features[name] = {};
          for (var i in stats) {
            features[name][i] = {};
            for (var j in stats[i])
              features[name][i][j] = stats[i][j];
          }
        }
      },
      parseConfig: function(string) {
        var result = { defaults: [] }, sections = ["defaults"];
        return string.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function(line) {
          return line.trim();
        }).filter(function(line) {
          return line !== "";
        }).forEach(function(line) {
          IS_SECTION.test(line) ? (sections = line.match(IS_SECTION)[1].trim().split(" "), sections.forEach(function(section) {
            if (result[section])
              throw new BrowserslistError(
                "Duplicate section " + section + " in Browserslist config"
              );
            result[section] = [];
          })) : sections.forEach(function(section) {
            result[section].push(line);
          });
        }), result;
      },
      readConfig: function(file) {
        if (!isFile(file))
          throw new BrowserslistError("Can't read " + file + " config");
        return module.exports.parseConfig(fs.readFileSync(file));
      },
      findConfigFile: function(from) {
        return eachParent(
          from,
          function(dir) {
            var config = path.join(dir, "browserslist"), pkg = path.join(dir, "package.json"), rc = path.join(dir, ".browserslistrc"), pkgBrowserslist;
            if (isFile(pkg))
              try {
                pkgBrowserslist = parsePackage(pkg);
              } catch (e) {
                if (e.name === "BrowserslistError") throw e;
                console.warn(
                  "[Browserslist] Could not parse " + pkg + ". Ignoring it."
                );
              }
            if (isFile(config) && pkgBrowserslist)
              throw new BrowserslistError(
                dir + " contains both browserslist and package.json with browsers"
              );
            if (isFile(rc) && pkgBrowserslist)
              throw new BrowserslistError(
                dir + " contains both .browserslistrc and package.json with browsers"
              );
            if (isFile(config) && isFile(rc))
              throw new BrowserslistError(
                dir + " contains both .browserslistrc and browserslist"
              );
            if (isFile(config))
              return config;
            if (isFile(rc))
              return rc;
            if (pkgBrowserslist)
              return pkg;
          },
          configPathCache
        );
      },
      findConfig: function(from) {
        var configFile = this.findConfigFile(from);
        return configFile ? parsePackageOrReadConfig(configFile) : void 0;
      },
      clearCaches: function() {
        dataTimeChecked = !1, statCache = {}, configPathCache = {}, parseConfigCache = {}, this.cache = {};
      },
      oldDataWarning: function(agentsObj) {
        if (!dataTimeChecked && (dataTimeChecked = !0, !process.env.BROWSERSLIST_IGNORE_OLD_DATA)) {
          var latest = latestReleaseTime(agentsObj), monthsPassed = getMonthsPassed(latest);
          if (latest !== 0 && monthsPassed >= 6) {
            process.env.BROWSERSLIST_TRACE_WARNING && (console.info("Last browser release in DB: " + String(new Date(latest))), console.trace());
            var months = monthsPassed + " " + (monthsPassed > 1 ? "months" : "month");
            console.warn(
              "Browserslist: browsers data (caniuse-lite) is " + months + ` old. Please run:
  npx update-browserslist-db@latest
  Why you should do it regularly: https://github.com/browserslist/update-db#readme`
            );
          }
        }
      },
      currentNode: function() {
        return "node " + process.versions.node;
      },
      env: process.env
    };
  }
});

// ../node_modules/browserslist/parse.js
var require_parse2 = __commonJS({
  "../node_modules/browserslist/parse.js"(exports, module) {
    var AND_REGEXP = /^\s+and\s+(.*)/i, OR_REGEXP = /^(?:,\s*|\s+or\s+)(.*)/i;
    function flatten(array) {
      return Array.isArray(array) ? array.reduce(function(a, b) {
        return a.concat(flatten(b));
      }, []) : [array];
    }
    function find(string, predicate) {
      for (var max = string.length, n = 1; n <= max; n++) {
        var parsed = string.substr(-n, n);
        if (predicate(parsed, n, max))
          return string.slice(0, -n);
      }
      return "";
    }
    function matchQuery(all, query) {
      var node = { query };
      query.indexOf("not ") === 0 && (node.not = !0, query = query.slice(4));
      for (var name in all) {
        var type = all[name], match = query.match(type.regexp);
        if (match) {
          node.type = name;
          for (var i = 0; i < type.matches.length; i++)
            node[type.matches[i]] = match[i + 1];
          return node;
        }
      }
      return node.type = "unknown", node;
    }
    function matchBlock(all, string, qs) {
      var node;
      return find(string, function(parsed, n, max) {
        return AND_REGEXP.test(parsed) ? (node = matchQuery(all, parsed.match(AND_REGEXP)[1]), node.compose = "and", qs.unshift(node), !0) : OR_REGEXP.test(parsed) ? (node = matchQuery(all, parsed.match(OR_REGEXP)[1]), node.compose = "or", qs.unshift(node), !0) : n === max ? (node = matchQuery(all, parsed.trim()), node.compose = "or", qs.unshift(node), !0) : !1;
      });
    }
    module.exports = function(all, queries) {
      return Array.isArray(queries) || (queries = [queries]), flatten(
        queries.map(function(block) {
          var qs = [];
          do
            block = matchBlock(all, block, qs);
          while (block);
          return qs;
        })
      );
    };
  }
});

// ../node_modules/browserslist/index.js
var require_browserslist = __commonJS({
  "../node_modules/browserslist/index.js"(exports, module) {
    var bbm = require_dist(), jsReleases = require_envs(), agents = require_agents2().agents, e2c = require_versions(), jsEOL = require_release_schedule(), path = __require("path"), BrowserslistError = require_error(), env = require_node2(), parseWithoutCache = require_parse2(), YEAR = 365.259641 * 24 * 60 * 60 * 1e3, ANDROID_EVERGREEN_FIRST = "37", OP_MOB_BLINK_FIRST = 14, FIREFOX_ESR_VERSION = "140";
    function isVersionsMatch(versionA, versionB) {
      return (versionA + ".").indexOf(versionB + ".") === 0;
    }
    function isEolReleased(name) {
      var version = name.slice(1);
      return browserslist.nodeVersions.some(function(i) {
        return isVersionsMatch(i, version);
      });
    }
    function normalize(versions) {
      return versions.filter(function(version) {
        return typeof version == "string";
      });
    }
    function normalizeElectron(version) {
      var versionToUse = version;
      return version.split(".").length === 3 && (versionToUse = version.split(".").slice(0, -1).join(".")), versionToUse;
    }
    function nameMapper(name) {
      return function(version) {
        return name + " " + version;
      };
    }
    function getMajor(version) {
      return parseInt(version.split(".")[0]);
    }
    function getMajorVersions(released, number) {
      if (released.length === 0) return [];
      var majorVersions = uniq(released.map(getMajor)), minimum = majorVersions[majorVersions.length - number];
      if (!minimum)
        return released;
      for (var selected = [], i = released.length - 1; i >= 0 && !(minimum > getMajor(released[i])); i--)
        selected.unshift(released[i]);
      return selected;
    }
    function uniq(array) {
      for (var filtered = [], i = 0; i < array.length; i++)
        filtered.indexOf(array[i]) === -1 && filtered.push(array[i]);
      return filtered;
    }
    function fillUsage(result, name, data) {
      for (var i in data)
        result[name + " " + i] = data[i];
    }
    function generateFilter(sign, version) {
      if (version = parseFloat(version), sign === ">")
        return function(v) {
          return parseLatestFloat(v) > version;
        };
      return sign === ">=" ? function(v) {
        return parseLatestFloat(v) >= version;
      } : sign === "<" ? function(v) {
        return parseFloat(v) < version;
      } : function(v) {
        return parseFloat(v) <= version;
      };
      function parseLatestFloat(v) {
        return parseFloat(v.split("-")[1] || v);
      }
    }
    function generateSemverFilter(sign, version) {
      return version = version.split(".").map(parseSimpleInt), version[1] = version[1] || 0, version[2] = version[2] || 0, sign === ">" ? function(v) {
        return v = v.split(".").map(parseSimpleInt), compareSemver(v, version) > 0;
      } : sign === ">=" ? function(v) {
        return v = v.split(".").map(parseSimpleInt), compareSemver(v, version) >= 0;
      } : sign === "<" ? function(v) {
        return v = v.split(".").map(parseSimpleInt), compareSemver(version, v) > 0;
      } : function(v) {
        return v = v.split(".").map(parseSimpleInt), compareSemver(version, v) >= 0;
      };
    }
    function parseSimpleInt(x) {
      return parseInt(x);
    }
    function compare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function compareSemver(a, b) {
      return compare(parseInt(a[0]), parseInt(b[0])) || compare(parseInt(a[1] || "0"), parseInt(b[1] || "0")) || compare(parseInt(a[2] || "0"), parseInt(b[2] || "0"));
    }
    function semverFilterLoose(operator, range) {
      switch (range = range.split(".").map(parseSimpleInt), typeof range[1] > "u" && (range[1] = "x"), operator) {
        case "<=":
          return function(version) {
            return version = version.split(".").map(parseSimpleInt), compareSemverLoose(version, range) <= 0;
          };
        case ">=":
        default:
          return function(version) {
            return version = version.split(".").map(parseSimpleInt), compareSemverLoose(version, range) >= 0;
          };
      }
    }
    function compareSemverLoose(version, range) {
      return version[0] !== range[0] ? version[0] < range[0] ? -1 : 1 : range[1] === "x" ? 0 : version[1] !== range[1] ? version[1] < range[1] ? -1 : 1 : 0;
    }
    function resolveVersion(data, version) {
      return data.versions.indexOf(version) !== -1 ? version : browserslist.versionAliases[data.name][version] ? browserslist.versionAliases[data.name][version] : !1;
    }
    function normalizeVersion(data, version) {
      var resolved = resolveVersion(data, version);
      return resolved || (data.versions.length === 1 ? data.versions[0] : !1);
    }
    function filterByYear(since, context) {
      return since = since / 1e3, Object.keys(agents).reduce(function(selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var versions = Object.keys(data.releaseDate).filter(function(v) {
          var date = data.releaseDate[v];
          return date !== null && date >= since;
        });
        return selected.concat(versions.map(nameMapper(data.name)));
      }, []);
    }
    function cloneData(data) {
      return {
        name: data.name,
        versions: data.versions,
        released: data.released,
        releaseDate: data.releaseDate
      };
    }
    function byName(name, context) {
      if (name = name.toLowerCase(), name = browserslist.aliases[name] || name, context.mobileToDesktop && browserslist.desktopNames[name]) {
        var desktop = browserslist.data[browserslist.desktopNames[name]];
        if (name === "android")
          return normalizeAndroidData(cloneData(browserslist.data[name]), desktop);
        var cloned = cloneData(desktop);
        return cloned.name = name, cloned;
      }
      return browserslist.data[name];
    }
    function normalizeAndroidVersions(androidVersions, chromeVersions) {
      var iFirstEvergreen = chromeVersions.indexOf(ANDROID_EVERGREEN_FIRST);
      return androidVersions.filter(function(version) {
        return /^(?:[2-4]\.|[34]$)/.test(version);
      }).concat(chromeVersions.slice(iFirstEvergreen));
    }
    function copyObject(obj) {
      var copy = {};
      for (var key in obj)
        copy[key] = obj[key];
      return copy;
    }
    function normalizeAndroidData(android, chrome) {
      return android.released = normalizeAndroidVersions(android.released, chrome.released), android.versions = normalizeAndroidVersions(android.versions, chrome.versions), android.releaseDate = copyObject(android.releaseDate), android.released.forEach(function(v) {
        android.releaseDate[v] === void 0 && (android.releaseDate[v] = chrome.releaseDate[v]);
      }), android;
    }
    function checkName(name, context) {
      var data = byName(name, context);
      if (!data) throw new BrowserslistError("Unknown browser " + name);
      return data;
    }
    function unknownQuery(query) {
      return new BrowserslistError(
        "Unknown browser query `" + query + "`. Maybe you are using old Browserslist or made typo in query."
      );
    }
    function filterJumps(list, name, nVersions, context) {
      var jump = 1;
      switch (name) {
        case "android":
          if (context.mobileToDesktop) return list;
          var released = browserslist.data.chrome.released;
          jump = released.length - released.indexOf(ANDROID_EVERGREEN_FIRST);
          break;
        case "op_mob":
          var latest = browserslist.data.op_mob.released.slice(-1)[0];
          jump = getMajor(latest) - OP_MOB_BLINK_FIRST + 1;
          break;
        default:
          return list;
      }
      return nVersions <= jump ? list.slice(-1) : list.slice(jump - 1 - nVersions);
    }
    function isSupported(flags, withPartial) {
      return typeof flags == "string" && (flags.indexOf("y") >= 0 || withPartial && flags.indexOf("a") >= 0);
    }
    function resolve(queries, context) {
      return parseQueries(queries).reduce(function(result, node, index) {
        if (node.not && index === 0)
          throw new BrowserslistError(
            "Write any browsers query (for instance, `defaults`) before `" + node.query + "`"
          );
        var type = QUERIES[node.type], array = type.select.call(browserslist, context, node).map(function(j) {
          var parts = j.split(" ");
          return parts[1] === "0" ? parts[0] + " " + byName(parts[0], context).versions[0] : j;
        });
        if (node.compose === "and")
          return node.not ? result.filter(function(j) {
            return array.indexOf(j) === -1;
          }) : result.filter(function(j) {
            return array.indexOf(j) !== -1;
          });
        if (node.not) {
          var filter = {};
          return array.forEach(function(j) {
            filter[j] = !0;
          }), result.filter(function(j) {
            return !filter[j];
          });
        }
        return result.concat(array);
      }, []);
    }
    function prepareOpts(opts) {
      return typeof opts > "u" && (opts = {}), typeof opts.path > "u" && (opts.path = path.resolve ? path.resolve(".") : "."), opts;
    }
    function prepareQueries(queries, opts) {
      if (typeof queries > "u" || queries === null) {
        var config = browserslist.loadConfig(opts);
        config ? queries = config : queries = browserslist.defaults;
      }
      return queries;
    }
    function checkQueries(queries) {
      if (!(typeof queries == "string" || Array.isArray(queries)))
        throw new BrowserslistError(
          "Browser queries must be an array or string. Got " + typeof queries + "."
        );
    }
    var cache = {}, parseCache = {};
    function browserslist(queries, opts) {
      opts = prepareOpts(opts), queries = prepareQueries(queries, opts), checkQueries(queries);
      var needsPath = parseQueries(queries).some(function(node) {
        return QUERIES[node.type].needsPath;
      }), context = {
        ignoreUnknownVersions: opts.ignoreUnknownVersions,
        dangerousExtend: opts.dangerousExtend,
        throwOnMissing: opts.throwOnMissing,
        mobileToDesktop: opts.mobileToDesktop,
        env: opts.env
      };
      needsPath && (context.path = opts.path), env.oldDataWarning(browserslist.data);
      var stats = env.getStat(opts, browserslist.data);
      if (stats) {
        context.customUsage = {};
        for (var browser in stats)
          fillUsage(context.customUsage, browser, stats[browser]);
      }
      var cacheKey = JSON.stringify([queries, context]);
      if (cache[cacheKey]) return cache[cacheKey];
      var result = uniq(resolve(queries, context)).sort(function(name1, name2) {
        if (name1 = name1.split(" "), name2 = name2.split(" "), name1[0] === name2[0]) {
          var version1 = name1[1].split("-")[0], version2 = name2[1].split("-")[0];
          return compareSemver(version2.split("."), version1.split("."));
        } else
          return compare(name1[0], name2[0]);
      });
      return env.env.BROWSERSLIST_DISABLE_CACHE || (cache[cacheKey] = result), result;
    }
    function parseQueries(queries) {
      var cacheKey = JSON.stringify(queries);
      if (cacheKey in parseCache) return parseCache[cacheKey];
      var result = parseWithoutCache(QUERIES, queries);
      return env.env.BROWSERSLIST_DISABLE_CACHE || (parseCache[cacheKey] = result), result;
    }
    function loadCustomUsage(context, config) {
      var stats = env.loadStat(context, config, browserslist.data);
      if (stats) {
        context.customUsage = {};
        for (var browser in stats)
          fillUsage(context.customUsage, browser, stats[browser]);
      }
      if (!context.customUsage)
        throw new BrowserslistError("Custom usage statistics was not provided");
      return context.customUsage;
    }
    browserslist.parse = function(queries, opts) {
      return opts = prepareOpts(opts), queries = prepareQueries(queries, opts), checkQueries(queries), parseQueries(queries);
    };
    browserslist.cache = {};
    browserslist.data = {};
    browserslist.usage = {
      global: {},
      custom: null
    };
    browserslist.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
    browserslist.aliases = {
      fx: "firefox",
      ff: "firefox",
      ios: "ios_saf",
      explorer: "ie",
      blackberry: "bb",
      explorermobile: "ie_mob",
      operamini: "op_mini",
      operamobile: "op_mob",
      chromeandroid: "and_chr",
      firefoxandroid: "and_ff",
      ucandroid: "and_uc",
      qqandroid: "and_qq"
    };
    browserslist.desktopNames = {
      and_chr: "chrome",
      and_ff: "firefox",
      ie_mob: "ie",
      android: "chrome"
      // has extra processing logic
    };
    browserslist.versionAliases = {};
    browserslist.clearCaches = env.clearCaches;
    browserslist.parseConfig = env.parseConfig;
    browserslist.readConfig = env.readConfig;
    browserslist.findConfigFile = env.findConfigFile;
    browserslist.findConfig = env.findConfig;
    browserslist.loadConfig = env.loadConfig;
    browserslist.coverage = function(browsers, stats) {
      var data;
      if (typeof stats > "u")
        data = browserslist.usage.global;
      else if (stats === "my stats") {
        var opts = {};
        opts.path = path.resolve ? path.resolve(".") : ".";
        var customStats = env.getStat(opts);
        if (!customStats)
          throw new BrowserslistError("Custom usage statistics was not provided");
        data = {};
        for (var browser in customStats)
          fillUsage(data, browser, customStats[browser]);
      } else if (typeof stats == "string")
        stats.length > 2 ? stats = stats.toLowerCase() : stats = stats.toUpperCase(), env.loadCountry(browserslist.usage, stats, browserslist.data), data = browserslist.usage[stats];
      else {
        "dataByBrowser" in stats && (stats = stats.dataByBrowser), data = {};
        for (var name in stats)
          for (var version in stats[name])
            data[name + " " + version] = stats[name][version];
      }
      return browsers.reduce(function(all, i) {
        var usage = data[i];
        return usage === void 0 && (usage = data[i.replace(/ \S+$/, " 0")]), all + (usage || 0);
      }, 0);
    };
    function nodeQuery(context, node) {
      var matched = browserslist.nodeVersions.filter(function(i) {
        return isVersionsMatch(i, node.version);
      });
      if (matched.length === 0) {
        if (context.ignoreUnknownVersions)
          return [];
        throw new BrowserslistError(
          "Unknown version " + node.version + " of Node.js"
        );
      }
      return ["node " + matched[matched.length - 1]];
    }
    function sinceQuery(context, node) {
      var year = parseInt(node.year), month = parseInt(node.month || "01") - 1, day = parseInt(node.day || "01");
      return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context);
    }
    function bbmTransform(bbmVersions) {
      var browsers = {
        chrome: "chrome",
        chrome_android: "and_chr",
        edge: "edge",
        firefox: "firefox",
        firefox_android: "and_ff",
        safari: "safari",
        safari_ios: "ios_saf",
        webview_android: "android",
        samsunginternet_android: "samsung",
        opera_android: "op_mob",
        opera: "opera",
        qq_android: "and_qq",
        uc_android: "and_uc",
        kai_os: "kaios"
      };
      return bbmVersions.filter(function(version) {
        return Object.keys(browsers).indexOf(version.browser) !== -1;
      }).map(function(version) {
        return browsers[version.browser] + " >= " + version.version;
      });
    }
    function coverQuery(context, node) {
      var coverage = parseFloat(node.coverage), usage = browserslist.usage.global;
      if (node.place)
        if (node.place.match(/^my\s+stats$/i)) {
          if (!context.customUsage)
            throw new BrowserslistError("Custom usage statistics was not provided");
          usage = context.customUsage;
        } else {
          var place;
          node.place.length === 2 ? place = node.place.toUpperCase() : place = node.place.toLowerCase(), env.loadCountry(browserslist.usage, place, browserslist.data), usage = browserslist.usage[place];
        }
      else node.config && (usage = loadCustomUsage(context, node.config));
      for (var versions = Object.keys(usage).sort(function(a, b) {
        return usage[b] - usage[a];
      }), covered = 0, result = [], version, i = 0; i < versions.length && (version = versions[i], !(usage[version] === 0 || (covered += usage[version], result.push(version), covered >= coverage))); i++)
        ;
      return result;
    }
    var QUERIES = {
      last_major_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
        select: function(context, node) {
          return Object.keys(agents).reduce(function(selected, name) {
            var data = byName(name, context);
            if (!data) return selected;
            var list = getMajorVersions(data.released, node.versions);
            return list = list.map(nameMapper(data.name)), list = filterJumps(list, data.name, node.versions, context), selected.concat(list);
          }, []);
        }
      },
      last_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+versions?$/i,
        select: function(context, node) {
          return Object.keys(agents).reduce(function(selected, name) {
            var data = byName(name, context);
            if (!data) return selected;
            var list = data.released.slice(-node.versions);
            return list = list.map(nameMapper(data.name)), list = filterJumps(list, data.name, node.versions, context), selected.concat(list);
          }, []);
        }
      },
      last_electron_major_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
        select: function(context, node) {
          var validVersions = getMajorVersions(Object.keys(e2c), node.versions);
          return validVersions.map(function(i) {
            return "chrome " + e2c[i];
          });
        }
      },
      last_node_major_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
        select: function(context, node) {
          return getMajorVersions(browserslist.nodeVersions, node.versions).map(
            function(version) {
              return "node " + version;
            }
          );
        }
      },
      last_browser_major_versions: {
        matches: ["versions", "browser"],
        regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
        select: function(context, node) {
          var data = checkName(node.browser, context), validVersions = getMajorVersions(data.released, node.versions), list = validVersions.map(nameMapper(data.name));
          return list = filterJumps(list, data.name, node.versions, context), list;
        }
      },
      last_electron_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
        select: function(context, node) {
          return Object.keys(e2c).slice(-node.versions).map(function(i) {
            return "chrome " + e2c[i];
          });
        }
      },
      last_node_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
        select: function(context, node) {
          return browserslist.nodeVersions.slice(-node.versions).map(function(version) {
            return "node " + version;
          });
        }
      },
      last_browser_versions: {
        matches: ["versions", "browser"],
        regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
        select: function(context, node) {
          var data = checkName(node.browser, context), list = data.released.slice(-node.versions).map(nameMapper(data.name));
          return list = filterJumps(list, data.name, node.versions, context), list;
        }
      },
      unreleased_versions: {
        matches: [],
        regexp: /^unreleased\s+versions$/i,
        select: function(context) {
          return Object.keys(agents).reduce(function(selected, name) {
            var data = byName(name, context);
            if (!data) return selected;
            var list = data.versions.filter(function(v) {
              return data.released.indexOf(v) === -1;
            });
            return list = list.map(nameMapper(data.name)), selected.concat(list);
          }, []);
        }
      },
      unreleased_electron_versions: {
        matches: [],
        regexp: /^unreleased\s+electron\s+versions?$/i,
        select: function() {
          return [];
        }
      },
      unreleased_browser_versions: {
        matches: ["browser"],
        regexp: /^unreleased\s+(\w+)\s+versions?$/i,
        select: function(context, node) {
          var data = checkName(node.browser, context);
          return data.versions.filter(function(v) {
            return data.released.indexOf(v) === -1;
          }).map(nameMapper(data.name));
        }
      },
      last_years: {
        matches: ["years"],
        regexp: /^last\s+((\d+\.)?\d+)\s+years?$/i,
        select: function(context, node) {
          return filterByYear(Date.now() - YEAR * node.years, context);
        }
      },
      since_y: {
        matches: ["year"],
        regexp: /^since (\d+)$/i,
        select: sinceQuery
      },
      since_y_m: {
        matches: ["year", "month"],
        regexp: /^since (\d+)-(\d+)$/i,
        select: sinceQuery
      },
      since_y_m_d: {
        matches: ["year", "month", "day"],
        regexp: /^since (\d+)-(\d+)-(\d+)$/i,
        select: sinceQuery
      },
      baseline: {
        matches: ["year", "availability", "date", "downstream", "kaios"],
        // Matches:
        //   baseline 2024
        //   baseline newly available
        //   baseline widely available
        //   baseline widely available on 2024-06-01
        //   ...with downstream
        //   ...including kaios
        regexp: /^baseline\s+(?:(\d+)|(newly|widely)\s+available(?:\s+on\s+(\d{4}-\d{2}-\d{2}))?)?(\s+with\s+downstream)?(\s+including\s+kaios)?$/i,
        select: function(context, node) {
          var baselineVersions, includeDownstream = !!node.downstream, includeKaiOS = !!node.kaios;
          if (node.availability === "newly" && node.date)
            throw new BrowserslistError(
              'Using newly available with a date is not supported, please use "widely available on YYYY-MM-DD" and add 30 months to the date you specified.'
            );
          if (node.year)
            baselineVersions = bbm.getCompatibleVersions({
              targetYear: node.year,
              includeDownstreamBrowsers: includeDownstream,
              includeKaiOS
            });
          else if (node.date)
            baselineVersions = bbm.getCompatibleVersions({
              widelyAvailableOnDate: node.date,
              includeDownstreamBrowsers: includeDownstream,
              includeKaiOS
            });
          else if (node.availability === "newly") {
            var future30months = (/* @__PURE__ */ new Date()).setMonth((/* @__PURE__ */ new Date()).getMonth() + 30);
            baselineVersions = bbm.getCompatibleVersions({
              widelyAvailableOnDate: future30months,
              includeDownstreamBrowsers: includeDownstream,
              includeKaiOS
            });
          } else
            baselineVersions = bbm.getCompatibleVersions({
              includeDownstreamBrowsers: includeDownstream,
              includeKaiOS
            });
          return resolve(bbmTransform(baselineVersions), context);
        }
      },
      popularity: {
        matches: ["sign", "popularity"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
        select: function(context, node) {
          var popularity = parseFloat(node.popularity), usage = browserslist.usage.global;
          return Object.keys(usage).reduce(function(result, version) {
            return node.sign === ">" ? usage[version] > popularity && result.push(version) : node.sign === "<" ? usage[version] < popularity && result.push(version) : node.sign === "<=" ? usage[version] <= popularity && result.push(version) : usage[version] >= popularity && result.push(version), result;
          }, []);
        }
      },
      popularity_in_my_stats: {
        matches: ["sign", "popularity"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
        select: function(context, node) {
          var popularity = parseFloat(node.popularity);
          if (!context.customUsage)
            throw new BrowserslistError("Custom usage statistics was not provided");
          var usage = context.customUsage;
          return Object.keys(usage).reduce(function(result, version) {
            var percentage = usage[version];
            return percentage == null || (node.sign === ">" ? percentage > popularity && result.push(version) : node.sign === "<" ? percentage < popularity && result.push(version) : node.sign === "<=" ? percentage <= popularity && result.push(version) : percentage >= popularity && result.push(version)), result;
          }, []);
        }
      },
      popularity_in_config_stats: {
        matches: ["sign", "popularity", "config"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
        select: function(context, node) {
          var popularity = parseFloat(node.popularity), usage = loadCustomUsage(context, node.config);
          return Object.keys(usage).reduce(function(result, version) {
            var percentage = usage[version];
            return percentage == null || (node.sign === ">" ? percentage > popularity && result.push(version) : node.sign === "<" ? percentage < popularity && result.push(version) : node.sign === "<=" ? percentage <= popularity && result.push(version) : percentage >= popularity && result.push(version)), result;
          }, []);
        }
      },
      popularity_in_place: {
        matches: ["sign", "popularity", "place"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
        select: function(context, node) {
          var popularity = parseFloat(node.popularity), place = node.place;
          place.length === 2 ? place = place.toUpperCase() : place = place.toLowerCase(), env.loadCountry(browserslist.usage, place, browserslist.data);
          var usage = browserslist.usage[place];
          return Object.keys(usage).reduce(function(result, version) {
            var percentage = usage[version];
            return percentage == null || (node.sign === ">" ? percentage > popularity && result.push(version) : node.sign === "<" ? percentage < popularity && result.push(version) : node.sign === "<=" ? percentage <= popularity && result.push(version) : percentage >= popularity && result.push(version)), result;
          }, []);
        }
      },
      cover: {
        matches: ["coverage"],
        regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
        select: coverQuery
      },
      cover_in: {
        matches: ["coverage", "place"],
        regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
        select: coverQuery
      },
      cover_config: {
        matches: ["coverage", "config"],
        regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/i,
        select: coverQuery
      },
      supports: {
        matches: ["supportType", "feature"],
        regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
        select: function(context, node) {
          env.loadFeature(browserslist.cache, node.feature);
          var withPartial = node.supportType !== "fully", features = browserslist.cache[node.feature], result = [];
          for (var name in features) {
            for (var data = byName(name, context), iMax = data.released.length - 1; iMax >= 0 && !(data.released[iMax] in features[name]); )
              iMax--;
            var checkDesktop = context.mobileToDesktop && name in browserslist.desktopNames && isSupported(features[name][data.released[iMax]], withPartial);
            data.versions.forEach(function(version) {
              var flags = features[name][version];
              flags === void 0 && checkDesktop && (flags = features[browserslist.desktopNames[name]][version]), isSupported(flags, withPartial) && result.push(name + " " + version);
            });
          }
          return result;
        }
      },
      electron_range: {
        matches: ["from", "to"],
        regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
        select: function(context, node) {
          var fromToUse = normalizeElectron(node.from), toToUse = normalizeElectron(node.to), from = parseFloat(node.from), to = parseFloat(node.to);
          if (!e2c[fromToUse])
            throw new BrowserslistError("Unknown version " + from + " of electron");
          if (!e2c[toToUse])
            throw new BrowserslistError("Unknown version " + to + " of electron");
          return Object.keys(e2c).filter(function(i) {
            var parsed = parseFloat(i);
            return parsed >= from && parsed <= to;
          }).map(function(i) {
            return "chrome " + e2c[i];
          });
        }
      },
      node_range: {
        matches: ["from", "to"],
        regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
        select: function(context, node) {
          return browserslist.nodeVersions.filter(semverFilterLoose(">=", node.from)).filter(semverFilterLoose("<=", node.to)).map(function(v) {
            return "node " + v;
          });
        }
      },
      browser_range: {
        matches: ["browser", "from", "to"],
        regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
        select: function(context, node) {
          var data = checkName(node.browser, context), from = parseFloat(normalizeVersion(data, node.from) || node.from), to = parseFloat(normalizeVersion(data, node.to) || node.to);
          function filter(v) {
            var parsed = parseFloat(v);
            return parsed >= from && parsed <= to;
          }
          return data.released.filter(filter).map(nameMapper(data.name));
        }
      },
      electron_ray: {
        matches: ["sign", "version"],
        regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
        select: function(context, node) {
          var versionToUse = normalizeElectron(node.version);
          return Object.keys(e2c).filter(generateFilter(node.sign, versionToUse)).map(function(i) {
            return "chrome " + e2c[i];
          });
        }
      },
      node_ray: {
        matches: ["sign", "version"],
        regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
        select: function(context, node) {
          return browserslist.nodeVersions.filter(generateSemverFilter(node.sign, node.version)).map(function(v) {
            return "node " + v;
          });
        }
      },
      browser_ray: {
        matches: ["browser", "sign", "version"],
        regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+|esr)$/i,
        select: function(context, node) {
          var version = node.version, data = checkName(node.browser, context), alias = browserslist.versionAliases[data.name][version.toLowerCase()];
          if (alias && (version = alias), !/[\d.]+/.test(version)) throw new BrowserslistError("Unknown version " + version + " of " + node.browser);
          return data.released.filter(generateFilter(node.sign, version)).map(function(v) {
            return data.name + " " + v;
          });
        }
      },
      firefox_esr: {
        matches: [],
        regexp: /^(firefox|ff|fx)\s+esr$/i,
        select: function() {
          return ["firefox " + FIREFOX_ESR_VERSION];
        }
      },
      opera_mini_all: {
        matches: [],
        regexp: /(operamini|op_mini)\s+all/i,
        select: function() {
          return ["op_mini all"];
        }
      },
      electron_version: {
        matches: ["version"],
        regexp: /^electron\s+([\d.]+)$/i,
        select: function(context, node) {
          var versionToUse = normalizeElectron(node.version), chrome = e2c[versionToUse];
          if (!chrome)
            throw new BrowserslistError(
              "Unknown version " + node.version + " of electron"
            );
          return ["chrome " + chrome];
        }
      },
      node_major_version: {
        matches: ["version"],
        regexp: /^node\s+(\d+)$/i,
        select: nodeQuery
      },
      node_minor_version: {
        matches: ["version"],
        regexp: /^node\s+(\d+\.\d+)$/i,
        select: nodeQuery
      },
      node_patch_version: {
        matches: ["version"],
        regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
        select: nodeQuery
      },
      current_node: {
        matches: [],
        regexp: /^current\s+node$/i,
        select: function(context) {
          return [env.currentNode(resolve, context)];
        }
      },
      maintained_node: {
        matches: [],
        regexp: /^maintained\s+node\s+versions$/i,
        select: function(context) {
          var now = Date.now(), queries = Object.keys(jsEOL).filter(function(key) {
            return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
          }).map(function(key) {
            return "node " + key.slice(1);
          });
          return resolve(queries, context);
        }
      },
      phantomjs_1_9: {
        matches: [],
        regexp: /^phantomjs\s+1.9$/i,
        select: function() {
          return ["safari 5"];
        }
      },
      phantomjs_2_1: {
        matches: [],
        regexp: /^phantomjs\s+2.1$/i,
        select: function() {
          return ["safari 6"];
        }
      },
      browser_version: {
        matches: ["browser", "version"],
        regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
        select: function(context, node) {
          var version = node.version;
          /^tp$/i.test(version) && (version = "TP");
          var data = checkName(node.browser, context), alias = normalizeVersion(data, version);
          if (alias)
            version = alias;
          else if (version.indexOf(".") === -1 ? alias = version + ".0" : alias = version.replace(/\.0$/, ""), alias = normalizeVersion(data, alias), alias)
            version = alias;
          else {
            if (context.ignoreUnknownVersions)
              return [];
            throw new BrowserslistError(
              "Unknown version " + version + " of " + node.browser
            );
          }
          return [data.name + " " + version];
        }
      },
      browserslist_config: {
        matches: [],
        regexp: /^browserslist config$/i,
        needsPath: !0,
        select: function(context) {
          return browserslist(void 0, context);
        }
      },
      extends: {
        matches: ["config"],
        regexp: /^extends (.+)$/i,
        needsPath: !0,
        select: function(context, node) {
          return resolve(env.loadQueries(context, node.config), context);
        }
      },
      defaults: {
        matches: [],
        regexp: /^defaults$/i,
        select: function(context) {
          return resolve(browserslist.defaults, context);
        }
      },
      dead: {
        matches: [],
        regexp: /^dead$/i,
        select: function(context) {
          var dead = [
            "Baidu >= 0",
            "ie <= 11",
            "ie_mob <= 11",
            "bb <= 10",
            "op_mob <= 12.1",
            "samsung 4"
          ];
          return resolve(dead, context);
        }
      },
      unknown: {
        matches: [],
        regexp: /^(\w+)$/i,
        select: function(context, node) {
          throw byName(node.query, context) ? new BrowserslistError(
            "Specify versions in Browserslist query for browser " + node.query
          ) : unknownQuery(node.query);
        }
      }
    };
    (function() {
      for (var name in agents) {
        var browser = agents[name];
        browserslist.data[name] = {
          name,
          versions: normalize(agents[name].versions),
          released: normalize(agents[name].versions.slice(0, -3)),
          releaseDate: agents[name].release_date
        }, fillUsage(browserslist.usage.global, name, browser.usage_global), browserslist.versionAliases[name] = {};
        for (var i = 0; i < browser.versions.length; i++) {
          var full = browser.versions[i];
          if (full && full.indexOf("-") !== -1)
            for (var interval = full.split("-"), j = 0; j < interval.length; j++)
              browserslist.versionAliases[name][interval[j]] = full;
        }
      }
      browserslist.nodeVersions = jsReleases.map(function(release) {
        return release.version;
      });
    })();
    browserslist.versionAliases.firefox.esr = FIREFOX_ESR_VERSION;
    module.exports = browserslist;
  }
});

// ../node_modules/@babel/helper-validator-option/lib/find-suggestion.js
var require_find_suggestion = __commonJS({
  "../node_modules/@babel/helper-validator-option/lib/find-suggestion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.findSuggestion = findSuggestion;
    var {
      min
    } = Math;
    function levenshtein(a, b) {
      let t = [], u = [], i, j, m = a.length, n = b.length;
      if (!m)
        return n;
      if (!n)
        return m;
      for (j = 0; j <= n; j++)
        t[j] = j;
      for (i = 1; i <= m; i++) {
        for (u = [i], j = 1; j <= n; j++)
          u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;
        t = u;
      }
      return u[n];
    }
    function findSuggestion(str, arr) {
      let distances = arr.map((el) => levenshtein(el, str));
      return arr[distances.indexOf(min(...distances))];
    }
  }
});

// ../node_modules/@babel/helper-validator-option/lib/validator.js
var require_validator = __commonJS({
  "../node_modules/@babel/helper-validator-option/lib/validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.OptionValidator = void 0;
    var _findSuggestion = require_find_suggestion(), OptionValidator = class {
      constructor(descriptor) {
        this.descriptor = descriptor;
      }
      validateTopLevelOptions(options, TopLevelOptionShape) {
        let validOptionNames = Object.keys(TopLevelOptionShape);
        for (let option of Object.keys(options))
          if (!validOptionNames.includes(option))
            throw new Error(this.formatMessage(`'${option}' is not a valid top-level option.
- Did you mean '${(0, _findSuggestion.findSuggestion)(option, validOptionNames)}'?`));
      }
      validateBooleanOption(name, value2, defaultValue) {
        return value2 === void 0 ? defaultValue : (this.invariant(typeof value2 == "boolean", `'${name}' option must be a boolean.`), value2);
      }
      validateStringOption(name, value2, defaultValue) {
        return value2 === void 0 ? defaultValue : (this.invariant(typeof value2 == "string", `'${name}' option must be a string.`), value2);
      }
      invariant(condition, message) {
        if (!condition)
          throw new Error(this.formatMessage(message));
      }
      formatMessage(message) {
        return `${this.descriptor}: ${message}`;
      }
    };
    exports.OptionValidator = OptionValidator;
  }
});

// ../node_modules/@babel/helper-validator-option/lib/index.js
var require_lib13 = __commonJS({
  "../node_modules/@babel/helper-validator-option/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "OptionValidator", {
      enumerable: !0,
      get: function() {
        return _validator.OptionValidator;
      }
    });
    Object.defineProperty(exports, "findSuggestion", {
      enumerable: !0,
      get: function() {
        return _findSuggestion.findSuggestion;
      }
    });
    var _validator = require_validator(), _findSuggestion = require_find_suggestion();
  }
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next)
          yield walker.value;
      };
    };
  }
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (self2 instanceof Yallist || (self2 = new Yallist()), self2.tail = null, self2.head = null, self2.length = 0, list && typeof list.forEach == "function")
        list.forEach(function(item) {
          self2.push(item);
        });
      else if (arguments.length > 0)
        for (var i = 0, l = arguments.length; i < l; i++)
          self2.push(arguments[i]);
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this)
        throw new Error("removing node which does not belong to this list");
      var next = node.next, prev = node.prev;
      return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node !== this.head) {
        node.list && node.list.removeNode(node);
        var head = this.head;
        node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
      }
    };
    Yallist.prototype.pushNode = function(node) {
      if (node !== this.tail) {
        node.list && node.list.removeNode(node);
        var tail = this.tail;
        node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
      }
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++)
        push(this, arguments[i]);
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++)
        unshift(this, arguments[i]);
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (this.tail) {
        var res = this.tail.value;
        return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
      }
    };
    Yallist.prototype.shift = function() {
      if (this.head) {
        var res = this.head.value;
        return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
      }
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++)
        fn.call(thisp, walker.value, i, this), walker = walker.next;
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
        fn.call(thisp, walker.value, i, this), walker = walker.prev;
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++)
        walker = walker.next;
      if (i === n && walker !== null)
        return walker.value;
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
        walker = walker.prev;
      if (i === n && walker !== null)
        return walker.value;
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.head; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.tail; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc, walker = this.head;
      if (arguments.length > 1)
        acc = initial;
      else if (this.head)
        walker = this.head.next, acc = this.head.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i = 0; walker !== null; i++)
        acc = fn(acc, walker.value, i), walker = walker.next;
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc, walker = this.tail;
      if (arguments.length > 1)
        acc = initial;
      else if (this.tail)
        walker = this.tail.prev, acc = this.tail.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i = this.length - 1; walker !== null; i--)
        acc = fn(acc, walker.value, i), walker = walker.prev;
      return acc;
    };
    Yallist.prototype.toArray = function() {
      for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
        arr[i] = walker.value, walker = walker.next;
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
        arr[i] = walker.value, walker = walker.prev;
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i = 0, walker = this.head; walker !== null && i < from; i++)
        walker = walker.next;
      for (; walker !== null && i < to; i++, walker = walker.next)
        ret.push(walker.value);
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
        walker = walker.prev;
      for (; walker !== null && i > from; i--, walker = walker.prev)
        ret.push(walker.value);
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount) {
      start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
      for (var i = 0, walker = this.head; walker !== null && i < start; i++)
        walker = walker.next;
      for (var ret = [], i = 0; walker && i < deleteCount; i++)
        ret.push(walker.value), walker = this.removeNode(walker);
      walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
      for (var i = 2; i < arguments.length; i++)
        walker = insert(this, walker, arguments[i]);
      return ret;
    };
    Yallist.prototype.reverse = function() {
      for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next, walker.next = p;
      }
      return this.head = tail, this.tail = head, this;
    };
    function insert(self2, node, value2) {
      var inserted = node === self2.head ? new Node(value2, null, node, self2) : new Node(value2, node, node.next, self2);
      return inserted.next === null && (self2.tail = inserted), inserted.prev === null && (self2.head = inserted), self2.length++, inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2), self2.head || (self2.head = self2.tail), self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2), self2.tail || (self2.tail = self2.head), self2.length++;
    }
    function Node(value2, prev, next, list) {
      if (!(this instanceof Node))
        return new Node(value2, prev, next, list);
      this.list = list, this.value = value2, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
    }
    try {
      require_iterator()(Yallist);
    } catch {
    }
  }
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    var Yallist = require_yallist(), MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = () => 1, LRUCache = class {
      constructor(options) {
        if (typeof options == "number" && (options = { max: options }), options || (options = {}), options.max && (typeof options.max != "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        let max = this[MAX] = options.max || 1 / 0, lc = options.length || naiveLength;
        if (this[LENGTH_CALCULATOR] = typeof lc != "function" ? naiveLength : lc, this[ALLOW_STALE] = options.stale || !1, options.maxAge && typeof options.maxAge != "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || !1, this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || !1, this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL != "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || 1 / 0, trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA != "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA, trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
        })), trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          let prev = walker.prev;
          forEachStep(this, fn, walker, thisp), walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          let next = walker.next;
          forEachStep(this, fn, walker, thisp), walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value)), this[CACHE] = /* @__PURE__ */ new Map(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? !1 : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value2, maxAge) {
        if (maxAge = maxAge || this[MAX_AGE], maxAge && typeof maxAge != "number")
          throw new TypeError("maxAge must be a number");
        let now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value2, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX])
            return del(this, this[CACHE].get(key)), !1;
          let item = this[CACHE].get(key).value;
          return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value2, this[LENGTH] += len - item.length, item.length = len, this.get(key), trim(this), !0;
        }
        let hit = new Entry(key, value2, len, now, maxAge);
        return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value2), !1) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), !0);
      }
      has(key) {
        if (!this[CACHE].has(key)) return !1;
        let hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, !0);
      }
      peek(key) {
        return get(this, key, !1);
      }
      pop() {
        let node = this[LRU_LIST].tail;
        return node ? (del(this, node), node.value) : null;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        let now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          let hit = arr[l], expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            let maxAge = expiresAt - now;
            maxAge > 0 && this.set(hit.k, hit.v, maxAge);
          }
        }
      }
      prune() {
        this[CACHE].forEach((value2, key) => get(this, key, !1));
      }
    }, get = (self2, key, doUse) => {
      let node = self2[CACHE].get(key);
      if (node) {
        let hit = node.value;
        if (isStale(self2, hit)) {
          if (del(self2, node), !self2[ALLOW_STALE])
            return;
        } else
          doUse && (self2[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self2[LRU_LIST].unshiftNode(node));
        return hit.value;
      }
    }, isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return !1;
      let diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    }, trim = (self2) => {
      if (self2[LENGTH] > self2[MAX])
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          let prev = walker.prev;
          del(self2, walker), walker = prev;
        }
    }, del = (self2, node) => {
      if (node) {
        let hit = node.value;
        self2[DISPOSE] && self2[DISPOSE](hit.key, hit.value), self2[LENGTH] -= hit.length, self2[CACHE].delete(hit.key), self2[LRU_LIST].removeNode(node);
      }
    }, Entry = class {
      constructor(key, value2, length, now, maxAge) {
        this.key = key, this.value = value2, this.length = length, this.now = now, this.maxAge = maxAge || 0;
      }
    }, forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      isStale(self2, hit) && (del(self2, node), self2[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  }
});

// ../node_modules/@babel/helper-compilation-targets/lib/targets.js
var require_targets = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/lib/targets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.unreleasedLabels = exports.browserNameMap = void 0;
    var unreleasedLabels = exports.unreleasedLabels = {
      safari: "tp"
    }, browserNameMap = exports.browserNameMap = {
      and_chr: "chrome",
      and_ff: "firefox",
      android: "android",
      chrome: "chrome",
      edge: "edge",
      firefox: "firefox",
      ie: "ie",
      ie_mob: "ie",
      ios_saf: "ios",
      node: "node",
      deno: "deno",
      op_mob: "opera_mobile",
      opera: "opera",
      safari: "safari",
      samsung: "samsung"
    };
  }
});

// ../node_modules/@babel/helper-compilation-targets/lib/utils.js
var require_utils3 = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.getHighestUnreleased = getHighestUnreleased;
    exports.getLowestImplementedVersion = getLowestImplementedVersion;
    exports.getLowestUnreleased = getLowestUnreleased;
    exports.isUnreleasedVersion = isUnreleasedVersion;
    exports.semverMin = semverMin;
    exports.semverify = semverify;
    var _semver = __require("semver"), _helperValidatorOption = require_lib13(), _targets = require_targets(), versionRegExp = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/, v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
    function semverMin(first, second) {
      return first && _semver.lt(first, second) ? first : second;
    }
    function semverify(version) {
      if (typeof version == "string" && _semver.valid(version))
        return version;
      v.invariant(typeof version == "number" || typeof version == "string" && versionRegExp.test(version), `'${version}' is not a valid version`), version = version.toString();
      let pos = 0, num = 0;
      for (; (pos = version.indexOf(".", pos + 1)) > 0; )
        num++;
      return version + ".0".repeat(2 - num);
    }
    function isUnreleasedVersion(version, env) {
      let unreleasedLabel = _targets.unreleasedLabels[env];
      return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
    }
    function getLowestUnreleased(a, b, env) {
      let unreleasedLabel = _targets.unreleasedLabels[env];
      return a === unreleasedLabel ? b : b === unreleasedLabel ? a : semverMin(a, b);
    }
    function getHighestUnreleased(a, b, env) {
      return getLowestUnreleased(a, b, env) === a ? b : a;
    }
    function getLowestImplementedVersion(plugin, environment) {
      let result = plugin[environment];
      return !result && environment === "android" ? plugin.chrome : result;
    }
  }
});

// ../node_modules/@babel/helper-compilation-targets/lib/options.js
var require_options2 = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/lib/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.TargetNames = void 0;
    var TargetNames = exports.TargetNames = {
      node: "node",
      deno: "deno",
      chrome: "chrome",
      opera: "opera",
      edge: "edge",
      firefox: "firefox",
      safari: "safari",
      ie: "ie",
      ios: "ios",
      android: "android",
      electron: "electron",
      samsung: "samsung",
      rhino: "rhino",
      opera_mobile: "opera_mobile"
    };
  }
});

// ../node_modules/@babel/helper-compilation-targets/lib/pretty.js
var require_pretty = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/lib/pretty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.prettifyTargets = prettifyTargets;
    exports.prettifyVersion = prettifyVersion;
    var _semver = __require("semver"), _targets = require_targets();
    function prettifyVersion(version) {
      if (typeof version != "string")
        return version;
      let {
        major,
        minor,
        patch
      } = _semver.parse(version), parts = [major];
      return (minor || patch) && parts.push(minor), patch && parts.push(patch), parts.join(".");
    }
    function prettifyTargets(targets) {
      return Object.keys(targets).reduce((results, target) => {
        let value2 = targets[target], unreleasedLabel = _targets.unreleasedLabels[target];
        return typeof value2 == "string" && unreleasedLabel !== value2 && (value2 = prettifyVersion(value2)), results[target] = value2, results;
      }, {});
    }
  }
});

// ../node_modules/@babel/helper-compilation-targets/lib/debug.js
var require_debug = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/lib/debug.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.getInclusionReasons = getInclusionReasons;
    var _semver = __require("semver"), _pretty = require_pretty(), _utils = require_utils3();
    function getInclusionReasons(item, targetVersions, list) {
      let minVersions = list[item] || {};
      return Object.keys(targetVersions).reduce((result, env) => {
        let minVersion = (0, _utils.getLowestImplementedVersion)(minVersions, env), targetVersion = targetVersions[env];
        if (!minVersion)
          result[env] = (0, _pretty.prettifyVersion)(targetVersion);
        else {
          let minIsUnreleased = (0, _utils.isUnreleasedVersion)(minVersion, env);
          !(0, _utils.isUnreleasedVersion)(targetVersion, env) && (minIsUnreleased || _semver.lt(targetVersion.toString(), (0, _utils.semverify)(minVersion))) && (result[env] = (0, _pretty.prettifyVersion)(targetVersion));
        }
        return result;
      }, {});
    }
  }
});

// ../node_modules/@babel/compat-data/data/plugins.json
var require_plugins = __commonJS({
  "../node_modules/@babel/compat-data/data/plugins.json"(exports, module) {
    module.exports = {
      "transform-explicit-resource-management": {
        chrome: "134",
        edge: "134",
        firefox: "141",
        node: "24",
        electron: "35.0"
      },
      "transform-duplicate-named-capturing-groups-regex": {
        chrome: "126",
        opera: "112",
        edge: "126",
        firefox: "129",
        safari: "17.4",
        node: "23",
        ios: "17.4",
        electron: "31.0"
      },
      "transform-regexp-modifiers": {
        chrome: "125",
        opera: "111",
        edge: "125",
        firefox: "132",
        node: "23",
        samsung: "27",
        electron: "31.0"
      },
      "transform-unicode-sets-regex": {
        chrome: "112",
        opera: "98",
        edge: "112",
        firefox: "116",
        safari: "17",
        node: "20",
        deno: "1.32",
        ios: "17",
        samsung: "23",
        opera_mobile: "75",
        electron: "24.0"
      },
      "bugfix/transform-v8-static-class-fields-redefine-readonly": {
        chrome: "98",
        opera: "84",
        edge: "98",
        firefox: "75",
        safari: "15",
        node: "12",
        deno: "1.18",
        ios: "15",
        samsung: "11",
        opera_mobile: "52",
        electron: "17.0"
      },
      "bugfix/transform-firefox-class-in-computed-class-key": {
        chrome: "74",
        opera: "62",
        edge: "79",
        firefox: "126",
        safari: "16",
        node: "12",
        deno: "1",
        ios: "16",
        samsung: "11",
        opera_mobile: "53",
        electron: "6.0"
      },
      "bugfix/transform-safari-class-field-initializer-scope": {
        chrome: "74",
        opera: "62",
        edge: "79",
        firefox: "69",
        safari: "16",
        node: "12",
        deno: "1",
        ios: "16",
        samsung: "11",
        opera_mobile: "53",
        electron: "6.0"
      },
      "transform-class-static-block": {
        chrome: "94",
        opera: "80",
        edge: "94",
        firefox: "93",
        safari: "16.4",
        node: "16.11",
        deno: "1.14",
        ios: "16.4",
        samsung: "17",
        opera_mobile: "66",
        electron: "15.0"
      },
      "proposal-class-static-block": {
        chrome: "94",
        opera: "80",
        edge: "94",
        firefox: "93",
        safari: "16.4",
        node: "16.11",
        deno: "1.14",
        ios: "16.4",
        samsung: "17",
        opera_mobile: "66",
        electron: "15.0"
      },
      "transform-private-property-in-object": {
        chrome: "91",
        opera: "77",
        edge: "91",
        firefox: "90",
        safari: "15",
        node: "16.9",
        deno: "1.9",
        ios: "15",
        samsung: "16",
        opera_mobile: "64",
        electron: "13.0"
      },
      "proposal-private-property-in-object": {
        chrome: "91",
        opera: "77",
        edge: "91",
        firefox: "90",
        safari: "15",
        node: "16.9",
        deno: "1.9",
        ios: "15",
        samsung: "16",
        opera_mobile: "64",
        electron: "13.0"
      },
      "transform-class-properties": {
        chrome: "74",
        opera: "62",
        edge: "79",
        firefox: "90",
        safari: "14.1",
        node: "12",
        deno: "1",
        ios: "14.5",
        samsung: "11",
        opera_mobile: "53",
        electron: "6.0"
      },
      "proposal-class-properties": {
        chrome: "74",
        opera: "62",
        edge: "79",
        firefox: "90",
        safari: "14.1",
        node: "12",
        deno: "1",
        ios: "14.5",
        samsung: "11",
        opera_mobile: "53",
        electron: "6.0"
      },
      "transform-private-methods": {
        chrome: "84",
        opera: "70",
        edge: "84",
        firefox: "90",
        safari: "15",
        node: "14.6",
        deno: "1",
        ios: "15",
        samsung: "14",
        opera_mobile: "60",
        electron: "10.0"
      },
      "proposal-private-methods": {
        chrome: "84",
        opera: "70",
        edge: "84",
        firefox: "90",
        safari: "15",
        node: "14.6",
        deno: "1",
        ios: "15",
        samsung: "14",
        opera_mobile: "60",
        electron: "10.0"
      },
      "transform-numeric-separator": {
        chrome: "75",
        opera: "62",
        edge: "79",
        firefox: "70",
        safari: "13",
        node: "12.5",
        deno: "1",
        ios: "13",
        samsung: "11",
        rhino: "1.7.14",
        opera_mobile: "54",
        electron: "6.0"
      },
      "proposal-numeric-separator": {
        chrome: "75",
        opera: "62",
        edge: "79",
        firefox: "70",
        safari: "13",
        node: "12.5",
        deno: "1",
        ios: "13",
        samsung: "11",
        rhino: "1.7.14",
        opera_mobile: "54",
        electron: "6.0"
      },
      "transform-logical-assignment-operators": {
        chrome: "85",
        opera: "71",
        edge: "85",
        firefox: "79",
        safari: "14",
        node: "15",
        deno: "1.2",
        ios: "14",
        samsung: "14",
        opera_mobile: "60",
        electron: "10.0"
      },
      "proposal-logical-assignment-operators": {
        chrome: "85",
        opera: "71",
        edge: "85",
        firefox: "79",
        safari: "14",
        node: "15",
        deno: "1.2",
        ios: "14",
        samsung: "14",
        opera_mobile: "60",
        electron: "10.0"
      },
      "transform-nullish-coalescing-operator": {
        chrome: "80",
        opera: "67",
        edge: "80",
        firefox: "72",
        safari: "13.1",
        node: "14",
        deno: "1",
        ios: "13.4",
        samsung: "13",
        rhino: "1.8",
        opera_mobile: "57",
        electron: "8.0"
      },
      "proposal-nullish-coalescing-operator": {
        chrome: "80",
        opera: "67",
        edge: "80",
        firefox: "72",
        safari: "13.1",
        node: "14",
        deno: "1",
        ios: "13.4",
        samsung: "13",
        rhino: "1.8",
        opera_mobile: "57",
        electron: "8.0"
      },
      "transform-optional-chaining": {
        chrome: "91",
        opera: "77",
        edge: "91",
        firefox: "74",
        safari: "13.1",
        node: "16.9",
        deno: "1.9",
        ios: "13.4",
        samsung: "16",
        opera_mobile: "64",
        electron: "13.0"
      },
      "proposal-optional-chaining": {
        chrome: "91",
        opera: "77",
        edge: "91",
        firefox: "74",
        safari: "13.1",
        node: "16.9",
        deno: "1.9",
        ios: "13.4",
        samsung: "16",
        opera_mobile: "64",
        electron: "13.0"
      },
      "transform-json-strings": {
        chrome: "66",
        opera: "53",
        edge: "79",
        firefox: "62",
        safari: "12",
        node: "10",
        deno: "1",
        ios: "12",
        samsung: "9",
        rhino: "1.7.14",
        opera_mobile: "47",
        electron: "3.0"
      },
      "proposal-json-strings": {
        chrome: "66",
        opera: "53",
        edge: "79",
        firefox: "62",
        safari: "12",
        node: "10",
        deno: "1",
        ios: "12",
        samsung: "9",
        rhino: "1.7.14",
        opera_mobile: "47",
        electron: "3.0"
      },
      "transform-optional-catch-binding": {
        chrome: "66",
        opera: "53",
        edge: "79",
        firefox: "58",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "proposal-optional-catch-binding": {
        chrome: "66",
        opera: "53",
        edge: "79",
        firefox: "58",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "transform-parameters": {
        chrome: "49",
        opera: "36",
        edge: "18",
        firefox: "52",
        safari: "16.3",
        node: "6",
        deno: "1",
        ios: "16.3",
        samsung: "5",
        opera_mobile: "36",
        electron: "0.37"
      },
      "transform-async-generator-functions": {
        chrome: "63",
        opera: "50",
        edge: "79",
        firefox: "57",
        safari: "12",
        node: "10",
        deno: "1",
        ios: "12",
        samsung: "8",
        opera_mobile: "46",
        electron: "3.0"
      },
      "proposal-async-generator-functions": {
        chrome: "63",
        opera: "50",
        edge: "79",
        firefox: "57",
        safari: "12",
        node: "10",
        deno: "1",
        ios: "12",
        samsung: "8",
        opera_mobile: "46",
        electron: "3.0"
      },
      "transform-object-rest-spread": {
        chrome: "60",
        opera: "47",
        edge: "79",
        firefox: "55",
        safari: "11.1",
        node: "8.3",
        deno: "1",
        ios: "11.3",
        samsung: "8",
        opera_mobile: "44",
        electron: "2.0"
      },
      "proposal-object-rest-spread": {
        chrome: "60",
        opera: "47",
        edge: "79",
        firefox: "55",
        safari: "11.1",
        node: "8.3",
        deno: "1",
        ios: "11.3",
        samsung: "8",
        opera_mobile: "44",
        electron: "2.0"
      },
      "transform-dotall-regex": {
        chrome: "62",
        opera: "49",
        edge: "79",
        firefox: "78",
        safari: "11.1",
        node: "8.10",
        deno: "1",
        ios: "11.3",
        samsung: "8",
        rhino: "1.7.15",
        opera_mobile: "46",
        electron: "3.0"
      },
      "transform-unicode-property-regex": {
        chrome: "64",
        opera: "51",
        edge: "79",
        firefox: "78",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "proposal-unicode-property-regex": {
        chrome: "64",
        opera: "51",
        edge: "79",
        firefox: "78",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "transform-named-capturing-groups-regex": {
        chrome: "64",
        opera: "51",
        edge: "79",
        firefox: "78",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "transform-async-to-generator": {
        chrome: "55",
        opera: "42",
        edge: "15",
        firefox: "52",
        safari: "11",
        node: "7.6",
        deno: "1",
        ios: "11",
        samsung: "6",
        opera_mobile: "42",
        electron: "1.6"
      },
      "transform-exponentiation-operator": {
        chrome: "52",
        opera: "39",
        edge: "14",
        firefox: "52",
        safari: "10.1",
        node: "7",
        deno: "1",
        ios: "10.3",
        samsung: "6",
        rhino: "1.7.14",
        opera_mobile: "41",
        electron: "1.3"
      },
      "transform-template-literals": {
        chrome: "41",
        opera: "28",
        edge: "13",
        firefox: "34",
        safari: "13",
        node: "4",
        deno: "1",
        ios: "13",
        samsung: "3.4",
        opera_mobile: "28",
        electron: "0.21"
      },
      "transform-literals": {
        chrome: "44",
        opera: "31",
        edge: "12",
        firefox: "53",
        safari: "9",
        node: "4",
        deno: "1",
        ios: "9",
        samsung: "4",
        rhino: "1.7.15",
        opera_mobile: "32",
        electron: "0.30"
      },
      "transform-function-name": {
        chrome: "51",
        opera: "38",
        edge: "79",
        firefox: "53",
        safari: "10",
        node: "6.5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "41",
        electron: "1.2"
      },
      "transform-arrow-functions": {
        chrome: "47",
        opera: "34",
        edge: "13",
        firefox: "43",
        safari: "10",
        node: "6",
        deno: "1",
        ios: "10",
        samsung: "5",
        rhino: "1.7.13",
        opera_mobile: "34",
        electron: "0.36"
      },
      "transform-block-scoped-functions": {
        chrome: "41",
        opera: "28",
        edge: "12",
        firefox: "46",
        safari: "10",
        node: "4",
        deno: "1",
        ie: "11",
        ios: "10",
        samsung: "3.4",
        opera_mobile: "28",
        electron: "0.21"
      },
      "transform-classes": {
        chrome: "46",
        opera: "33",
        edge: "13",
        firefox: "45",
        safari: "10",
        node: "5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "33",
        electron: "0.36"
      },
      "transform-object-super": {
        chrome: "46",
        opera: "33",
        edge: "13",
        firefox: "45",
        safari: "10",
        node: "5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "33",
        electron: "0.36"
      },
      "transform-shorthand-properties": {
        chrome: "43",
        opera: "30",
        edge: "12",
        firefox: "33",
        safari: "9",
        node: "4",
        deno: "1",
        ios: "9",
        samsung: "4",
        rhino: "1.7.14",
        opera_mobile: "30",
        electron: "0.27"
      },
      "transform-duplicate-keys": {
        chrome: "42",
        opera: "29",
        edge: "12",
        firefox: "34",
        safari: "9",
        node: "4",
        deno: "1",
        ios: "9",
        samsung: "3.4",
        opera_mobile: "29",
        electron: "0.25"
      },
      "transform-computed-properties": {
        chrome: "44",
        opera: "31",
        edge: "12",
        firefox: "34",
        safari: "7.1",
        node: "4",
        deno: "1",
        ios: "8",
        samsung: "4",
        rhino: "1.8",
        opera_mobile: "32",
        electron: "0.30"
      },
      "transform-for-of": {
        chrome: "51",
        opera: "38",
        edge: "15",
        firefox: "53",
        safari: "10",
        node: "6.5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "41",
        electron: "1.2"
      },
      "transform-sticky-regex": {
        chrome: "49",
        opera: "36",
        edge: "13",
        firefox: "3",
        safari: "10",
        node: "6",
        deno: "1",
        ios: "10",
        samsung: "5",
        rhino: "1.7.15",
        opera_mobile: "36",
        electron: "0.37"
      },
      "transform-unicode-escapes": {
        chrome: "44",
        opera: "31",
        edge: "12",
        firefox: "53",
        safari: "9",
        node: "4",
        deno: "1",
        ios: "9",
        samsung: "4",
        rhino: "1.7.15",
        opera_mobile: "32",
        electron: "0.30"
      },
      "transform-unicode-regex": {
        chrome: "50",
        opera: "37",
        edge: "13",
        firefox: "46",
        safari: "12",
        node: "6",
        deno: "1",
        ios: "12",
        samsung: "5",
        opera_mobile: "37",
        electron: "1.1"
      },
      "transform-spread": {
        chrome: "46",
        opera: "33",
        edge: "13",
        firefox: "45",
        safari: "10",
        node: "5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "33",
        electron: "0.36"
      },
      "transform-destructuring": {
        chrome: "51",
        opera: "38",
        edge: "15",
        firefox: "53",
        safari: "10",
        node: "6.5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "41",
        electron: "1.2"
      },
      "transform-block-scoping": {
        chrome: "50",
        opera: "37",
        edge: "14",
        firefox: "53",
        safari: "11",
        node: "6",
        deno: "1",
        ios: "11",
        samsung: "5",
        opera_mobile: "37",
        electron: "1.1"
      },
      "transform-typeof-symbol": {
        chrome: "48",
        opera: "35",
        edge: "12",
        firefox: "36",
        safari: "9",
        node: "6",
        deno: "1",
        ios: "9",
        samsung: "5",
        rhino: "1.8",
        opera_mobile: "35",
        electron: "0.37"
      },
      "transform-new-target": {
        chrome: "46",
        opera: "33",
        edge: "14",
        firefox: "41",
        safari: "10",
        node: "5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "33",
        electron: "0.36"
      },
      "transform-regenerator": {
        chrome: "50",
        opera: "37",
        edge: "13",
        firefox: "53",
        safari: "10",
        node: "6",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "37",
        electron: "1.1"
      },
      "transform-member-expression-literals": {
        chrome: "7",
        opera: "12",
        edge: "12",
        firefox: "2",
        safari: "5.1",
        node: "0.4",
        deno: "1",
        ie: "9",
        android: "4",
        ios: "6",
        phantom: "1.9",
        samsung: "1",
        rhino: "1.7.13",
        opera_mobile: "12",
        electron: "0.20"
      },
      "transform-property-literals": {
        chrome: "7",
        opera: "12",
        edge: "12",
        firefox: "2",
        safari: "5.1",
        node: "0.4",
        deno: "1",
        ie: "9",
        android: "4",
        ios: "6",
        phantom: "1.9",
        samsung: "1",
        rhino: "1.7.13",
        opera_mobile: "12",
        electron: "0.20"
      },
      "transform-reserved-words": {
        chrome: "13",
        opera: "10.50",
        edge: "12",
        firefox: "2",
        safari: "3.1",
        node: "0.6",
        deno: "1",
        ie: "9",
        android: "4.4",
        ios: "6",
        phantom: "1.9",
        samsung: "1",
        rhino: "1.7.13",
        opera_mobile: "10.1",
        electron: "0.20"
      },
      "transform-export-namespace-from": {
        chrome: "72",
        deno: "1.0",
        edge: "79",
        firefox: "80",
        node: "13.2.0",
        opera: "60",
        opera_mobile: "51",
        safari: "14.1",
        ios: "14.5",
        samsung: "11.0",
        android: "72",
        electron: "5.0"
      },
      "proposal-export-namespace-from": {
        chrome: "72",
        deno: "1.0",
        edge: "79",
        firefox: "80",
        node: "13.2.0",
        opera: "60",
        opera_mobile: "51",
        safari: "14.1",
        ios: "14.5",
        samsung: "11.0",
        android: "72",
        electron: "5.0"
      }
    };
  }
});

// ../node_modules/@babel/compat-data/plugins.js
var require_plugins2 = __commonJS({
  "../node_modules/@babel/compat-data/plugins.js"(exports, module) {
    module.exports = require_plugins();
  }
});

// ../node_modules/@babel/helper-compilation-targets/lib/filter-items.js
var require_filter_items = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/lib/filter-items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = filterItems;
    exports.isRequired = isRequired;
    exports.targetsSupported = targetsSupported;
    var _semver = __require("semver"), _utils = require_utils3(), pluginsCompatData = require_plugins2();
    function targetsSupported(target, support) {
      let targetEnvironments = Object.keys(target);
      return targetEnvironments.length === 0 ? !1 : targetEnvironments.filter((environment) => {
        let lowestImplementedVersion = (0, _utils.getLowestImplementedVersion)(support, environment);
        if (!lowestImplementedVersion)
          return !0;
        let lowestTargetedVersion = target[environment];
        if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment))
          return !1;
        if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment))
          return !0;
        if (!_semver.valid(lowestTargetedVersion.toString()))
          throw new Error(`Invalid version passed for target "${environment}": "${lowestTargetedVersion}". Versions must be in semver format (major.minor.patch)`);
        return _semver.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());
      }).length === 0;
    }
    function isRequired(name, targets, {
      compatData = pluginsCompatData,
      includes,
      excludes
    } = {}) {
      return excludes != null && excludes.has(name) ? !1 : includes != null && includes.has(name) ? !0 : !targetsSupported(targets, compatData[name]);
    }
    function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
      let result = /* @__PURE__ */ new Set(), options = {
        compatData: list,
        includes,
        excludes
      };
      for (let item in list)
        if (isRequired(item, targets, options))
          result.add(item);
        else if (pluginSyntaxMap) {
          let shippedProposalsSyntax = pluginSyntaxMap.get(item);
          shippedProposalsSyntax && result.add(shippedProposalsSyntax);
        }
      return defaultIncludes?.forEach((item) => !excludes.has(item) && result.add(item)), defaultExcludes?.forEach((item) => !includes.has(item) && result.delete(item)), result;
    }
  }
});

// ../node_modules/@babel/compat-data/data/native-modules.json
var require_native_modules = __commonJS({
  "../node_modules/@babel/compat-data/data/native-modules.json"(exports, module) {
    module.exports = {
      "es6.module": {
        chrome: "61",
        and_chr: "61",
        edge: "16",
        firefox: "60",
        and_ff: "60",
        node: "13.2.0",
        opera: "48",
        op_mob: "45",
        safari: "10.1",
        ios: "10.3",
        samsung: "8.2",
        android: "61",
        electron: "2.0",
        ios_saf: "10.3"
      }
    };
  }
});

// ../node_modules/@babel/compat-data/native-modules.js
var require_native_modules2 = __commonJS({
  "../node_modules/@babel/compat-data/native-modules.js"(exports, module) {
    module.exports = require_native_modules();
  }
});

// ../node_modules/@babel/helper-compilation-targets/lib/index.js
var require_lib14 = __commonJS({
  "../node_modules/@babel/helper-compilation-targets/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "TargetNames", {
      enumerable: !0,
      get: function() {
        return _options.TargetNames;
      }
    });
    exports.default = getTargets;
    Object.defineProperty(exports, "filterItems", {
      enumerable: !0,
      get: function() {
        return _filterItems.default;
      }
    });
    Object.defineProperty(exports, "getInclusionReasons", {
      enumerable: !0,
      get: function() {
        return _debug.getInclusionReasons;
      }
    });
    exports.isBrowsersQueryValid = isBrowsersQueryValid;
    Object.defineProperty(exports, "isRequired", {
      enumerable: !0,
      get: function() {
        return _filterItems.isRequired;
      }
    });
    Object.defineProperty(exports, "prettifyTargets", {
      enumerable: !0,
      get: function() {
        return _pretty.prettifyTargets;
      }
    });
    Object.defineProperty(exports, "unreleasedLabels", {
      enumerable: !0,
      get: function() {
        return _targets.unreleasedLabels;
      }
    });
    var _browserslist = require_browserslist(), _helperValidatorOption = require_lib13(), _lruCache = require_lru_cache(), _utils = require_utils3(), _targets = require_targets(), _options = require_options2(), _pretty = require_pretty(), _debug = require_debug(), _filterItems = require_filter_items(), browserModulesData = require_native_modules2(), ESM_SUPPORT = browserModulesData["es6.module"], v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
    function validateTargetNames(targets) {
      let validTargets = Object.keys(_options.TargetNames);
      for (let target of Object.keys(targets))
        if (!(target in _options.TargetNames))
          throw new Error(v.formatMessage(`'${target}' is not a valid target
- Did you mean '${(0, _helperValidatorOption.findSuggestion)(target, validTargets)}'?`));
      return targets;
    }
    function isBrowsersQueryValid(browsers) {
      return typeof browsers == "string" || Array.isArray(browsers) && browsers.every((b) => typeof b == "string");
    }
    function validateBrowsers(browsers) {
      return v.invariant(browsers === void 0 || isBrowsersQueryValid(browsers), `'${String(browsers)}' is not a valid browserslist query`), browsers;
    }
    function getLowestVersions(browsers) {
      return browsers.reduce((all, browser) => {
        let [browserName, browserVersion] = browser.split(" "), target = _targets.browserNameMap[browserName];
        if (!target)
          return all;
        try {
          let splitVersion = browserVersion.split("-")[0].toLowerCase(), isSplitUnreleased = (0, _utils.isUnreleasedVersion)(splitVersion, target);
          if (!all[target])
            return all[target] = isSplitUnreleased ? splitVersion : (0, _utils.semverify)(splitVersion), all;
          let version = all[target], isUnreleased = (0, _utils.isUnreleasedVersion)(version, target);
          if (isUnreleased && isSplitUnreleased)
            all[target] = (0, _utils.getLowestUnreleased)(version, splitVersion, target);
          else if (isUnreleased)
            all[target] = (0, _utils.semverify)(splitVersion);
          else if (!isUnreleased && !isSplitUnreleased) {
            let parsedBrowserVersion = (0, _utils.semverify)(splitVersion);
            all[target] = (0, _utils.semverMin)(version, parsedBrowserVersion);
          }
        } catch {
        }
        return all;
      }, {});
    }
    function outputDecimalWarning(decimalTargets) {
      decimalTargets.length && (console.warn(`Warning, the following targets are using a decimal version:
`), decimalTargets.forEach(({
        target,
        value: value2
      }) => console.warn(`  ${target}: ${value2}`)), console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`));
    }
    function semverifyTarget(target, value2) {
      try {
        return (0, _utils.semverify)(value2);
      } catch {
        throw new Error(v.formatMessage(`'${value2}' is not a valid value for 'targets.${target}'.`));
      }
    }
    function nodeTargetParser(value2) {
      return ["node", value2 === !0 || value2 === "current" ? process.versions.node.split("-")[0] : semverifyTarget("node", value2)];
    }
    function defaultTargetParser(target, value2) {
      let version = (0, _utils.isUnreleasedVersion)(value2, target) ? value2.toLowerCase() : semverifyTarget(target, value2);
      return [target, version];
    }
    function generateTargets(inputTargets) {
      let input = Object.assign({}, inputTargets);
      return delete input.esmodules, delete input.browsers, input;
    }
    function resolveTargets(queries, env) {
      let resolved = _browserslist(queries, {
        mobileToDesktop: !0,
        env
      });
      return getLowestVersions(resolved);
    }
    var targetsCache = new _lruCache({
      max: 64
    });
    function resolveTargetsCached(queries, env) {
      let cacheKey = typeof queries == "string" ? queries : queries.join() + env, cached = targetsCache.get(cacheKey);
      return cached || (cached = resolveTargets(queries, env), targetsCache.set(cacheKey, cached)), Object.assign({}, cached);
    }
    function getTargets(inputTargets = {}, options = {}) {
      var _browsers, _browsers2;
      let {
        browsers,
        esmodules
      } = inputTargets, {
        configPath = ".",
        onBrowserslistConfigFound
      } = options;
      validateBrowsers(browsers);
      let input = generateTargets(inputTargets), targets = validateTargetNames(input), hasTargets = !!browsers || Object.keys(targets).length > 0, shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;
      if (!browsers && shouldSearchForConfig) {
        if (browsers = process.env.BROWSERSLIST, !browsers) {
          let configFile = options.configFile || process.env.BROWSERSLIST_CONFIG || _browserslist.findConfigFile(configPath);
          configFile != null && (onBrowserslistConfigFound?.(configFile), browsers = _browserslist.loadConfig({
            config: configFile,
            env: options.browserslistEnv
          }));
        }
        browsers == null && (browsers = []);
      }
      if (esmodules && (esmodules !== "intersect" || !((_browsers = browsers) != null && _browsers.length)) && (browsers = Object.keys(ESM_SUPPORT).map((browser) => `${browser} >= ${ESM_SUPPORT[browser]}`).join(", "), esmodules = !1), (_browsers2 = browsers) != null && _browsers2.length) {
        let queryBrowsers = resolveTargetsCached(browsers, options.browserslistEnv);
        if (esmodules === "intersect")
          for (let browser of Object.keys(queryBrowsers))
            if (browser !== "deno" && browser !== "ie") {
              let esmSupportVersion = ESM_SUPPORT[browser === "opera_mobile" ? "op_mob" : browser];
              if (esmSupportVersion) {
                let version = queryBrowsers[browser];
                queryBrowsers[browser] = (0, _utils.getHighestUnreleased)(version, (0, _utils.semverify)(esmSupportVersion), browser);
              } else
                delete queryBrowsers[browser];
            } else
              delete queryBrowsers[browser];
        targets = Object.assign(queryBrowsers, targets);
      }
      let result = {}, decimalWarnings = [];
      for (let target of Object.keys(targets).sort()) {
        let value2 = targets[target];
        typeof value2 == "number" && value2 % 1 !== 0 && decimalWarnings.push({
          target,
          value: value2
        });
        let [parsedTarget, parsedValue] = target === "node" ? nodeTargetParser(value2) : defaultTargetParser(target, value2);
        parsedValue && (result[parsedTarget] = parsedValue);
      }
      return outputDecimalWarning(decimalWarnings), result;
    }
  }
});

// ../node_modules/@babel/core/lib/config/resolve-targets.js
var require_resolve_targets = __commonJS({
  "../node_modules/@babel/core/lib/config/resolve-targets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.resolveBrowserslistConfigFile = resolveBrowserslistConfigFile;
    exports.resolveTargets = resolveTargets;
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    function _helperCompilationTargets() {
      let data = require_lib14();
      return _helperCompilationTargets = function() {
        return data;
      }, data;
    }
    function resolveBrowserslistConfigFile(browserslistConfigFile, configFileDir) {
      return _path().resolve(configFileDir, browserslistConfigFile);
    }
    function resolveTargets(options, root) {
      let optTargets = options.targets, targets;
      typeof optTargets == "string" || Array.isArray(optTargets) ? targets = {
        browsers: optTargets
      } : optTargets && ("esmodules" in optTargets ? targets = Object.assign({}, optTargets, {
        esmodules: "intersect"
      }) : targets = optTargets);
      let {
        browserslistConfigFile
      } = options, configFile, ignoreBrowserslistConfig = !1;
      return typeof browserslistConfigFile == "string" ? configFile = browserslistConfigFile : ignoreBrowserslistConfig = browserslistConfigFile === !1, (0, _helperCompilationTargets().default)(targets, {
        ignoreBrowserslistConfig,
        configFile,
        configPath: root,
        browserslistEnv: options.browserslistEnv
      });
    }
  }
});

// ../node_modules/@babel/core/lib/config/config-descriptors.js
var require_config_descriptors = __commonJS({
  "../node_modules/@babel/core/lib/config/config-descriptors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.createCachedDescriptors = createCachedDescriptors;
    exports.createDescriptor = createDescriptor;
    exports.createUncachedDescriptors = createUncachedDescriptors;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var _functional = require_functional(), _index = require_files(), _item = require_item(), _caching = require_caching(), _resolveTargets = require_resolve_targets();
    function isEqualDescriptor(a, b) {
      var _a$file, _b$file, _a$file2, _b$file2;
      return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && ((_a$file = a.file) == null ? void 0 : _a$file.request) === ((_b$file = b.file) == null ? void 0 : _b$file.request) && ((_a$file2 = a.file) == null ? void 0 : _a$file2.resolved) === ((_b$file2 = b.file) == null ? void 0 : _b$file2.resolved);
    }
    function* handlerOf(value2) {
      return value2;
    }
    function optionsWithResolvedBrowserslistConfigFile(options, dirname) {
      return typeof options.browserslistConfigFile == "string" && (options.browserslistConfigFile = (0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile, dirname)), options;
    }
    function createCachedDescriptors(dirname, options, alias) {
      let {
        plugins,
        presets,
        passPerPreset
      } = options;
      return {
        options: optionsWithResolvedBrowserslistConfigFile(options, dirname),
        plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname)(alias) : () => handlerOf([]),
        presets: presets ? () => createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset) : () => handlerOf([])
      };
    }
    function createUncachedDescriptors(dirname, options, alias) {
      return {
        options: optionsWithResolvedBrowserslistConfigFile(options, dirname),
        plugins: (0, _functional.once)(() => createPluginDescriptors(options.plugins || [], dirname, alias)),
        presets: (0, _functional.once)(() => createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset))
      };
    }
    var PRESET_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap(), createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {
      let dirname = cache.using((dir) => dir);
      return (0, _caching.makeStrongCacheSync)((alias) => (0, _caching.makeStrongCache)(function* (passPerPreset) {
        return (yield* createPresetDescriptors(items, dirname, alias, passPerPreset)).map((desc) => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc));
      }));
    }), PLUGIN_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap(), createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {
      let dirname = cache.using((dir) => dir);
      return (0, _caching.makeStrongCache)(function* (alias) {
        return (yield* createPluginDescriptors(items, dirname, alias)).map((desc) => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc));
      });
    }), DEFAULT_OPTIONS = {};
    function loadCachedDescriptor(cache, desc) {
      let {
        value: value2,
        options = DEFAULT_OPTIONS
      } = desc;
      if (options === !1) return desc;
      let cacheByOptions = cache.get(value2);
      cacheByOptions || (cacheByOptions = /* @__PURE__ */ new WeakMap(), cache.set(value2, cacheByOptions));
      let possibilities = cacheByOptions.get(options);
      if (possibilities || (possibilities = [], cacheByOptions.set(options, possibilities)), !possibilities.includes(desc)) {
        let matches = possibilities.filter((possibility) => isEqualDescriptor(possibility, desc));
        if (matches.length > 0)
          return matches[0];
        possibilities.push(desc);
      }
      return desc;
    }
    function* createPresetDescriptors(items, dirname, alias, passPerPreset) {
      return yield* createDescriptors("preset", items, dirname, alias, passPerPreset);
    }
    function* createPluginDescriptors(items, dirname, alias) {
      return yield* createDescriptors("plugin", items, dirname, alias);
    }
    function* createDescriptors(type, items, dirname, alias, ownPass) {
      let descriptors = yield* _gensync().all(items.map((item, index) => createDescriptor(item, dirname, {
        type,
        alias: `${alias}$${index}`,
        ownPass: !!ownPass
      })));
      return assertNoDuplicates(descriptors), descriptors;
    }
    function* createDescriptor(pair, dirname, {
      type,
      alias,
      ownPass
    }) {
      let desc = (0, _item.getItemDescriptor)(pair);
      if (desc)
        return desc;
      let name, options, value2 = pair;
      Array.isArray(value2) && (value2.length === 3 ? [value2, options, name] = value2 : [value2, options] = value2);
      let file, filepath = null;
      if (typeof value2 == "string") {
        if (typeof type != "string")
          throw new Error("To resolve a string-based item, the type of item must be given");
        let resolver = type === "plugin" ? _index.loadPlugin : _index.loadPreset, request = value2;
        ({
          filepath,
          value: value2
        } = yield* resolver(value2, dirname)), file = {
          request,
          resolved: filepath
        };
      }
      if (!value2)
        throw new Error(`Unexpected falsy value: ${String(value2)}`);
      if (typeof value2 == "object" && value2.__esModule)
        if (value2.default)
          value2 = value2.default;
        else
          throw new Error("Must export a default export when using ES6 modules.");
      if (typeof value2 != "object" && typeof value2 != "function")
        throw new Error(`Unsupported format: ${typeof value2}. Expected an object or a function.`);
      if (filepath !== null && typeof value2 == "object" && value2)
        throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);
      return {
        name,
        alias: filepath || alias,
        value: value2,
        options,
        dirname,
        ownPass,
        file
      };
    }
    function assertNoDuplicates(items) {
      let map = /* @__PURE__ */ new Map();
      for (let item of items) {
        if (typeof item.value != "function") continue;
        let nameMap = map.get(item.value);
        if (nameMap || (nameMap = /* @__PURE__ */ new Set(), map.set(item.value, nameMap)), nameMap.has(item.name)) {
          let conflicts = items.filter((i) => i.value === item.value);
          throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(conflicts, null, 2)}`].join(`
`));
        }
        nameMap.add(item.name);
      }
    }
  }
});

// ../node_modules/@babel/core/lib/config/item.js
var require_item = __commonJS({
  "../node_modules/@babel/core/lib/config/item.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.createConfigItem = createConfigItem;
    exports.createItemFromDescriptor = createItemFromDescriptor;
    exports.getItemDescriptor = getItemDescriptor;
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    var _configDescriptors = require_config_descriptors();
    function createItemFromDescriptor(desc) {
      return new ConfigItem(desc);
    }
    function* createConfigItem(value2, {
      dirname = ".",
      type
    } = {}) {
      let descriptor = yield* (0, _configDescriptors.createDescriptor)(value2, _path().resolve(dirname), {
        type,
        alias: "programmatic item"
      });
      return createItemFromDescriptor(descriptor);
    }
    var CONFIG_ITEM_BRAND = Symbol.for("@babel/core@7 - ConfigItem");
    function getItemDescriptor(item) {
      if (item != null && item[CONFIG_ITEM_BRAND])
        return item._descriptor;
    }
    var ConfigItem = class {
      constructor(descriptor) {
        this._descriptor = void 0, this[CONFIG_ITEM_BRAND] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = descriptor, Object.defineProperty(this, "_descriptor", {
          enumerable: !1
        }), Object.defineProperty(this, CONFIG_ITEM_BRAND, {
          enumerable: !1
        }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? {
          request: this._descriptor.file.request,
          resolved: this._descriptor.file.resolved
        } : void 0, Object.freeze(this);
      }
    };
    Object.freeze(ConfigItem.prototype);
  }
});

// ../node_modules/@babel/core/lib/config/validation/removed.js
var require_removed = __commonJS({
  "../node_modules/@babel/core/lib/config/validation/removed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _default = exports.default = {
      auxiliaryComment: {
        message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
      },
      blacklist: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      breakConfig: {
        message: "This is not a necessary option in Babel 6"
      },
      experimental: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      externalHelpers: {
        message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
      },
      extra: {
        message: ""
      },
      jsxPragma: {
        message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
      },
      loose: {
        message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
      },
      metadataUsedHelpers: {
        message: "Not required anymore as this is enabled by default"
      },
      modules: {
        message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
      },
      nonStandard: {
        message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
      },
      optional: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      sourceMapName: {
        message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
      },
      stage: {
        message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
      },
      whitelist: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      resolveModuleSource: {
        version: 6,
        message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
      },
      metadata: {
        version: 6,
        message: "Generated plugin metadata is always included in the output result"
      },
      sourceMapTarget: {
        version: 6,
        message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
      }
    };
  }
});

// ../node_modules/@babel/core/lib/config/validation/option-assertions.js
var require_option_assertions = __commonJS({
  "../node_modules/@babel/core/lib/config/validation/option-assertions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.access = access;
    exports.assertArray = assertArray;
    exports.assertAssumptions = assertAssumptions;
    exports.assertBabelrcSearch = assertBabelrcSearch;
    exports.assertBoolean = assertBoolean;
    exports.assertCallerMetadata = assertCallerMetadata;
    exports.assertCompact = assertCompact;
    exports.assertConfigApplicableTest = assertConfigApplicableTest;
    exports.assertConfigFileSearch = assertConfigFileSearch;
    exports.assertFunction = assertFunction;
    exports.assertIgnoreList = assertIgnoreList;
    exports.assertInputSourceMap = assertInputSourceMap;
    exports.assertObject = assertObject;
    exports.assertPluginList = assertPluginList;
    exports.assertRootMode = assertRootMode;
    exports.assertSourceMaps = assertSourceMaps;
    exports.assertSourceType = assertSourceType;
    exports.assertString = assertString;
    exports.assertTargets = assertTargets;
    exports.msg = msg;
    function _helperCompilationTargets() {
      let data = require_lib14();
      return _helperCompilationTargets = function() {
        return data;
      }, data;
    }
    var _options = require_options3();
    function msg(loc) {
      switch (loc.type) {
        case "root":
          return "";
        case "env":
          return `${msg(loc.parent)}.env["${loc.name}"]`;
        case "overrides":
          return `${msg(loc.parent)}.overrides[${loc.index}]`;
        case "option":
          return `${msg(loc.parent)}.${loc.name}`;
        case "access":
          return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;
        default:
          throw new Error(`Assertion failure: Unknown type ${loc.type}`);
      }
    }
    function access(loc, name) {
      return {
        type: "access",
        name,
        parent: loc
      };
    }
    function assertRootMode(loc, value2) {
      if (value2 !== void 0 && value2 !== "root" && value2 !== "upward" && value2 !== "upward-optional")
        throw new Error(`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`);
      return value2;
    }
    function assertSourceMaps(loc, value2) {
      if (value2 !== void 0 && typeof value2 != "boolean" && value2 !== "inline" && value2 !== "both")
        throw new Error(`${msg(loc)} must be a boolean, "inline", "both", or undefined`);
      return value2;
    }
    function assertCompact(loc, value2) {
      if (value2 !== void 0 && typeof value2 != "boolean" && value2 !== "auto")
        throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);
      return value2;
    }
    function assertSourceType(loc, value2) {
      if (value2 !== void 0 && value2 !== "module" && value2 !== "commonjs" && value2 !== "script" && value2 !== "unambiguous")
        throw new Error(`${msg(loc)} must be "module", "commonjs", "script", "unambiguous", or undefined`);
      return value2;
    }
    function assertCallerMetadata(loc, value2) {
      let obj = assertObject(loc, value2);
      if (obj) {
        if (typeof obj.name != "string")
          throw new Error(`${msg(loc)} set but does not contain "name" property string`);
        for (let prop of Object.keys(obj)) {
          let propLoc = access(loc, prop), value3 = obj[prop];
          if (value3 != null && typeof value3 != "boolean" && typeof value3 != "string" && typeof value3 != "number")
            throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);
        }
      }
      return value2;
    }
    function assertInputSourceMap(loc, value2) {
      if (value2 !== void 0 && typeof value2 != "boolean" && (typeof value2 != "object" || !value2))
        throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);
      return value2;
    }
    function assertString(loc, value2) {
      if (value2 !== void 0 && typeof value2 != "string")
        throw new Error(`${msg(loc)} must be a string, or undefined`);
      return value2;
    }
    function assertFunction(loc, value2) {
      if (value2 !== void 0 && typeof value2 != "function")
        throw new Error(`${msg(loc)} must be a function, or undefined`);
      return value2;
    }
    function assertBoolean(loc, value2) {
      if (value2 !== void 0 && typeof value2 != "boolean")
        throw new Error(`${msg(loc)} must be a boolean, or undefined`);
      return value2;
    }
    function assertObject(loc, value2) {
      if (value2 !== void 0 && (typeof value2 != "object" || Array.isArray(value2) || !value2))
        throw new Error(`${msg(loc)} must be an object, or undefined`);
      return value2;
    }
    function assertArray(loc, value2) {
      if (value2 != null && !Array.isArray(value2))
        throw new Error(`${msg(loc)} must be an array, or undefined`);
      return value2;
    }
    function assertIgnoreList(loc, value2) {
      let arr = assertArray(loc, value2);
      return arr?.forEach((item, i) => assertIgnoreItem(access(loc, i), item)), arr;
    }
    function assertIgnoreItem(loc, value2) {
      if (typeof value2 != "string" && typeof value2 != "function" && !(value2 instanceof RegExp))
        throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);
      return value2;
    }
    function assertConfigApplicableTest(loc, value2) {
      if (value2 === void 0)
        return value2;
      if (Array.isArray(value2))
        value2.forEach((item, i) => {
          if (!checkValidTest(item))
            throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
        });
      else if (!checkValidTest(value2))
        throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);
      return value2;
    }
    function checkValidTest(value2) {
      return typeof value2 == "string" || typeof value2 == "function" || value2 instanceof RegExp;
    }
    function assertConfigFileSearch(loc, value2) {
      if (value2 !== void 0 && typeof value2 != "boolean" && typeof value2 != "string")
        throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, got ${JSON.stringify(value2)}`);
      return value2;
    }
    function assertBabelrcSearch(loc, value2) {
      if (value2 === void 0 || typeof value2 == "boolean")
        return value2;
      if (Array.isArray(value2))
        value2.forEach((item, i) => {
          if (!checkValidTest(item))
            throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
        });
      else if (!checkValidTest(value2))
        throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(value2)}`);
      return value2;
    }
    function assertPluginList(loc, value2) {
      let arr = assertArray(loc, value2);
      return arr && arr.forEach((item, i) => assertPluginItem(access(loc, i), item)), arr;
    }
    function assertPluginItem(loc, value2) {
      if (Array.isArray(value2)) {
        if (value2.length === 0)
          throw new Error(`${msg(loc)} must include an object`);
        if (value2.length > 3)
          throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);
        if (assertPluginTarget(access(loc, 0), value2[0]), value2.length > 1) {
          let opts = value2[1];
          if (opts !== void 0 && opts !== !1 && (typeof opts != "object" || Array.isArray(opts) || opts === null))
            throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);
        }
        if (value2.length === 3) {
          let name = value2[2];
          if (name !== void 0 && typeof name != "string")
            throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);
        }
      } else
        assertPluginTarget(loc, value2);
      return value2;
    }
    function assertPluginTarget(loc, value2) {
      if ((typeof value2 != "object" || !value2) && typeof value2 != "string" && typeof value2 != "function")
        throw new Error(`${msg(loc)} must be a string, object, function`);
      return value2;
    }
    function assertTargets(loc, value2) {
      if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value2)) return value2;
      if (typeof value2 != "object" || !value2 || Array.isArray(value2))
        throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);
      let browsersLoc = access(loc, "browsers"), esmodulesLoc = access(loc, "esmodules");
      assertBrowsersList(browsersLoc, value2.browsers), assertBoolean(esmodulesLoc, value2.esmodules);
      for (let key of Object.keys(value2)) {
        let val = value2[key], subLoc = access(loc, key);
        if (key === "esmodules") assertBoolean(subLoc, val);
        else if (key === "browsers") assertBrowsersList(subLoc, val);
        else if (hasOwnProperty.call(_helperCompilationTargets().TargetNames, key))
          assertBrowserVersion(subLoc, val);
        else {
          let validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(", ");
          throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);
        }
      }
      return value2;
    }
    function assertBrowsersList(loc, value2) {
      if (value2 !== void 0 && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value2))
        throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`);
    }
    function assertBrowserVersion(loc, value2) {
      if (!(typeof value2 == "number" && Math.round(value2) === value2) && typeof value2 != "string")
        throw new Error(`${msg(loc)} must be a string or an integer number`);
    }
    function assertAssumptions(loc, value2) {
      if (value2 === void 0) return;
      if (typeof value2 != "object" || value2 === null)
        throw new Error(`${msg(loc)} must be an object or undefined.`);
      let root = loc;
      do
        root = root.parent;
      while (root.type !== "root");
      let inPreset = root.source === "preset";
      for (let name of Object.keys(value2)) {
        let subLoc = access(loc, name);
        if (!_options.assumptionsNames.has(name))
          throw new Error(`${msg(subLoc)} is not a supported assumption.`);
        if (typeof value2[name] != "boolean")
          throw new Error(`${msg(subLoc)} must be a boolean.`);
        if (inPreset && value2[name] === !1)
          throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`);
      }
      return value2;
    }
  }
});

// ../node_modules/@babel/core/lib/config/validation/options.js
var require_options3 = __commonJS({
  "../node_modules/@babel/core/lib/config/validation/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.assumptionsNames = void 0;
    exports.checkNoUnwrappedItemOptionPairs = checkNoUnwrappedItemOptionPairs;
    exports.validate = validate;
    var _removed = require_removed(), _optionAssertions = require_option_assertions(), _configError = require_config_error(), ROOT_VALIDATORS = {
      cwd: _optionAssertions.assertString,
      root: _optionAssertions.assertString,
      rootMode: _optionAssertions.assertRootMode,
      configFile: _optionAssertions.assertConfigFileSearch,
      caller: _optionAssertions.assertCallerMetadata,
      filename: _optionAssertions.assertString,
      filenameRelative: _optionAssertions.assertString,
      code: _optionAssertions.assertBoolean,
      ast: _optionAssertions.assertBoolean,
      cloneInputAst: _optionAssertions.assertBoolean,
      envName: _optionAssertions.assertString
    }, BABELRC_VALIDATORS = {
      babelrc: _optionAssertions.assertBoolean,
      babelrcRoots: _optionAssertions.assertBabelrcSearch
    }, NONPRESET_VALIDATORS = {
      extends: _optionAssertions.assertString,
      ignore: _optionAssertions.assertIgnoreList,
      only: _optionAssertions.assertIgnoreList,
      targets: _optionAssertions.assertTargets,
      browserslistConfigFile: _optionAssertions.assertConfigFileSearch,
      browserslistEnv: _optionAssertions.assertString
    }, COMMON_VALIDATORS = {
      inputSourceMap: _optionAssertions.assertInputSourceMap,
      presets: _optionAssertions.assertPluginList,
      plugins: _optionAssertions.assertPluginList,
      passPerPreset: _optionAssertions.assertBoolean,
      assumptions: _optionAssertions.assertAssumptions,
      env: assertEnvSet,
      overrides: assertOverridesList,
      test: _optionAssertions.assertConfigApplicableTest,
      include: _optionAssertions.assertConfigApplicableTest,
      exclude: _optionAssertions.assertConfigApplicableTest,
      retainLines: _optionAssertions.assertBoolean,
      comments: _optionAssertions.assertBoolean,
      shouldPrintComment: _optionAssertions.assertFunction,
      compact: _optionAssertions.assertCompact,
      minified: _optionAssertions.assertBoolean,
      auxiliaryCommentBefore: _optionAssertions.assertString,
      auxiliaryCommentAfter: _optionAssertions.assertString,
      sourceType: _optionAssertions.assertSourceType,
      wrapPluginVisitorMethod: _optionAssertions.assertFunction,
      highlightCode: _optionAssertions.assertBoolean,
      sourceMaps: _optionAssertions.assertSourceMaps,
      sourceMap: _optionAssertions.assertSourceMaps,
      sourceFileName: _optionAssertions.assertString,
      sourceRoot: _optionAssertions.assertString,
      parserOpts: _optionAssertions.assertObject,
      generatorOpts: _optionAssertions.assertObject
    };
    Object.assign(COMMON_VALIDATORS, {
      getModuleId: _optionAssertions.assertFunction,
      moduleRoot: _optionAssertions.assertString,
      moduleIds: _optionAssertions.assertBoolean,
      moduleId: _optionAssertions.assertString
    });
    var knownAssumptions = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUninitializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"], assumptionsNames = exports.assumptionsNames = new Set(knownAssumptions);
    function getSource(loc) {
      return loc.type === "root" ? loc.source : getSource(loc.parent);
    }
    function validate(type, opts, filename) {
      try {
        return validateNested({
          type: "root",
          source: type
        }, opts);
      } catch (error) {
        let configError = new _configError.default(error.message, filename);
        throw error.code && (configError.code = error.code), configError;
      }
    }
    function validateNested(loc, opts) {
      let type = getSource(loc);
      return assertNoDuplicateSourcemap(opts), Object.keys(opts).forEach((key) => {
        let optLoc = {
          type: "option",
          name: key,
          parent: loc
        };
        if (type === "preset" && NONPRESET_VALIDATORS[key])
          throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);
        if (type !== "arguments" && ROOT_VALIDATORS[key])
          throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);
        if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key])
          throw type === "babelrcfile" || type === "extendsfile" ? new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);
        (COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError)(optLoc, opts[key]);
      }), opts;
    }
    function throwUnknownError(loc) {
      let key = loc.name;
      if (_removed.default[key]) {
        let {
          message,
          version = 5
        } = _removed.default[key];
        throw new Error(`Using removed Babel ${version} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);
      } else {
        let unknownOptErr = new Error(`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
        throw unknownOptErr.code = "BABEL_UNKNOWN_OPTION", unknownOptErr;
      }
    }
    function assertNoDuplicateSourcemap(opts) {
      if (hasOwnProperty.call(opts, "sourceMap") && hasOwnProperty.call(opts, "sourceMaps"))
        throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
    }
    function assertEnvSet(loc, value2) {
      if (loc.parent.type === "env")
        throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);
      let parent = loc.parent, obj = (0, _optionAssertions.assertObject)(loc, value2);
      if (obj)
        for (let envName of Object.keys(obj)) {
          let env = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);
          if (!env) continue;
          validateNested({
            type: "env",
            name: envName,
            parent
          }, env);
        }
      return obj;
    }
    function assertOverridesList(loc, value2) {
      if (loc.parent.type === "env")
        throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);
      if (loc.parent.type === "overrides")
        throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);
      let parent = loc.parent, arr = (0, _optionAssertions.assertArray)(loc, value2);
      if (arr)
        for (let [index, item] of arr.entries()) {
          let objLoc = (0, _optionAssertions.access)(loc, index), env = (0, _optionAssertions.assertObject)(objLoc, item);
          if (!env) throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);
          validateNested({
            type: "overrides",
            index,
            parent
          }, env);
        }
      return arr;
    }
    function checkNoUnwrappedItemOptionPairs(items, index, type, e) {
      if (index === 0) return;
      let lastItem = items[index - 1], thisItem = items[index];
      lastItem.file && lastItem.options === void 0 && typeof thisItem.value == "object" && (e.message += `
- Maybe you meant to use
"${type}s": [
  ["${lastItem.file.request}", ${JSON.stringify(thisItem.value, void 0, 2)}]
]
To be a valid ${type}, its name and options should be wrapped in a pair of brackets`);
    }
  }
});

// ../node_modules/@babel/core/lib/config/pattern-to-regex.js
var require_pattern_to_regex = __commonJS({
  "../node_modules/@babel/core/lib/config/pattern-to-regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = pathToPattern;
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    var sep = `\\${_path().sep}`, endSep = `(?:${sep}|$)`, substitution = `[^${sep}]+`, starPat = `(?:${substitution}${sep})`, starPatLast = `(?:${substitution}${endSep})`, starStarPat = `${starPat}*?`, starStarPatLast = `${starPat}*?${starPatLast}?`;
    function escapeRegExp(string) {
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
    }
    function pathToPattern(pattern, dirname) {
      let parts = _path().resolve(dirname, pattern).split(_path().sep);
      return new RegExp(["^", ...parts.map((part, i) => {
        let last = i === parts.length - 1;
        return part === "**" ? last ? starStarPatLast : starStarPat : part === "*" ? last ? starPatLast : starPat : part.indexOf("*.") === 0 ? substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep) : escapeRegExp(part) + (last ? endSep : sep);
      })].join(""));
    }
  }
});

// ../node_modules/@babel/core/lib/config/printer.js
var require_printer2 = __commonJS({
  "../node_modules/@babel/core/lib/config/printer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ConfigPrinter = exports.ChainFormatter = void 0;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var ChainFormatter = exports.ChainFormatter = {
      Programmatic: 0,
      Config: 1
    }, Formatter = {
      title(type, callerName, filepath) {
        let title = "";
        return type === ChainFormatter.Programmatic ? (title = "programmatic options", callerName && (title += " from " + callerName)) : title = "config " + filepath, title;
      },
      loc(index, envName) {
        let loc = "";
        return index != null && (loc += `.overrides[${index}]`), envName != null && (loc += `.env["${envName}"]`), loc;
      },
      *optionsAndDescriptors(opt) {
        let content = Object.assign({}, opt.options);
        delete content.overrides, delete content.env;
        let pluginDescriptors = [...yield* opt.plugins()];
        pluginDescriptors.length && (content.plugins = pluginDescriptors.map((d) => descriptorToConfig(d)));
        let presetDescriptors = [...yield* opt.presets()];
        return presetDescriptors.length && (content.presets = [...presetDescriptors].map((d) => descriptorToConfig(d))), JSON.stringify(content, void 0, 2);
      }
    };
    function descriptorToConfig(d) {
      var _d$file;
      let name = (_d$file = d.file) == null ? void 0 : _d$file.request;
      return name == null && (typeof d.value == "object" ? name = d.value : typeof d.value == "function" && (name = `[Function: ${d.value.toString().slice(0, 50)} ... ]`)), name == null && (name = "[Unknown]"), d.options === void 0 ? name : d.name == null ? [name, d.options] : [name, d.options, d.name];
    }
    var ConfigPrinter = class _ConfigPrinter {
      constructor() {
        this._stack = [];
      }
      configure(enabled, type, {
        callerName,
        filepath
      }) {
        return enabled ? (content, index, envName) => {
          this._stack.push({
            type,
            callerName,
            filepath,
            content,
            index,
            envName
          });
        } : () => {
        };
      }
      static *format(config) {
        let title = Formatter.title(config.type, config.callerName, config.filepath), loc = Formatter.loc(config.index, config.envName);
        loc && (title += ` ${loc}`);
        let content = yield* Formatter.optionsAndDescriptors(config.content);
        return `${title}
${content}`;
      }
      *output() {
        return this._stack.length === 0 ? "" : (yield* _gensync().all(this._stack.map((s) => _ConfigPrinter.format(s)))).join(`

`);
      }
    };
    exports.ConfigPrinter = ConfigPrinter;
  }
});

// ../node_modules/@babel/core/lib/config/config-chain.js
var require_config_chain = __commonJS({
  "../node_modules/@babel/core/lib/config/config-chain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.buildPresetChain = buildPresetChain;
    exports.buildPresetChainWalker = void 0;
    exports.buildRootChain = buildRootChain;
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    function _debug() {
      let data = require_src();
      return _debug = function() {
        return data;
      }, data;
    }
    var _options = require_options3(), _patternToRegex = require_pattern_to_regex(), _printer = require_printer2(), _rewriteStackTrace = require_rewrite_stack_trace(), _configError = require_config_error(), _index = require_files(), _caching = require_caching(), _configDescriptors = require_config_descriptors(), debug = _debug()("babel:config:config-chain");
    function* buildPresetChain(arg, context) {
      let chain = yield* buildPresetChainWalker(arg, context);
      return chain ? {
        plugins: dedupDescriptors(chain.plugins),
        presets: dedupDescriptors(chain.presets),
        options: chain.options.map((o) => createConfigChainOptions(o)),
        files: /* @__PURE__ */ new Set()
      } : null;
    }
    var buildPresetChainWalker = exports.buildPresetChainWalker = makeChainWalker({
      root: (preset) => loadPresetDescriptors(preset),
      env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),
      overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),
      overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName),
      createLogger: () => () => {
      }
    }), loadPresetDescriptors = (0, _caching.makeWeakCacheSync)((preset) => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors)), loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName))), loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index) => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index))), loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));
    function* buildRootChain(opts, context) {
      let configReport, babelRcReport, programmaticLogger = new _printer.ConfigPrinter(), programmaticChain = yield* loadProgrammaticChain({
        options: opts,
        dirname: context.cwd
      }, context, void 0, programmaticLogger);
      if (!programmaticChain) return null;
      let programmaticReport = yield* programmaticLogger.output(), configFile;
      typeof opts.configFile == "string" ? configFile = yield* (0, _index.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller) : opts.configFile !== !1 && (configFile = yield* (0, _index.findRootConfig)(context.root, context.envName, context.caller));
      let {
        babelrc,
        babelrcRoots
      } = opts, babelrcRootsDirectory = context.cwd, configFileChain = emptyChain(), configFileLogger = new _printer.ConfigPrinter();
      if (configFile) {
        let validatedFile = validateConfigFile(configFile), result = yield* loadFileChain(validatedFile, context, void 0, configFileLogger);
        if (!result) return null;
        configReport = yield* configFileLogger.output(), babelrc === void 0 && (babelrc = validatedFile.options.babelrc), babelrcRoots === void 0 && (babelrcRootsDirectory = validatedFile.dirname, babelrcRoots = validatedFile.options.babelrcRoots), mergeChain(configFileChain, result);
      }
      let ignoreFile, babelrcFile, isIgnored = !1, fileChain = emptyChain();
      if ((babelrc === !0 || babelrc === void 0) && typeof context.filename == "string") {
        let pkgData = yield* (0, _index.findPackageData)(context.filename);
        if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {
          if ({
            ignore: ignoreFile,
            config: babelrcFile
          } = yield* (0, _index.findRelativeConfig)(pkgData, context.envName, context.caller), ignoreFile && fileChain.files.add(ignoreFile.filepath), ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname) && (isIgnored = !0), babelrcFile && !isIgnored) {
            let validatedFile = validateBabelrcFile(babelrcFile), babelrcLogger = new _printer.ConfigPrinter(), result = yield* loadFileChain(validatedFile, context, void 0, babelrcLogger);
            result ? (babelRcReport = yield* babelrcLogger.output(), mergeChain(fileChain, result)) : isIgnored = !0;
          }
          babelrcFile && isIgnored && fileChain.files.add(babelrcFile.filepath);
        }
      }
      context.showConfig && console.log(`Babel configs on "${context.filename}" (ascending priority):
` + [configReport, babelRcReport, programmaticReport].filter((x) => !!x).join(`

`) + `
-----End Babel configs-----`);
      let chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
      return {
        plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),
        presets: isIgnored ? [] : dedupDescriptors(chain.presets),
        options: isIgnored ? [] : chain.options.map((o) => createConfigChainOptions(o)),
        fileHandling: isIgnored ? "ignored" : "transpile",
        ignore: ignoreFile || void 0,
        babelrc: babelrcFile || void 0,
        config: configFile || void 0,
        files: chain.files
      };
    }
    function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
      if (typeof babelrcRoots == "boolean") return babelrcRoots;
      let absoluteRoot = context.root;
      if (babelrcRoots === void 0)
        return pkgData.directories.includes(absoluteRoot);
      let babelrcPatterns = babelrcRoots;
      return Array.isArray(babelrcPatterns) || (babelrcPatterns = [babelrcPatterns]), babelrcPatterns = babelrcPatterns.map((pat) => typeof pat == "string" ? _path().resolve(babelrcRootsDirectory, pat) : pat), babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot ? pkgData.directories.includes(absoluteRoot) : babelrcPatterns.some((pat) => (typeof pat == "string" && (pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory)), pkgData.directories.some((directory) => matchPattern(pat, babelrcRootsDirectory, directory, context))));
    }
    var validateConfigFile = (0, _caching.makeWeakCacheSync)((file) => ({
      filepath: file.filepath,
      dirname: file.dirname,
      options: (0, _options.validate)("configfile", file.options, file.filepath)
    })), validateBabelrcFile = (0, _caching.makeWeakCacheSync)((file) => ({
      filepath: file.filepath,
      dirname: file.dirname,
      options: (0, _options.validate)("babelrcfile", file.options, file.filepath)
    })), validateExtendFile = (0, _caching.makeWeakCacheSync)((file) => ({
      filepath: file.filepath,
      dirname: file.dirname,
      options: (0, _options.validate)("extendsfile", file.options, file.filepath)
    })), loadProgrammaticChain = makeChainWalker({
      root: (input) => buildRootDescriptors(input, "base", _configDescriptors.createCachedDescriptors),
      env: (input, envName) => buildEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, envName),
      overrides: (input, index) => buildOverrideDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index),
      overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index, envName),
      createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)
    }), loadFileChainWalker = makeChainWalker({
      root: (file) => loadFileDescriptors(file),
      env: (file, envName) => loadFileEnvDescriptors(file)(envName),
      overrides: (file, index) => loadFileOverridesDescriptors(file)(index),
      overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName),
      createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)
    });
    function* loadFileChain(input, context, files, baseLogger) {
      let chain = yield* loadFileChainWalker(input, context, files, baseLogger);
      return chain?.files.add(input.filepath), chain;
    }
    var loadFileDescriptors = (0, _caching.makeWeakCacheSync)((file) => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors)), loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName))), loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index) => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index))), loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));
    function buildFileLogger(filepath, context, baseLogger) {
      return baseLogger ? baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {
        filepath
      }) : () => {
      };
    }
    function buildRootDescriptors({
      dirname,
      options
    }, alias, descriptors) {
      return descriptors(dirname, options, alias);
    }
    function buildProgrammaticLogger(_, context, baseLogger) {
      var _context$caller;
      return baseLogger ? baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {
        callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name
      }) : () => {
      };
    }
    function buildEnvDescriptors({
      dirname,
      options
    }, alias, descriptors, envName) {
      var _options$env;
      let opts = (_options$env = options.env) == null ? void 0 : _options$env[envName];
      return opts ? descriptors(dirname, opts, `${alias}.env["${envName}"]`) : null;
    }
    function buildOverrideDescriptors({
      dirname,
      options
    }, alias, descriptors, index) {
      var _options$overrides;
      let opts = (_options$overrides = options.overrides) == null ? void 0 : _options$overrides[index];
      if (!opts) throw new Error("Assertion failure - missing override");
      return descriptors(dirname, opts, `${alias}.overrides[${index}]`);
    }
    function buildOverrideEnvDescriptors({
      dirname,
      options
    }, alias, descriptors, index, envName) {
      var _options$overrides2, _override$env;
      let override = (_options$overrides2 = options.overrides) == null ? void 0 : _options$overrides2[index];
      if (!override) throw new Error("Assertion failure - missing override");
      let opts = (_override$env = override.env) == null ? void 0 : _override$env[envName];
      return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env["${envName}"]`) : null;
    }
    function makeChainWalker({
      root,
      env,
      overrides,
      overridesEnv,
      createLogger
    }) {
      return function* (input, context, files = /* @__PURE__ */ new Set(), baseLogger) {
        let {
          dirname
        } = input, flattenedConfigs = [], rootOpts = root(input);
        if (configIsApplicable(rootOpts, dirname, context, input.filepath)) {
          flattenedConfigs.push({
            config: rootOpts,
            envName: void 0,
            index: void 0
          });
          let envOpts = env(input, context.envName);
          envOpts && configIsApplicable(envOpts, dirname, context, input.filepath) && flattenedConfigs.push({
            config: envOpts,
            envName: context.envName,
            index: void 0
          }), (rootOpts.options.overrides || []).forEach((_, index) => {
            let overrideOps = overrides(input, index);
            if (configIsApplicable(overrideOps, dirname, context, input.filepath)) {
              flattenedConfigs.push({
                config: overrideOps,
                index,
                envName: void 0
              });
              let overrideEnvOpts = overridesEnv(input, index, context.envName);
              overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context, input.filepath) && flattenedConfigs.push({
                config: overrideEnvOpts,
                index,
                envName: context.envName
              });
            }
          });
        }
        if (flattenedConfigs.some(({
          config: {
            options: {
              ignore,
              only
            }
          }
        }) => shouldIgnore(context, ignore, only, dirname)))
          return null;
        let chain = emptyChain(), logger = createLogger(input, context, baseLogger);
        for (let {
          config,
          index,
          envName
        } of flattenedConfigs) {
          if (!(yield* mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger)))
            return null;
          logger(config, index, envName), yield* mergeChainOpts(chain, config);
        }
        return chain;
      };
    }
    function* mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {
      if (opts.extends === void 0) return !0;
      let file = yield* (0, _index.loadConfig)(opts.extends, dirname, context.envName, context.caller);
      if (files.has(file))
        throw new Error(`Configuration cycle detected loading ${file.filepath}.
File already loaded following the config chain:
` + Array.from(files, (file2) => ` - ${file2.filepath}`).join(`
`));
      files.add(file);
      let fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);
      return files.delete(file), fileChain ? (mergeChain(chain, fileChain), !0) : !1;
    }
    function mergeChain(target, source) {
      target.options.push(...source.options), target.plugins.push(...source.plugins), target.presets.push(...source.presets);
      for (let file of source.files)
        target.files.add(file);
      return target;
    }
    function* mergeChainOpts(target, {
      options,
      plugins,
      presets
    }) {
      return target.options.push(options), target.plugins.push(...yield* plugins()), target.presets.push(...yield* presets()), target;
    }
    function emptyChain() {
      return {
        options: [],
        presets: [],
        plugins: [],
        files: /* @__PURE__ */ new Set()
      };
    }
    function createConfigChainOptions(opts) {
      let options = Object.assign({}, opts);
      return delete options.extends, delete options.env, delete options.overrides, delete options.plugins, delete options.presets, delete options.passPerPreset, delete options.ignore, delete options.only, delete options.test, delete options.include, delete options.exclude, hasOwnProperty.call(options, "sourceMap") && (options.sourceMaps = options.sourceMap, delete options.sourceMap), options;
    }
    function dedupDescriptors(items) {
      let map = /* @__PURE__ */ new Map(), descriptors = [];
      for (let item of items)
        if (typeof item.value == "function") {
          let fnKey = item.value, nameMap = map.get(fnKey);
          nameMap || (nameMap = /* @__PURE__ */ new Map(), map.set(fnKey, nameMap));
          let desc = nameMap.get(item.name);
          desc ? desc.value = item : (desc = {
            value: item
          }, descriptors.push(desc), item.ownPass || nameMap.set(item.name, desc));
        } else
          descriptors.push({
            value: item
          });
      return descriptors.reduce((acc, desc) => (acc.push(desc.value), acc), []);
    }
    function configIsApplicable({
      options
    }, dirname, context, configName) {
      return (options.test === void 0 || configFieldIsApplicable(context, options.test, dirname, configName)) && (options.include === void 0 || configFieldIsApplicable(context, options.include, dirname, configName)) && (options.exclude === void 0 || !configFieldIsApplicable(context, options.exclude, dirname, configName));
    }
    function configFieldIsApplicable(context, test, dirname, configName) {
      let patterns = Array.isArray(test) ? test : [test];
      return matchesPatterns(context, patterns, dirname, configName);
    }
    function ignoreListReplacer(_key, value2) {
      return value2 instanceof RegExp ? String(value2) : value2;
    }
    function shouldIgnore(context, ignore, only, dirname) {
      if (ignore && matchesPatterns(context, ignore, dirname)) {
        var _context$filename;
        let message = `No config is applied to "${(_context$filename = context.filename) != null ? _context$filename : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\` from "${dirname}"`;
        return debug(message), context.showConfig && console.log(message), !0;
      }
      if (only && !matchesPatterns(context, only, dirname)) {
        var _context$filename2;
        let message = `No config is applied to "${(_context$filename2 = context.filename) != null ? _context$filename2 : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(only, ignoreListReplacer)}\` from "${dirname}"`;
        return debug(message), context.showConfig && console.log(message), !0;
      }
      return !1;
    }
    function matchesPatterns(context, patterns, dirname, configName) {
      return patterns.some((pattern) => matchPattern(pattern, dirname, context.filename, context, configName));
    }
    function matchPattern(pattern, dirname, pathToTest, context, configName) {
      if (typeof pattern == "function")
        return !!(0, _rewriteStackTrace.endHiddenCallStack)(pattern)(pathToTest, {
          dirname,
          envName: context.envName,
          caller: context.caller
        });
      if (typeof pathToTest != "string")
        throw new _configError.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", configName);
      return typeof pattern == "string" && (pattern = (0, _patternToRegex.default)(pattern, dirname)), pattern.test(pathToTest);
    }
  }
});

// ../node_modules/@babel/core/lib/config/validation/plugins.js
var require_plugins3 = __commonJS({
  "../node_modules/@babel/core/lib/config/validation/plugins.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.validatePluginObject = validatePluginObject;
    var _optionAssertions = require_option_assertions(), VALIDATORS = {
      name: _optionAssertions.assertString,
      manipulateOptions: _optionAssertions.assertFunction,
      pre: _optionAssertions.assertFunction,
      post: _optionAssertions.assertFunction,
      inherits: _optionAssertions.assertFunction,
      visitor: assertVisitorMap,
      parserOverride: _optionAssertions.assertFunction,
      generatorOverride: _optionAssertions.assertFunction
    };
    function assertVisitorMap(loc, value2) {
      let obj = (0, _optionAssertions.assertObject)(loc, value2);
      if (obj && (Object.keys(obj).forEach((prop) => {
        prop !== "_exploded" && prop !== "_verified" && assertVisitorHandler(prop, obj[prop]);
      }), obj.enter || obj.exit))
        throw new Error(`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
      return obj;
    }
    function assertVisitorHandler(key, value2) {
      if (value2 && typeof value2 == "object")
        Object.keys(value2).forEach((handler) => {
          if (handler !== "enter" && handler !== "exit")
            throw new Error(`.visitor["${key}"] may only have .enter and/or .exit handlers.`);
        });
      else if (typeof value2 != "function")
        throw new Error(`.visitor["${key}"] must be a function`);
    }
    function validatePluginObject(obj) {
      let rootPath = {
        type: "root",
        source: "plugin"
      };
      return Object.keys(obj).forEach((key) => {
        let validator = VALIDATORS[key];
        if (validator)
          validator({
            type: "option",
            name: key,
            parent: rootPath
          }, obj[key]);
        else {
          let invalidPluginPropertyError = new Error(`.${key} is not a valid Plugin property`);
          throw invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", invalidPluginPropertyError;
        }
      }), obj;
    }
  }
});

// ../node_modules/@babel/core/lib/config/helpers/environment.js
var require_environment = __commonJS({
  "../node_modules/@babel/core/lib/config/helpers/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.getEnv = getEnv;
    function getEnv(defaultValue = "development") {
      return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue;
    }
  }
});

// ../node_modules/@babel/core/lib/config/partial.js
var require_partial = __commonJS({
  "../node_modules/@babel/core/lib/config/partial.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = loadPrivatePartialConfig;
    exports.loadPartialConfig = loadPartialConfig;
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    var _plugin = require_plugin(), _util = require_util2(), _item = require_item(), _configChain = require_config_chain(), _environment = require_environment(), _options = require_options3(), _index = require_files(), _resolveTargets = require_resolve_targets(), _excluded = ["showIgnoredFiles"];
    function _objectWithoutPropertiesLoose(r, e) {
      if (r == null) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.indexOf(n) !== -1) continue;
        t[n] = r[n];
      }
      return t;
    }
    function resolveRootMode(rootDir, rootMode) {
      switch (rootMode) {
        case "root":
          return rootDir;
        case "upward-optional": {
          let upwardRootDir = (0, _index.findConfigUpwards)(rootDir);
          return upwardRootDir === null ? rootDir : upwardRootDir;
        }
        case "upward": {
          let upwardRootDir = (0, _index.findConfigUpwards)(rootDir);
          if (upwardRootDir !== null) return upwardRootDir;
          throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${rootDir}".
One of the following config files must be in the directory tree: "${_index.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
            code: "BABEL_ROOT_NOT_FOUND",
            dirname: rootDir
          });
        }
        default:
          throw new Error("Assertion failure - unknown rootMode value.");
      }
    }
    function* loadPrivatePartialConfig(inputOpts) {
      if (inputOpts != null && (typeof inputOpts != "object" || Array.isArray(inputOpts)))
        throw new Error("Babel options must be an object, null, or undefined");
      let args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {}, {
        envName = (0, _environment.getEnv)(),
        cwd = ".",
        root: rootDir = ".",
        rootMode = "root",
        caller,
        cloneInputAst = !0
      } = args, absoluteCwd = _path().resolve(cwd), absoluteRootDir = resolveRootMode(_path().resolve(absoluteCwd, rootDir), rootMode), filename = typeof args.filename == "string" ? _path().resolve(cwd, args.filename) : void 0, showConfigPath = yield* (0, _index.resolveShowConfigPath)(absoluteCwd), context = {
        filename,
        cwd: absoluteCwd,
        root: absoluteRootDir,
        envName,
        caller,
        showConfig: showConfigPath === filename
      }, configChain = yield* (0, _configChain.buildRootChain)(args, context);
      if (!configChain) return null;
      let merged = {
        assumptions: {}
      };
      return configChain.options.forEach((opts) => {
        (0, _util.mergeOptions)(merged, opts);
      }), {
        options: Object.assign({}, merged, {
          targets: (0, _resolveTargets.resolveTargets)(merged, absoluteRootDir),
          cloneInputAst,
          babelrc: !1,
          configFile: !1,
          browserslistConfigFile: !1,
          passPerPreset: !1,
          envName: context.envName,
          cwd: context.cwd,
          root: context.root,
          rootMode: "root",
          filename: typeof context.filename == "string" ? context.filename : void 0,
          plugins: configChain.plugins.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor)),
          presets: configChain.presets.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor))
        }),
        context,
        fileHandling: configChain.fileHandling,
        ignore: configChain.ignore,
        babelrc: configChain.babelrc,
        config: configChain.config,
        files: configChain.files
      };
    }
    function* loadPartialConfig(opts) {
      let showIgnoredFiles = !1;
      if (typeof opts == "object" && opts !== null && !Array.isArray(opts)) {
        var _opts = opts;
        ({
          showIgnoredFiles
        } = _opts), opts = _objectWithoutPropertiesLoose(_opts, _excluded);
      }
      let result = yield* loadPrivatePartialConfig(opts);
      if (!result) return null;
      let {
        options,
        babelrc,
        ignore,
        config,
        fileHandling,
        files
      } = result;
      return fileHandling === "ignored" && !showIgnoredFiles ? null : ((options.plugins || []).forEach((item) => {
        if (item.value instanceof _plugin.default)
          throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
      }), new PartialConfig(options, babelrc ? babelrc.filepath : void 0, ignore ? ignore.filepath : void 0, config ? config.filepath : void 0, fileHandling, files));
    }
    var PartialConfig = class {
      constructor(options, babelrc, ignore, config, fileHandling, files) {
        this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = options, this.babelignore = ignore, this.babelrc = babelrc, this.config = config, this.fileHandling = fileHandling, this.files = files, Object.freeze(this);
      }
      hasFilesystemConfig() {
        return this.babelrc !== void 0 || this.config !== void 0;
      }
    };
    Object.freeze(PartialConfig.prototype);
  }
});

// ../node_modules/@babel/core/lib/config/full.js
var require_full = __commonJS({
  "../node_modules/@babel/core/lib/config/full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var _async = require_async(), _util = require_util2(), context = require_lib27(), _plugin = require_plugin(), _item = require_item(), _configChain = require_config_chain(), _deepArray = require_deep_array();
    function _traverse() {
      let data = require_lib10();
      return _traverse = function() {
        return data;
      }, data;
    }
    var _caching = require_caching(), _options = require_options3(), _plugins = require_plugins3(), _configApi = require_config_api(), _partial = require_partial(), _configError = require_config_error(), _default = exports.default = _gensync()(function* (inputOpts) {
      var _opts$assumptions;
      let result = yield* (0, _partial.default)(inputOpts);
      if (!result)
        return null;
      let {
        options,
        context: context2,
        fileHandling
      } = result;
      if (fileHandling === "ignored")
        return null;
      let optionDefaults = {}, {
        plugins,
        presets
      } = options;
      if (!plugins || !presets)
        throw new Error("Assertion failure - plugins and presets exist");
      let presetContext = Object.assign({}, context2, {
        targets: options.targets
      }), toDescriptor = (item) => {
        let desc = (0, _item.getItemDescriptor)(item);
        if (!desc)
          throw new Error("Assertion failure - must be config item");
        return desc;
      }, presetsDescriptors = presets.map(toDescriptor), initialPluginsDescriptors = plugins.map(toDescriptor), pluginDescriptorsByPass = [[]], passes = [], externalDependencies = [];
      if (yield* enhanceError(context2, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
        let presets2 = [];
        for (let i = 0; i < rawPresets.length; i++) {
          let descriptor = rawPresets[i];
          if (descriptor.options !== !1) {
            try {
              var preset = yield* loadPresetDescriptor(descriptor, presetContext);
            } catch (e) {
              throw e.code === "BABEL_UNKNOWN_OPTION" && (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, "preset", e), e;
            }
            externalDependencies.push(preset.externalDependencies), descriptor.ownPass ? presets2.push({
              preset: preset.chain,
              pass: []
            }) : presets2.unshift({
              preset: preset.chain,
              pass: pluginDescriptorsPass
            });
          }
        }
        if (presets2.length > 0) {
          pluginDescriptorsByPass.splice(1, 0, ...presets2.map((o) => o.pass).filter((p) => p !== pluginDescriptorsPass));
          for (let {
            preset: preset2,
            pass
          } of presets2) {
            if (!preset2 || (pass.push(...preset2.plugins), yield* recursePresetDescriptors(preset2.presets, pass))) return !0;
            preset2.options.forEach((opts2) => {
              (0, _util.mergeOptions)(optionDefaults, opts2);
            });
          }
        }
      })(presetsDescriptors, pluginDescriptorsByPass[0])) return null;
      let opts = optionDefaults;
      (0, _util.mergeOptions)(opts, options);
      let pluginContext = Object.assign({}, presetContext, {
        assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}
      });
      return yield* enhanceError(context2, function* () {
        pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);
        for (let descs of pluginDescriptorsByPass) {
          let pass = [];
          passes.push(pass);
          for (let i = 0; i < descs.length; i++) {
            let descriptor = descs[i];
            if (descriptor.options !== !1) {
              try {
                var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);
              } catch (e) {
                throw e.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, "plugin", e), e;
              }
              pass.push(plugin), externalDependencies.push(plugin.externalDependencies);
            }
          }
        }
      })(), opts.plugins = passes[0], opts.presets = passes.slice(1).filter((plugins2) => plugins2.length > 0).map((plugins2) => ({
        plugins: plugins2
      })), opts.passPerPreset = opts.presets.length > 0, {
        options: opts,
        passes,
        externalDependencies: (0, _deepArray.finalize)(externalDependencies)
      };
    });
    function enhanceError(context2, fn) {
      return function* (arg1, arg2) {
        try {
          return yield* fn(arg1, arg2);
        } catch (e) {
          if (!/^\[BABEL\]/.test(e.message)) {
            var _context$filename;
            e.message = `[BABEL] ${(_context$filename = context2.filename) != null ? _context$filename : "unknown file"}: ${e.message}`;
          }
          throw e;
        }
      };
    }
    var makeDescriptorLoader = (apiFactory) => (0, _caching.makeWeakCache)(function* ({
      value: value2,
      options,
      dirname,
      alias
    }, cache) {
      if (options === !1) throw new Error("Assertion failure");
      options = options || {};
      let externalDependencies = [], item = value2;
      if (typeof value2 == "function") {
        let factory = (0, _async.maybeAsync)(value2, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), api = Object.assign({}, context, apiFactory(cache, externalDependencies));
        try {
          item = yield* factory(api, options, dirname);
        } catch (e) {
          throw alias && (e.message += ` (While processing: ${JSON.stringify(alias)})`), e;
        }
      }
      if (!item || typeof item != "object")
        throw new Error("Plugin/Preset did not return an object.");
      if ((0, _async.isThenable)(item))
        throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(alias)})`);
      if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === "forever")) {
        let error = `A plugin/preset has external untracked dependencies (${externalDependencies[0]}), but the cache `;
        throw cache.configured() ? error += " has been configured to never be invalidated. " : error += "has not been configured to be invalidated when the external dependencies change. ", error += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(alias)})`, new Error(error);
      }
      return {
        value: item,
        options,
        dirname,
        alias,
        externalDependencies: (0, _deepArray.finalize)(externalDependencies)
      };
    }), pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI), presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI), instantiatePlugin = (0, _caching.makeWeakCache)(function* ({
      value: value2,
      options,
      dirname,
      alias,
      externalDependencies
    }, cache) {
      let pluginObj = (0, _plugins.validatePluginObject)(value2), plugin = Object.assign({}, pluginObj);
      if (plugin.visitor && (plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor))), plugin.inherits) {
        let inheritsDescriptor = {
          name: void 0,
          alias: `${alias}$inherits`,
          value: plugin.inherits,
          options,
          dirname
        }, inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, (run) => cache.invalidate((data) => run(inheritsDescriptor, data)));
        plugin.pre = chainMaybeAsync(inherits.pre, plugin.pre), plugin.post = chainMaybeAsync(inherits.post, plugin.post), plugin.manipulateOptions = chainMaybeAsync(inherits.manipulateOptions, plugin.manipulateOptions), plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]), inherits.externalDependencies.length > 0 && (externalDependencies.length === 0 ? externalDependencies = inherits.externalDependencies : externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]));
      }
      return new _plugin.default(plugin, options, alias, externalDependencies);
    });
    function* loadPluginDescriptor(descriptor, context2) {
      if (descriptor.value instanceof _plugin.default) {
        if (descriptor.options)
          throw new Error("Passed options to an existing Plugin instance will not work.");
        return descriptor.value;
      }
      return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context2), context2);
    }
    var needsFilename = (val) => val && typeof val != "function", validateIfOptionNeedsFilename = (options, descriptor) => {
      if (needsFilename(options.test) || needsFilename(options.include) || needsFilename(options.exclude)) {
        let formattedPresetName = descriptor.name ? `"${descriptor.name}"` : "/* your preset */";
        throw new _configError.default([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
      }
    }, validatePreset = (preset, context2, descriptor) => {
      if (!context2.filename) {
        var _options$overrides;
        let {
          options
        } = preset;
        validateIfOptionNeedsFilename(options, descriptor), (_options$overrides = options.overrides) == null || _options$overrides.forEach((overrideOptions) => validateIfOptionNeedsFilename(overrideOptions, descriptor));
      }
    }, instantiatePreset = (0, _caching.makeWeakCacheSync)(({
      value: value2,
      dirname,
      alias,
      externalDependencies
    }) => ({
      options: (0, _options.validate)("preset", value2),
      alias,
      dirname,
      externalDependencies
    }));
    function* loadPresetDescriptor(descriptor, context2) {
      let preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context2));
      return validatePreset(preset, context2, descriptor), {
        chain: yield* (0, _configChain.buildPresetChain)(preset, context2),
        externalDependencies: preset.externalDependencies
      };
    }
    function chainMaybeAsync(a, b) {
      return a ? b ? function(...args) {
        let res = a.apply(this, args);
        return res && typeof res.then == "function" ? res.then(() => b.apply(this, args)) : b.apply(this, args);
      } : a : b;
    }
  }
});

// ../node_modules/@babel/core/lib/config/index.js
var require_config = __commonJS({
  "../node_modules/@babel/core/lib/config/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.createConfigItem = createConfigItem;
    exports.createConfigItemAsync = createConfigItemAsync;
    exports.createConfigItemSync = createConfigItemSync;
    Object.defineProperty(exports, "default", {
      enumerable: !0,
      get: function() {
        return _full.default;
      }
    });
    exports.loadOptions = loadOptions;
    exports.loadOptionsAsync = loadOptionsAsync;
    exports.loadOptionsSync = loadOptionsSync;
    exports.loadPartialConfig = loadPartialConfig;
    exports.loadPartialConfigAsync = loadPartialConfigAsync;
    exports.loadPartialConfigSync = loadPartialConfigSync;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var _full = require_full(), _partial = require_partial(), _item = require_item(), _rewriteStackTrace = require_rewrite_stack_trace(), loadPartialConfigRunner = _gensync()(_partial.loadPartialConfig);
    function loadPartialConfigAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.async)(...args);
    }
    function loadPartialConfigSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.sync)(...args);
    }
    function loadPartialConfig(opts, callback) {
      if (callback !== void 0)
        (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(opts, callback);
      else if (typeof opts == "function")
        (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(void 0, opts);
      else
        return loadPartialConfigSync(opts);
    }
    function* loadOptionsImpl(opts) {
      var _config$options;
      let config = yield* (0, _full.default)(opts);
      return (_config$options = config?.options) != null ? _config$options : null;
    }
    var loadOptionsRunner = _gensync()(loadOptionsImpl);
    function loadOptionsAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.async)(...args);
    }
    function loadOptionsSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.sync)(...args);
    }
    function loadOptions(opts, callback) {
      if (callback !== void 0)
        (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(opts, callback);
      else if (typeof opts == "function")
        (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(void 0, opts);
      else
        return loadOptionsSync(opts);
    }
    var createConfigItemRunner = _gensync()(_item.createConfigItem);
    function createConfigItemAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.async)(...args);
    }
    function createConfigItemSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.sync)(...args);
    }
    function createConfigItem(target, options, callback) {
      if (callback !== void 0)
        (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target, options, callback);
      else if (typeof options == "function")
        (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target, void 0, callback);
      else
        return createConfigItemSync(target, options);
    }
  }
});

// ../node_modules/@babel/core/lib/transformation/plugin-pass.js
var require_plugin_pass = __commonJS({
  "../node_modules/@babel/core/lib/transformation/plugin-pass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var PluginPass = class {
      constructor(file, key, options, isAsync) {
        this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.isAsync = void 0, this.key = key, this.file = file, this.opts = options || {}, this.cwd = file.opts.cwd, this.filename = file.opts.filename, this.isAsync = isAsync;
      }
      set(key, val) {
        this._map.set(key, val);
      }
      get(key) {
        return this._map.get(key);
      }
      availableHelper(name, versionRange) {
        return this.file.availableHelper(name, versionRange);
      }
      addHelper(name) {
        return this.file.addHelper(name);
      }
      buildCodeFrameError(node, msg, _Error) {
        return this.file.buildCodeFrameError(node, msg, _Error);
      }
    };
    exports.default = PluginPass;
    PluginPass.prototype.getModuleName = function() {
      return this.file.getModuleName();
    }, PluginPass.prototype.addImport = function() {
      this.file.addImport();
    };
  }
});

// ../node_modules/@babel/core/lib/transformation/block-hoist-plugin.js
var require_block_hoist_plugin = __commonJS({
  "../node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = loadBlockHoistPlugin;
    function _traverse() {
      let data = require_lib10();
      return _traverse = function() {
        return data;
      }, data;
    }
    var _plugin = require_plugin(), LOADED_PLUGIN, blockHoistPlugin = {
      name: "internal.blockHoist",
      visitor: {
        Block: {
          exit({
            node
          }) {
            node.body = performHoisting(node.body);
          }
        },
        SwitchCase: {
          exit({
            node
          }) {
            node.consequent = performHoisting(node.consequent);
          }
        }
      }
    };
    function performHoisting(body) {
      let max = Math.pow(2, 30) - 1, hasChange = !1;
      for (let i = 0; i < body.length; i++) {
        let n = body[i], p = priority(n);
        if (p > max) {
          hasChange = !0;
          break;
        }
        max = p;
      }
      return hasChange ? stableSort(body.slice()) : body;
    }
    function loadBlockHoistPlugin() {
      return LOADED_PLUGIN || (LOADED_PLUGIN = new _plugin.default(Object.assign({}, blockHoistPlugin, {
        visitor: _traverse().default.explode(blockHoistPlugin.visitor)
      }), {})), LOADED_PLUGIN;
    }
    function priority(bodyNode) {
      let priority2 = bodyNode?._blockHoist;
      return priority2 == null ? 1 : priority2 === !0 ? 2 : priority2;
    }
    function stableSort(body) {
      let buckets = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < body.length; i++) {
        let n = body[i], p = priority(n);
        (buckets[p] || (buckets[p] = [])).push(n);
      }
      let keys = Object.keys(buckets).map((k) => +k).sort((a, b) => b - a), index = 0;
      for (let key of keys) {
        let bucket = buckets[key];
        for (let n of bucket)
          body[index++] = n;
      }
      return body;
    }
  }
});

// ../node_modules/@babel/core/lib/transformation/normalize-opts.js
var require_normalize_opts = __commonJS({
  "../node_modules/@babel/core/lib/transformation/normalize-opts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = normalizeOptions;
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    function normalizeOptions(config) {
      let {
        filename,
        cwd,
        filenameRelative = typeof filename == "string" ? _path().relative(cwd, filename) : "unknown",
        sourceType = "module",
        inputSourceMap,
        sourceMaps = !!inputSourceMap,
        sourceRoot = config.options.moduleRoot,
        sourceFileName = _path().basename(filenameRelative),
        comments = !0,
        compact = "auto"
      } = config.options, opts = config.options, options = Object.assign({}, opts, {
        parserOpts: Object.assign({
          sourceType: _path().extname(filenameRelative) === ".mjs" ? "module" : sourceType,
          sourceFileName: filename,
          plugins: []
        }, opts.parserOpts),
        generatorOpts: Object.assign({
          filename,
          auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
          auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
          retainLines: opts.retainLines,
          comments,
          shouldPrintComment: opts.shouldPrintComment,
          compact,
          minified: opts.minified,
          sourceMaps: !!sourceMaps,
          sourceRoot,
          sourceFileName
        }, opts.generatorOpts)
      });
      for (let plugins of config.passes)
        for (let plugin of plugins)
          plugin.manipulateOptions && plugin.manipulateOptions(options, options.parserOpts);
      return options;
    }
  }
});

// ../node_modules/convert-source-map/index.js
var require_convert_source_map = __commonJS({
  "../node_modules/convert-source-map/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "commentRegex", {
      get: function() {
        return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
      }
    });
    Object.defineProperty(exports, "mapFileCommentRegex", {
      get: function() {
        return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
      }
    });
    var decodeBase64;
    typeof Buffer < "u" ? typeof Buffer.from == "function" ? decodeBase64 = decodeBase64WithBufferFrom : decodeBase64 = decodeBase64WithNewBuffer : decodeBase64 = decodeBase64WithAtob;
    function decodeBase64WithBufferFrom(base64) {
      return Buffer.from(base64, "base64").toString();
    }
    function decodeBase64WithNewBuffer(base64) {
      if (typeof value == "number")
        throw new TypeError("The value to decode must not be of type number.");
      return new Buffer(base64, "base64").toString();
    }
    function decodeBase64WithAtob(base64) {
      return decodeURIComponent(escape(atob(base64)));
    }
    function stripComment(sm) {
      return sm.split(",").pop();
    }
    function readFromFileMap(sm, read) {
      var r = exports.mapFileCommentRegex.exec(sm), filename = r[1] || r[2];
      try {
        var sm = read(filename);
        return sm != null && typeof sm.catch == "function" ? sm.catch(throwError) : sm;
      } catch (e) {
        throwError(e);
      }
      function throwError(e) {
        throw new Error("An error occurred while trying to read the map file at " + filename + `
` + e.stack);
      }
    }
    function Converter(sm, opts) {
      opts = opts || {}, opts.hasComment && (sm = stripComment(sm)), opts.encoding === "base64" ? sm = decodeBase64(sm) : opts.encoding === "uri" && (sm = decodeURIComponent(sm)), (opts.isJSON || opts.encoding) && (sm = JSON.parse(sm)), this.sourcemap = sm;
    }
    Converter.prototype.toJSON = function(space) {
      return JSON.stringify(this.sourcemap, null, space);
    };
    typeof Buffer < "u" ? typeof Buffer.from == "function" ? Converter.prototype.toBase64 = encodeBase64WithBufferFrom : Converter.prototype.toBase64 = encodeBase64WithNewBuffer : Converter.prototype.toBase64 = encodeBase64WithBtoa;
    function encodeBase64WithBufferFrom() {
      var json = this.toJSON();
      return Buffer.from(json, "utf8").toString("base64");
    }
    function encodeBase64WithNewBuffer() {
      var json = this.toJSON();
      if (typeof json == "number")
        throw new TypeError("The json to encode must not be of type number.");
      return new Buffer(json, "utf8").toString("base64");
    }
    function encodeBase64WithBtoa() {
      var json = this.toJSON();
      return btoa(unescape(encodeURIComponent(json)));
    }
    Converter.prototype.toURI = function() {
      var json = this.toJSON();
      return encodeURIComponent(json);
    };
    Converter.prototype.toComment = function(options) {
      var encoding, content, data;
      return options != null && options.encoding === "uri" ? (encoding = "", content = this.toURI()) : (encoding = ";base64", content = this.toBase64()), data = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content, options != null && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
    Converter.prototype.toObject = function() {
      return JSON.parse(this.toJSON());
    };
    Converter.prototype.addProperty = function(key, value2) {
      if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value2);
    };
    Converter.prototype.setProperty = function(key, value2) {
      return this.sourcemap[key] = value2, this;
    };
    Converter.prototype.getProperty = function(key) {
      return this.sourcemap[key];
    };
    exports.fromObject = function(obj) {
      return new Converter(obj);
    };
    exports.fromJSON = function(json) {
      return new Converter(json, { isJSON: !0 });
    };
    exports.fromURI = function(uri) {
      return new Converter(uri, { encoding: "uri" });
    };
    exports.fromBase64 = function(base64) {
      return new Converter(base64, { encoding: "base64" });
    };
    exports.fromComment = function(comment) {
      var m, encoding;
      return comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), m = exports.commentRegex.exec(comment), encoding = m && m[4] || "uri", new Converter(comment, { encoding, hasComment: !0 });
    };
    function makeConverter(sm) {
      return new Converter(sm, { isJSON: !0 });
    }
    exports.fromMapFileComment = function(comment, read) {
      if (typeof read == "string")
        throw new Error(
          "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
        );
      var sm = readFromFileMap(comment, read);
      return sm != null && typeof sm.then == "function" ? sm.then(makeConverter) : makeConverter(sm);
    };
    exports.fromSource = function(content) {
      var m = content.match(exports.commentRegex);
      return m ? exports.fromComment(m.pop()) : null;
    };
    exports.fromMapFileSource = function(content, read) {
      if (typeof read == "string")
        throw new Error(
          "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
        );
      var m = content.match(exports.mapFileCommentRegex);
      return m ? exports.fromMapFileComment(m.pop(), read) : null;
    };
    exports.removeComments = function(src) {
      return src.replace(exports.commentRegex, "");
    };
    exports.removeMapFileComments = function(src) {
      return src.replace(exports.mapFileCommentRegex, "");
    };
    exports.generateMapFileComment = function(file, options) {
      var data = "sourceMappingURL=" + file;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
  }
});

// ../node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js
var require_missing_plugin_helper = __commonJS({
  "../node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = generateMissingPluginMessage;
    var pluginNameMap = {
      asyncDoExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-async-do-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
        }
      },
      decimal: {
        syntax: {
          name: "@babel/plugin-syntax-decimal",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
        }
      },
      decorators: {
        syntax: {
          name: "@babel/plugin-syntax-decorators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
        },
        transform: {
          name: "@babel/plugin-proposal-decorators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
        }
      },
      doExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-do-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
        },
        transform: {
          name: "@babel/plugin-proposal-do-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
        }
      },
      exportDefaultFrom: {
        syntax: {
          name: "@babel/plugin-syntax-export-default-from",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
        },
        transform: {
          name: "@babel/plugin-proposal-export-default-from",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
        }
      },
      flow: {
        syntax: {
          name: "@babel/plugin-syntax-flow",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
        },
        transform: {
          name: "@babel/preset-flow",
          url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
        }
      },
      functionBind: {
        syntax: {
          name: "@babel/plugin-syntax-function-bind",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
        },
        transform: {
          name: "@babel/plugin-proposal-function-bind",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
        }
      },
      functionSent: {
        syntax: {
          name: "@babel/plugin-syntax-function-sent",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
        },
        transform: {
          name: "@babel/plugin-proposal-function-sent",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
        }
      },
      jsx: {
        syntax: {
          name: "@babel/plugin-syntax-jsx",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
        },
        transform: {
          name: "@babel/preset-react",
          url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
        }
      },
      pipelineOperator: {
        syntax: {
          name: "@babel/plugin-syntax-pipeline-operator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
        },
        transform: {
          name: "@babel/plugin-proposal-pipeline-operator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
        }
      },
      recordAndTuple: {
        syntax: {
          name: "@babel/plugin-syntax-record-and-tuple",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
        }
      },
      throwExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-throw-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
        },
        transform: {
          name: "@babel/plugin-proposal-throw-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
        }
      },
      typescript: {
        syntax: {
          name: "@babel/plugin-syntax-typescript",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
        },
        transform: {
          name: "@babel/preset-typescript",
          url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
        }
      }
    };
    Object.assign(pluginNameMap, {
      asyncGenerators: {
        syntax: {
          name: "@babel/plugin-syntax-async-generators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
        },
        transform: {
          name: "@babel/plugin-transform-async-generator-functions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
        }
      },
      classProperties: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
        },
        transform: {
          name: "@babel/plugin-transform-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
        }
      },
      classPrivateProperties: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
        },
        transform: {
          name: "@babel/plugin-transform-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
        }
      },
      classPrivateMethods: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
        },
        transform: {
          name: "@babel/plugin-transform-private-methods",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
        }
      },
      classStaticBlock: {
        syntax: {
          name: "@babel/plugin-syntax-class-static-block",
          url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
        },
        transform: {
          name: "@babel/plugin-transform-class-static-block",
          url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
        }
      },
      dynamicImport: {
        syntax: {
          name: "@babel/plugin-syntax-dynamic-import",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
        }
      },
      exportNamespaceFrom: {
        syntax: {
          name: "@babel/plugin-syntax-export-namespace-from",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
        },
        transform: {
          name: "@babel/plugin-transform-export-namespace-from",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
        }
      },
      importAssertions: {
        syntax: {
          name: "@babel/plugin-syntax-import-assertions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
        }
      },
      importAttributes: {
        syntax: {
          name: "@babel/plugin-syntax-import-attributes",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
        }
      },
      importMeta: {
        syntax: {
          name: "@babel/plugin-syntax-import-meta",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
        }
      },
      logicalAssignment: {
        syntax: {
          name: "@babel/plugin-syntax-logical-assignment-operators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
        },
        transform: {
          name: "@babel/plugin-transform-logical-assignment-operators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
        }
      },
      moduleStringNames: {
        syntax: {
          name: "@babel/plugin-syntax-module-string-names",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
        }
      },
      numericSeparator: {
        syntax: {
          name: "@babel/plugin-syntax-numeric-separator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
        },
        transform: {
          name: "@babel/plugin-transform-numeric-separator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
        }
      },
      nullishCoalescingOperator: {
        syntax: {
          name: "@babel/plugin-syntax-nullish-coalescing-operator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
        },
        transform: {
          name: "@babel/plugin-transform-nullish-coalescing-operator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
        }
      },
      objectRestSpread: {
        syntax: {
          name: "@babel/plugin-syntax-object-rest-spread",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
        },
        transform: {
          name: "@babel/plugin-transform-object-rest-spread",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
        }
      },
      optionalCatchBinding: {
        syntax: {
          name: "@babel/plugin-syntax-optional-catch-binding",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
        },
        transform: {
          name: "@babel/plugin-transform-optional-catch-binding",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
        }
      },
      optionalChaining: {
        syntax: {
          name: "@babel/plugin-syntax-optional-chaining",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
        },
        transform: {
          name: "@babel/plugin-transform-optional-chaining",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
        }
      },
      privateIn: {
        syntax: {
          name: "@babel/plugin-syntax-private-property-in-object",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
        },
        transform: {
          name: "@babel/plugin-transform-private-property-in-object",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
        }
      },
      regexpUnicodeSets: {
        syntax: {
          name: "@babel/plugin-syntax-unicode-sets-regex",
          url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
        },
        transform: {
          name: "@babel/plugin-transform-unicode-sets-regex",
          url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
        }
      }
    });
    var getNameURLCombination = ({
      name,
      url
    }) => `${name} (${url})`;
    function generateMissingPluginMessage(missingPluginName, loc, codeFrame, filename) {
      let helpMessage = `Support for the experimental syntax '${missingPluginName}' isn't currently enabled (${loc.line}:${loc.column + 1}):

` + codeFrame, pluginInfo = pluginNameMap[missingPluginName];
      if (pluginInfo) {
        let {
          syntax: syntaxPlugin,
          transform: transformPlugin
        } = pluginInfo;
        if (syntaxPlugin) {
          let syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
          if (transformPlugin) {
            let transformPluginInfo = getNameURLCombination(transformPlugin), sectionType = transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets";
            helpMessage += `

Add ${transformPluginInfo} to the '${sectionType}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`;
          } else
            helpMessage += `

Add ${syntaxPluginInfo} to the 'plugins' section of your Babel config to enable parsing.`;
        }
      }
      return helpMessage += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${filename === "unknown" ? "<name of the input file>" : filename} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, helpMessage;
    }
  }
});

// ../node_modules/@babel/core/lib/parser/index.js
var require_parser = __commonJS({
  "../node_modules/@babel/core/lib/parser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = parser3;
    function _parser() {
      let data = require_lib5();
      return _parser = function() {
        return data;
      }, data;
    }
    function _codeFrame() {
      let data = require_lib6();
      return _codeFrame = function() {
        return data;
      }, data;
    }
    var _missingPluginHelper = require_missing_plugin_helper();
    function* parser3(pluginPasses, {
      parserOpts,
      highlightCode = !0,
      filename = "unknown"
    }, code) {
      try {
        let results = [];
        for (let plugins of pluginPasses)
          for (let plugin of plugins) {
            let {
              parserOverride
            } = plugin;
            if (parserOverride) {
              let ast = parserOverride(code, parserOpts, _parser().parse);
              ast !== void 0 && results.push(ast);
            }
          }
        if (results.length === 0)
          return (0, _parser().parse)(code, parserOpts);
        if (results.length === 1) {
          if (yield* [], typeof results[0].then == "function")
            throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          return results[0];
        }
        throw new Error("More than one plugin attempted to override parsing.");
      } catch (err) {
        err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (err.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
        let {
          loc,
          missingPlugin
        } = err;
        if (loc) {
          let codeFrame = (0, _codeFrame().codeFrameColumns)(code, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          }, {
            highlightCode
          });
          missingPlugin ? err.message = `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame, filename) : err.message = `${filename}: ${err.message}

` + codeFrame, err.code = "BABEL_PARSE_ERROR";
        }
        throw err;
      }
    }
  }
});

// ../node_modules/@babel/core/lib/transformation/util/clone-deep.js
var require_clone_deep = __commonJS({
  "../node_modules/@babel/core/lib/transformation/util/clone-deep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = _default;
    var circleSet = /* @__PURE__ */ new Set(), depth = 0;
    function deepClone(value2, cache, allowCircle) {
      if (value2 !== null) {
        if (allowCircle) {
          if (cache.has(value2)) return cache.get(value2);
        } else if (++depth > 250) {
          if (circleSet.has(value2))
            throw depth = 0, circleSet.clear(), new Error("Babel-deepClone: Cycles are not allowed in AST");
          circleSet.add(value2);
        }
        let cloned;
        if (Array.isArray(value2)) {
          cloned = new Array(value2.length), allowCircle && cache.set(value2, cloned);
          for (let i = 0; i < value2.length; i++)
            cloned[i] = typeof value2[i] != "object" ? value2[i] : deepClone(value2[i], cache, allowCircle);
        } else {
          cloned = {}, allowCircle && cache.set(value2, cloned);
          let keys = Object.keys(value2);
          for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            cloned[key] = typeof value2[key] != "object" ? value2[key] : deepClone(value2[key], cache, allowCircle || key === "leadingComments" || key === "innerComments" || key === "trailingComments" || key === "extra");
          }
        }
        return allowCircle || depth-- > 250 && circleSet.delete(value2), cloned;
      }
      return value2;
    }
    function _default(value2) {
      if (typeof value2 != "object") return value2;
      try {
        return deepClone(value2, /* @__PURE__ */ new Map(), !0);
      } catch {
        return structuredClone(value2);
      }
    }
  }
});

// ../node_modules/@babel/core/lib/transformation/normalize-file.js
var require_normalize_file = __commonJS({
  "../node_modules/@babel/core/lib/transformation/normalize-file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = normalizeFile;
    function _fs() {
      let data = __require("fs");
      return _fs = function() {
        return data;
      }, data;
    }
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    function _debug() {
      let data = require_src();
      return _debug = function() {
        return data;
      }, data;
    }
    function _t() {
      let data = require_lib4();
      return _t = function() {
        return data;
      }, data;
    }
    function _convertSourceMap() {
      let data = require_convert_source_map();
      return _convertSourceMap = function() {
        return data;
      }, data;
    }
    var _file = require_file(), _index = require_parser(), _cloneDeep = require_clone_deep(), {
      file,
      traverseFast
    } = _t(), debug = _debug()("babel:transform:file"), INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/, EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
    function* normalizeFile(pluginPasses, options, code, ast) {
      if (code = `${code || ""}`, ast) {
        if (ast.type === "Program")
          ast = file(ast, [], []);
        else if (ast.type !== "File")
          throw new Error("AST root must be a Program or File node");
        options.cloneInputAst && (ast = (0, _cloneDeep.default)(ast));
      } else
        ast = yield* (0, _index.default)(pluginPasses, options, code);
      let inputMap = null;
      if (options.inputSourceMap !== !1) {
        if (typeof options.inputSourceMap == "object" && (inputMap = _convertSourceMap().fromObject(options.inputSourceMap)), !inputMap) {
          let lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);
          if (lastComment)
            try {
              inputMap = _convertSourceMap().fromComment("//" + lastComment);
            } catch {
              debug("discarding unknown inline input sourcemap");
            }
        }
        if (!inputMap) {
          let lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);
          if (typeof options.filename == "string" && lastComment)
            try {
              let match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment), inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]), "utf8");
              inputMap = _convertSourceMap().fromJSON(inputMapContent);
            } catch (err) {
              debug("discarding unknown file input sourcemap", err);
            }
          else lastComment && debug("discarding un-loadable file input sourcemap");
        }
      }
      return new _file.default(options, {
        code,
        ast,
        inputMap
      });
    }
    function extractCommentsFromList(regex, comments, lastComment) {
      return comments && (comments = comments.filter(({
        value: value2
      }) => regex.test(value2) ? (lastComment = value2, !1) : !0)), [comments, lastComment];
    }
    function extractComments(regex, ast) {
      let lastComment = null;
      return traverseFast(ast, (node) => {
        [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment), [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment), [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);
      }), lastComment;
    }
  }
});

// ../node_modules/@jridgewell/remapping/dist/remapping.umd.js
var require_remapping_umd = __commonJS({
  "../node_modules/@jridgewell/remapping/dist/remapping.umd.js"(exports, module) {
    (function(global2, factory) {
      if (typeof exports == "object" && typeof module < "u")
        factory(module, require_gen_mapping_umd(), require_trace_mapping_umd()), module.exports = def(module);
      else if (typeof define == "function" && define.amd)
        define(["module", "@jridgewell/gen-mapping", "@jridgewell/trace-mapping"], function(mod) {
          factory.apply(this, arguments), mod.exports = def(mod);
        });
      else {
        let mod = { exports: {} };
        factory(mod, global2.genMapping, global2.traceMapping), global2 = typeof globalThis < "u" ? globalThis : global2 || self, global2.remapping = def(mod);
      }
      function def(m) {
        return "default" in m.exports ? m.exports.default : m.exports;
      }
    })(exports, (function(module2, require_genMapping, require_traceMapping) {
      "use strict";
      var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJS2 = (cb, mod) => function() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      }, __export = (target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: !0 });
      }, __copyProps = (to, from, except, desc) => {
        if (from && typeof from == "object" || typeof from == "function")
          for (let key of __getOwnPropNames(from))
            !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        return to;
      }, __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
        mod
      )), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod), require_trace_mapping = __commonJS2({
        "umd:@jridgewell/trace-mapping"(exports2, module22) {
          module22.exports = require_traceMapping;
        }
      }), require_gen_mapping = __commonJS2({
        "umd:@jridgewell/gen-mapping"(exports2, module22) {
          module22.exports = require_genMapping;
        }
      }), remapping_exports = {};
      __export(remapping_exports, {
        default: () => remapping
      }), module2.exports = __toCommonJS(remapping_exports);
      var import_trace_mapping2 = __toESM2(require_trace_mapping()), import_gen_mapping = __toESM2(require_gen_mapping()), import_trace_mapping = __toESM2(require_trace_mapping()), SOURCELESS_MAPPING = SegmentObject("", -1, -1, "", null, !1), EMPTY_SOURCES = [];
      function SegmentObject(source, line, column, name, content, ignore) {
        return { source, line, column, name, content, ignore };
      }
      function Source(map, sources, source, content, ignore) {
        return {
          map,
          sources,
          source,
          content,
          ignore
        };
      }
      function MapSource(map, sources) {
        return Source(map, sources, "", null, !1);
      }
      function OriginalSource(source, content, ignore) {
        return Source(null, EMPTY_SOURCES, source, content, ignore);
      }
      function traceMappings(tree) {
        let gen = new import_gen_mapping.GenMapping({ file: tree.map.file }), { sources: rootSources, map } = tree, rootNames = map.names, rootMappings = (0, import_trace_mapping.decodedMappings)(map);
        for (let i = 0; i < rootMappings.length; i++) {
          let segments = rootMappings[i];
          for (let j = 0; j < segments.length; j++) {
            let segment = segments[j], genCol = segment[0], traced = SOURCELESS_MAPPING;
            if (segment.length !== 1) {
              let source2 = rootSources[segment[1]];
              if (traced = originalPositionFor(
                source2,
                segment[2],
                segment[3],
                segment.length === 5 ? rootNames[segment[4]] : ""
              ), traced == null) continue;
            }
            let { column, line, name, content, source, ignore } = traced;
            (0, import_gen_mapping.maybeAddSegment)(gen, i, genCol, source, line, column, name), source && content != null && (0, import_gen_mapping.setSourceContent)(gen, source, content), ignore && (0, import_gen_mapping.setIgnore)(gen, source, !0);
          }
        }
        return gen;
      }
      function originalPositionFor(source, line, column, name) {
        if (!source.map)
          return SegmentObject(source.source, line, column, name, source.content, source.ignore);
        let segment = (0, import_trace_mapping.traceSegment)(source.map, line, column);
        return segment == null ? null : segment.length === 1 ? SOURCELESS_MAPPING : originalPositionFor(
          source.sources[segment[1]],
          segment[2],
          segment[3],
          segment.length === 5 ? source.map.names[segment[4]] : name
        );
      }
      function asArray(value2) {
        return Array.isArray(value2) ? value2 : [value2];
      }
      function buildSourceMapTree(input, loader) {
        let maps = asArray(input).map((m) => new import_trace_mapping2.TraceMap(m, "")), map = maps.pop();
        for (let i = 0; i < maps.length; i++)
          if (maps[i].sources.length > 1)
            throw new Error(
              `Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`
            );
        let tree = build(map, loader, "", 0);
        for (let i = maps.length - 1; i >= 0; i--)
          tree = MapSource(maps[i], [tree]);
        return tree;
      }
      function build(map, loader, importer, importerDepth) {
        let { resolvedSources, sourcesContent, ignoreList } = map, depth = importerDepth + 1, children = resolvedSources.map((sourceFile, i) => {
          let ctx = {
            importer,
            depth,
            source: sourceFile || "",
            content: void 0,
            ignore: void 0
          }, sourceMap = loader(ctx.source, ctx), { source, content, ignore } = ctx;
          if (sourceMap) return build(new import_trace_mapping2.TraceMap(sourceMap, source), loader, source, depth);
          let sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null, ignored = ignore !== void 0 ? ignore : ignoreList ? ignoreList.includes(i) : !1;
          return OriginalSource(source, sourceContent, ignored);
        });
        return MapSource(map, children);
      }
      var import_gen_mapping2 = __toESM2(require_gen_mapping()), SourceMap = class {
        constructor(map, options) {
          let out = options.decodedMappings ? (0, import_gen_mapping2.toDecodedMap)(map) : (0, import_gen_mapping2.toEncodedMap)(map);
          this.version = out.version, this.file = out.file, this.mappings = out.mappings, this.names = out.names, this.ignoreList = out.ignoreList, this.sourceRoot = out.sourceRoot, this.sources = out.sources, options.excludeContent || (this.sourcesContent = out.sourcesContent);
        }
        toString() {
          return JSON.stringify(this);
        }
      };
      function remapping(input, loader, options) {
        let opts = typeof options == "object" ? options : { excludeContent: !!options, decodedMappings: !1 }, tree = buildSourceMapTree(input, loader);
        return new SourceMap(traceMappings(tree), opts);
      }
    }));
  }
});

// ../node_modules/@babel/core/lib/transformation/file/merge-map.js
var require_merge_map = __commonJS({
  "../node_modules/@babel/core/lib/transformation/file/merge-map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = mergeSourceMap;
    function _remapping() {
      let data = require_remapping_umd();
      return _remapping = function() {
        return data;
      }, data;
    }
    function mergeSourceMap(inputMap, map, sourceFileName) {
      let source = sourceFileName.replace(/\\/g, "/"), found = !1, result = _remapping()(rootless(map), (s, ctx) => s === source && !found ? (found = !0, ctx.source = "", rootless(inputMap)) : null);
      return typeof inputMap.sourceRoot == "string" && (result.sourceRoot = inputMap.sourceRoot), Object.assign({}, result);
    }
    function rootless(map) {
      return Object.assign({}, map, {
        sourceRoot: null
      });
    }
  }
});

// ../node_modules/@babel/core/lib/transformation/file/generate.js
var require_generate = __commonJS({
  "../node_modules/@babel/core/lib/transformation/file/generate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = generateCode;
    function _convertSourceMap() {
      let data = require_convert_source_map();
      return _convertSourceMap = function() {
        return data;
      }, data;
    }
    function _generator() {
      let data = require_lib9();
      return _generator = function() {
        return data;
      }, data;
    }
    var _mergeMap = require_merge_map();
    function generateCode(pluginPasses, file) {
      let {
        opts,
        ast,
        code,
        inputMap
      } = file, {
        generatorOpts
      } = opts;
      generatorOpts.inputSourceMap = inputMap?.toObject();
      let results = [];
      for (let plugins of pluginPasses)
        for (let plugin of plugins) {
          let {
            generatorOverride
          } = plugin;
          if (generatorOverride) {
            let result2 = generatorOverride(ast, generatorOpts, code, _generator().default);
            result2 !== void 0 && results.push(result2);
          }
        }
      let result;
      if (results.length === 0)
        result = (0, _generator().default)(ast, generatorOpts, code);
      else if (results.length === 1) {
        if (result = results[0], typeof result.then == "function")
          throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      } else
        throw new Error("More than one plugin attempted to override codegen.");
      let {
        code: outputCode,
        decodedMap: outputMap = result.map
      } = result;
      return result.__mergedMap ? outputMap = Object.assign({}, result.map) : outputMap && (inputMap ? outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap, generatorOpts.sourceFileName) : outputMap = result.map), (opts.sourceMaps === "inline" || opts.sourceMaps === "both") && (outputCode += `
` + _convertSourceMap().fromObject(outputMap).toComment()), opts.sourceMaps === "inline" && (outputMap = null), {
        outputCode,
        outputMap
      };
    }
  }
});

// ../node_modules/@babel/core/lib/transformation/index.js
var require_transformation = __commonJS({
  "../node_modules/@babel/core/lib/transformation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.run = run;
    function _traverse() {
      let data = require_lib10();
      return _traverse = function() {
        return data;
      }, data;
    }
    var _pluginPass = require_plugin_pass(), _blockHoistPlugin = require_block_hoist_plugin(), _normalizeOpts = require_normalize_opts(), _normalizeFile = require_normalize_file(), _generate = require_generate(), _deepArray = require_deep_array(), _async = require_async();
    function* run(config, code, ast) {
      let file = yield* (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code, ast), opts = file.opts;
      try {
        yield* transformFile(file, config.passes);
      } catch (e) {
        var _opts$filename;
        throw e.message = `${(_opts$filename = opts.filename) != null ? _opts$filename : "unknown file"}: ${e.message}`, e.code || (e.code = "BABEL_TRANSFORM_ERROR"), e;
      }
      let outputCode, outputMap;
      try {
        opts.code !== !1 && ({
          outputCode,
          outputMap
        } = (0, _generate.default)(config.passes, file));
      } catch (e) {
        var _opts$filename2;
        throw e.message = `${(_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown file"}: ${e.message}`, e.code || (e.code = "BABEL_GENERATE_ERROR"), e;
      }
      return {
        metadata: file.metadata,
        options: opts,
        ast: opts.ast === !0 ? file.ast : null,
        code: outputCode === void 0 ? null : outputCode,
        map: outputMap === void 0 ? null : outputMap,
        sourceType: file.ast.program.sourceType,
        externalDependencies: (0, _deepArray.flattenToSet)(config.externalDependencies)
      };
    }
    function* transformFile(file, pluginPasses) {
      let async = yield* (0, _async.isAsync)();
      for (let pluginPairs of pluginPasses) {
        let passPairs = [], passes = [], visitors = [];
        for (let plugin of pluginPairs.concat([(0, _blockHoistPlugin.default)()])) {
          let pass = new _pluginPass.default(file, plugin.key, plugin.options, async);
          passPairs.push([plugin, pass]), passes.push(pass), visitors.push(plugin.visitor);
        }
        for (let [plugin, pass] of passPairs)
          plugin.pre && (yield* (0, _async.maybeAsync)(plugin.pre, "You appear to be using an async plugin/preset, but Babel has been called synchronously").call(pass, file));
        let visitor = _traverse().default.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);
        (0, _traverse().default)(file.ast, visitor, file.scope);
        for (let [plugin, pass] of passPairs)
          plugin.post && (yield* (0, _async.maybeAsync)(plugin.post, "You appear to be using an async plugin/preset, but Babel has been called synchronously").call(pass, file));
      }
    }
  }
});

// ../node_modules/@babel/core/lib/transform-file.js
var require_transform_file = __commonJS({
  "../node_modules/@babel/core/lib/transform-file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.transformFile = transformFile;
    exports.transformFileAsync = transformFileAsync;
    exports.transformFileSync = transformFileSync;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var _index = require_config(), _index2 = require_transformation(), fs = require_fs(), transformFileRunner = _gensync()(function* (filename, opts) {
      let options = Object.assign({}, opts, {
        filename
      }), config = yield* (0, _index.default)(options);
      if (config === null) return null;
      let code = yield* fs.readFile(filename, "utf8");
      return yield* (0, _index2.run)(config, code);
    });
    function transformFile(...args) {
      transformFileRunner.errback(...args);
    }
    function transformFileSync(...args) {
      return transformFileRunner.sync(...args);
    }
    function transformFileAsync(...args) {
      return transformFileRunner.async(...args);
    }
  }
});

// ../node_modules/@babel/core/lib/config/files/import.cjs
var require_import = __commonJS({
  "../node_modules/@babel/core/lib/config/files/import.cjs"(exports, module) {
    module.exports = function(filepath) {
      return import(filepath);
    };
  }
});

// ../node_modules/@babel/preset-typescript/package.json
var require_package2 = __commonJS({
  "../node_modules/@babel/preset-typescript/package.json"(exports, module) {
    module.exports = {
      name: "@babel/preset-typescript",
      version: "7.28.5",
      description: "Babel preset for TypeScript.",
      repository: {
        type: "git",
        url: "https://github.com/babel/babel.git",
        directory: "packages/babel-preset-typescript"
      },
      license: "MIT",
      publishConfig: {
        access: "public"
      },
      main: "./lib/index.js",
      keywords: [
        "babel-preset",
        "typescript"
      ],
      dependencies: {
        "@babel/helper-plugin-utils": "^7.27.1",
        "@babel/helper-validator-option": "^7.27.1",
        "@babel/plugin-syntax-jsx": "^7.27.1",
        "@babel/plugin-transform-modules-commonjs": "^7.27.1",
        "@babel/plugin-transform-typescript": "^7.28.5"
      },
      peerDependencies: {
        "@babel/core": "^7.0.0-0"
      },
      devDependencies: {
        "@babel/core": "^7.28.5",
        "@babel/helper-plugin-test-runner": "^7.27.1"
      },
      homepage: "https://babel.dev/docs/en/next/babel-preset-typescript",
      bugs: "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen",
      engines: {
        node: ">=6.9.0"
      },
      author: "The Babel Team (https://babel.dev/team)",
      type: "commonjs"
    };
  }
});

// ../node_modules/@babel/helper-plugin-utils/lib/index.js
var require_lib15 = __commonJS({
  "../node_modules/@babel/helper-plugin-utils/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.declare = declare;
    exports.declarePreset = void 0;
    var apiPolyfills = {
      assertVersion: (api) => (range) => {
        throwVersionError(range, api.version);
      }
    };
    Object.assign(apiPolyfills, {
      targets: () => () => ({}),
      assumption: () => () => {
      },
      addExternalDependency: () => () => {
      }
    });
    function declare(builder) {
      return (api, options, dirname) => {
        let clonedApi;
        for (let name of Object.keys(apiPolyfills))
          api[name] || (clonedApi ?? (clonedApi = copyApiObject(api)), clonedApi[name] = apiPolyfills[name](clonedApi));
        return builder(clonedApi ?? api, options || {}, dirname);
      };
    }
    var declarePreset = exports.declarePreset = declare;
    function copyApiObject(api) {
      let proto = null;
      return typeof api.version == "string" && /^7\./.test(api.version) && (proto = Object.getPrototypeOf(api), proto && (!hasOwnProperty.call(proto, "version") || !hasOwnProperty.call(proto, "transform") || !hasOwnProperty.call(proto, "template") || !hasOwnProperty.call(proto, "types")) && (proto = null)), Object.assign({}, proto, api);
    }
    function throwVersionError(range, version) {
      if (typeof range == "number") {
        if (!Number.isInteger(range))
          throw new Error("Expected string or integer value.");
        range = `^${range}.0.0-0`;
      }
      if (typeof range != "string")
        throw new Error("Expected string or integer value.");
      let limit = Error.stackTraceLimit;
      typeof limit == "number" && limit < 25 && (Error.stackTraceLimit = 25);
      let err;
      throw version.slice(0, 2) === "7." ? err = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". You'll need to update your @babel/core version.`) : err = new Error(`Requires Babel "${range}", but was loaded with "${version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof limit == "number" && (Error.stackTraceLimit = limit), Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version,
        range
      });
    }
  }
});

// ../node_modules/@babel/plugin-syntax-typescript/lib/index.js
var require_lib16 = __commonJS({
  "../node_modules/@babel/plugin-syntax-typescript/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _helperPluginUtils = require_lib15();
    removePlugin = function(plugins, name) {
      let indices = [];
      plugins.forEach((plugin, i) => {
        (Array.isArray(plugin) ? plugin[0] : plugin) === name && indices.unshift(i);
      });
      for (let i of indices)
        plugins.splice(i, 1);
    };
    var removePlugin, _default = exports.default = (0, _helperPluginUtils.declare)((api, opts) => {
      api.assertVersion(7);
      let {
        disallowAmbiguousJSXLike,
        dts
      } = opts;
      var {
        isTSX
      } = opts;
      return {
        name: "syntax-typescript",
        manipulateOptions(opts2, parserOpts) {
          {
            let {
              plugins
            } = parserOpts;
            removePlugin(plugins, "flow"), removePlugin(plugins, "jsx"), plugins.push("objectRestSpread", "classProperties"), isTSX && plugins.push("jsx");
          }
          parserOpts.plugins.push(["typescript", {
            disallowAmbiguousJSXLike,
            dts
          }]);
        }
      };
    });
  }
});

// ../node_modules/@babel/helper-member-expression-to-functions/lib/index.js
var require_lib17 = __commonJS({
  "../node_modules/@babel/helper-member-expression-to-functions/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _t = require_lib4();
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var _t__namespace = _interopNamespace(_t);
    function willPathCastToBoolean(path) {
      let maybeWrapped = path, {
        node,
        parentPath
      } = maybeWrapped;
      if (parentPath.isLogicalExpression()) {
        let {
          operator,
          right
        } = parentPath.node;
        if (operator === "&&" || operator === "||" || operator === "??" && node === right)
          return willPathCastToBoolean(parentPath);
      }
      if (parentPath.isSequenceExpression()) {
        let {
          expressions
        } = parentPath.node;
        return expressions[expressions.length - 1] === node ? willPathCastToBoolean(parentPath) : !0;
      }
      return parentPath.isConditional({
        test: node
      }) || parentPath.isUnaryExpression({
        operator: "!"
      }) || parentPath.isForStatement({
        test: node
      }) || parentPath.isWhile({
        test: node
      });
    }
    var {
      LOGICAL_OPERATORS,
      arrowFunctionExpression,
      assignmentExpression,
      binaryExpression,
      booleanLiteral,
      callExpression,
      cloneNode,
      conditionalExpression,
      identifier,
      isMemberExpression,
      isOptionalCallExpression,
      isOptionalMemberExpression,
      isUpdateExpression,
      logicalExpression,
      memberExpression,
      nullLiteral,
      optionalCallExpression,
      optionalMemberExpression,
      sequenceExpression,
      updateExpression
    } = _t__namespace, AssignmentMemoiser = class {
      constructor() {
        this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
      }
      has(key) {
        return this._map.has(key);
      }
      get(key) {
        if (!this.has(key)) return;
        let record = this._map.get(key), {
          value: value2
        } = record;
        return record.count--, record.count === 0 ? assignmentExpression("=", value2, key) : value2;
      }
      set(key, value2, count) {
        return this._map.set(key, {
          count,
          value: value2
        });
      }
    };
    function toNonOptional(path, base) {
      let {
        node
      } = path;
      if (isOptionalMemberExpression(node))
        return memberExpression(base, node.property, node.computed);
      if (path.isOptionalCallExpression()) {
        let callee = path.get("callee");
        if (path.node.optional && callee.isOptionalMemberExpression()) {
          let object = callee.node.object, context = path.scope.maybeGenerateMemoised(object);
          return callee.get("object").replaceWith(assignmentExpression("=", context, object)), callExpression(memberExpression(base, identifier("call")), [context, ...path.node.arguments]);
        }
        return callExpression(base, path.node.arguments);
      }
      return path.node;
    }
    function isInDetachedTree(path) {
      for (; path && !path.isProgram(); ) {
        let {
          parentPath,
          container,
          listKey
        } = path, parentNode = parentPath.node;
        if (listKey) {
          if (container !== parentNode[listKey])
            return !0;
        } else if (container !== parentNode) return !0;
        path = parentPath;
      }
      return !1;
    }
    var handle = {
      memoise() {
      },
      handle(member, noDocumentAll) {
        let {
          node,
          parent,
          parentPath,
          scope
        } = member;
        if (member.isOptionalMemberExpression()) {
          if (isInDetachedTree(member)) return;
          let endPath = member.find(({
            node: node2,
            parent: parent2
          }) => isOptionalMemberExpression(parent2) ? parent2.optional || parent2.object !== node2 : isOptionalCallExpression(parent2) ? node2 !== member.node && parent2.optional || parent2.callee !== node2 : !0);
          if (scope.path.isPattern()) {
            endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));
            return;
          }
          let willEndPathCastToBoolean = willPathCastToBoolean(endPath), rootParentPath = endPath.parentPath;
          if (rootParentPath.isUpdateExpression({
            argument: node
          }))
            throw member.buildCodeFrameError("can't handle update expression");
          let isAssignment = rootParentPath.isAssignmentExpression({
            left: endPath.node
          }), isDeleteOperation = rootParentPath.isUnaryExpression({
            operator: "delete"
          });
          if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName())
            throw member.buildCodeFrameError("can't delete a private class element");
          let startingOptional = member;
          for (; ; ) {
            if (startingOptional.isOptionalMemberExpression()) {
              if (startingOptional.node.optional) break;
              startingOptional = startingOptional.get("object");
              continue;
            } else if (startingOptional.isOptionalCallExpression()) {
              if (startingOptional.node.optional) break;
              startingOptional = startingOptional.get("callee");
              continue;
            }
            throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);
          }
          let startingNode = startingOptional.isOptionalMemberExpression() ? startingOptional.node.object : startingOptional.node.callee, baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode), baseRef = baseNeedsMemoised ?? startingNode, parentIsOptionalCall = parentPath.isOptionalCallExpression({
            callee: node
          }), isOptionalCall = (parent2) => parentIsOptionalCall, parentIsCall = parentPath.isCallExpression({
            callee: node
          });
          startingOptional.replaceWith(toNonOptional(startingOptional, baseRef)), isOptionalCall() ? parent.optional ? parentPath.replaceWith(this.optionalCall(member, parent.arguments)) : parentPath.replaceWith(this.call(member, parent.arguments)) : parentIsCall ? member.replaceWith(this.boundGet(member)) : this.delete && parentPath.isUnaryExpression({
            operator: "delete"
          }) ? parentPath.replaceWith(this.delete(member)) : parentPath.isAssignmentExpression() ? handleAssignment(this, member, parentPath) : member.replaceWith(this.get(member));
          let regular = member.node;
          for (let current = member; current !== endPath; ) {
            let parentPath2 = current.parentPath;
            if (parentPath2 === endPath && isOptionalCall() && parent.optional) {
              regular = parentPath2.node;
              break;
            }
            regular = toNonOptional(parentPath2, regular), current = parentPath2;
          }
          let context, endParentPath = endPath.parentPath;
          if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({
            callee: endPath.node,
            optional: !0
          })) {
            let {
              object
            } = regular;
            context = member.scope.maybeGenerateMemoised(object), context && (regular.object = assignmentExpression("=", context, object));
          }
          let replacementPath = endPath;
          (isDeleteOperation || isAssignment) && (replacementPath = endParentPath, regular = endParentPath.node);
          let baseMemoised = baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);
          if (willEndPathCastToBoolean) {
            let nonNullishCheck;
            noDocumentAll ? nonNullishCheck = binaryExpression("!=", baseMemoised, nullLiteral()) : nonNullishCheck = logicalExpression("&&", binaryExpression("!==", baseMemoised, nullLiteral()), binaryExpression("!==", cloneNode(baseRef), scope.buildUndefinedNode())), replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
          } else {
            let nullishCheck;
            noDocumentAll ? nullishCheck = binaryExpression("==", baseMemoised, nullLiteral()) : nullishCheck = logicalExpression("||", binaryExpression("===", baseMemoised, nullLiteral()), binaryExpression("===", cloneNode(baseRef), scope.buildUndefinedNode())), replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(!0) : scope.buildUndefinedNode(), regular));
          }
          if (context) {
            let endParent = endParentPath.node;
            endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier("call"), !1, !0), [cloneNode(context), ...endParent.arguments], !1));
          }
          return;
        }
        if (isUpdateExpression(parent, {
          argument: node
        })) {
          if (this.simpleSet) {
            member.replaceWith(this.simpleSet(member));
            return;
          }
          let {
            operator,
            prefix
          } = parent;
          this.memoise(member, 2);
          let ref = scope.generateUidIdentifierBasedOnNode(node);
          scope.push({
            id: ref
          });
          let seq = [assignmentExpression("=", cloneNode(ref), this.get(member))];
          if (prefix) {
            seq.push(updateExpression(operator, cloneNode(ref), prefix));
            let value2 = sequenceExpression(seq);
            parentPath.replaceWith(this.set(member, value2));
            return;
          } else {
            let ref2 = scope.generateUidIdentifierBasedOnNode(node);
            scope.push({
              id: ref2
            }), seq.push(assignmentExpression("=", cloneNode(ref2), updateExpression(operator, cloneNode(ref), prefix)), cloneNode(ref));
            let value2 = sequenceExpression(seq);
            parentPath.replaceWith(sequenceExpression([this.set(member, value2), cloneNode(ref2)]));
            return;
          }
        }
        if (parentPath.isAssignmentExpression({
          left: node
        })) {
          handleAssignment(this, member, parentPath);
          return;
        }
        if (parentPath.isCallExpression({
          callee: node
        })) {
          parentPath.replaceWith(this.call(member, parentPath.node.arguments));
          return;
        }
        if (parentPath.isOptionalCallExpression({
          callee: node
        })) {
          if (scope.path.isPattern()) {
            parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), []));
            return;
          }
          parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));
          return;
        }
        if (this.delete && parentPath.isUnaryExpression({
          operator: "delete"
        })) {
          parentPath.replaceWith(this.delete(member));
          return;
        }
        if (parentPath.isForXStatement({
          left: node
        }) || parentPath.isObjectProperty({
          value: node
        }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
          left: node
        }) && parentPath.parentPath.isObjectProperty({
          value: parent
        }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
          left: node
        }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
          member.replaceWith(this.destructureSet(member));
          return;
        }
        parentPath.isTaggedTemplateExpression() ? member.replaceWith(this.boundGet(member)) : member.replaceWith(this.get(member));
      }
    };
    function handleAssignment(state, member, parentPath) {
      if (state.simpleSet) {
        member.replaceWith(state.simpleSet(member));
        return;
      }
      let {
        operator,
        right: value2
      } = parentPath.node;
      if (operator === "=")
        parentPath.replaceWith(state.set(member, value2));
      else {
        let operatorTrunc = operator.slice(0, -1);
        LOGICAL_OPERATORS.includes(operatorTrunc) ? (state.memoise(member, 1), parentPath.replaceWith(logicalExpression(operatorTrunc, state.get(member), state.set(member, value2)))) : (state.memoise(member, 2), parentPath.replaceWith(state.set(member, binaryExpression(operatorTrunc, state.get(member), value2))));
      }
    }
    function memberExpressionToFunctions(path, visitor, state) {
      path.traverse(visitor, Object.assign({}, handle, state, {
        memoiser: new AssignmentMemoiser()
      }));
    }
    exports.default = memberExpressionToFunctions;
  }
});

// ../node_modules/@babel/helper-optimise-call-expression/lib/index.js
var require_lib18 = __commonJS({
  "../node_modules/@babel/helper-optimise-call-expression/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = optimiseCallExpression;
    var _t = require_lib4(), {
      callExpression,
      identifier,
      isIdentifier,
      isSpreadElement,
      memberExpression,
      optionalCallExpression,
      optionalMemberExpression
    } = _t;
    function optimiseCallExpression(callee, thisNode, args, optional) {
      return args.length === 1 && isSpreadElement(args[0]) && isIdentifier(args[0].argument, {
        name: "arguments"
      }) ? optional ? optionalCallExpression(optionalMemberExpression(callee, identifier("apply"), !1, !0), [thisNode, args[0].argument], !1) : callExpression(memberExpression(callee, identifier("apply")), [thisNode, args[0].argument]) : optional ? optionalCallExpression(optionalMemberExpression(callee, identifier("call"), !1, !0), [thisNode, ...args], !1) : callExpression(memberExpression(callee, identifier("call")), [thisNode, ...args]);
    }
  }
});

// ../node_modules/@babel/helper-replace-supers/lib/index.js
var require_lib19 = __commonJS({
  "../node_modules/@babel/helper-replace-supers/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _helperMemberExpressionToFunctions = require_lib17(), _helperOptimiseCallExpression = require_lib18(), _core = require_lib27(), _traverse = require_lib10(), {
      assignmentExpression,
      callExpression,
      cloneNode,
      identifier,
      memberExpression,
      sequenceExpression,
      stringLiteral,
      thisExpression
    } = _core.types;
    exports.environmentVisitor = _traverse.visitors.environmentVisitor({}), exports.skipAllButComputedKey = function(path) {
      path.skip(), path.node.computed && path.context.maybeQueue(path.get("key"));
    };
    var visitor = _traverse.visitors.environmentVisitor({
      Super(path, state) {
        let {
          node,
          parentPath
        } = path;
        parentPath.isMemberExpression({
          object: node
        }) && state.handle(parentPath);
      }
    }), unshadowSuperBindingVisitor = _traverse.visitors.environmentVisitor({
      Scopable(path, {
        refName
      }) {
        let binding = path.scope.getOwnBinding(refName);
        binding && binding.identifier.name === refName && path.scope.rename(refName);
      }
    }), specHandlers = {
      memoise(superMember, count) {
        let {
          scope,
          node
        } = superMember, {
          computed,
          property
        } = node;
        if (!computed)
          return;
        let memo = scope.maybeGenerateMemoised(property);
        memo && this.memoiser.set(property, memo, count);
      },
      prop(superMember) {
        let {
          computed,
          property
        } = superMember.node;
        return this.memoiser.has(property) ? cloneNode(this.memoiser.get(property)) : computed ? cloneNode(property) : stringLiteral(property.name);
      },
      _getPrototypeOfExpression() {
        let objectRef = cloneNode(this.getObjectRef()), targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
        return callExpression(this.file.addHelper("getPrototypeOf"), [targetRef]);
      },
      get(superMember) {
        let objectRef = cloneNode(this.getObjectRef());
        return callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), thisExpression(), ...this.isStatic || this.isPrivateMethod ? [] : [_core.types.numericLiteral(1)]]);
      },
      _call(superMember, args, optional) {
        let objectRef = cloneNode(this.getObjectRef()), argsNode;
        args.length === 1 && _core.types.isSpreadElement(args[0]) && (_core.types.isIdentifier(args[0].argument) || _core.types.isArrayExpression(args[0].argument)) ? argsNode = args[0].argument : argsNode = _core.types.arrayExpression(args);
        let call = _core.types.callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), thisExpression(), _core.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))]);
        return optional ? _core.types.optionalCallExpression(call, [argsNode], !0) : callExpression(call, [argsNode]);
      },
      set(superMember, value2) {
        let objectRef = cloneNode(this.getObjectRef());
        return callExpression(this.file.addHelper("superPropSet"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), objectRef]) : objectRef, this.prop(superMember), value2, thisExpression(), _core.types.numericLiteral(superMember.isInStrictMode() ? 1 : 0), ...this.isStatic || this.isPrivateMethod ? [] : [_core.types.numericLiteral(1)]]);
      },
      destructureSet(superMember) {
        throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
      },
      call(superMember, args) {
        return this._call(superMember, args, !1);
      },
      optionalCall(superMember, args) {
        return this._call(superMember, args, !0);
      },
      delete(superMember) {
        return superMember.node.computed ? sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), _core.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : _core.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
      }
    }, specHandlers_old = {
      memoise(superMember, count) {
        let {
          scope,
          node
        } = superMember, {
          computed,
          property
        } = node;
        if (!computed)
          return;
        let memo = scope.maybeGenerateMemoised(property);
        memo && this.memoiser.set(property, memo, count);
      },
      prop(superMember) {
        let {
          computed,
          property
        } = superMember.node;
        return this.memoiser.has(property) ? cloneNode(this.memoiser.get(property)) : computed ? cloneNode(property) : stringLiteral(property.name);
      },
      _getPrototypeOfExpression() {
        let objectRef = cloneNode(this.getObjectRef()), targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
        return callExpression(this.file.addHelper("getPrototypeOf"), [targetRef]);
      },
      get(superMember) {
        return this._get(superMember);
      },
      _get(superMember) {
        let proto = this._getPrototypeOfExpression();
        return callExpression(this.file.addHelper("get"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), proto]) : proto, this.prop(superMember), thisExpression()]);
      },
      set(superMember, value2) {
        let proto = this._getPrototypeOfExpression();
        return callExpression(this.file.addHelper("set"), [this.isDerivedConstructor ? sequenceExpression([thisExpression(), proto]) : proto, this.prop(superMember), value2, thisExpression(), _core.types.booleanLiteral(superMember.isInStrictMode())]);
      },
      destructureSet(superMember) {
        throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
      },
      call(superMember, args) {
        return (0, _helperOptimiseCallExpression.default)(this._get(superMember), thisExpression(), args, !1);
      },
      optionalCall(superMember, args) {
        return (0, _helperOptimiseCallExpression.default)(this._get(superMember), cloneNode(thisExpression()), args, !0);
      },
      delete(superMember) {
        return superMember.node.computed ? sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), _core.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : _core.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
      }
    }, looseHandlers = Object.assign({}, specHandlers, {
      prop(superMember) {
        let {
          property
        } = superMember.node;
        return this.memoiser.has(property) ? cloneNode(this.memoiser.get(property)) : cloneNode(property);
      },
      get(superMember) {
        let {
          isStatic,
          getSuperRef
        } = this, {
          computed
        } = superMember.node, prop = this.prop(superMember), object;
        if (isStatic) {
          var _getSuperRef;
          object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype"));
        } else {
          var _getSuperRef2;
          object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
        }
        return memberExpression(object, prop, computed);
      },
      set(superMember, value2) {
        let {
          computed
        } = superMember.node, prop = this.prop(superMember);
        return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value2);
      },
      destructureSet(superMember) {
        let {
          computed
        } = superMember.node, prop = this.prop(superMember);
        return memberExpression(thisExpression(), prop, computed);
      },
      call(superMember, args) {
        return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, !1);
      },
      optionalCall(superMember, args) {
        return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, !0);
      }
    }), ReplaceSupers = class {
      constructor(opts) {
        var _opts$constantSuper;
        let path = opts.methodPath;
        this.methodPath = path, this.isDerivedConstructor = path.isClassMethod({
          kind: "constructor"
        }) && !!opts.superRef, this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock()), this.isPrivateMethod = path.isPrivate() && path.isMethod(), this.file = opts.file, this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose, this.opts = opts;
      }
      getObjectRef() {
        return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
      }
      getSuperRef() {
        if (this.opts.superRef) return cloneNode(this.opts.superRef);
        if (this.opts.getSuperRef)
          return cloneNode(this.opts.getSuperRef());
      }
      replace() {
        let {
          methodPath
        } = this;
        this.opts.refToPreserve && methodPath.traverse(unshadowSuperBindingVisitor, {
          refName: this.opts.refToPreserve.name
        });
        let handler = this.constantSuper ? looseHandlers : this.file.availableHelper("superPropSet") ? specHandlers : specHandlers_old;
        visitor.shouldSkip = (path) => {
          if (path.parentPath === methodPath && (path.parentKey === "decorators" || path.parentKey === "key"))
            return !0;
        }, (0, _helperMemberExpressionToFunctions.default)(methodPath, visitor, Object.assign({
          file: this.file,
          scope: this.methodPath.scope,
          isDerivedConstructor: this.isDerivedConstructor,
          isStatic: this.isStatic,
          isPrivateMethod: this.isPrivateMethod,
          getObjectRef: this.getObjectRef.bind(this),
          getSuperRef: this.getSuperRef.bind(this),
          boundGet: handler.get
        }, handler));
      }
    };
    exports.default = ReplaceSupers;
  }
});

// ../node_modules/@babel/helper-annotate-as-pure/lib/index.js
var require_lib20 = __commonJS({
  "../node_modules/@babel/helper-annotate-as-pure/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = annotateAsPure;
    var _t = require_lib4(), {
      addComment
    } = _t, PURE_ANNOTATION = "#__PURE__", isPureAnnotated = ({
      leadingComments
    }) => !!leadingComments && leadingComments.some((comment) => /[@#]__PURE__/.test(comment.value));
    function annotateAsPure(pathOrNode) {
      let node = pathOrNode.node || pathOrNode;
      isPureAnnotated(node) || addComment(node, "leading", PURE_ANNOTATION);
    }
  }
});

// ../node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js
var require_lib21 = __commonJS({
  "../node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.isTransparentExprWrapper = isTransparentExprWrapper;
    exports.skipTransparentExprWrapperNodes = skipTransparentExprWrapperNodes;
    exports.skipTransparentExprWrappers = skipTransparentExprWrappers;
    var _t = require_lib4(), {
      isParenthesizedExpression,
      isTSAsExpression,
      isTSNonNullExpression,
      isTSSatisfiesExpression,
      isTSTypeAssertion,
      isTypeCastExpression
    } = _t;
    function isTransparentExprWrapper(node) {
      return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);
    }
    function skipTransparentExprWrappers(path) {
      for (; isTransparentExprWrapper(path.node); )
        path = path.get("expression");
      return path;
    }
    function skipTransparentExprWrapperNodes(node) {
      for (; isTransparentExprWrapper(node); )
        node = node.expression;
      return node;
    }
  }
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js
var require_typescript3 = __commonJS({
  "../node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.assertFieldTransformed = assertFieldTransformed;
    function assertFieldTransformed(path) {
      if (path.node.declare)
        throw path.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`);
    }
  }
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/fields.js
var require_fields = __commonJS({
  "../node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.buildCheckInRHS = buildCheckInRHS;
    exports.buildFieldsInitNodes = buildFieldsInitNodes;
    exports.buildPrivateNamesMap = buildPrivateNamesMap;
    exports.buildPrivateNamesNodes = buildPrivateNamesNodes;
    exports.privateNameVisitorFactory = privateNameVisitorFactory;
    exports.transformPrivateNamesUsage = transformPrivateNamesUsage;
    var _core = require_lib27(), _traverse = require_lib10(), _helperReplaceSupers = require_lib19(), _helperMemberExpressionToFunctions = require_lib17(), _helperOptimiseCallExpression = require_lib18(), _helperAnnotateAsPure = require_lib20(), _helperSkipTransparentExpressionWrappers = require_lib21(), ts = require_typescript3();
    newHelpers = (file) => file.availableHelper("classPrivateFieldGet2");
    var newHelpers;
    function buildPrivateNamesMap(className, privateFieldsAsSymbolsOrProperties, props, file) {
      let privateNamesMap = /* @__PURE__ */ new Map(), classBrandId;
      for (let prop of props)
        if (prop.isPrivate()) {
          let {
            name
          } = prop.node.key.id, update = privateNamesMap.get(name);
          if (!update) {
            let isMethod = !prop.isProperty(), isStatic = prop.node.static, initAdded = !1, id;
            !privateFieldsAsSymbolsOrProperties && newHelpers(file) && isMethod && !isStatic ? (initAdded = !!classBrandId, classBrandId ?? (classBrandId = prop.scope.generateUidIdentifier(`${className}_brand`)), id = classBrandId) : id = prop.scope.generateUidIdentifier(name), update = {
              id,
              static: isStatic,
              method: isMethod,
              initAdded
            }, privateNamesMap.set(name, update);
          }
          if (prop.isClassPrivateMethod())
            if (prop.node.kind === "get") {
              let {
                body
              } = prop.node.body, $;
              body.length === 1 && _core.types.isReturnStatement($ = body[0]) && _core.types.isCallExpression($ = $.argument) && $.arguments.length === 1 && _core.types.isThisExpression($.arguments[0]) && _core.types.isIdentifier($ = $.callee) ? (update.getId = _core.types.cloneNode($), update.getterDeclared = !0) : update.getId = prop.scope.generateUidIdentifier(`get_${name}`);
            } else if (prop.node.kind === "set") {
              let {
                params
              } = prop.node, {
                body
              } = prop.node.body, $;
              body.length === 1 && _core.types.isExpressionStatement($ = body[0]) && _core.types.isCallExpression($ = $.expression) && $.arguments.length === 2 && _core.types.isThisExpression($.arguments[0]) && _core.types.isIdentifier($.arguments[1], {
                name: params[0].name
              }) && _core.types.isIdentifier($ = $.callee) ? (update.setId = _core.types.cloneNode($), update.setterDeclared = !0) : update.setId = prop.scope.generateUidIdentifier(`set_${name}`);
            } else prop.node.kind === "method" && (update.methodId = prop.scope.generateUidIdentifier(name));
          privateNamesMap.set(name, update);
        }
      return privateNamesMap;
    }
    function buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {
      let initNodes = [], injectedIds = /* @__PURE__ */ new Set();
      for (let [name, value2] of privateNamesMap) {
        let {
          static: isStatic,
          method: isMethod,
          getId,
          setId
        } = value2, isGetterOrSetter = getId || setId, id = _core.types.cloneNode(value2.id), init;
        if (privateFieldsAsProperties)
          init = _core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"), [_core.types.stringLiteral(name)]);
        else if (privateFieldsAsSymbols)
          init = _core.types.callExpression(_core.types.identifier("Symbol"), [_core.types.stringLiteral(name)]);
        else if (!isStatic) {
          if (injectedIds.has(id.name)) continue;
          injectedIds.add(id.name), init = _core.types.newExpression(_core.types.identifier(isMethod && (!isGetterOrSetter || newHelpers(state)) ? "WeakSet" : "WeakMap"), []);
        }
        init && (privateFieldsAsSymbols || (0, _helperAnnotateAsPure.default)(init), initNodes.push(_core.template.statement.ast`var ${id} = ${init}`));
      }
      return initNodes;
    }
    function privateNameVisitorFactory(visitor) {
      let nestedVisitor = _traverse.visitors.environmentVisitor(Object.assign({}, visitor)), privateNameVisitor2 = Object.assign({}, visitor, {
        Class(path) {
          let {
            privateNamesMap
          } = this, body = path.get("body.body"), visiblePrivateNames = new Map(privateNamesMap), redeclared = [];
          for (let prop of body) {
            if (!prop.isPrivate()) continue;
            let {
              name
            } = prop.node.key.id;
            visiblePrivateNames.delete(name), redeclared.push(name);
          }
          redeclared.length && (path.get("body").traverse(nestedVisitor, Object.assign({}, this, {
            redeclared
          })), path.traverse(privateNameVisitor2, Object.assign({}, this, {
            privateNamesMap: visiblePrivateNames
          })), path.skipKey("body"));
        }
      });
      return privateNameVisitor2;
    }
    var privateNameVisitor = privateNameVisitorFactory({
      PrivateName(path, {
        noDocumentAll
      }) {
        let {
          privateNamesMap,
          redeclared
        } = this, {
          node,
          parentPath
        } = path;
        if (!parentPath.isMemberExpression({
          property: node
        }) && !parentPath.isOptionalMemberExpression({
          property: node
        }))
          return;
        let {
          name
        } = node.id;
        privateNamesMap.has(name) && (redeclared != null && redeclared.includes(name) || this.handle(parentPath, noDocumentAll));
      }
    });
    function unshadow(name, scope, innerBinding) {
      for (; (_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding); ) {
        var _scope;
        scope.rename(name), scope = scope.parent;
      }
    }
    function buildCheckInRHS(rhs, file, inRHSIsObject) {
      return inRHSIsObject || !(file.availableHelper != null && file.availableHelper("checkInRHS")) ? rhs : _core.types.callExpression(file.addHelper("checkInRHS"), [rhs]);
    }
    var privateInVisitor = privateNameVisitorFactory({
      BinaryExpression(path, {
        file
      }) {
        let {
          operator,
          left,
          right
        } = path.node;
        if (operator !== "in" || !_core.types.isPrivateName(left)) return;
        let {
          privateFieldsAsProperties,
          privateNamesMap,
          redeclared
        } = this, {
          name
        } = left.id;
        if (!privateNamesMap.has(name) || redeclared != null && redeclared.includes(name)) return;
        if (unshadow(this.classRef.name, path.scope, this.innerBinding), privateFieldsAsProperties) {
          let {
            id: id2
          } = privateNamesMap.get(name);
          path.replaceWith(_core.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right, file)}, ${_core.types.cloneNode(id2)})
      `);
          return;
        }
        let {
          id,
          static: isStatic
        } = privateNamesMap.get(name);
        if (isStatic) {
          path.replaceWith(_core.template.expression.ast`${buildCheckInRHS(right, file)} === ${_core.types.cloneNode(this.classRef)}`);
          return;
        }
        path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${buildCheckInRHS(right, file)})`);
      }
    });
    function readOnlyError(file, name) {
      return _core.types.callExpression(file.addHelper("readOnlyError"), [_core.types.stringLiteral(`#${name}`)]);
    }
    function writeOnlyError(file, name) {
      return file.availableHelper("writeOnlyError") ? _core.types.callExpression(file.addHelper("writeOnlyError"), [_core.types.stringLiteral(`#${name}`)]) : (console.warn("@babel/helpers is outdated, update it to silence this warning."), _core.types.buildUndefinedNode());
    }
    function buildStaticPrivateFieldAccess(expr, noUninitializedPrivateFieldAccess) {
      return noUninitializedPrivateFieldAccess ? expr : _core.types.memberExpression(expr, _core.types.identifier("_"));
    }
    function autoInherits(fn) {
      return function(member) {
        return _core.types.inherits(fn.apply(this, arguments), member.node);
      };
    }
    var privateNameHandlerSpec = {
      memoise(member, count) {
        let {
          scope
        } = member, {
          object
        } = member.node, memo = scope.maybeGenerateMemoised(object);
        memo && this.memoiser.set(object, memo, count);
      },
      receiver(member) {
        let {
          object
        } = member.node;
        return this.memoiser.has(object) ? _core.types.cloneNode(this.memoiser.get(object)) : _core.types.cloneNode(object);
      },
      get: autoInherits(function(member) {
        let {
          classRef,
          privateNamesMap,
          file,
          innerBinding,
          noUninitializedPrivateFieldAccess
        } = this, privateName = member.node.property, {
          name
        } = privateName.id, {
          id,
          static: isStatic,
          method: isMethod,
          methodId,
          getId,
          setId
        } = privateNamesMap.get(name), isGetterOrSetter = getId || setId, cloneId = (id2) => _core.types.inherits(_core.types.cloneNode(id2), privateName);
        if (isStatic) {
          if (unshadow(classRef.name, member.scope, innerBinding), !newHelpers(file)) {
            let helperName = isMethod && !isGetterOrSetter ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
            return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id)]);
          }
          let receiver = this.receiver(member), skipCheck = _core.types.isIdentifier(receiver) && receiver.name === classRef.name;
          if (!isMethod)
            return buildStaticPrivateFieldAccess(skipCheck ? cloneId(id) : _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver, cloneId(id)]), noUninitializedPrivateFieldAccess);
          if (getId)
            return skipCheck ? _core.types.callExpression(cloneId(getId), [receiver]) : _core.types.callExpression(file.addHelper("classPrivateGetter"), [_core.types.cloneNode(classRef), receiver, cloneId(getId)]);
          if (setId) {
            let err = _core.types.buildUndefinedNode();
            return skipCheck ? err : _core.types.sequenceExpression([_core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver]), err]);
          }
          return skipCheck ? cloneId(id) : _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver, cloneId(id)]);
        }
        return isMethod ? isGetterOrSetter ? getId ? newHelpers(file) ? _core.types.callExpression(file.addHelper("classPrivateGetter"), [_core.types.cloneNode(id), this.receiver(member), cloneId(getId)]) : _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneId(id)]) : _core.types.sequenceExpression([this.receiver(member), writeOnlyError(file, name)]) : newHelpers(file) ? _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(id), this.receiver(member), cloneId(methodId)]) : _core.types.callExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), _core.types.cloneNode(id), cloneId(methodId)]) : newHelpers(file) ? _core.types.callExpression(file.addHelper("classPrivateFieldGet2"), [cloneId(id), this.receiver(member)]) : _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneId(id)]);
      }),
      boundGet(member) {
        return this.memoise(member, 1), _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [this.receiver(member)]);
      },
      set: autoInherits(function(member, value2) {
        let {
          classRef,
          privateNamesMap,
          file,
          noUninitializedPrivateFieldAccess
        } = this, privateName = member.node.property, {
          name
        } = privateName.id, {
          id,
          static: isStatic,
          method: isMethod,
          setId,
          getId
        } = privateNamesMap.get(name), isGetterOrSetter = getId || setId, cloneId = (id2) => _core.types.inherits(_core.types.cloneNode(id2), privateName);
        if (isStatic) {
          if (!newHelpers(file)) {
            let helperName = isMethod && !isGetterOrSetter ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
            return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id), value2]);
          }
          let receiver = this.receiver(member), skipCheck = _core.types.isIdentifier(receiver) && receiver.name === classRef.name;
          if (isMethod && !setId) {
            let err = readOnlyError(file, name);
            return skipCheck ? _core.types.sequenceExpression([value2, err]) : _core.types.sequenceExpression([value2, _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver]), readOnlyError(file, name)]);
          }
          return setId ? skipCheck ? _core.types.callExpression(_core.types.cloneNode(setId), [receiver, value2]) : _core.types.callExpression(file.addHelper("classPrivateSetter"), [_core.types.cloneNode(classRef), cloneId(setId), receiver, value2]) : _core.types.assignmentExpression("=", buildStaticPrivateFieldAccess(cloneId(id), noUninitializedPrivateFieldAccess), skipCheck ? value2 : _core.types.callExpression(file.addHelper("assertClassBrand"), [_core.types.cloneNode(classRef), receiver, value2]));
        }
        return isMethod ? setId ? newHelpers(file) ? _core.types.callExpression(file.addHelper("classPrivateSetter"), [_core.types.cloneNode(id), cloneId(setId), this.receiver(member), value2]) : _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneId(id), value2]) : _core.types.sequenceExpression([this.receiver(member), value2, readOnlyError(file, name)]) : newHelpers(file) ? _core.types.callExpression(file.addHelper("classPrivateFieldSet2"), [cloneId(id), this.receiver(member), value2]) : _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneId(id), value2]);
      }),
      destructureSet(member) {
        let {
          classRef,
          privateNamesMap,
          file,
          noUninitializedPrivateFieldAccess
        } = this, privateName = member.node.property, {
          name
        } = privateName.id, {
          id,
          static: isStatic,
          method: isMethod,
          setId
        } = privateNamesMap.get(name), cloneId = (id2) => _core.types.inherits(_core.types.cloneNode(id2), privateName);
        if (!newHelpers(file)) {
          if (isStatic) {
            try {
              var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
            } catch {
              throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
            }
            return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), cloneId(id)]), _core.types.identifier("value"));
          }
          return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), cloneId(id)]), _core.types.identifier("value"));
        }
        if (isMethod && !setId)
          return _core.types.memberExpression(_core.types.sequenceExpression([member.node.object, readOnlyError(file, name)]), _core.types.identifier("_"));
        if (isStatic && !isMethod) {
          let getCall = this.get(member);
          if (!noUninitializedPrivateFieldAccess || !_core.types.isCallExpression(getCall))
            return getCall;
          let ref = getCall.arguments.pop();
          return getCall.arguments.push(_core.template.expression.ast`(_) => ${ref} = _`), _core.types.memberExpression(_core.types.callExpression(file.addHelper("toSetter"), [getCall]), _core.types.identifier("_"));
        }
        let setCall = this.set(member, _core.types.identifier("_"));
        if (!_core.types.isCallExpression(setCall) || !_core.types.isIdentifier(setCall.arguments[setCall.arguments.length - 1], {
          name: "_"
        }))
          throw member.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github.com/babel/babel/issues.");
        let args;
        return _core.types.isMemberExpression(setCall.callee, {
          computed: !1
        }) && _core.types.isIdentifier(setCall.callee.property) && setCall.callee.property.name === "call" ? args = [setCall.callee.object, _core.types.arrayExpression(setCall.arguments.slice(1, -1)), setCall.arguments[0]] : args = [setCall.callee, _core.types.arrayExpression(setCall.arguments.slice(0, -1))], _core.types.memberExpression(_core.types.callExpression(file.addHelper("toSetter"), args), _core.types.identifier("_"));
      },
      call(member, args) {
        return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, !1);
      },
      optionalCall(member, args) {
        return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, !0);
      },
      delete() {
        throw new Error("Internal Babel error: deleting private elements is a parsing error.");
      }
    }, privateNameHandlerLoose = {
      get(member) {
        let {
          privateNamesMap,
          file
        } = this, {
          object
        } = member.node, {
          name
        } = member.node.property.id;
        return _core.template.expression`BASE(REF, PROP)[PROP]`({
          BASE: file.addHelper("classPrivateFieldLooseBase"),
          REF: _core.types.cloneNode(object),
          PROP: _core.types.cloneNode(privateNamesMap.get(name).id)
        });
      },
      set() {
        throw new Error("private name handler with loose = true don't need set()");
      },
      boundGet(member) {
        return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [_core.types.cloneNode(member.node.object)]);
      },
      simpleSet(member) {
        return this.get(member);
      },
      destructureSet(member) {
        return this.get(member);
      },
      call(member, args) {
        return _core.types.callExpression(this.get(member), args);
      },
      optionalCall(member, args) {
        return _core.types.optionalCallExpression(this.get(member), args, !0);
      },
      delete() {
        throw new Error("Internal Babel error: deleting private elements is a parsing error.");
      }
    };
    function transformPrivateNamesUsage(ref, path, privateNamesMap, {
      privateFieldsAsProperties,
      noUninitializedPrivateFieldAccess,
      noDocumentAll,
      innerBinding
    }, state) {
      if (!privateNamesMap.size) return;
      let body = path.get("body"), handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
      (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({
        privateNamesMap,
        classRef: ref,
        file: state
      }, handler, {
        noDocumentAll,
        noUninitializedPrivateFieldAccess,
        innerBinding
      })), body.traverse(privateInVisitor, {
        privateNamesMap,
        classRef: ref,
        file: state,
        privateFieldsAsProperties,
        innerBinding
      });
    }
    function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
      let {
        id
      } = privateNamesMap.get(prop.node.key.id.name), value2 = prop.node.value || prop.scope.buildUndefinedNode();
      return inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${value2}
      });
    `, prop);
    }
    function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {
      let {
        id
      } = privateNamesMap.get(prop.node.key.id.name), value2 = prop.node.value || prop.scope.buildUndefinedNode();
      if (!state.availableHelper("classPrivateFieldInitSpec"))
        return inheritPropComments(_core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${value2},
        })`, prop);
      let helper = state.addHelper("classPrivateFieldInitSpec");
      return inheritLoc(inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(helper, [_core.types.thisExpression(), inheritLoc(_core.types.cloneNode(id), prop.node.key), newHelpers(state) ? value2 : _core.template.expression.ast`{ writable: true, value: ${value2} }`])), prop), prop.node);
    }
    function buildPrivateStaticFieldInitSpec(prop, privateNamesMap, noUninitializedPrivateFieldAccess) {
      let privateName = privateNamesMap.get(prop.node.key.id.name), value2 = noUninitializedPrivateFieldAccess ? prop.node.value : _core.template.expression.ast`{
        _: ${prop.node.value || _core.types.buildUndefinedNode()}
      }`;
      return inheritPropComments(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.cloneNode(privateName.id), value2)]), prop);
    }
    buildPrivateStaticFieldInitSpecOld = function(prop, privateNamesMap) {
      let privateName = privateNamesMap.get(prop.node.key.id.name), {
        id,
        getId,
        setId,
        initAdded
      } = privateName, isGetterOrSetter = getId || setId;
      if (!prop.isProperty() && (initAdded || !isGetterOrSetter)) return;
      if (isGetterOrSetter)
        return privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: !0
        })), inheritPropComments(_core.template.statement.ast`
          var ${_core.types.cloneNode(id)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
          }
        `, prop);
      let value2 = prop.node.value || prop.scope.buildUndefinedNode();
      return inheritPropComments(_core.template.statement.ast`
        var ${_core.types.cloneNode(id)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${value2}
        };
      `, prop);
    };
    var buildPrivateStaticFieldInitSpecOld;
    function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
      let privateName = privateNamesMap.get(prop.node.key.id.name), {
        methodId,
        id,
        getId,
        setId,
        initAdded
      } = privateName;
      if (initAdded) return;
      if (methodId)
        return inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${methodId.name}
        });
      `, prop);
      if (getId || setId)
        return privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: !0
        })), inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        });
      `, prop);
    }
    function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {
      let privateName = privateNamesMap.get(prop.node.key.id.name);
      if (!privateName.initAdded)
        return !newHelpers(state) && (privateName.getId || privateName.setId) ? buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) : buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state);
    }
    function buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {
      let privateName = privateNamesMap.get(prop.node.key.id.name), {
        id,
        getId,
        setId
      } = privateName;
      if (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: !0
      })), !state.availableHelper("classPrivateFieldInitSpec"))
        return inheritPropComments(_core.template.statement.ast`
          ${id}.set(${ref}, {
            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
          });
        `, prop);
      let helper = state.addHelper("classPrivateFieldInitSpec");
      return inheritLoc(inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)},
      {
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      },
    )`, prop), prop.node);
    }
    function buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state) {
      let privateName = privateNamesMap.get(prop.node.key.id.name), {
        id
      } = privateName;
      if (!state.availableHelper("classPrivateMethodInitSpec"))
        return inheritPropComments(_core.template.statement.ast`${id}.add(${ref})`, prop);
      let helper = state.addHelper("classPrivateMethodInitSpec");
      return inheritPropComments(_core.template.statement.ast`${helper}(
      ${_core.types.thisExpression()},
      ${_core.types.cloneNode(id)}
    )`, prop);
    }
    function buildPublicFieldInitLoose(ref, prop) {
      let {
        key,
        computed
      } = prop.node, value2 = prop.node.value || prop.scope.buildUndefinedNode();
      return inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value2)), prop);
    }
    function buildPublicFieldInitSpec(ref, prop, state) {
      let {
        key,
        computed
      } = prop.node, value2 = prop.node.value || prop.scope.buildUndefinedNode();
      return inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value2])), prop);
    }
    function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
      let privateName = privateNamesMap.get(prop.node.key.id.name), {
        id,
        methodId,
        getId,
        setId,
        initAdded
      } = privateName;
      return initAdded ? void 0 : getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: !0
      })), inheritPropComments(_core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        })
      `, prop)) : inheritPropComments(_core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${methodId.name}
      });
    `, prop);
    }
    function buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties = !1) {
      let privateName = privateNamesMap.get(prop.node.key.id.name), {
        id,
        methodId,
        getId,
        setId,
        getterDeclared,
        setterDeclared,
        static: isStatic
      } = privateName, {
        params,
        body,
        generator,
        async
      } = prop.node, isGetter = getId && params.length === 0, isSetter = setId && params.length > 0;
      if (isGetter && getterDeclared || isSetter && setterDeclared)
        return privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: !0
        })), null;
      if (newHelpers(file) && (isGetter || isSetter) && !privateFieldsAsSymbolsOrProperties) {
        let scope = prop.get("body").scope, thisArg = scope.generateUidIdentifier("this"), state = {
          thisRef: thisArg,
          argumentsPath: []
        };
        if (prop.traverse(thisContextVisitor, state), state.argumentsPath.length) {
          let argumentsId = scope.generateUidIdentifier("arguments");
          scope.push({
            id: argumentsId,
            init: _core.template.expression.ast`[].slice.call(arguments, 1)`
          });
          for (let path of state.argumentsPath)
            path.replaceWith(_core.types.cloneNode(argumentsId));
        }
        params.unshift(_core.types.cloneNode(thisArg));
      }
      let declId = methodId;
      return isGetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        getterDeclared: !0,
        initAdded: !0
      })), declId = getId) : isSetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        setterDeclared: !0,
        initAdded: !0
      })), declId = setId) : isStatic && !privateFieldsAsSymbolsOrProperties && (declId = id), inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async), prop);
    }
    var thisContextVisitor = _traverse.visitors.environmentVisitor({
      Identifier(path, state) {
        state.argumentsPath && path.node.name === "arguments" && state.argumentsPath.push(path);
      },
      UnaryExpression(path) {
        let {
          node
        } = path;
        if (node.operator === "delete") {
          let argument = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(node.argument);
          _core.types.isThisExpression(argument) && path.replaceWith(_core.types.booleanLiteral(!0));
        }
      },
      ThisExpression(path, state) {
        state.needsClassRef = !0, path.replaceWith(_core.types.cloneNode(state.thisRef));
      },
      MetaProperty(path) {
        let {
          node,
          scope
        } = path;
        node.meta.name === "new" && node.property.name === "target" && path.replaceWith(scope.buildUndefinedNode());
      }
    }), innerReferencesVisitor = {
      ReferencedIdentifier(path, state) {
        path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding) && (state.needsClassRef = !0, path.node.name = state.thisRef.name);
      }
    };
    function replaceThisContext(path, ref, innerBindingRef) {
      var _state$thisRef;
      let state = {
        thisRef: ref,
        needsClassRef: !1,
        innerBinding: innerBindingRef
      };
      return path.isMethod() || path.traverse(thisContextVisitor, state), innerBindingRef != null && (_state$thisRef = state.thisRef) != null && _state$thisRef.name && state.thisRef.name !== innerBindingRef.name && path.traverse(innerReferencesVisitor, state), state.needsClassRef;
    }
    function isNameOrLength({
      key,
      computed
    }) {
      return key.type === "Identifier" ? !computed && (key.name === "name" || key.name === "length") : key.type === "StringLiteral" ? key.value === "name" || key.value === "length" : !1;
    }
    function inheritPropComments(node, prop) {
      return _core.types.inheritLeadingComments(node, prop.node), _core.types.inheritInnerComments(node, prop.node), node;
    }
    function inheritLoc(node, original) {
      return node.start = original.start, node.end = original.end, node.loc = original.loc, node;
    }
    function buildFieldsInitNodes(ref, superRef, props, privateNamesMap, file, setPublicClassFields, privateFieldsAsSymbolsOrProperties, noUninitializedPrivateFieldAccess, constantSuper, innerBindingRef) {
      let classRefFlags = 0, injectSuperRef, staticNodes = [], instanceNodes = [], lastInstanceNodeReturnsThis = !1, pureStaticNodes = [], classBindingNode = null, getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => (injectSuperRef ?? (injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef)), injectSuperRef), classRefForInnerBinding = ref ?? props[0].scope.generateUidIdentifier(innerBindingRef?.name || "Class");
      ref ?? (ref = _core.types.cloneNode(innerBindingRef));
      for (let prop of props) {
        prop.isClassProperty() && ts.assertFieldTransformed(prop);
        let isStatic = !(_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node)) && prop.node.static, isInstance = !isStatic, isPrivate = prop.isPrivate(), isPublic = !isPrivate, isField = prop.isProperty(), isMethod = !isField, isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();
        switch (isStatic && (classRefFlags |= 1), (isStatic || isMethod && isPrivate || isStaticBlock) && (new _helperReplaceSupers.default({
          methodPath: prop,
          constantSuper,
          file,
          refToPreserve: innerBindingRef,
          getSuperRef,
          getObjectRef() {
            return classRefFlags |= 2, isStatic || isStaticBlock ? classRefForInnerBinding : _core.types.memberExpression(classRefForInnerBinding, _core.types.identifier("prototype"));
          }
        }).replace(), replaceThisContext(prop, classRefForInnerBinding, innerBindingRef) && (classRefFlags |= 2)), lastInstanceNodeReturnsThis = !1, !0) {
          case isStaticBlock: {
            let blockBody = prop.node.body;
            blockBody.length === 1 && _core.types.isExpressionStatement(blockBody[0]) ? staticNodes.push(inheritPropComments(blockBody[0], prop)) : staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast`(() => { ${blockBody} })()`, prop.node));
            break;
          }
          case (isStatic && isPrivate && isField && privateFieldsAsSymbolsOrProperties):
            staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));
            break;
          case (isStatic && isPrivate && isField && !privateFieldsAsSymbolsOrProperties):
            newHelpers(file) ? staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap, noUninitializedPrivateFieldAccess)) : staticNodes.push(buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap));
            break;
          case (isStatic && isPublic && isField && setPublicClassFields):
            if (!isNameOrLength(prop.node)) {
              staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));
              break;
            }
          case (isStatic && isPublic && isField && !setPublicClassFields):
            staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, file));
            break;
          case (isInstance && isPrivate && isField && privateFieldsAsSymbolsOrProperties):
            instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
            break;
          case (isInstance && isPrivate && isField && !privateFieldsAsSymbolsOrProperties):
            instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file));
            break;
          case (isInstance && isPrivate && isMethod && privateFieldsAsSymbolsOrProperties):
            instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap)), pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
            break;
          case (isInstance && isPrivate && isMethod && !privateFieldsAsSymbolsOrProperties):
            instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, file)), pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
            break;
          case (isStatic && isPrivate && isMethod && !privateFieldsAsSymbolsOrProperties):
            newHelpers(file) || staticNodes.unshift(buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap)), pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
            break;
          case (isStatic && isPrivate && isMethod && privateFieldsAsSymbolsOrProperties):
            staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, file, privateNamesMap)), pureStaticNodes.push(buildPrivateMethodDeclaration(file, prop, privateNamesMap, privateFieldsAsSymbolsOrProperties));
            break;
          case (isInstance && isPublic && isField && setPublicClassFields):
            instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));
            break;
          case (isInstance && isPublic && isField && !setPublicClassFields):
            lastInstanceNodeReturnsThis = !0, instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, file));
            break;
          default:
            throw new Error("Unreachable.");
        }
      }
      return classRefFlags & 2 && innerBindingRef != null && (classBindingNode = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classRefForInnerBinding), _core.types.cloneNode(innerBindingRef)))), {
        staticNodes: staticNodes.filter(Boolean),
        instanceNodes: instanceNodes.filter(Boolean),
        lastInstanceNodeReturnsThis,
        pureStaticNodes: pureStaticNodes.filter(Boolean),
        classBindingNode,
        wrapClass(path) {
          for (let prop of props)
            prop.node.leadingComments = null, prop.remove();
          return injectSuperRef && (path.scope.push({
            id: _core.types.cloneNode(injectSuperRef)
          }), path.set("superClass", _core.types.assignmentExpression("=", injectSuperRef, path.node.superClass))), classRefFlags !== 0 && (path.isClassExpression() ? (path.scope.push({
            id: ref
          }), path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(ref), path.node))) : (innerBindingRef == null && (path.node.id = ref), classBindingNode != null && path.scope.push({
            id: classRefForInnerBinding
          }))), path;
        }
      };
    }
  }
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/misc.js
var require_misc2 = __commonJS({
  "../node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.extractComputedKeys = extractComputedKeys;
    exports.injectInitialization = injectInitialization;
    exports.memoiseComputedKey = memoiseComputedKey;
    var _core = require_lib27(), _traverse = require_lib10(), findBareSupers = _traverse.visitors.environmentVisitor({
      Super(path) {
        let {
          node,
          parentPath
        } = path;
        parentPath.isCallExpression({
          callee: node
        }) && this.push(parentPath);
      }
    }), referenceVisitor = {
      "TSTypeAnnotation|TypeAnnotation"(path) {
        path.skip();
      },
      ReferencedIdentifier(path, {
        scope
      }) {
        scope.hasOwnBinding(path.node.name) && (scope.rename(path.node.name), path.skip());
      }
    };
    function handleClassTDZ(path, state) {
      if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
        let classNameTDZError = state.file.addHelper("classNameTDZError"), throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);
        path.replaceWith(_core.types.sequenceExpression([throwNode, path.node])), path.skip();
      }
    }
    var classFieldDefinitionEvaluationTDZVisitor = {
      ReferencedIdentifier: handleClassTDZ,
      "TSTypeAnnotation|TypeAnnotation"(path) {
        path.skip();
      }
    };
    function injectInitialization(path, constructor, nodes, renamer, lastReturnsThis) {
      if (!nodes.length) return;
      let isDerived = !!path.node.superClass;
      if (!constructor) {
        let newConstructor = _core.types.classMethod("constructor", _core.types.identifier("constructor"), [], _core.types.blockStatement([]));
        isDerived && (newConstructor.params = [_core.types.restElement(_core.types.identifier("args"))], newConstructor.body.body.push(_core.template.statement.ast`super(...args)`)), [constructor] = path.get("body").unshiftContainer("body", newConstructor);
      }
      if (renamer && renamer(referenceVisitor, {
        scope: constructor.scope
      }), isDerived) {
        let bareSupers = [];
        constructor.traverse(findBareSupers, bareSupers);
        let isFirst = !0;
        for (let bareSuper of bareSupers)
          if (isFirst ? isFirst = !1 : nodes = nodes.map((n) => _core.types.cloneNode(n)), bareSuper.parentPath.isExpressionStatement())
            bareSuper.insertAfter(nodes);
          else {
            let allNodes = [bareSuper.node, ...nodes.map((n) => _core.types.toExpression(n))];
            lastReturnsThis || allNodes.push(_core.types.thisExpression()), bareSuper.replaceWith(_core.types.sequenceExpression(allNodes));
          }
      } else
        constructor.get("body").unshiftContainer("body", nodes);
    }
    function memoiseComputedKey(keyNode, scope, hint) {
      if (_core.types.isIdentifier(keyNode) && scope.hasUid(keyNode.name))
        return;
      if (_core.types.isAssignmentExpression(keyNode, {
        operator: "="
      }) && _core.types.isIdentifier(keyNode.left) && scope.hasUid(keyNode.left.name))
        return _core.types.cloneNode(keyNode);
      {
        let ident = _core.types.identifier(hint);
        return scope.push({
          id: ident,
          kind: "let"
        }), _core.types.assignmentExpression("=", _core.types.cloneNode(ident), keyNode);
      }
    }
    function extractComputedKeys(path, computedPaths, file) {
      let {
        scope
      } = path, declarations = [], state = {
        classBinding: path.node.id && scope.getBinding(path.node.id.name),
        file
      };
      for (let computedPath of computedPaths) {
        let computedKey = computedPath.get("key");
        computedKey.isReferencedIdentifier() ? handleClassTDZ(computedKey, state) : computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
        let computedNode = computedPath.node;
        if (!computedKey.isConstantExpression()) {
          let assignment = memoiseComputedKey(computedKey.node, scope, scope.generateUidBasedOnNode(computedKey.node));
          assignment && (declarations.push(_core.types.expressionStatement(assignment)), computedNode.key = _core.types.cloneNode(assignment.left));
        }
      }
      return declarations;
    }
  }
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js
var require_decorators = __commonJS({
  "../node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.buildNamedEvaluationVisitor = buildNamedEvaluationVisitor;
    exports.default = _default;
    exports.hasDecorators = hasDecorators;
    exports.hasOwnDecorators = hasOwnDecorators;
    var _core = require_lib27(), _helperReplaceSupers = require_lib19(), _helperSkipTransparentExpressionWrappers = require_lib21(), _fields = require_fields(), _misc = require_misc2();
    function hasOwnDecorators(node) {
      var _node$decorators;
      return !!((_node$decorators = node.decorators) != null && _node$decorators.length);
    }
    function hasDecorators(node) {
      return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
    }
    function incrementId(id, idx = id.length - 1) {
      if (idx === -1) {
        id.unshift(65);
        return;
      }
      let current = id[idx];
      current === 90 ? id[idx] = 97 : current === 122 ? (id[idx] = 65, incrementId(id, idx - 1)) : id[idx] = current + 1;
    }
    function createPrivateUidGeneratorForClass(classPath) {
      let currentPrivateId = [], privateNames = /* @__PURE__ */ new Set();
      return _core.types.traverseFast(classPath.node, (node) => {
        _core.types.isPrivateName(node) && privateNames.add(node.id.name);
      }), () => {
        let reifiedId;
        do
          incrementId(currentPrivateId), reifiedId = String.fromCharCode(...currentPrivateId);
        while (privateNames.has(reifiedId));
        return _core.types.privateName(_core.types.identifier(reifiedId));
      };
    }
    function createLazyPrivateUidGeneratorForClass(classPath) {
      let generator;
      return () => (generator || (generator = createPrivateUidGeneratorForClass(classPath)), generator());
    }
    function replaceClassWithVar(path, className) {
      let id = path.node.id, scope = path.scope;
      if (path.type === "ClassDeclaration") {
        let className2 = id.name, varId = scope.generateUidIdentifierBasedOnNode(id), classId = _core.types.identifier(className2);
        return scope.rename(className2, varId.name), path.get("id").replaceWith(classId), {
          id: _core.types.cloneNode(varId),
          path
        };
      } else {
        let varId;
        id ? (className = id.name, varId = generateLetUidIdentifier(scope.parent, className), scope.rename(className, varId.name)) : varId = generateLetUidIdentifier(scope.parent, typeof className == "string" ? className : "decorated_class");
        let newClassExpr = _core.types.classExpression(typeof className == "string" ? _core.types.identifier(className) : null, path.node.superClass, path.node.body), [newPath] = path.replaceWith(_core.types.sequenceExpression([newClassExpr, varId]));
        return {
          id: _core.types.cloneNode(varId),
          path: newPath.get("expressions.0")
        };
      }
    }
    function generateClassProperty(key, value2, isStatic) {
      return key.type === "PrivateName" ? _core.types.classPrivateProperty(key, value2, void 0, isStatic) : _core.types.classProperty(key, value2, void 0, void 0, isStatic);
    }
    function assignIdForAnonymousClass(path, className) {
      path.node.id || (path.node.id = typeof className == "string" ? _core.types.identifier(className) : path.scope.generateUidIdentifier("Class"));
    }
    function addProxyAccessorsFor(className, element, getterKey, setterKey, targetKey, isComputed, isStatic, version) {
      let thisArg = (version === "2023-11" || version === "2023-05") && isStatic ? className : _core.types.thisExpression(), getterBody = _core.types.blockStatement([_core.types.returnStatement(_core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)))]), setterBody = _core.types.blockStatement([_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(thisArg), _core.types.cloneNode(targetKey)), _core.types.identifier("v")))]), getter, setter;
      getterKey.type === "PrivateName" ? (getter = _core.types.classPrivateMethod("get", getterKey, [], getterBody, isStatic), setter = _core.types.classPrivateMethod("set", setterKey, [_core.types.identifier("v")], setterBody, isStatic)) : (getter = _core.types.classMethod("get", getterKey, [], getterBody, isComputed, isStatic), setter = _core.types.classMethod("set", setterKey, [_core.types.identifier("v")], setterBody, isComputed, isStatic)), element.insertAfter(setter), element.insertAfter(getter);
    }
    function extractProxyAccessorsFor(targetKey, version) {
      return version !== "2023-11" && version !== "2023-05" && version !== "2023-01" ? [_core.template.expression.ast`
        function () {
          return this.${_core.types.cloneNode(targetKey)};
        }
      `, _core.template.expression.ast`
        function (value) {
          this.${_core.types.cloneNode(targetKey)} = value;
        }
      `] : [_core.template.expression.ast`
      o => o.${_core.types.cloneNode(targetKey)}
    `, _core.template.expression.ast`
      (o, v) => o.${_core.types.cloneNode(targetKey)} = v
    `];
    }
    function getComputedKeyLastElement(path) {
      if (path = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path), path.isSequenceExpression()) {
        let expressions = path.get("expressions");
        return getComputedKeyLastElement(expressions[expressions.length - 1]);
      }
      return path;
    }
    function getComputedKeyMemoiser(path) {
      let element = getComputedKeyLastElement(path);
      if (element.isConstantExpression())
        return _core.types.cloneNode(path.node);
      if (element.isIdentifier() && path.scope.hasUid(element.node.name))
        return _core.types.cloneNode(path.node);
      if (element.isAssignmentExpression() && element.get("left").isIdentifier())
        return _core.types.cloneNode(element.node.left);
      throw new Error(`Internal Error: the computed key ${path.toString()} has not yet been memoised.`);
    }
    function prependExpressionsToComputedKey(expressions, fieldPath) {
      let key = fieldPath.get("key");
      key.isSequenceExpression() ? expressions.push(...key.node.expressions) : expressions.push(key.node), key.replaceWith(maybeSequenceExpression(expressions));
    }
    function appendExpressionsToComputedKey(expressions, fieldPath) {
      let key = fieldPath.get("key"), completion = getComputedKeyLastElement(key);
      if (completion.isConstantExpression())
        prependExpressionsToComputedKey(expressions, fieldPath);
      else {
        let scopeParent = key.scope.parent, maybeAssignment = (0, _misc.memoiseComputedKey)(completion.node, scopeParent, scopeParent.generateUid("computedKey"));
        if (!maybeAssignment)
          prependExpressionsToComputedKey(expressions, fieldPath);
        else {
          let expressionSequence = [...expressions, _core.types.cloneNode(maybeAssignment.left)], completionParent = completion.parentPath;
          completionParent.isSequenceExpression() ? completionParent.pushContainer("expressions", expressionSequence) : completion.replaceWith(maybeSequenceExpression([_core.types.cloneNode(maybeAssignment), ...expressionSequence]));
        }
      }
    }
    function prependExpressionsToFieldInitializer(expressions, fieldPath) {
      let initializer = fieldPath.get("value");
      initializer.node ? expressions.push(initializer.node) : expressions.length > 0 && (expressions[expressions.length - 1] = _core.types.unaryExpression("void", expressions[expressions.length - 1])), initializer.replaceWith(maybeSequenceExpression(expressions));
    }
    function prependExpressionsToStaticBlock(expressions, blockPath) {
      blockPath.unshiftContainer("body", _core.types.expressionStatement(maybeSequenceExpression(expressions)));
    }
    function prependExpressionsToConstructor(expressions, constructorPath) {
      constructorPath.node.body.body.unshift(_core.types.expressionStatement(maybeSequenceExpression(expressions)));
    }
    function isProtoInitCallExpression(expression, protoInitCall) {
      return _core.types.isCallExpression(expression) && _core.types.isIdentifier(expression.callee, {
        name: protoInitCall.name
      });
    }
    function optimizeSuperCallAndExpressions(expressions, protoInitLocal) {
      if (protoInitLocal) {
        if (expressions.length >= 2 && isProtoInitCallExpression(expressions[1], protoInitLocal)) {
          let mergedSuperCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [expressions[0]]);
          expressions.splice(0, 2, mergedSuperCall);
        }
        expressions.length >= 2 && _core.types.isThisExpression(expressions[expressions.length - 1]) && isProtoInitCallExpression(expressions[expressions.length - 2], protoInitLocal) && expressions.splice(expressions.length - 1, 1);
      }
      return maybeSequenceExpression(expressions);
    }
    function insertExpressionsAfterSuperCallAndOptimize(expressions, constructorPath, protoInitLocal) {
      constructorPath.traverse({
        CallExpression: {
          exit(path) {
            if (!path.get("callee").isSuper()) return;
            let newNodes = [path.node, ...expressions.map((expr) => _core.types.cloneNode(expr))];
            path.isCompletionRecord() && newNodes.push(_core.types.thisExpression()), path.replaceWith(optimizeSuperCallAndExpressions(newNodes, protoInitLocal)), path.skip();
          }
        },
        ClassMethod(path) {
          path.node.kind === "constructor" && path.skip();
        }
      });
    }
    function createConstructorFromExpressions(expressions, isDerivedClass) {
      let body = [_core.types.expressionStatement(maybeSequenceExpression(expressions))];
      return isDerivedClass && body.unshift(_core.types.expressionStatement(_core.types.callExpression(_core.types.super(), [_core.types.spreadElement(_core.types.identifier("args"))]))), _core.types.classMethod("constructor", _core.types.identifier("constructor"), isDerivedClass ? [_core.types.restElement(_core.types.identifier("args"))] : [], _core.types.blockStatement(body));
    }
    function createStaticBlockFromExpressions(expressions) {
      return _core.types.staticBlock([_core.types.expressionStatement(maybeSequenceExpression(expressions))]);
    }
    var FIELD = 0, ACCESSOR = 1, METHOD = 2, GETTER = 3, SETTER = 4, STATIC_OLD_VERSION = 5, STATIC = 8, DECORATORS_HAVE_THIS = 16;
    function getElementKind(element) {
      switch (element.node.type) {
        case "ClassProperty":
        case "ClassPrivateProperty":
          return FIELD;
        case "ClassAccessorProperty":
          return ACCESSOR;
        case "ClassMethod":
        case "ClassPrivateMethod":
          return element.node.kind === "get" ? GETTER : element.node.kind === "set" ? SETTER : METHOD;
      }
    }
    function toSortedDecoratorInfo(info) {
      return [...info.filter((el) => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...info.filter((el) => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER), ...info.filter((el) => el.isStatic && el.kind === FIELD), ...info.filter((el) => !el.isStatic && el.kind === FIELD)];
    }
    function generateDecorationList(decorators, decoratorsThis, version) {
      let decsCount = decorators.length, haveOneThis = decoratorsThis.some(Boolean), decs = [];
      for (let i = 0; i < decsCount; i++)
        (version === "2023-11" || version === "2023-05") && haveOneThis && decs.push(decoratorsThis[i] || _core.types.unaryExpression("void", _core.types.numericLiteral(0))), decs.push(decorators[i].expression);
      return {
        haveThis: haveOneThis,
        decs
      };
    }
    function generateDecorationExprs(decorationInfo, version) {
      return _core.types.arrayExpression(decorationInfo.map((el) => {
        let flag = el.kind;
        return el.isStatic && (flag += version === "2023-11" || version === "2023-05" ? STATIC : STATIC_OLD_VERSION), el.decoratorsHaveThis && (flag += DECORATORS_HAVE_THIS), _core.types.arrayExpression([el.decoratorsArray, _core.types.numericLiteral(flag), el.name, ...el.privateMethods || []]);
      }));
    }
    function extractElementLocalAssignments(decorationInfo) {
      let localIds = [];
      for (let el of decorationInfo) {
        let {
          locals
        } = el;
        Array.isArray(locals) ? localIds.push(...locals) : locals !== void 0 && localIds.push(locals);
      }
      return localIds;
    }
    function addCallAccessorsFor(version, element, key, getId, setId, isStatic) {
      element.insertAfter(_core.types.classPrivateMethod("get", _core.types.cloneNode(key), [], _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.cloneNode(getId), version === "2023-11" && isStatic ? [] : [_core.types.thisExpression()]))]), isStatic)), element.insertAfter(_core.types.classPrivateMethod("set", _core.types.cloneNode(key), [_core.types.identifier("v")], _core.types.blockStatement([_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(setId), version === "2023-11" && isStatic ? [_core.types.identifier("v")] : [_core.types.thisExpression(), _core.types.identifier("v")]))]), isStatic));
    }
    function movePrivateAccessor(element, key, methodLocalVar, isStatic) {
      let params, block;
      element.node.kind === "set" ? (params = [_core.types.identifier("v")], block = [_core.types.expressionStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression(), _core.types.identifier("v")]))]) : (params = [], block = [_core.types.returnStatement(_core.types.callExpression(methodLocalVar, [_core.types.thisExpression()]))]), element.replaceWith(_core.types.classPrivateMethod(element.node.kind, _core.types.cloneNode(key), params, _core.types.blockStatement(block), isStatic));
    }
    function isClassDecoratableElementPath(path) {
      let {
        type
      } = path;
      return type !== "TSDeclareMethod" && type !== "TSIndexSignature" && type !== "StaticBlock";
    }
    function staticBlockToIIFE(block) {
      return _core.types.callExpression(_core.types.arrowFunctionExpression([], _core.types.blockStatement(block.body)), []);
    }
    function staticBlockToFunctionClosure(block) {
      return _core.types.functionExpression(null, [], _core.types.blockStatement(block.body));
    }
    function fieldInitializerToClosure(value2) {
      return _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(value2)]));
    }
    function maybeSequenceExpression(exprs) {
      return exprs.length === 0 ? _core.types.unaryExpression("void", _core.types.numericLiteral(0)) : exprs.length === 1 ? exprs[0] : _core.types.sequenceExpression(exprs);
    }
    function createFunctionExpressionFromPrivateMethod(node) {
      let {
        params,
        body,
        generator: isGenerator,
        async: isAsync
      } = node;
      return _core.types.functionExpression(void 0, params, body, isGenerator, isAsync);
    }
    function createSetFunctionNameCall(state, className) {
      return _core.types.callExpression(state.addHelper("setFunctionName"), [_core.types.thisExpression(), className]);
    }
    function createToPropertyKeyCall(state, propertyKey) {
      return _core.types.callExpression(state.addHelper("toPropertyKey"), [propertyKey]);
    }
    function createPrivateBrandCheckClosure(brandName) {
      return _core.types.arrowFunctionExpression([_core.types.identifier("_")], _core.types.binaryExpression("in", _core.types.cloneNode(brandName), _core.types.identifier("_")));
    }
    function usesPrivateField(expression) {
      try {
        return _core.types.traverseFast(expression, (node) => {
          if (_core.types.isPrivateName(node))
            throw null;
        }), !1;
      } catch {
        return !0;
      }
    }
    function convertToComputedKey(path) {
      let {
        node
      } = path;
      node.computed = !0, _core.types.isIdentifier(node.key) && (node.key = _core.types.stringLiteral(node.key.name));
    }
    function hasInstancePrivateAccess(path, privateNames) {
      let containsInstancePrivateAccess = !1;
      if (privateNames.length > 0) {
        let privateNameVisitor = (0, _fields.privateNameVisitorFactory)({
          PrivateName(path2, state) {
            state.privateNamesMap.has(path2.node.id.name) && (containsInstancePrivateAccess = !0, path2.stop());
          }
        }), privateNamesMap = /* @__PURE__ */ new Map();
        for (let name of privateNames)
          privateNamesMap.set(name, null);
        path.traverse(privateNameVisitor, {
          privateNamesMap
        });
      }
      return containsInstancePrivateAccess;
    }
    function checkPrivateMethodUpdateError(path, decoratedPrivateMethods) {
      let privateNameVisitor = (0, _fields.privateNameVisitorFactory)({
        PrivateName(path2, state) {
          if (!state.privateNamesMap.has(path2.node.id.name)) return;
          let parentPath = path2.parentPath, parentParentPath = parentPath.parentPath;
          if (parentParentPath.node.type === "AssignmentExpression" && parentParentPath.node.left === parentPath.node || parentParentPath.node.type === "UpdateExpression" || parentParentPath.node.type === "RestElement" || parentParentPath.node.type === "ArrayPattern" || parentParentPath.node.type === "ObjectProperty" && parentParentPath.node.value === parentPath.node && parentParentPath.parentPath.type === "ObjectPattern" || parentParentPath.node.type === "ForOfStatement" && parentParentPath.node.left === parentPath.node)
            throw path2.buildCodeFrameError(`Decorated private methods are read-only, but "#${path2.node.id.name}" is updated via this expression.`);
        }
      }), privateNamesMap = /* @__PURE__ */ new Map();
      for (let name of decoratedPrivateMethods)
        privateNamesMap.set(name, null);
      path.traverse(privateNameVisitor, {
        privateNamesMap
      });
    }
    function transformClass(path, state, constantSuper, ignoreFunctionLength, className, propertyVisitor, version) {
      var _path$node$id;
      let body = path.get("body.body"), classDecorators = path.node.decorators, hasElementDecorators = !1, hasComputedKeysSideEffects = !1, elemDecsUseFnContext = !1, generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path), classAssignments = [], scopeParent = path.scope.parent, memoiseExpression = (expression, hint, assignments) => {
        let localEvaluatedId = generateLetUidIdentifier(scopeParent, hint);
        return assignments.push(_core.types.assignmentExpression("=", localEvaluatedId, expression)), _core.types.cloneNode(localEvaluatedId);
      }, protoInitLocal, staticInitLocal, classIdName = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name, setClassName = typeof className == "object" ? className : void 0, usesFunctionContextOrYieldAwait = (decorator) => {
        try {
          return _core.types.traverseFast(decorator, (node) => {
            if (_core.types.isThisExpression(node) || _core.types.isSuper(node) || _core.types.isYieldExpression(node) || _core.types.isAwaitExpression(node) || _core.types.isIdentifier(node, {
              name: "arguments"
            }) || classIdName && _core.types.isIdentifier(node, {
              name: classIdName
            }) || _core.types.isMetaProperty(node) && node.meta.name !== "import")
              throw null;
          }), !1;
        } catch {
          return !0;
        }
      }, instancePrivateNames = [];
      for (let element of body) {
        if (!isClassDecoratableElementPath(element))
          continue;
        let elementNode = element.node;
        if (!elementNode.static && _core.types.isPrivateName(elementNode.key) && instancePrivateNames.push(elementNode.key.id.name), isDecorated(elementNode)) {
          switch (elementNode.type) {
            case "ClassProperty":
              propertyVisitor.ClassProperty(element, state);
              break;
            case "ClassPrivateProperty":
              propertyVisitor.ClassPrivateProperty(element, state);
              break;
            case "ClassAccessorProperty":
              if (propertyVisitor.ClassAccessorProperty(element, state), version === "2023-11")
                break;
            default:
              elementNode.static ? staticInitLocal ?? (staticInitLocal = generateLetUidIdentifier(scopeParent, "initStatic")) : protoInitLocal ?? (protoInitLocal = generateLetUidIdentifier(scopeParent, "initProto"));
              break;
          }
          hasElementDecorators = !0, elemDecsUseFnContext || (elemDecsUseFnContext = elementNode.decorators.some(usesFunctionContextOrYieldAwait));
        } else if (elementNode.type === "ClassAccessorProperty") {
          propertyVisitor.ClassAccessorProperty(element, state);
          let {
            key,
            value: value2,
            static: isStatic,
            computed
          } = elementNode, newId = generateClassPrivateUid(), newField = generateClassProperty(newId, value2, isStatic), keyPath = element.get("key"), [newPath] = element.replaceWith(newField), getterKey, setterKey;
          computed && !keyPath.isConstantExpression() ? (getterKey = (0, _misc.memoiseComputedKey)(createToPropertyKeyCall(state, key), scopeParent, scopeParent.generateUid("computedKey")), setterKey = _core.types.cloneNode(getterKey.left)) : (getterKey = _core.types.cloneNode(key), setterKey = _core.types.cloneNode(key)), assignIdForAnonymousClass(path, className), addProxyAccessorsFor(path.node.id, newPath, getterKey, setterKey, newId, computed, isStatic, version);
        }
        "computed" in element.node && element.node.computed && (hasComputedKeysSideEffects || (hasComputedKeysSideEffects = !scopeParent.isStatic(element.node.key)));
      }
      if (!classDecorators && !hasElementDecorators) {
        !path.node.id && typeof className == "string" && (path.node.id = _core.types.identifier(className)), setClassName && path.node.body.body.unshift(createStaticBlockFromExpressions([createSetFunctionNameCall(state, setClassName)]));
        return;
      }
      let elementDecoratorInfo = [], constructorPath, decoratedPrivateMethods = /* @__PURE__ */ new Set(), classInitLocal, classIdLocal, decoratorReceiverId = null;
      function handleDecorators(decorators) {
        let hasSideEffects = !1, usesFnContext = !1, decoratorsThis = [];
        for (let decorator of decorators) {
          let {
            expression
          } = decorator, object;
          (version === "2023-11" || version === "2023-05") && _core.types.isMemberExpression(expression) && (_core.types.isSuper(expression.object) ? object = _core.types.thisExpression() : scopeParent.isStatic(expression.object) ? object = _core.types.cloneNode(expression.object) : (decoratorReceiverId ?? (decoratorReceiverId = generateLetUidIdentifier(scopeParent, "obj")), object = _core.types.assignmentExpression("=", _core.types.cloneNode(decoratorReceiverId), expression.object), expression.object = _core.types.cloneNode(decoratorReceiverId))), decoratorsThis.push(object), hasSideEffects || (hasSideEffects = !scopeParent.isStatic(expression)), usesFnContext || (usesFnContext = usesFunctionContextOrYieldAwait(decorator));
        }
        return {
          hasSideEffects,
          usesFnContext,
          decoratorsThis
        };
      }
      let willExtractSomeElemDecs = hasComputedKeysSideEffects || elemDecsUseFnContext || version !== "2023-11", needsDeclarationForClassBinding = !1, classDecorationsFlag = 0, classDecorations = [], classDecorationsId, computedKeyAssignments = [];
      if (classDecorators) {
        classInitLocal = generateLetUidIdentifier(scopeParent, "initClass"), needsDeclarationForClassBinding = path.isClassDeclaration(), {
          id: classIdLocal,
          path
        } = replaceClassWithVar(path, className), path.node.decorators = null;
        let classDecsUsePrivateName = classDecorators.some(usesPrivateField), {
          hasSideEffects,
          usesFnContext,
          decoratorsThis
        } = handleDecorators(classDecorators), {
          haveThis,
          decs
        } = generateDecorationList(classDecorators, decoratorsThis, version);
        if (classDecorationsFlag = haveThis ? 1 : 0, classDecorations = decs, (usesFnContext || hasSideEffects && willExtractSomeElemDecs || classDecsUsePrivateName) && (classDecorationsId = memoiseExpression(_core.types.arrayExpression(classDecorations), "classDecs", classAssignments)), !hasElementDecorators)
          for (let element of path.get("body.body")) {
            let {
              node
            } = element;
            if ("computed" in node && node.computed)
              if (element.isClassProperty({
                static: !0
              })) {
                if (!element.get("key").isConstantExpression()) {
                  let key = node.key, maybeAssignment = (0, _misc.memoiseComputedKey)(key, scopeParent, scopeParent.generateUid("computedKey"));
                  maybeAssignment != null && (node.key = _core.types.cloneNode(maybeAssignment.left), computedKeyAssignments.push(maybeAssignment));
                }
              } else computedKeyAssignments.length > 0 && (prependExpressionsToComputedKey(computedKeyAssignments, element), computedKeyAssignments = []);
          }
      } else
        assignIdForAnonymousClass(path, className), classIdLocal = _core.types.cloneNode(path.node.id);
      let lastInstancePrivateName, needsInstancePrivateBrandCheck = !1, fieldInitializerExpressions = [], staticFieldInitializerExpressions = [];
      if (hasElementDecorators) {
        if (protoInitLocal) {
          let protoInitCall = _core.types.callExpression(_core.types.cloneNode(protoInitLocal), [_core.types.thisExpression()]);
          fieldInitializerExpressions.push(protoInitCall);
        }
        for (let element of body) {
          if (!isClassDecoratableElementPath(element)) {
            staticFieldInitializerExpressions.length > 0 && element.isStaticBlock() && (prependExpressionsToStaticBlock(staticFieldInitializerExpressions, element), staticFieldInitializerExpressions = []);
            continue;
          }
          let {
            node
          } = element, decorators = node.decorators, hasDecorators2 = !!(decorators != null && decorators.length), isComputed = "computed" in node && node.computed, name = "computedKey";
          node.key.type === "PrivateName" ? name = node.key.id.name : !isComputed && node.key.type === "Identifier" && (name = node.key.name);
          let decoratorsArray, decoratorsHaveThis;
          if (hasDecorators2) {
            let {
              hasSideEffects,
              usesFnContext,
              decoratorsThis
            } = handleDecorators(decorators), {
              decs,
              haveThis
            } = generateDecorationList(decorators, decoratorsThis, version);
            decoratorsHaveThis = haveThis, decoratorsArray = decs.length === 1 ? decs[0] : _core.types.arrayExpression(decs), (usesFnContext || hasSideEffects && willExtractSomeElemDecs) && (decoratorsArray = memoiseExpression(decoratorsArray, name + "Decs", computedKeyAssignments));
          }
          if (isComputed && !element.get("key").isConstantExpression()) {
            let key2 = node.key, maybeAssignment = (0, _misc.memoiseComputedKey)(hasDecorators2 ? createToPropertyKeyCall(state, key2) : key2, scopeParent, scopeParent.generateUid("computedKey"));
            maybeAssignment != null && (classDecorators && element.isClassProperty({
              static: !0
            }) ? (node.key = _core.types.cloneNode(maybeAssignment.left), computedKeyAssignments.push(maybeAssignment)) : node.key = maybeAssignment);
          }
          let {
            key,
            static: isStatic
          } = node, isPrivate = key.type === "PrivateName", kind = getElementKind(element);
          isPrivate && !isStatic && (hasDecorators2 && (needsInstancePrivateBrandCheck = !0), (_core.types.isClassPrivateProperty(node) || !lastInstancePrivateName) && (lastInstancePrivateName = key)), element.isClassMethod({
            kind: "constructor"
          }) && (constructorPath = element);
          let locals;
          if (hasDecorators2) {
            let privateMethods, nameExpr;
            if (isComputed ? nameExpr = getComputedKeyMemoiser(element.get("key")) : key.type === "PrivateName" ? nameExpr = _core.types.stringLiteral(key.id.name) : key.type === "Identifier" ? nameExpr = _core.types.stringLiteral(key.name) : nameExpr = _core.types.cloneNode(key), kind === ACCESSOR) {
              let {
                value: value2
              } = element.node, params = version === "2023-11" && isStatic ? [] : [_core.types.thisExpression()];
              value2 && params.push(_core.types.cloneNode(value2));
              let newId = generateClassPrivateUid(), newFieldInitId = generateLetUidIdentifier(scopeParent, `init_${name}`), newValue = _core.types.callExpression(_core.types.cloneNode(newFieldInitId), params), newField = generateClassProperty(newId, newValue, isStatic), [newPath] = element.replaceWith(newField);
              if (isPrivate) {
                privateMethods = extractProxyAccessorsFor(newId, version);
                let getId = generateLetUidIdentifier(scopeParent, `get_${name}`), setId = generateLetUidIdentifier(scopeParent, `set_${name}`);
                addCallAccessorsFor(version, newPath, key, getId, setId, isStatic), locals = [newFieldInitId, getId, setId];
              } else
                assignIdForAnonymousClass(path, className), addProxyAccessorsFor(path.node.id, newPath, _core.types.cloneNode(key), _core.types.isAssignmentExpression(key) ? _core.types.cloneNode(key.left) : _core.types.cloneNode(key), newId, isComputed, isStatic, version), locals = [newFieldInitId];
            } else if (kind === FIELD) {
              let initId = generateLetUidIdentifier(scopeParent, `init_${name}`), valuePath = element.get("value"), args = version === "2023-11" && isStatic ? [] : [_core.types.thisExpression()];
              valuePath.node && args.push(valuePath.node), valuePath.replaceWith(_core.types.callExpression(_core.types.cloneNode(initId), args)), locals = [initId], isPrivate && (privateMethods = extractProxyAccessorsFor(key, version));
            } else if (isPrivate) {
              let callId = generateLetUidIdentifier(scopeParent, `call_${name}`);
              if (locals = [callId], new _helperReplaceSupers.default({
                constantSuper,
                methodPath: element,
                objectRef: classIdLocal,
                superRef: path.node.superClass,
                file: state.file,
                refToPreserve: classIdLocal
              }).replace(), privateMethods = [createFunctionExpressionFromPrivateMethod(element.node)], kind === GETTER || kind === SETTER)
                movePrivateAccessor(element, _core.types.cloneNode(key), _core.types.cloneNode(callId), isStatic);
              else {
                let node2 = element.node;
                path.node.body.body.unshift(_core.types.classPrivateProperty(key, _core.types.cloneNode(callId), [], node2.static)), decoratedPrivateMethods.add(key.id.name), element.remove();
              }
            }
            elementDecoratorInfo.push({
              kind,
              decoratorsArray,
              decoratorsHaveThis,
              name: nameExpr,
              isStatic,
              privateMethods,
              locals
            }), element.node && (element.node.decorators = null);
          }
          if (isComputed && computedKeyAssignments.length > 0 && (classDecorators && element.isClassProperty({
            static: !0
          }) || (prependExpressionsToComputedKey(computedKeyAssignments, kind === ACCESSOR ? element.getNextSibling() : element), computedKeyAssignments = [])), fieldInitializerExpressions.length > 0 && !isStatic && (kind === FIELD || kind === ACCESSOR) && (prependExpressionsToFieldInitializer(fieldInitializerExpressions, element), fieldInitializerExpressions = []), staticFieldInitializerExpressions.length > 0 && isStatic && (kind === FIELD || kind === ACCESSOR) && (prependExpressionsToFieldInitializer(staticFieldInitializerExpressions, element), staticFieldInitializerExpressions = []), hasDecorators2 && version === "2023-11" && (kind === FIELD || kind === ACCESSOR)) {
            let initExtraId = generateLetUidIdentifier(scopeParent, `init_extra_${name}`);
            locals.push(initExtraId);
            let initExtraCall = _core.types.callExpression(_core.types.cloneNode(initExtraId), isStatic ? [] : [_core.types.thisExpression()]);
            isStatic ? staticFieldInitializerExpressions.push(initExtraCall) : fieldInitializerExpressions.push(initExtraCall);
          }
        }
      }
      if (computedKeyAssignments.length > 0) {
        let elements = path.get("body.body"), lastComputedElement;
        for (let i = elements.length - 1; i >= 0; i--) {
          let path2 = elements[i], node = path2.node;
          if (node.computed) {
            if (classDecorators && _core.types.isClassProperty(node, {
              static: !0
            }))
              continue;
            lastComputedElement = path2;
            break;
          }
        }
        lastComputedElement != null && (appendExpressionsToComputedKey(computedKeyAssignments, lastComputedElement), computedKeyAssignments = []);
      }
      if (fieldInitializerExpressions.length > 0) {
        let isDerivedClass = !!path.node.superClass;
        constructorPath ? isDerivedClass ? insertExpressionsAfterSuperCallAndOptimize(fieldInitializerExpressions, constructorPath, protoInitLocal) : prependExpressionsToConstructor(fieldInitializerExpressions, constructorPath) : path.node.body.body.unshift(createConstructorFromExpressions(fieldInitializerExpressions, isDerivedClass)), fieldInitializerExpressions = [];
      }
      staticFieldInitializerExpressions.length > 0 && (path.node.body.body.push(createStaticBlockFromExpressions(staticFieldInitializerExpressions)), staticFieldInitializerExpressions = []);
      let sortedElementDecoratorInfo = toSortedDecoratorInfo(elementDecoratorInfo), elementDecorations = generateDecorationExprs(version === "2023-11" ? elementDecoratorInfo : sortedElementDecoratorInfo, version), elementLocals = extractElementLocalAssignments(sortedElementDecoratorInfo);
      protoInitLocal && elementLocals.push(protoInitLocal), staticInitLocal && elementLocals.push(staticInitLocal);
      let classLocals = [], classInitInjected = !1, classInitCall = classInitLocal && _core.types.callExpression(_core.types.cloneNode(classInitLocal), []), originalClassPath = path, originalClass = path.node, staticClosures = [];
      if (classDecorators) {
        classLocals.push(classIdLocal, classInitLocal);
        let statics = [];
        if (path.get("body.body").forEach((element) => {
          if (element.isStaticBlock()) {
            if (hasInstancePrivateAccess(element, instancePrivateNames)) {
              let staticBlockClosureId = memoiseExpression(staticBlockToFunctionClosure(element.node), "staticBlock", staticClosures);
              staticFieldInitializerExpressions.push(_core.types.callExpression(_core.types.memberExpression(staticBlockClosureId, _core.types.identifier("call")), [_core.types.thisExpression()]));
            } else
              staticFieldInitializerExpressions.push(staticBlockToIIFE(element.node));
            element.remove();
            return;
          }
          if ((element.isClassProperty() || element.isClassPrivateProperty()) && element.node.static) {
            let valuePath = element.get("value");
            if (hasInstancePrivateAccess(valuePath, instancePrivateNames)) {
              let fieldValueClosureId = memoiseExpression(fieldInitializerToClosure(valuePath.node), "fieldValue", staticClosures);
              valuePath.replaceWith(_core.types.callExpression(_core.types.memberExpression(fieldValueClosureId, _core.types.identifier("call")), [_core.types.thisExpression()]));
            }
            staticFieldInitializerExpressions.length > 0 && (prependExpressionsToFieldInitializer(staticFieldInitializerExpressions, element), staticFieldInitializerExpressions = []), element.node.static = !1, statics.push(element.node), element.remove();
          } else if (element.isClassPrivateMethod({
            static: !0
          })) {
            if (hasInstancePrivateAccess(element, instancePrivateNames)) {
              new _helperReplaceSupers.default({
                constantSuper,
                methodPath: element,
                objectRef: classIdLocal,
                superRef: path.node.superClass,
                file: state.file,
                refToPreserve: classIdLocal
              }).replace();
              let privateMethodDelegateId = memoiseExpression(createFunctionExpressionFromPrivateMethod(element.node), element.get("key.id").node.name, staticClosures);
              ignoreFunctionLength ? (element.node.params = [_core.types.restElement(_core.types.identifier("arg"))], element.node.body = _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId, _core.types.identifier("apply")), [_core.types.thisExpression(), _core.types.identifier("arg")]))])) : (element.node.params = element.node.params.map((p, i) => _core.types.isRestElement(p) ? _core.types.restElement(_core.types.identifier("arg")) : _core.types.identifier("_" + i)), element.node.body = _core.types.blockStatement([_core.types.returnStatement(_core.types.callExpression(_core.types.memberExpression(privateMethodDelegateId, _core.types.identifier("apply")), [_core.types.thisExpression(), _core.types.identifier("arguments")]))]));
            }
            element.node.static = !1, statics.push(element.node), element.remove();
          }
        }), statics.length > 0 || staticFieldInitializerExpressions.length > 0) {
          let staticsClass = _core.template.expression.ast`
        class extends ${state.addHelper("identity")} {}
      `;
          staticsClass.body.body = [_core.types.classProperty(_core.types.toExpression(originalClass), void 0, void 0, void 0, !0, !0), ...statics];
          let constructorBody = [], newExpr = _core.types.newExpression(staticsClass, []);
          staticFieldInitializerExpressions.length > 0 && constructorBody.push(...staticFieldInitializerExpressions), classInitCall && (classInitInjected = !0, constructorBody.push(classInitCall)), constructorBody.length > 0 ? (constructorBody.unshift(_core.types.callExpression(_core.types.super(), [_core.types.cloneNode(classIdLocal)])), staticsClass.body.body.push(createConstructorFromExpressions(constructorBody, !1))) : newExpr.arguments.push(_core.types.cloneNode(classIdLocal));
          let [newPath] = path.replaceWith(newExpr);
          originalClassPath = newPath.get("callee").get("body").get("body.0.key");
        }
      }
      !classInitInjected && classInitCall && path.node.body.body.push(_core.types.staticBlock([_core.types.expressionStatement(classInitCall)]));
      let {
        superClass
      } = originalClass;
      if (superClass && (version === "2023-11" || version === "2023-05")) {
        let id = path.scope.maybeGenerateMemoised(superClass);
        id && (originalClass.superClass = _core.types.assignmentExpression("=", id, superClass), superClass = id);
      }
      let applyDecoratorWrapper = _core.types.staticBlock([]);
      originalClass.body.body.unshift(applyDecoratorWrapper);
      let applyDecsBody = applyDecoratorWrapper.body;
      if (computedKeyAssignments.length > 0) {
        let elements = originalClassPath.get("body.body"), firstPublicElement;
        for (let path2 of elements)
          if ((path2.isClassProperty() || path2.isClassMethod()) && path2.node.kind !== "constructor") {
            firstPublicElement = path2;
            break;
          }
        firstPublicElement != null ? (convertToComputedKey(firstPublicElement), prependExpressionsToComputedKey(computedKeyAssignments, firstPublicElement)) : (originalClass.body.body.unshift(_core.types.classProperty(_core.types.sequenceExpression([...computedKeyAssignments, _core.types.stringLiteral("_")]), void 0, void 0, void 0, !0, !0)), applyDecsBody.push(_core.types.expressionStatement(_core.types.unaryExpression("delete", _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("_")))))), computedKeyAssignments = [];
      }
      if (applyDecsBody.push(_core.types.expressionStatement(createLocalsAssignment(elementLocals, classLocals, elementDecorations, classDecorationsId ?? _core.types.arrayExpression(classDecorations), _core.types.numericLiteral(classDecorationsFlag), needsInstancePrivateBrandCheck ? lastInstancePrivateName : null, setClassName, _core.types.cloneNode(superClass), state, version))), staticInitLocal && applyDecsBody.push(_core.types.expressionStatement(_core.types.callExpression(_core.types.cloneNode(staticInitLocal), [_core.types.thisExpression()]))), staticClosures.length > 0 && applyDecsBody.push(...staticClosures.map((expr) => _core.types.expressionStatement(expr))), path.insertBefore(classAssignments.map((expr) => _core.types.expressionStatement(expr))), needsDeclarationForClassBinding)
        if (!scopeParent.getBinding(classIdLocal.name).constantViolations.length)
          path.insertBefore(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]));
        else {
          let classOuterBindingDelegateLocal = scopeParent.generateUidIdentifier("t" + classIdLocal.name), classOuterBindingLocal = classIdLocal;
          path.replaceWithMultiple([_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classOuterBindingLocal)), _core.types.variableDeclarator(classOuterBindingDelegateLocal)]), _core.types.blockStatement([_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(classIdLocal))]), path.node, _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classOuterBindingDelegateLocal), _core.types.cloneNode(classIdLocal)))]), _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(classOuterBindingLocal), _core.types.cloneNode(classOuterBindingDelegateLocal)))]);
        }
      return decoratedPrivateMethods.size > 0 && checkPrivateMethodUpdateError(path, decoratedPrivateMethods), path.scope.crawl(), path;
    }
    function createLocalsAssignment(elementLocals, classLocals, elementDecorations, classDecorations, classDecorationsFlag, maybePrivateBrandName, setClassName, superClass, state, version) {
      let lhs, rhs, args = [setClassName ? createSetFunctionNameCall(state, setClassName) : _core.types.thisExpression(), classDecorations, elementDecorations];
      {
        if (version !== "2023-11" && args.splice(1, 2, elementDecorations, classDecorations), version === "2021-12" || version === "2022-03" && !state.availableHelper("applyDecs2203R"))
          return lhs = _core.types.arrayPattern([...elementLocals, ...classLocals]), rhs = _core.types.callExpression(state.addHelper(version === "2021-12" ? "applyDecs" : "applyDecs2203"), args), _core.types.assignmentExpression("=", lhs, rhs);
        version === "2022-03" ? rhs = _core.types.callExpression(state.addHelper("applyDecs2203R"), args) : version === "2023-01" ? (maybePrivateBrandName && args.push(createPrivateBrandCheckClosure(maybePrivateBrandName)), rhs = _core.types.callExpression(state.addHelper("applyDecs2301"), args)) : version === "2023-05" && ((maybePrivateBrandName || superClass || classDecorationsFlag.value !== 0) && args.push(classDecorationsFlag), maybePrivateBrandName ? args.push(createPrivateBrandCheckClosure(maybePrivateBrandName)) : superClass && args.push(_core.types.unaryExpression("void", _core.types.numericLiteral(0))), superClass && args.push(superClass), rhs = _core.types.callExpression(state.addHelper("applyDecs2305"), args));
      }
      return version === "2023-11" && ((maybePrivateBrandName || superClass || classDecorationsFlag.value !== 0) && args.push(classDecorationsFlag), maybePrivateBrandName ? args.push(createPrivateBrandCheckClosure(maybePrivateBrandName)) : superClass && args.push(_core.types.unaryExpression("void", _core.types.numericLiteral(0))), superClass && args.push(superClass), rhs = _core.types.callExpression(state.addHelper("applyDecs2311"), args)), elementLocals.length > 0 ? classLocals.length > 0 ? lhs = _core.types.objectPattern([_core.types.objectProperty(_core.types.identifier("e"), _core.types.arrayPattern(elementLocals)), _core.types.objectProperty(_core.types.identifier("c"), _core.types.arrayPattern(classLocals))]) : (lhs = _core.types.arrayPattern(elementLocals), rhs = _core.types.memberExpression(rhs, _core.types.identifier("e"), !1, !1)) : (lhs = _core.types.arrayPattern(classLocals), rhs = _core.types.memberExpression(rhs, _core.types.identifier("c"), !1, !1)), _core.types.assignmentExpression("=", lhs, rhs);
    }
    function isProtoKey(node) {
      return node.type === "Identifier" ? node.name === "__proto__" : node.value === "__proto__";
    }
    function isDecorated(node) {
      return node.decorators && node.decorators.length > 0;
    }
    function shouldTransformElement(node) {
      switch (node.type) {
        case "ClassAccessorProperty":
          return !0;
        case "ClassMethod":
        case "ClassProperty":
        case "ClassPrivateMethod":
        case "ClassPrivateProperty":
          return isDecorated(node);
        default:
          return !1;
      }
    }
    function shouldTransformClass(node) {
      return isDecorated(node) || node.body.body.some(shouldTransformElement);
    }
    function buildNamedEvaluationVisitor(needsName, visitor) {
      function handleComputedProperty(propertyPath, key, state) {
        switch (key.type) {
          case "StringLiteral":
            return _core.types.stringLiteral(key.value);
          case "NumericLiteral":
          case "BigIntLiteral": {
            let keyValue = key.value + "";
            return propertyPath.get("key").replaceWith(_core.types.stringLiteral(keyValue)), _core.types.stringLiteral(keyValue);
          }
          default: {
            let ref = propertyPath.scope.maybeGenerateMemoised(key);
            return propertyPath.get("key").replaceWith(_core.types.assignmentExpression("=", ref, createToPropertyKeyCall(state, key))), _core.types.cloneNode(ref);
          }
        }
      }
      return {
        VariableDeclarator(path, state) {
          let id = path.node.id;
          if (id.type === "Identifier") {
            let initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("init"));
            if (needsName(initializer)) {
              let name = id.name;
              visitor(initializer, state, name);
            }
          }
        },
        AssignmentExpression(path, state) {
          let id = path.node.left;
          if (id.type === "Identifier") {
            let initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("right"));
            if (needsName(initializer))
              switch (path.node.operator) {
                case "=":
                case "&&=":
                case "||=":
                case "??=":
                  visitor(initializer, state, id.name);
              }
          }
        },
        AssignmentPattern(path, state) {
          let id = path.node.left;
          if (id.type === "Identifier") {
            let initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("right"));
            if (needsName(initializer)) {
              let name = id.name;
              visitor(initializer, state, name);
            }
          }
        },
        ObjectExpression(path, state) {
          for (let propertyPath of path.get("properties")) {
            if (!propertyPath.isObjectProperty()) continue;
            let {
              node
            } = propertyPath, id = node.key, initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(propertyPath.get("value"));
            if (needsName(initializer)) {
              if (node.computed) {
                let ref = handleComputedProperty(propertyPath, id, state);
                visitor(initializer, state, ref);
              } else if (!isProtoKey(id))
                if (id.type === "Identifier")
                  visitor(initializer, state, id.name);
                else {
                  let className = _core.types.stringLiteral(id.value + "");
                  visitor(initializer, state, className);
                }
            }
          }
        },
        ClassPrivateProperty(path, state) {
          let {
            node
          } = path, initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));
          if (needsName(initializer)) {
            let className = _core.types.stringLiteral("#" + node.key.id.name);
            visitor(initializer, state, className);
          }
        },
        ClassAccessorProperty(path, state) {
          let {
            node
          } = path, id = node.key, initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));
          if (needsName(initializer))
            if (node.computed) {
              let ref = handleComputedProperty(path, id, state);
              visitor(initializer, state, ref);
            } else if (id.type === "Identifier")
              visitor(initializer, state, id.name);
            else if (id.type === "PrivateName") {
              let className = _core.types.stringLiteral("#" + id.id.name);
              visitor(initializer, state, className);
            } else {
              let className = _core.types.stringLiteral(id.value + "");
              visitor(initializer, state, className);
            }
        },
        ClassProperty(path, state) {
          let {
            node
          } = path, id = node.key, initializer = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("value"));
          if (needsName(initializer))
            if (node.computed) {
              let ref = handleComputedProperty(path, id, state);
              visitor(initializer, state, ref);
            } else if (id.type === "Identifier")
              visitor(initializer, state, id.name);
            else {
              let className = _core.types.stringLiteral(id.value + "");
              visitor(initializer, state, className);
            }
        }
      };
    }
    function isDecoratedAnonymousClassExpression(path) {
      return path.isClassExpression({
        id: null
      }) && shouldTransformClass(path.node);
    }
    function generateLetUidIdentifier(scope, name) {
      let id = scope.generateUidIdentifier(name);
      return scope.push({
        id,
        kind: "let"
      }), _core.types.cloneNode(id);
    }
    function _default({
      assertVersion,
      assumption
    }, {
      loose
    }, version, inherits) {
      var _assumption, _assumption2;
      assertVersion(version === "2023-11" || version === "2023-05" || version === "2023-01" ? "^7.21.0" : version === "2021-12" ? "^7.16.0" : "^7.19.0");
      let VISITED = /* @__PURE__ */ new WeakSet(), constantSuper = (_assumption = assumption("constantSuper")) != null ? _assumption : loose, ignoreFunctionLength = (_assumption2 = assumption("ignoreFunctionLength")) != null ? _assumption2 : loose, namedEvaluationVisitor = buildNamedEvaluationVisitor(isDecoratedAnonymousClassExpression, visitClass);
      function visitClass(path, state, className) {
        var _node$id;
        if (VISITED.has(path)) return;
        let {
          node
        } = path;
        className ?? (className = (_node$id = node.id) == null ? void 0 : _node$id.name);
        let newPath = transformClass(path, state, constantSuper, ignoreFunctionLength, className, namedEvaluationVisitor, version);
        if (newPath) {
          VISITED.add(newPath);
          return;
        }
        VISITED.add(path);
      }
      return {
        name: "proposal-decorators",
        inherits,
        visitor: Object.assign({
          ExportDefaultDeclaration(path, state) {
            let {
              declaration
            } = path.node;
            if (declaration?.type === "ClassDeclaration" && isDecorated(declaration)) {
              let isAnonymous = !declaration.id;
              {
                var _path$splitExportDecl;
                (_path$splitExportDecl = path.splitExportDeclaration) != null || (path.splitExportDeclaration = require_lib10().NodePath.prototype.splitExportDeclaration);
              }
              let updatedVarDeclarationPath = path.splitExportDeclaration();
              isAnonymous && visitClass(updatedVarDeclarationPath, state, _core.types.stringLiteral("default"));
            }
          },
          ExportNamedDeclaration(path) {
            let {
              declaration
            } = path.node;
            if (declaration?.type === "ClassDeclaration" && isDecorated(declaration)) {
              {
                var _path$splitExportDecl2;
                (_path$splitExportDecl2 = path.splitExportDeclaration) != null || (path.splitExportDeclaration = require_lib10().NodePath.prototype.splitExportDeclaration);
              }
              path.splitExportDeclaration();
            }
          },
          Class(path, state) {
            visitClass(path, state, void 0);
          }
        }, namedEvaluationVisitor)
      };
    }
  }
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js
var require_decorators_2018_09 = __commonJS({
  "../node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.buildDecoratedClass = buildDecoratedClass;
    var _core = require_lib27(), _helperReplaceSupers = require_lib19();
    function prop(key, value2) {
      return value2 ? _core.types.objectProperty(_core.types.identifier(key), value2) : null;
    }
    function method(key, body) {
      return _core.types.objectMethod("method", _core.types.identifier(key), [], _core.types.blockStatement(body));
    }
    function takeDecorators(node) {
      let result;
      return node.decorators && node.decorators.length > 0 && (result = _core.types.arrayExpression(node.decorators.map((decorator) => decorator.expression))), node.decorators = void 0, result;
    }
    function getKey(node) {
      return node.computed ? node.key : _core.types.isIdentifier(node.key) ? _core.types.stringLiteral(node.key.name) : _core.types.stringLiteral(String(node.key.value));
    }
    function extractElementDescriptor(file, classRef, superRef, path) {
      let isMethod = path.isClassMethod();
      if (path.isPrivate())
        throw path.buildCodeFrameError(`Private ${isMethod ? "methods" : "fields"} in decorated classes are not supported yet.`);
      if (path.node.type === "ClassAccessorProperty")
        throw path.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
      if (path.node.type === "StaticBlock")
        throw path.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
      let {
        node,
        scope
      } = path;
      path.isTSDeclareMethod() || new _helperReplaceSupers.default({
        methodPath: path,
        objectRef: classRef,
        superRef,
        file,
        refToPreserve: classRef
      }).replace();
      let properties = [prop("kind", _core.types.stringLiteral(_core.types.isClassMethod(node) ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node.static && _core.types.booleanLiteral(!0)), prop("key", getKey(node))].filter(Boolean);
      if (isMethod) {
        {
          var _path$ensureFunctionN;
          (_path$ensureFunctionN = path.ensureFunctionName) != null || (path.ensureFunctionName = require_lib10().NodePath.prototype.ensureFunctionName);
        }
        path.ensureFunctionName(!1), properties.push(prop("value", _core.types.toExpression(path.node)));
      } else _core.types.isClassProperty(node) && node.value ? properties.push(method("value", _core.template.statements.ast`return ${node.value}`)) : properties.push(prop("value", scope.buildUndefinedNode()));
      return path.remove(), _core.types.objectExpression(properties);
    }
    function addDecorateHelper(file) {
      return file.addHelper("decorate");
    }
    function buildDecoratedClass(ref, path, elements, file) {
      let {
        node,
        scope
      } = path, initializeId = scope.generateUidIdentifier("initialize"), isDeclaration = node.id && path.isDeclaration(), isStrict = path.isInStrictMode(), {
        superClass
      } = node;
      node.type = "ClassDeclaration", node.id || (node.id = _core.types.cloneNode(ref));
      let superId;
      superClass && (superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super"), node.superClass = superId);
      let classDecorators = takeDecorators(node), definitions = _core.types.arrayExpression(elements.filter((element) => !element.node.abstract && element.node.type !== "TSIndexSignature").map((path2) => extractElementDescriptor(file, node.id, superId, path2))), wrapperCall = _core.template.expression.ast`
    ${addDecorateHelper(file)}(
      ${classDecorators || _core.types.nullLiteral()},
      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {
        ${node}
        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `;
      isStrict || wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
      let replacement = wrapperCall, classPathDesc = "arguments.1.body.body.0";
      return isDeclaration && (replacement = _core.template.statement.ast`let ${ref} = ${wrapperCall}`, classPathDesc = "declarations.0.init." + classPathDesc), {
        instanceNodes: [_core.template.statement.ast`
        ${_core.types.cloneNode(initializeId)}(this)
      `],
        wrapClass(path2) {
          return path2.replaceWith(replacement), path2.get(classPathDesc);
        }
      };
    }
  }
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/features.js
var require_features = __commonJS({
  "../node_modules/@babel/helper-create-class-features-plugin/lib/features.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.FEATURES = void 0;
    exports.enableFeature = enableFeature;
    exports.isLoose = isLoose;
    exports.shouldTransform = shouldTransform;
    var _decorators = require_decorators(), FEATURES = exports.FEATURES = Object.freeze({
      fields: 2,
      privateMethods: 4,
      decorators: 8,
      privateIn: 16,
      staticBlocks: 32
    }), featuresSameLoose = /* @__PURE__ */ new Map([[FEATURES.fields, "@babel/plugin-transform-class-properties"], [FEATURES.privateMethods, "@babel/plugin-transform-private-methods"], [FEATURES.privateIn, "@babel/plugin-transform-private-property-in-object"]]), featuresKey = "@babel/plugin-class-features/featuresKey", looseKey = "@babel/plugin-class-features/looseKey";
    looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
    var looseLowPriorityKey;
    canIgnoreLoose = function(file, feature) {
      return !!(file.get(looseLowPriorityKey) & feature);
    };
    var canIgnoreLoose;
    function enableFeature(file, feature, loose) {
      (!hasFeature(file, feature) || canIgnoreLoose(file, feature)) && (file.set(featuresKey, file.get(featuresKey) | feature), loose === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" ? (setLoose(file, feature, !0), file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : loose === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" ? (setLoose(file, feature, !1), file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : setLoose(file, feature, loose));
      let resolvedLoose;
      for (let [mask, name] of featuresSameLoose) {
        if (!hasFeature(file, mask) || canIgnoreLoose(file, mask)) continue;
        let loose2 = isLoose(file, mask);
        if (resolvedLoose === !loose2)
          throw new Error(`'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).

` + getBabelShowConfigForHint(file));
        resolvedLoose = loose2;
        var higherPriorityPluginName = name;
      }
      if (resolvedLoose !== void 0)
        for (let [mask, name] of featuresSameLoose)
          hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose && (setLoose(file, mask, resolvedLoose), console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env config, it will not be used for ${name} since the "loose" mode option was set to "${resolvedLoose}" for ${higherPriorityPluginName}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${name}", { "loose": ${resolvedLoose} }]
to the "plugins" section of your Babel config.

` + getBabelShowConfigForHint(file)));
    }
    function getBabelShowConfigForHint(file) {
      let {
        filename
      } = file.opts;
      return (!filename || filename === "unknown") && (filename = "[name of the input file]"), `If you already set the same 'loose' mode for these plugins in your config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${filename} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
    }
    function hasFeature(file, feature) {
      return !!(file.get(featuresKey) & feature);
    }
    function isLoose(file, feature) {
      return !!(file.get(looseKey) & feature);
    }
    function setLoose(file, feature, loose) {
      loose ? file.set(looseKey, file.get(looseKey) | feature) : file.set(looseKey, file.get(looseKey) & ~feature), file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
    }
    function shouldTransform(path, file) {
      let decoratorPath = null, publicFieldPath = null, privateFieldPath = null, privateMethodPath = null, staticBlockPath = null;
      (0, _decorators.hasOwnDecorators)(path.node) && (decoratorPath = path.get("decorators.0"));
      for (let el of path.get("body.body"))
        !decoratorPath && (0, _decorators.hasOwnDecorators)(el.node) && (decoratorPath = el.get("decorators.0")), !publicFieldPath && el.isClassProperty() && (publicFieldPath = el), !privateFieldPath && el.isClassPrivateProperty() && (privateFieldPath = el), !privateMethodPath && el.isClassPrivateMethod != null && el.isClassPrivateMethod() && (privateMethodPath = el), !staticBlockPath && el.isStaticBlock != null && el.isStaticBlock() && (staticBlockPath = el);
      if (decoratorPath && privateFieldPath)
        throw privateFieldPath.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
      if (decoratorPath && privateMethodPath)
        throw privateMethodPath.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
      if (decoratorPath && !hasFeature(file, FEATURES.decorators))
        throw path.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);
      if (privateMethodPath && !hasFeature(file, FEATURES.privateMethods))
        throw privateMethodPath.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
      if ((publicFieldPath || privateFieldPath) && !hasFeature(file, FEATURES.fields) && !hasFeature(file, FEATURES.privateMethods))
        throw path.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
      if (staticBlockPath && !hasFeature(file, FEATURES.staticBlocks))
        throw path.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
      return !!(decoratorPath || privateMethodPath || staticBlockPath || (publicFieldPath || privateFieldPath) && hasFeature(file, FEATURES.fields));
    }
  }
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/index.js
var require_lib22 = __commonJS({
  "../node_modules/@babel/helper-create-class-features-plugin/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "FEATURES", {
      enumerable: !0,
      get: function() {
        return _features.FEATURES;
      }
    });
    Object.defineProperty(exports, "buildCheckInRHS", {
      enumerable: !0,
      get: function() {
        return _fields.buildCheckInRHS;
      }
    });
    Object.defineProperty(exports, "buildNamedEvaluationVisitor", {
      enumerable: !0,
      get: function() {
        return _decorators.buildNamedEvaluationVisitor;
      }
    });
    exports.createClassFeaturePlugin = createClassFeaturePlugin;
    Object.defineProperty(exports, "enableFeature", {
      enumerable: !0,
      get: function() {
        return _features.enableFeature;
      }
    });
    Object.defineProperty(exports, "injectInitialization", {
      enumerable: !0,
      get: function() {
        return _misc.injectInitialization;
      }
    });
    var _core = require_lib27(), _semver = __require("semver"), _fields = require_fields(), _decorators = require_decorators(), _decorators2 = require_decorators_2018_09(), _misc = require_misc2(), _features = require_features(), _typescript = require_typescript3(), versionKey = "@babel/plugin-class-features/version";
    function createClassFeaturePlugin({
      name,
      feature,
      loose,
      manipulateOptions,
      api,
      inherits,
      decoratorVersion
    }) {
      var _api$assumption;
      if (feature & _features.FEATURES.decorators && (decoratorVersion === "2023-11" || decoratorVersion === "2023-05" || decoratorVersion === "2023-01" || decoratorVersion === "2022-03" || decoratorVersion === "2021-12"))
        return (0, _decorators.default)(api, {
          loose
        }, decoratorVersion, inherits);
      api ?? (api = {
        assumption: () => {
        }
      });
      let setPublicClassFields = api.assumption("setPublicClassFields"), privateFieldsAsSymbols = api.assumption("privateFieldsAsSymbols"), privateFieldsAsProperties = api.assumption("privateFieldsAsProperties"), noUninitializedPrivateFieldAccess = (_api$assumption = api.assumption("noUninitializedPrivateFieldAccess")) != null ? _api$assumption : !1, constantSuper = api.assumption("constantSuper"), noDocumentAll = api.assumption("noDocumentAll");
      if (privateFieldsAsProperties && privateFieldsAsSymbols)
        throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
      let privateFieldsAsSymbolsOrProperties = privateFieldsAsProperties || privateFieldsAsSymbols;
      if (loose === !0) {
        let explicit = [];
        setPublicClassFields !== void 0 && explicit.push('"setPublicClassFields"'), privateFieldsAsProperties !== void 0 && explicit.push('"privateFieldsAsProperties"'), privateFieldsAsSymbols !== void 0 && explicit.push('"privateFieldsAsSymbols"'), explicit.length !== 0 && console.warn(`[${name}]: You are using the "loose: true" option and you are explicitly setting a value for the ${explicit.join(" and ")} assumption${explicit.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
      }
      return {
        name,
        manipulateOptions,
        inherits,
        pre(file) {
          if ((0, _features.enableFeature)(file, feature, loose), typeof file.get(versionKey) == "number") {
            file.set(versionKey, "7.28.5");
            return;
          }
          (!file.get(versionKey) || _semver.lt(file.get(versionKey), "7.28.5")) && file.set(versionKey, "7.28.5");
        },
        visitor: {
          Class(path, {
            file
          }) {
            if (file.get(versionKey) !== "7.28.5" || !(0, _features.shouldTransform)(path, file)) return;
            let pathIsClassDeclaration = path.isClassDeclaration();
            pathIsClassDeclaration && (0, _typescript.assertFieldTransformed)(path);
            let loose2 = (0, _features.isLoose)(file, feature), constructor, isDecorated = (0, _decorators.hasDecorators)(path.node), props = [], elements = [], computedPaths = [], privateNames = /* @__PURE__ */ new Set(), body = path.get("body");
            for (let path2 of body.get("body")) {
              if ((path2.isClassProperty() || path2.isClassMethod()) && path2.node.computed && computedPaths.push(path2), path2.isPrivate()) {
                let {
                  name: name2
                } = path2.node.key.id, getName = `get ${name2}`, setName = `set ${name2}`;
                if (path2.isClassPrivateMethod()) {
                  if (path2.node.kind === "get") {
                    if (privateNames.has(getName) || privateNames.has(name2) && !privateNames.has(setName))
                      throw path2.buildCodeFrameError("Duplicate private field");
                    privateNames.add(getName).add(name2);
                  } else if (path2.node.kind === "set") {
                    if (privateNames.has(setName) || privateNames.has(name2) && !privateNames.has(getName))
                      throw path2.buildCodeFrameError("Duplicate private field");
                    privateNames.add(setName).add(name2);
                  }
                } else {
                  if (privateNames.has(name2) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name2) && (privateNames.has(getName) || privateNames.has(setName)))
                    throw path2.buildCodeFrameError("Duplicate private field");
                  privateNames.add(name2);
                }
              }
              path2.isClassMethod({
                kind: "constructor"
              }) ? constructor = path2 : (elements.push(path2), (path2.isProperty() || path2.isPrivate() || path2.isStaticBlock != null && path2.isStaticBlock()) && props.push(path2));
            }
            if (!props.length && !isDecorated) return;
            let innerBinding = path.node.id, ref;
            if (!innerBinding || !pathIsClassDeclaration) {
              {
                var _path$ensureFunctionN;
                (_path$ensureFunctionN = path.ensureFunctionName) != null || (path.ensureFunctionName = require_lib10().NodePath.prototype.ensureFunctionName);
              }
              path.ensureFunctionName(!1), ref = path.scope.generateUidIdentifier(innerBinding?.name || "Class");
            }
            let classRefForDefine = ref ?? _core.types.cloneNode(innerBinding), privateNamesMap = (0, _fields.buildPrivateNamesMap)(classRefForDefine.name, privateFieldsAsSymbolsOrProperties ?? loose2, props, file), privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties ?? loose2, privateFieldsAsSymbols ?? !1, file);
            (0, _fields.transformPrivateNamesUsage)(classRefForDefine, path, privateNamesMap, {
              privateFieldsAsProperties: privateFieldsAsSymbolsOrProperties ?? loose2,
              noUninitializedPrivateFieldAccess,
              noDocumentAll,
              innerBinding
            }, file);
            let keysNodes, staticNodes, instanceNodes, lastInstanceNodeReturnsThis, pureStaticNodes, classBindingNode, wrapClass;
            isDecorated ? (staticNodes = pureStaticNodes = keysNodes = [], {
              instanceNodes,
              wrapClass
            } = (0, _decorators2.buildDecoratedClass)(classRefForDefine, path, elements, file)) : (keysNodes = (0, _misc.extractComputedKeys)(path, computedPaths, file), {
              staticNodes,
              pureStaticNodes,
              instanceNodes,
              lastInstanceNodeReturnsThis,
              classBindingNode,
              wrapClass
            } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, file, setPublicClassFields ?? loose2, privateFieldsAsSymbolsOrProperties ?? loose2, noUninitializedPrivateFieldAccess, constantSuper ?? loose2, innerBinding)), instanceNodes.length > 0 && (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {
              if (!isDecorated)
                for (let prop of props)
                  _core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node) || prop.node.static || prop.traverse(referenceVisitor, state);
            }, lastInstanceNodeReturnsThis);
            let wrappedPath = wrapClass(path);
            wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]), staticNodes.length > 0 && wrappedPath.insertAfter(staticNodes), pureStaticNodes.length > 0 && wrappedPath.find((parent) => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes), classBindingNode != null && pathIsClassDeclaration && wrappedPath.insertAfter(classBindingNode);
          },
          ExportDefaultDeclaration(path, {
            file
          }) {
            {
              if (file.get(versionKey) !== "7.28.5") return;
              let decl = path.get("declaration");
              if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node))
                if (decl.node.id) {
                  {
                    var _path$splitExportDecl;
                    (_path$splitExportDecl = path.splitExportDeclaration) != null || (path.splitExportDeclaration = require_lib10().NodePath.prototype.splitExportDeclaration);
                  }
                  path.splitExportDeclaration();
                } else
                  decl.node.type = "ClassExpression";
            }
          }
        }
      };
    }
  }
});

// ../node_modules/@babel/plugin-transform-typescript/lib/enum.js
var require_enum = __commonJS({
  "../node_modules/@babel/plugin-transform-typescript/lib/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = transpileEnum;
    exports.isSyntacticallyString = isSyntacticallyString;
    exports.translateEnumValues = translateEnumValues;
    var _core = require_lib27(), _assert = __require("assert"), _helperAnnotateAsPure = require_lib20(), _helperSkipTransparentExpressionWrappers = require_lib21(), ENUMS = /* @__PURE__ */ new WeakMap(), buildEnumWrapper = _core.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);
    function transpileEnum(path, t) {
      let {
        node,
        parentPath
      } = path;
      if (node.declare) {
        path.remove();
        return;
      }
      let name = node.id.name, {
        fill,
        data,
        isPure
      } = enumFill(path, t, node.id);
      switch (parentPath.type) {
        case "BlockStatement":
        case "ExportNamedDeclaration":
        case "Program": {
          let isGlobal = t.isProgram(path.parent), isSeen = seen(parentPath), init = t.objectExpression([]);
          (isSeen || isGlobal) && (init = t.logicalExpression("||", t.cloneNode(fill.ID), init));
          let enumIIFE = buildEnumWrapper(Object.assign({}, fill, {
            INIT: init
          }));
          isPure && (0, _helperAnnotateAsPure.default)(enumIIFE), isSeen ? (parentPath.isExportDeclaration() ? parentPath : path).replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(node.id), enumIIFE))) : path.scope.registerDeclaration(path.replaceWith(t.variableDeclaration(isGlobal ? "var" : "let", [t.variableDeclarator(node.id, enumIIFE)]))[0]), ENUMS.set(path.scope.getBindingIdentifier(name), data);
          break;
        }
        default:
          throw new Error(`Unexpected enum parent '${path.parent.type}`);
      }
      function seen(parentPath2) {
        return parentPath2.isExportDeclaration() ? seen(parentPath2.parentPath) : parentPath2.getData(name) ? !0 : (parentPath2.setData(name, !0), !1);
      }
    }
    var buildStringAssignment = _core.template.statement(`
  ENUM["NAME"] = VALUE;
`), buildNumericAssignment = _core.template.statement(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`), buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);
    function enumFill(path, t, id) {
      let {
        enumValues,
        data,
        isPure
      } = translateEnumValues(path, t), enumMembers = path.get("members"), assignments = [];
      for (let i = 0; i < enumMembers.length; i++) {
        let [memberName, memberValue] = enumValues[i];
        assignments.push(t.inheritsComments(buildEnumMember(isSyntacticallyString(memberValue), {
          ENUM: t.cloneNode(id),
          NAME: memberName,
          VALUE: memberValue
        }), enumMembers[i].node));
      }
      return {
        fill: {
          ID: t.cloneNode(id),
          ASSIGNMENTS: assignments
        },
        data,
        isPure
      };
    }
    function isSyntacticallyString(expr) {
      switch (expr = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(expr), expr.type) {
        case "BinaryExpression": {
          let left = expr.left, right = expr.right;
          return expr.operator === "+" && (isSyntacticallyString(left) || isSyntacticallyString(right));
        }
        case "TemplateLiteral":
        case "StringLiteral":
          return !0;
      }
      return !1;
    }
    function ReferencedIdentifier(expr, state) {
      let {
        seen,
        path,
        t
      } = state, name = expr.node.name;
      if (seen.has(name)) {
        for (let curScope = expr.scope; curScope !== path.scope; curScope = curScope.parent)
          if (curScope.hasOwnBinding(name))
            return;
        expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node))), expr.skip();
      }
    }
    var enumSelfReferenceVisitor = {
      ReferencedIdentifier
    };
    function translateEnumValues(path, t) {
      var _ENUMS$get;
      let bindingIdentifier = path.scope.getBindingIdentifier(path.node.id.name), seen = (_ENUMS$get = ENUMS.get(bindingIdentifier)) != null ? _ENUMS$get : /* @__PURE__ */ new Map(), constValue = -1, lastName, isPure = !0, enumValues = path.get("members").map((memberPath) => {
        let member = memberPath.node, name = t.isIdentifier(member.id) ? member.id.name : member.id.value, initializerPath = memberPath.get("initializer"), initializer = member.initializer, value2;
        if (initializer)
          constValue = computeConstantValue(initializerPath, seen), constValue !== void 0 ? (seen.set(name, constValue), _assert(typeof constValue == "number" || typeof constValue == "string"), constValue === 1 / 0 || Number.isNaN(constValue) ? value2 = t.identifier(String(constValue)) : constValue === -1 / 0 ? value2 = t.unaryExpression("-", t.identifier("Infinity")) : value2 = t.valueToNode(constValue)) : (isPure && (isPure = initializerPath.isPure()), initializerPath.isReferencedIdentifier() ? ReferencedIdentifier(initializerPath, {
            t,
            seen,
            path
          }) : initializerPath.traverse(enumSelfReferenceVisitor, {
            t,
            seen,
            path
          }), value2 = initializerPath.node, seen.set(name, void 0));
        else if (typeof constValue == "number")
          constValue += 1, value2 = t.numericLiteral(constValue), seen.set(name, constValue);
        else {
          if (typeof constValue == "string")
            throw path.buildCodeFrameError("Enum member must have initializer.");
          {
            let lastRef = t.memberExpression(t.cloneNode(path.node.id), t.stringLiteral(lastName), !0);
            value2 = t.binaryExpression("+", t.numericLiteral(1), lastRef), seen.set(name, void 0);
          }
        }
        return lastName = name, [name, value2];
      });
      return {
        isPure,
        data: seen,
        enumValues
      };
    }
    function computeConstantValue(path, prevMembers, seen = /* @__PURE__ */ new Set()) {
      return evaluate(path);
      function evaluate(path2) {
        let expr = path2.node;
        switch (expr.type) {
          case "MemberExpression":
            return evaluateRef(path2, prevMembers, seen);
          case "StringLiteral":
            return expr.value;
          case "UnaryExpression":
            return evalUnaryExpression(path2);
          case "BinaryExpression":
            return evalBinaryExpression(path2);
          case "NumericLiteral":
            return expr.value;
          case "ParenthesizedExpression":
            return evaluate(path2.get("expression"));
          case "Identifier":
            return evaluateRef(path2, prevMembers, seen);
          case "TemplateLiteral": {
            if (expr.quasis.length === 1)
              return expr.quasis[0].value.cooked;
            let paths = path2.get("expressions"), quasis = expr.quasis, str = "";
            for (let i = 0; i < quasis.length; i++)
              if (str += quasis[i].value.cooked, i + 1 < quasis.length) {
                let value2 = evaluateRef(paths[i], prevMembers, seen);
                if (value2 === void 0) return;
                str += value2;
              }
            return str;
          }
          default:
            return;
        }
      }
      function evaluateRef(path2, prevMembers2, seen2) {
        if (path2.isMemberExpression()) {
          let expr = path2.node, obj = expr.object, prop = expr.property;
          if (!_core.types.isIdentifier(obj) || (expr.computed ? !_core.types.isStringLiteral(prop) : !_core.types.isIdentifier(prop)))
            return;
          let bindingIdentifier = path2.scope.getBindingIdentifier(obj.name), data = ENUMS.get(bindingIdentifier);
          return data ? data.get(prop.computed ? prop.value : prop.name) : void 0;
        } else if (path2.isIdentifier()) {
          let name = path2.node.name;
          if (["Infinity", "NaN"].includes(name))
            return Number(name);
          let value2 = prevMembers2?.get(name);
          return value2 !== void 0 ? value2 : prevMembers2 != null && prevMembers2.has(name) || seen2.has(path2.node) ? void 0 : (seen2.add(path2.node), value2 = computeConstantValue(path2.resolve(), prevMembers2, seen2), value2);
        }
      }
      function evalUnaryExpression(path2) {
        let value2 = evaluate(path2.get("argument"));
        if (value2 !== void 0)
          switch (path2.node.operator) {
            case "+":
              return value2;
            case "-":
              return -value2;
            case "~":
              return ~value2;
            default:
              return;
          }
      }
      function evalBinaryExpression(path2) {
        let left = evaluate(path2.get("left"));
        if (left === void 0)
          return;
        let right = evaluate(path2.get("right"));
        if (right !== void 0)
          switch (path2.node.operator) {
            case "|":
              return left | right;
            case "&":
              return left & right;
            case ">>":
              return left >> right;
            case ">>>":
              return left >>> right;
            case "<<":
              return left << right;
            case "^":
              return left ^ right;
            case "*":
              return left * right;
            case "/":
              return left / right;
            case "+":
              return left + right;
            case "-":
              return left - right;
            case "%":
              return left % right;
            case "**":
              return Math.pow(left, right);
            default:
              return;
          }
      }
    }
  }
});

// ../node_modules/@babel/plugin-transform-typescript/lib/const-enum.js
var require_const_enum = __commonJS({
  "../node_modules/@babel/plugin-transform-typescript/lib/const-enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.EXPORTED_CONST_ENUMS_IN_NAMESPACE = void 0;
    exports.default = transpileConstEnum;
    var _enum = require_enum(), EXPORTED_CONST_ENUMS_IN_NAMESPACE = exports.EXPORTED_CONST_ENUMS_IN_NAMESPACE = /* @__PURE__ */ new WeakSet();
    function transpileConstEnum(path, t) {
      let {
        name
      } = path.node.id, parentIsExport = path.parentPath.isExportNamedDeclaration(), isExported = parentIsExport;
      !isExported && t.isProgram(path.parent) && (isExported = path.parent.body.some((stmt) => t.isExportNamedDeclaration(stmt) && stmt.exportKind !== "type" && !stmt.source && stmt.specifiers.some((spec) => t.isExportSpecifier(spec) && spec.exportKind !== "type" && spec.local.name === name)));
      let {
        enumValues: entries
      } = (0, _enum.translateEnumValues)(path, t);
      if (isExported || EXPORTED_CONST_ENUMS_IN_NAMESPACE.has(path.node)) {
        let obj = t.objectExpression(entries.map(([name2, value2]) => t.objectProperty(t.isValidIdentifier(name2) ? t.identifier(name2) : t.stringLiteral(name2), value2)));
        path.scope.hasOwnBinding(name) ? (parentIsExport ? path.parentPath : path).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [path.node.id, obj]))) : (path.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(path.node.id, obj)])), path.scope.registerDeclaration(path));
        return;
      }
      let entriesMap = new Map(entries);
      path.scope.path.traverse({
        Scope(path2) {
          path2.scope.hasOwnBinding(name) && path2.skip();
        },
        MemberExpression(path2) {
          if (!t.isIdentifier(path2.node.object, {
            name
          })) return;
          let key;
          if (path2.node.computed)
            if (t.isStringLiteral(path2.node.property))
              key = path2.node.property.value;
            else
              return;
          else if (t.isIdentifier(path2.node.property))
            key = path2.node.property.name;
          else
            return;
          entriesMap.has(key) && path2.replaceWith(t.cloneNode(entriesMap.get(key)));
        }
      }), path.remove();
    }
  }
});

// ../node_modules/@babel/plugin-transform-typescript/lib/global-types.js
var require_global_types = __commonJS({
  "../node_modules/@babel/plugin-transform-typescript/lib/global-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.GLOBAL_TYPES = void 0;
    exports.isGlobalType = isGlobalType;
    exports.registerGlobalType = registerGlobalType;
    var GLOBAL_TYPES = exports.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
    function isGlobalType({
      scope
    }, name) {
      return scope.hasBinding(name) ? !1 : GLOBAL_TYPES.get(scope).has(name) ? !0 : (console.warn(`The exported identifier "${name}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${name}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), !1);
    }
    function registerGlobalType(programScope, name) {
      GLOBAL_TYPES.get(programScope).add(name);
    }
  }
});

// ../node_modules/@babel/plugin-transform-typescript/lib/namespace.js
var require_namespace = __commonJS({
  "../node_modules/@babel/plugin-transform-typescript/lib/namespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = transpileNamespace;
    exports.getFirstIdentifier = getFirstIdentifier;
    var _core = require_lib27(), _globalTypes = require_global_types(), _constEnum = require_const_enum();
    function getFirstIdentifier(node) {
      return _core.types.isIdentifier(node) ? node : getFirstIdentifier(node.left);
    }
    function transpileNamespace(path, allowNamespaces) {
      if (path.node.declare || path.node.id.type === "StringLiteral") {
        path.remove();
        return;
      }
      if (!allowNamespaces)
        throw path.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
      let name = getFirstIdentifier(path.node.id).name, value2 = handleNested(path, path.node);
      if (value2 === null) {
        let program = path.findParent((p) => p.isProgram());
        (0, _globalTypes.registerGlobalType)(program.scope, name), path.remove();
      } else path.scope.hasOwnBinding(name) ? path.replaceWith(value2) : path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(name), value2])[0]);
    }
    function getDeclaration(name) {
      return _core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.identifier(name))]);
    }
    function getMemberExpression(name, itemName) {
      return _core.types.memberExpression(_core.types.identifier(name), _core.types.identifier(itemName));
    }
    function handleVariableDeclaration(node, name, hub) {
      if (node.kind !== "const")
        throw hub.file.buildCodeFrameError(node, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
      let {
        declarations
      } = node;
      if (declarations.every((declarator) => _core.types.isIdentifier(declarator.id))) {
        for (let declarator of declarations)
          declarator.init = _core.types.assignmentExpression("=", getMemberExpression(name, declarator.id.name), declarator.init);
        return [node];
      }
      let bindingIdentifiers = _core.types.getBindingIdentifiers(node), assignments = [];
      for (let idName in bindingIdentifiers)
        assignments.push(_core.types.assignmentExpression("=", getMemberExpression(name, idName), _core.types.cloneNode(bindingIdentifiers[idName])));
      return [node, _core.types.expressionStatement(_core.types.sequenceExpression(assignments))];
    }
    function buildNestedAmbientModuleError(path, node) {
      return path.hub.buildError(node, "Ambient modules cannot be nested in other modules or namespaces.", Error);
    }
    function handleNested(path, node, parentExport) {
      let names = /* @__PURE__ */ new Set(), realName = node.id, name = path.scope.generateUid(realName.name), body = node.body, id = node.id, namespaceTopLevel;
      namespaceTopLevel = _core.types.isTSModuleBlock(body) ? body.body : [_core.types.exportNamedDeclaration(body)];
      let isEmpty = !0;
      for (let i = 0; i < namespaceTopLevel.length; i++) {
        let subNode = namespaceTopLevel[i];
        switch (subNode.type) {
          case "TSModuleDeclaration": {
            if (!_core.types.isIdentifier(subNode.id))
              throw buildNestedAmbientModuleError(path, subNode);
            let transformed = handleNested(path, subNode);
            if (transformed !== null) {
              isEmpty = !1;
              let moduleName = subNode.id.name;
              names.has(moduleName) ? namespaceTopLevel[i] = transformed : (names.add(moduleName), namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed));
            }
            continue;
          }
          case "TSEnumDeclaration":
          case "FunctionDeclaration":
          case "ClassDeclaration":
            isEmpty = !1, names.add(subNode.id.name);
            continue;
          case "VariableDeclaration": {
            isEmpty = !1;
            for (let name2 in _core.types.getBindingIdentifiers(subNode))
              names.add(name2);
            continue;
          }
          default:
            isEmpty && (isEmpty = _core.types.isTypeScript(subNode));
            continue;
          case "ExportNamedDeclaration":
        }
        if (!("declare" in subNode.declaration && subNode.declaration.declare))
          switch (subNode.declaration.type) {
            case "TSEnumDeclaration":
              _constEnum.EXPORTED_CONST_ENUMS_IN_NAMESPACE.add(subNode.declaration);
            case "FunctionDeclaration":
            case "ClassDeclaration": {
              isEmpty = !1;
              let itemName = subNode.declaration.id.name;
              names.add(itemName), namespaceTopLevel.splice(i++, 1, subNode.declaration, _core.types.expressionStatement(_core.types.assignmentExpression("=", getMemberExpression(name, itemName), _core.types.identifier(itemName))));
              break;
            }
            case "VariableDeclaration": {
              isEmpty = !1;
              let nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);
              namespaceTopLevel.splice(i, nodes.length, ...nodes), i += nodes.length - 1;
              break;
            }
            case "TSModuleDeclaration": {
              if (!_core.types.isIdentifier(subNode.declaration.id))
                throw buildNestedAmbientModuleError(path, subNode.declaration);
              let transformed = handleNested(path, subNode.declaration, _core.types.identifier(name));
              if (transformed !== null) {
                isEmpty = !1;
                let moduleName = subNode.declaration.id.name;
                names.has(moduleName) ? namespaceTopLevel[i] = transformed : (names.add(moduleName), namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed));
              } else
                namespaceTopLevel.splice(i, 1), i--;
            }
          }
      }
      if (isEmpty) return null;
      let fallthroughValue = _core.types.objectExpression([]);
      if (parentExport) {
        let memberExpr = _core.types.memberExpression(parentExport, realName);
        fallthroughValue = _core.template.expression.ast`
      ${_core.types.cloneNode(memberExpr)} ||
        (${_core.types.cloneNode(memberExpr)} = ${fallthroughValue})
    `;
      }
      return _core.template.statement.ast`
    (function (${_core.types.identifier(name)}) {
      ${namespaceTopLevel}
    })(${realName} || (${_core.types.cloneNode(realName)} = ${fallthroughValue}));
  `;
    }
  }
});

// ../node_modules/@babel/plugin-transform-typescript/lib/index.js
var require_lib23 = __commonJS({
  "../node_modules/@babel/plugin-transform-typescript/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _helperPluginUtils = require_lib15(), _pluginSyntaxTypescript = require_lib16(), _helperCreateClassFeaturesPlugin = require_lib22(), _constEnum = require_const_enum(), _enum = require_enum(), _globalTypes = require_global_types(), _namespace = require_namespace();
    function isInType(path) {
      switch (path.parent.type) {
        case "TSTypeReference":
        case "TSExpressionWithTypeArguments":
        case "TSExpressionWithTypeArguments":
        case "TSTypeQuery":
          return !0;
        case "TSQualifiedName":
          return path.parentPath.findParent((path2) => path2.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
        case "ExportSpecifier":
          return path.parent.exportKind === "type" || path.parentPath.parent.exportKind === "type";
        default:
          return !1;
      }
    }
    var NEEDS_EXPLICIT_ESM = /* @__PURE__ */ new WeakMap(), PARSED_PARAMS = /* @__PURE__ */ new WeakSet();
    function safeRemove(path) {
      let ids = path.getBindingIdentifiers();
      for (let name of Object.keys(ids)) {
        let binding = path.scope.getBinding(name);
        binding && binding.identifier === ids[name] && binding.scope.removeBinding(name);
      }
      path.opts.noScope = !0, path.remove(), path.opts.noScope = !1;
    }
    function assertCjsTransformEnabled(path, pass, wrong, suggestion, extra = "") {
      if (pass.file.get("@babel/plugin-transform-modules-*") !== "commonjs")
        throw path.buildCodeFrameError(`\`${wrong}\` is only supported when compiling modules to CommonJS.
Please consider using \`${suggestion}\`${extra}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
    }
    var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts) => {
      let {
        types: t,
        template
      } = api;
      api.assertVersion(7);
      let JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/, {
        allowNamespaces = !0,
        jsxPragma = "React.createElement",
        jsxPragmaFrag = "React.Fragment",
        onlyRemoveTypeImports = !1,
        optimizeConstEnums = !1
      } = opts;
      var {
        allowDeclareFields = !1
      } = opts;
      let classMemberVisitors = {
        field(path) {
          let {
            node
          } = path;
          if (!allowDeclareFields && node.declare)
            throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
          if (node.declare) {
            if (node.value)
              throw path.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
            node.decorators || path.remove();
          } else if (node.definite) {
            if (node.value)
              throw path.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
            !allowDeclareFields && !node.decorators && !t.isClassPrivateProperty(node) && path.remove();
          } else (node.abstract || !allowDeclareFields && !node.value && !node.decorators && !t.isClassPrivateProperty(node)) && path.remove();
          node.accessibility && (node.accessibility = null), node.abstract && (node.abstract = null), node.readonly && (node.readonly = null), node.optional && (node.optional = null), node.typeAnnotation && (node.typeAnnotation = null), node.definite && (node.definite = null), node.declare && (node.declare = null), node.override && (node.override = null);
        },
        method({
          node
        }) {
          node.accessibility && (node.accessibility = null), node.abstract && (node.abstract = null), node.optional && (node.optional = null), node.override && (node.override = null);
        },
        constructor(path, classPath) {
          path.node.accessibility && (path.node.accessibility = null);
          let assigns = [], {
            scope
          } = path;
          for (let paramPath of path.get("params")) {
            let param = paramPath.node;
            if (param.type === "TSParameterProperty") {
              let parameter = param.parameter;
              if (PARSED_PARAMS.has(parameter)) continue;
              PARSED_PARAMS.add(parameter);
              let id;
              if (t.isIdentifier(parameter))
                id = parameter;
              else if (t.isAssignmentPattern(parameter) && t.isIdentifier(parameter.left))
                id = parameter.left;
              else
                throw paramPath.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
              assigns.push(template.statement.ast`
              this.${t.cloneNode(id)} = ${t.cloneNode(id)}
            `), paramPath.replaceWith(paramPath.get("parameter")), scope.registerBinding("param", paramPath);
            }
          }
          (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);
        }
      };
      return {
        name: "transform-typescript",
        inherits: _pluginSyntaxTypescript.default,
        visitor: {
          Pattern: visitPattern,
          Identifier: visitPattern,
          RestElement: visitPattern,
          Program: {
            enter(path, state) {
              let {
                file
              } = state, fileJsxPragma = null, fileJsxPragmaFrag = null, programScope = path.scope;
              if (_globalTypes.GLOBAL_TYPES.has(programScope) || _globalTypes.GLOBAL_TYPES.set(programScope, /* @__PURE__ */ new Set()), file.ast.comments)
                for (let comment of file.ast.comments) {
                  let jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);
                  jsxMatches && (jsxMatches[1] ? fileJsxPragmaFrag = jsxMatches[2] : fileJsxPragma = jsxMatches[2]);
                }
              let pragmaImportName = fileJsxPragma || jsxPragma;
              pragmaImportName && ([pragmaImportName] = pragmaImportName.split("."));
              let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;
              pragmaFragImportName && ([pragmaFragImportName] = pragmaFragImportName.split("."));
              for (let stmt of path.get("body")) {
                if (stmt.isImportDeclaration()) {
                  if (NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, !0), stmt.node.importKind === "type") {
                    for (let specifier of stmt.node.specifiers)
                      (0, _globalTypes.registerGlobalType)(programScope, specifier.local.name);
                    stmt.remove();
                    continue;
                  }
                  let importsToRemove = /* @__PURE__ */ new Set(), specifiersLength = stmt.node.specifiers.length, isAllSpecifiersElided = () => specifiersLength > 0 && specifiersLength === importsToRemove.size;
                  for (let specifier of stmt.node.specifiers)
                    if (specifier.type === "ImportSpecifier" && specifier.importKind === "type") {
                      (0, _globalTypes.registerGlobalType)(programScope, specifier.local.name);
                      let binding = stmt.scope.getBinding(specifier.local.name);
                      binding && importsToRemove.add(binding.path);
                    }
                  if (onlyRemoveTypeImports)
                    NEEDS_EXPLICIT_ESM.set(path.node, !1);
                  else {
                    if (stmt.node.specifiers.length === 0) {
                      NEEDS_EXPLICIT_ESM.set(path.node, !1);
                      continue;
                    }
                    for (let specifier of stmt.node.specifiers) {
                      let binding = stmt.scope.getBinding(specifier.local.name);
                      binding && !importsToRemove.has(binding.path) && (isImportTypeOnly({
                        binding,
                        programPath: path,
                        pragmaImportName,
                        pragmaFragImportName
                      }) ? importsToRemove.add(binding.path) : NEEDS_EXPLICIT_ESM.set(path.node, !1));
                    }
                  }
                  if (isAllSpecifiersElided() && !onlyRemoveTypeImports)
                    stmt.remove();
                  else
                    for (let importPath of importsToRemove)
                      importPath.remove();
                  continue;
                }
                if (!onlyRemoveTypeImports && stmt.isTSImportEqualsDeclaration()) {
                  let {
                    id
                  } = stmt.node, binding = stmt.scope.getBinding(id.name);
                  if (binding && !stmt.node.isExport && isImportTypeOnly({
                    binding,
                    programPath: path,
                    pragmaImportName,
                    pragmaFragImportName
                  })) {
                    stmt.remove();
                    continue;
                  }
                }
                if (stmt.isExportDeclaration() && (stmt = stmt.get("declaration")), stmt.isVariableDeclaration({
                  declare: !0
                }))
                  for (let name of Object.keys(stmt.getBindingIdentifiers()))
                    (0, _globalTypes.registerGlobalType)(programScope, name);
                else (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
                  declare: !0
                }) || stmt.isTSEnumDeclaration({
                  declare: !0
                }) || stmt.isTSModuleDeclaration({
                  declare: !0
                }) && stmt.get("id").isIdentifier()) && (0, _globalTypes.registerGlobalType)(programScope, stmt.node.id.name);
              }
            },
            exit(path) {
              path.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path.node) && path.pushContainer("body", t.exportNamedDeclaration());
            }
          },
          ExportNamedDeclaration(path, state) {
            if (NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, !0), path.node.exportKind === "type") {
              path.remove();
              return;
            }
            if (path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every((specifier) => specifier.type === "ExportSpecifier" && specifier.exportKind === "type")) {
              path.remove();
              return;
            }
            if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every((specifier) => t.isExportSpecifier(specifier) && (0, _globalTypes.isGlobalType)(path, specifier.local.name))) {
              path.remove();
              return;
            }
            if (t.isTSModuleDeclaration(path.node.declaration)) {
              let namespace = path.node.declaration;
              if (!t.isStringLiteral(namespace.id)) {
                let id = (0, _namespace.getFirstIdentifier)(namespace.id);
                if (path.scope.hasOwnBinding(id.name))
                  path.replaceWith(namespace);
                else {
                  let [newExport] = path.replaceWithMultiple([t.exportNamedDeclaration(t.variableDeclaration("let", [t.variableDeclarator(t.cloneNode(id))])), namespace]);
                  path.scope.registerDeclaration(newExport);
                }
              }
            }
            NEEDS_EXPLICIT_ESM.set(state.file.ast.program, !1);
          },
          ExportAllDeclaration(path) {
            path.node.exportKind === "type" && path.remove();
          },
          ExportSpecifier(path) {
            (!path.parent.source && (0, _globalTypes.isGlobalType)(path, path.node.local.name) || path.node.exportKind === "type") && path.remove();
          },
          ExportDefaultDeclaration(path, state) {
            if (NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, !0), t.isIdentifier(path.node.declaration) && (0, _globalTypes.isGlobalType)(path, path.node.declaration.name)) {
              path.remove();
              return;
            }
            NEEDS_EXPLICIT_ESM.set(state.file.ast.program, !1);
          },
          TSDeclareFunction(path) {
            safeRemove(path);
          },
          TSDeclareMethod(path) {
            safeRemove(path);
          },
          VariableDeclaration(path) {
            path.node.declare && safeRemove(path);
          },
          VariableDeclarator({
            node
          }) {
            node.definite && (node.definite = null);
          },
          TSIndexSignature(path) {
            path.remove();
          },
          ClassDeclaration(path) {
            let {
              node
            } = path;
            node.declare && safeRemove(path);
          },
          Class(path) {
            let {
              node
            } = path;
            node.typeParameters && (node.typeParameters = null), node.superTypeParameters && (node.superTypeParameters = null), node.implements && (node.implements = null), node.abstract && (node.abstract = null), path.get("body.body").forEach((child) => {
              child.isClassMethod() || child.isClassPrivateMethod() ? child.node.kind === "constructor" ? classMemberVisitors.constructor(child, path) : classMemberVisitors.method(child) : (child.isClassProperty() || child.isClassPrivateProperty() || child.isClassAccessorProperty()) && classMemberVisitors.field(child);
            });
          },
          Function(path) {
            let {
              node
            } = path;
            node.typeParameters && (node.typeParameters = null), node.returnType && (node.returnType = null);
            let params = node.params;
            params.length > 0 && t.isIdentifier(params[0], {
              name: "this"
            }) && params.shift();
          },
          TSModuleDeclaration(path) {
            (0, _namespace.default)(path, allowNamespaces);
          },
          TSInterfaceDeclaration(path) {
            path.remove();
          },
          TSTypeAliasDeclaration(path) {
            path.remove();
          },
          TSEnumDeclaration(path) {
            optimizeConstEnums && path.node.const ? (0, _constEnum.default)(path, t) : (0, _enum.default)(path, t);
          },
          TSImportEqualsDeclaration(path, pass) {
            let {
              id,
              moduleReference
            } = path.node, init, varKind;
            t.isTSExternalModuleReference(moduleReference) ? (assertCjsTransformEnabled(path, pass, `import ${id.name} = require(...);`, `import ${id.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option"), init = t.callExpression(t.identifier("require"), [moduleReference.expression]), varKind = "const") : (init = entityNameToExpr(moduleReference), varKind = "var");
            let newNode = t.variableDeclaration(varKind, [t.variableDeclarator(id, init)]);
            path.replaceWith(path.node.isExport ? t.exportNamedDeclaration(newNode) : newNode), path.scope.registerDeclaration(path);
          },
          TSExportAssignment(path, pass) {
            assertCjsTransformEnabled(path, pass, "export = <value>;", "export default <value>;"), path.replaceWith(template.statement.ast`module.exports = ${path.node.expression}`);
          },
          TSTypeAssertion(path) {
            path.replaceWith(path.node.expression);
          },
          [`TSAsExpression${t.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`](path) {
            let {
              node
            } = path;
            do
              node = node.expression;
            while (t.isTSAsExpression(node) || t.isTSSatisfiesExpression != null && t.isTSSatisfiesExpression(node));
            path.replaceWith(node);
          },
          [api.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](path) {
            path.replaceWith(path.node.expression);
          },
          CallExpression(path) {
            path.node.typeParameters = null;
          },
          OptionalCallExpression(path) {
            path.node.typeParameters = null;
          },
          NewExpression(path) {
            path.node.typeParameters = null;
          },
          JSXOpeningElement(path) {
            path.node.typeParameters = null;
          },
          TaggedTemplateExpression(path) {
            path.node.typeParameters = null;
          }
        }
      };
      function entityNameToExpr(node) {
        return t.isTSQualifiedName(node) ? t.memberExpression(entityNameToExpr(node.left), node.right) : node;
      }
      function visitPattern({
        node
      }) {
        node.typeAnnotation && (node.typeAnnotation = null), t.isIdentifier(node) && node.optional && (node.optional = null);
      }
      function isImportTypeOnly({
        binding,
        programPath,
        pragmaImportName,
        pragmaFragImportName
      }) {
        for (let path of binding.referencePaths)
          if (!isInType(path))
            return !1;
        if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName)
          return !0;
        let sourceFileHasJsx = !1;
        return programPath.traverse({
          "JSXElement|JSXFragment"(path) {
            sourceFileHasJsx = !0, path.stop();
          }
        }), !sourceFileHasJsx;
      }
    });
  }
});

// ../node_modules/@babel/plugin-syntax-jsx/lib/index.js
var require_lib24 = __commonJS({
  "../node_modules/@babel/plugin-syntax-jsx/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _helperPluginUtils = require_lib15(), _default = exports.default = (0, _helperPluginUtils.declare)((api) => (api.assertVersion(7), {
      name: "syntax-jsx",
      manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.some((p) => (Array.isArray(p) ? p[0] : p) === "typescript") || parserOpts.plugins.push("jsx");
      }
    }));
  }
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js
var require_dynamic_import2 = __commonJS({
  "../node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.transformDynamicImport = transformDynamicImport;
    var _core = require_lib27(), _helperModuleTransforms = require_lib12(), requireNoInterop = (source) => _core.template.expression.ast`require(${source})`, requireInterop = (source, file) => _core.types.callExpression(file.addHelper("interopRequireWildcard"), [requireNoInterop(source)]);
    function transformDynamicImport(path, noInterop, file) {
      let buildRequire = noInterop ? requireNoInterop : requireInterop;
      path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, !0, !1, (specifier) => buildRequire(specifier, file)));
    }
  }
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js
var require_lazy = __commonJS({
  "../node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.lazyImportsHook = void 0;
    var _core = require_lib27(), _helperModuleTransforms = require_lib12(), lazyImportsHook = (lazy) => ({
      name: "@babel/plugin-transform-modules-commonjs/lazy",
      version: "7.27.1",
      getWrapperPayload(source, metadata) {
        if ((0, _helperModuleTransforms.isSideEffectImport)(metadata) || metadata.reexportAll)
          return null;
        if (lazy === !0)
          return source.includes(".") ? null : "lazy/function";
        if (Array.isArray(lazy))
          return lazy.includes(source) ? "lazy/function" : null;
        if (typeof lazy == "function")
          return lazy(source) ? "lazy/function" : null;
      },
      buildRequireWrapper(name, init, payload, referenced) {
        if (payload === "lazy/function")
          return referenced ? _core.template.statement.ast`
        function ${name}() {
          const data = ${init};
          ${name} = function(){ return data; };
          return data;
        }
      ` : !1;
      },
      wrapReference(ref, payload) {
        if (payload === "lazy/function") return _core.types.callExpression(ref, []);
      }
    });
    exports.lazyImportsHook = lazyImportsHook;
  }
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js
var require_hooks = __commonJS({
  "../node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.defineCommonJSHook = defineCommonJSHook;
    exports.makeInvokers = makeInvokers;
    var commonJSHooksKey = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
    function defineCommonJSHook(file, hook) {
      let hooks = file.get(commonJSHooksKey);
      hooks || file.set(commonJSHooksKey, hooks = []), hooks.push(hook);
    }
    function findMap(arr, cb) {
      if (arr)
        for (let el of arr) {
          let res = cb(el);
          if (res != null) return res;
        }
    }
    function makeInvokers(file) {
      let hooks = file.get(commonJSHooksKey);
      return {
        getWrapperPayload(...args) {
          return findMap(hooks, (hook) => hook.getWrapperPayload == null ? void 0 : hook.getWrapperPayload(...args));
        },
        wrapReference(...args) {
          return findMap(hooks, (hook) => hook.wrapReference == null ? void 0 : hook.wrapReference(...args));
        },
        buildRequireWrapper(...args) {
          return findMap(hooks, (hook) => hook.buildRequireWrapper == null ? void 0 : hook.buildRequireWrapper(...args));
        }
      };
    }
  }
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js
var require_lib25 = __commonJS({
  "../node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    Object.defineProperty(exports, "defineCommonJSHook", {
      enumerable: !0,
      get: function() {
        return _hooks.defineCommonJSHook;
      }
    });
    var _helperPluginUtils = require_lib15(), _helperModuleTransforms = require_lib12(), _core = require_lib27(), _dynamicImport = require_dynamic_import2(), _lazy = require_lazy(), _hooks = require_hooks(), _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
      var _api$assumption, _api$assumption2, _api$assumption3;
      api.assertVersion(7);
      let {
        strictNamespace = !1,
        mjsStrictNamespace = strictNamespace,
        allowTopLevelThis,
        strict,
        strictMode,
        noInterop,
        importInterop,
        lazy = !1,
        allowCommonJSExports = !0,
        loose = !1
      } = options, constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : loose, enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : loose, noIncompleteNsImportDetection = (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) != null ? _api$assumption3 : !1;
      if (typeof lazy != "boolean" && typeof lazy != "function" && (!Array.isArray(lazy) || !lazy.every((item) => typeof item == "string")))
        throw new Error(".lazy must be a boolean, array of strings, or a function");
      if (typeof strictNamespace != "boolean")
        throw new Error(".strictNamespace must be a boolean, or undefined");
      if (typeof mjsStrictNamespace != "boolean")
        throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
      let getAssertion = (localName) => _core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, moduleExportsVisitor = {
        ReferencedIdentifier(path) {
          let localName = path.node.name;
          if (localName !== "module" && localName !== "exports") return;
          let localBinding = path.scope.getBinding(localName);
          this.scope.getBinding(localName) !== localBinding || path.parentPath.isObjectProperty({
            value: path.node
          }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
            left: path.node
          }) || path.isAssignmentExpression({
            left: path.node
          }) || path.replaceWith(getAssertion(localName));
        },
        UpdateExpression(path) {
          let arg = path.get("argument");
          if (!arg.isIdentifier()) return;
          let localName = arg.node.name;
          if (localName !== "module" && localName !== "exports") return;
          let localBinding = path.scope.getBinding(localName);
          this.scope.getBinding(localName) === localBinding && path.replaceWith(_core.types.assignmentExpression(path.node.operator[0] + "=", arg.node, getAssertion(localName)));
        },
        AssignmentExpression(path) {
          let left = path.get("left");
          if (left.isIdentifier()) {
            let localName = left.node.name;
            if (localName !== "module" && localName !== "exports") return;
            let localBinding = path.scope.getBinding(localName);
            if (this.scope.getBinding(localName) !== localBinding) return;
            let right = path.get("right");
            right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
          } else if (left.isPattern()) {
            let ids = left.getOuterBindingIdentifiers(), localName = Object.keys(ids).find((localName2) => localName2 !== "module" && localName2 !== "exports" ? !1 : this.scope.getBinding(localName2) === path.scope.getBinding(localName2));
            if (localName) {
              let right = path.get("right");
              right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
            }
          }
        }
      };
      return {
        name: "transform-modules-commonjs",
        pre() {
          this.file.set("@babel/plugin-transform-modules-*", "commonjs"), lazy && (0, _hooks.defineCommonJSHook)(this.file, (0, _lazy.lazyImportsHook)(lazy));
        },
        visitor: {
          ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")](path) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import") || path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;
            let {
              scope
            } = path;
            do
              scope.rename("require");
            while (scope = scope.parent);
            (0, _dynamicImport.transformDynamicImport)(path, noInterop, this.file);
          },
          Program: {
            exit(path, state) {
              if (!(0, _helperModuleTransforms.isModule)(path)) return;
              path.scope.rename("exports"), path.scope.rename("module"), path.scope.rename("require"), path.scope.rename("__filename"), path.scope.rename("__dirname"), allowCommonJSExports || path.traverse(moduleExportsVisitor, {
                scope: path.scope
              });
              let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
              moduleName && (moduleName = _core.types.stringLiteral(moduleName));
              let hooks = (0, _hooks.makeInvokers)(this.file), {
                meta,
                headers
              } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
                exportName: "exports",
                constantReexports,
                enumerableModuleMeta,
                strict,
                strictMode,
                allowTopLevelThis,
                noInterop,
                importInterop,
                wrapReference: hooks.wrapReference,
                getWrapperPayload: hooks.getWrapperPayload,
                esNamespaceOnly: typeof state.filename == "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace,
                noIncompleteNsImportDetection,
                filename: this.file.opts.filename
              });
              for (let [source, metadata] of meta.source) {
                let loadExpr = _core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]), header;
                if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                  if (lazy && metadata.wrap === "function")
                    throw new Error("Assertion failure");
                  header = _core.types.expressionStatement(loadExpr);
                } else {
                  let init = (0, _helperModuleTransforms.wrapInterop)(path, loadExpr, metadata.interop) || loadExpr;
                  if (metadata.wrap) {
                    let res = hooks.buildRequireWrapper(metadata.name, init, metadata.wrap, metadata.referenced);
                    if (res === !1) continue;
                    header = res;
                  }
                  header ?? (header = _core.template.statement.ast`
                var ${metadata.name} = ${init};
              `);
                }
                header.loc = metadata.loc, headers.push(header), headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports, hooks.wrapReference));
              }
              (0, _helperModuleTransforms.ensureStatementsHoisted)(headers), path.unshiftContainer("body", headers), path.get("body").forEach((path2) => {
                headers.includes(path2.node) && path2.isVariableDeclaration() && path2.scope.registerDeclaration(path2);
              });
            }
          }
        }
      };
    });
  }
});

// ../node_modules/@babel/preset-typescript/lib/index.js
var require_lib26 = __commonJS({
  "../node_modules/@babel/preset-typescript/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var helperPluginUtils = require_lib15(), transformTypeScript = require_lib23();
    require_lib24();
    var transformModulesCommonJS = require_lib25(), helperValidatorOption = require_lib13();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var transformTypeScript__default = _interopDefault(transformTypeScript), transformModulesCommonJS__default = _interopDefault(transformModulesCommonJS), v = new helperValidatorOption.OptionValidator("@babel/preset-typescript");
    function normalizeOptions(options = {}) {
      let {
        allowNamespaces = !0,
        jsxPragma,
        onlyRemoveTypeImports
      } = options, TopLevelOptions = {
        ignoreExtensions: "ignoreExtensions",
        allowNamespaces: "allowNamespaces",
        disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
        jsxPragma: "jsxPragma",
        jsxPragmaFrag: "jsxPragmaFrag",
        onlyRemoveTypeImports: "onlyRemoveTypeImports",
        optimizeConstEnums: "optimizeConstEnums",
        rewriteImportExtensions: "rewriteImportExtensions",
        allExtensions: "allExtensions",
        isTSX: "isTSX"
      }, jsxPragmaFrag = v.validateStringOption(TopLevelOptions.jsxPragmaFrag, options.jsxPragmaFrag, "React.Fragment");
      {
        var allExtensions = v.validateBooleanOption(TopLevelOptions.allExtensions, options.allExtensions, !1), isTSX = v.validateBooleanOption(TopLevelOptions.isTSX, options.isTSX, !1);
        isTSX && v.invariant(allExtensions, "isTSX:true requires allExtensions:true");
      }
      let ignoreExtensions = v.validateBooleanOption(TopLevelOptions.ignoreExtensions, options.ignoreExtensions, !1), disallowAmbiguousJSXLike = v.validateBooleanOption(TopLevelOptions.disallowAmbiguousJSXLike, options.disallowAmbiguousJSXLike, !1);
      disallowAmbiguousJSXLike && v.invariant(allExtensions, "disallowAmbiguousJSXLike:true requires allExtensions:true");
      let optimizeConstEnums = v.validateBooleanOption(TopLevelOptions.optimizeConstEnums, options.optimizeConstEnums, !1), rewriteImportExtensions = v.validateBooleanOption(TopLevelOptions.rewriteImportExtensions, options.rewriteImportExtensions, !1), normalized = {
        ignoreExtensions,
        allowNamespaces,
        disallowAmbiguousJSXLike,
        jsxPragma,
        jsxPragmaFrag,
        onlyRemoveTypeImports,
        optimizeConstEnums,
        rewriteImportExtensions
      };
      return normalized.allExtensions = allExtensions, normalized.isTSX = isTSX, normalized;
    }
    var pluginRewriteTSImports = helperPluginUtils.declare(function({
      types: t,
      template
    }) {
      function maybeReplace(source, path, state) {
        if (source) {
          if (t.isStringLiteral(source)) {
            /^\.\.?\//.test(source.value) && (source.value = source.value.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
              return tsx ? ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
            }));
            return;
          }
          state.availableHelper("tsRewriteRelativeImportExtensions") ? path.replaceWith(t.callExpression(state.addHelper("tsRewriteRelativeImportExtensions"), [source])) : path.replaceWith(template.expression.ast`(${source} + "").replace(/([\\/].*\.[mc]?)tsx?$/, "$1js")`);
        }
      }
      return {
        name: "preset-typescript/plugin-rewrite-ts-imports",
        visitor: {
          "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"(path, state) {
            let node = path.node;
            (t.isImportDeclaration(node) ? node.importKind : node.exportKind) === "value" && maybeReplace(node.source, path.get("source"), state);
          },
          CallExpression(path, state) {
            t.isImport(path.node.callee) && maybeReplace(path.node.arguments[0], path.get("arguments.0"), state);
          },
          ImportExpression(path, state) {
            maybeReplace(path.node.source, path.get("source"), state);
          }
        }
      };
    }), index = helperPluginUtils.declarePreset((api, opts) => {
      api.assertVersion(7);
      let {
        allExtensions,
        ignoreExtensions,
        allowNamespaces,
        disallowAmbiguousJSXLike,
        isTSX,
        jsxPragma,
        jsxPragmaFrag,
        onlyRemoveTypeImports,
        optimizeConstEnums,
        rewriteImportExtensions
      } = normalizeOptions(opts), pluginOptions = (disallowAmbiguousJSXLike2) => ({
        allowDeclareFields: opts.allowDeclareFields,
        allowNamespaces,
        disallowAmbiguousJSXLike: disallowAmbiguousJSXLike2,
        jsxPragma,
        jsxPragmaFrag,
        onlyRemoveTypeImports,
        optimizeConstEnums
      }), getPlugins = (isTSX2, disallowAmbiguousJSXLike2) => [[transformTypeScript__default.default, Object.assign({
        isTSX: isTSX2
      }, pluginOptions(disallowAmbiguousJSXLike2))]];
      return {
        plugins: rewriteImportExtensions ? [pluginRewriteTSImports] : [],
        overrides: allExtensions || ignoreExtensions ? [{
          plugins: getPlugins(isTSX, disallowAmbiguousJSXLike)
        }] : [{
          test: /\.ts$/,
          plugins: getPlugins(!1, !1)
        }, {
          test: /\.mts$/,
          sourceType: "module",
          plugins: getPlugins(!1, !0)
        }, {
          test: /\.cts$/,
          sourceType: "unambiguous",
          plugins: [[transformModulesCommonJS__default.default, {
            allowTopLevelThis: !0
          }], [transformTypeScript__default.default, pluginOptions(!0)]]
        }, {
          test: /\.tsx$/,
          plugins: getPlugins(!0, !1)
        }]
      };
    });
    exports.default = index;
  }
});

// ../node_modules/@babel/core/lib/config/files/module-types.js
var require_module_types = __commonJS({
  "../node_modules/@babel/core/lib/config/files/module-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = loadCodeDefault;
    exports.supportsESM = void 0;
    var _async = require_async();
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    function _url() {
      let data = __require("url");
      return _url = function() {
        return data;
      }, data;
    }
    __require("module");
    function _semver() {
      let data = __require("semver");
      return _semver = function() {
        return data;
      }, data;
    }
    function _debug() {
      let data = require_src();
      return _debug = function() {
        return data;
      }, data;
    }
    var _rewriteStackTrace = require_rewrite_stack_trace(), _configError = require_config_error(), _transformFile = require_transform_file();
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var debug = _debug()("babel:config:loading:files:module-types");
    try {
      import_ = require_import();
    } catch {
    }
    var import_, supportsESM = exports.supportsESM = _semver().satisfies(process.versions.node, "^12.17 || >=13.2"), LOADING_CJS_FILES = /* @__PURE__ */ new Set();
    function loadCjsDefault(filepath) {
      if (LOADING_CJS_FILES.has(filepath))
        return debug("Auto-ignoring usage of config %o.", filepath), {};
      let module2;
      try {
        LOADING_CJS_FILES.add(filepath), module2 = (0, _rewriteStackTrace.endHiddenCallStack)(__require)(filepath);
      } finally {
        LOADING_CJS_FILES.delete(filepath);
      }
      return module2 != null && (module2.__esModule || module2[Symbol.toStringTag] === "Module") ? module2.default || (arguments[1] ? module2 : void 0) : module2;
    }
    var loadMjsFromPath = (0, _rewriteStackTrace.endHiddenCallStack)((function() {
      var _loadMjsFromPath = _asyncToGenerator(function* (filepath) {
        let url = (0, _url().pathToFileURL)(filepath).toString() + "?import";
        {
          if (!import_)
            throw new _configError.default(`Internal error: Native ECMAScript modules aren't supported by this platform.
`, filepath);
          return yield import_(url);
        }
      });
      function loadMjsFromPath2(_x) {
        return _loadMjsFromPath.apply(this, arguments);
      }
      return loadMjsFromPath2;
    })()), tsNotSupportedError = (ext) => `You are using a ${ext} config file, but Babel only supports transpiling .cts configs. Either:
- Use a .cts config file
- Update to Node.js 23.6.0, which has native TypeScript support
- Install tsx to transpile ${ext} files on the fly`, SUPPORTED_EXTENSIONS = {
      ".js": "unknown",
      ".mjs": "esm",
      ".cjs": "cjs",
      ".ts": "unknown",
      ".mts": "esm",
      ".cts": "cjs"
    }, asyncModules = /* @__PURE__ */ new Set();
    function* loadCodeDefault(filepath, loader, esmError, tlaError) {
      let async, ext = _path().extname(filepath), isTS = ext === ".ts" || ext === ".cts" || ext === ".mts", type = SUPPORTED_EXTENSIONS[hasOwnProperty.call(SUPPORTED_EXTENSIONS, ext) ? ext : ".js"];
      switch (`${loader} ${type}`) {
        case "require cjs":
        case "auto cjs":
          return isTS ? ensureTsSupport(filepath, ext, () => loadCjsDefault(filepath)) : loadCjsDefault(filepath, arguments[2]);
        case "auto unknown":
        case "require unknown":
        case "require esm":
          try {
            return isTS ? ensureTsSupport(filepath, ext, () => loadCjsDefault(filepath)) : loadCjsDefault(filepath, arguments[2]);
          } catch (e) {
            if (e.code === "ERR_REQUIRE_ASYNC_MODULE" || e.code === "ERR_REQUIRE_CYCLE_MODULE" && asyncModules.has(filepath)) {
              if (asyncModules.add(filepath), !(async ?? (async = yield* (0, _async.isAsync)())))
                throw new _configError.default(tlaError, filepath);
            } else if (!(e.code === "ERR_REQUIRE_ESM" || type === "esm"))
              throw e;
          }
        case "auto esm":
          if (async ?? (async = yield* (0, _async.isAsync)())) {
            let promise = isTS ? ensureTsSupport(filepath, ext, () => loadMjsFromPath(filepath)) : loadMjsFromPath(filepath);
            return (yield* (0, _async.waitFor)(promise)).default;
          }
          throw isTS ? new _configError.default(tsNotSupportedError(ext), filepath) : new _configError.default(esmError, filepath);
        default:
          throw new Error("Internal Babel error: unreachable code.");
      }
    }
    function ensureTsSupport(filepath, ext, callback) {
      if (process.features.typescript || __require.extensions[".ts"] || __require.extensions[".cts"] || __require.extensions[".mts"])
        return callback();
      if (ext !== ".cts")
        throw new _configError.default(tsNotSupportedError(ext), filepath);
      let opts = {
        babelrc: !1,
        configFile: !1,
        sourceType: "unambiguous",
        sourceMaps: "inline",
        sourceFileName: _path().basename(filepath),
        presets: [[getTSPreset(filepath), Object.assign({
          onlyRemoveTypeImports: !0,
          optimizeConstEnums: !0
        }, {
          allowDeclareFields: !0
        })]]
      }, handler = function(m, filename) {
        if (handler && filename.endsWith(".cts"))
          try {
            return m._compile((0, _transformFile.transformFileSync)(filename, Object.assign({}, opts, {
              filename
            })).code, filename);
          } catch (error) {
            let packageJson = require_package2();
            throw _semver().lt(packageJson.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`."), error;
          }
        return __require.extensions[".js"](m, filename);
      };
      __require.extensions[ext] = handler;
      try {
        return callback();
      } finally {
        __require.extensions[ext] === handler && delete __require.extensions[ext], handler = void 0;
      }
    }
    function getTSPreset(filepath) {
      try {
        return require_lib26();
      } catch (error) {
        if (error.code !== "MODULE_NOT_FOUND") throw error;
        let message = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
        throw process.versions.pnp && (message += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new _configError.default(message, filepath);
      }
    }
  }
});

// ../node_modules/@babel/core/lib/config/files/configuration.js
var require_configuration = __commonJS({
  "../node_modules/@babel/core/lib/config/files/configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ROOT_CONFIG_FILENAMES = void 0;
    exports.findConfigUpwards = findConfigUpwards;
    exports.findRelativeConfig = findRelativeConfig;
    exports.findRootConfig = findRootConfig;
    exports.loadConfig = loadConfig;
    exports.resolveShowConfigPath = resolveShowConfigPath;
    function _debug() {
      let data = require_src();
      return _debug = function() {
        return data;
      }, data;
    }
    function _fs() {
      let data = __require("fs");
      return _fs = function() {
        return data;
      }, data;
    }
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    function _json() {
      let data = require_lib();
      return _json = function() {
        return data;
      }, data;
    }
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var _caching = require_caching(), _configApi = require_config_api(), _utils = require_utils2(), _moduleTypes = require_module_types(), _patternToRegex = require_pattern_to_regex(), _configError = require_config_error(), fs = require_fs();
    __require("module");
    var _rewriteStackTrace = require_rewrite_stack_trace(), _async = require_async(), debug = _debug()("babel:config:loading:files:configuration"), ROOT_CONFIG_FILENAMES = exports.ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts", "babel.config.ts", "babel.config.mts"], RELATIVE_CONFIG_FILENAMES = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], BABELIGNORE_FILENAME = ".babelignore", runConfig = (0, _caching.makeWeakCache)(function* (options, cache) {
      return yield* [], {
        options: (0, _rewriteStackTrace.endHiddenCallStack)(options)((0, _configApi.makeConfigAPI)(cache)),
        cacheNeedsConfiguration: !cache.configured()
      };
    });
    function* readConfigCode(filepath, data) {
      if (!_fs().existsSync(filepath)) return null;
      let options = yield* (0, _moduleTypes.default)(filepath, (yield* (0, _async.isAsync)()) ? "auto" : "require", "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously or when using the Node.js `--experimental-require-module` flag.", "You appear to be using a configuration file that contains top-level await, which is only supported when running Babel asynchronously."), cacheNeedsConfiguration = !1;
      if (typeof options == "function" && ({
        options,
        cacheNeedsConfiguration
      } = yield* runConfig(options, data)), !options || typeof options != "object" || Array.isArray(options))
        throw new _configError.default("Configuration should be an exported JavaScript object.", filepath);
      if (typeof options.then == "function")
        throw options.catch == null || options.catch(() => {
        }), new _configError.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.", filepath);
      return cacheNeedsConfiguration && throwConfigError(filepath), buildConfigFileObject(options, filepath);
    }
    var cfboaf = /* @__PURE__ */ new WeakMap();
    function buildConfigFileObject(options, filepath) {
      let configFilesByFilepath = cfboaf.get(options);
      configFilesByFilepath || cfboaf.set(options, configFilesByFilepath = /* @__PURE__ */ new Map());
      let configFile = configFilesByFilepath.get(filepath);
      return configFile || (configFile = {
        filepath,
        dirname: _path().dirname(filepath),
        options
      }, configFilesByFilepath.set(filepath, configFile)), configFile;
    }
    var packageToBabelConfig = (0, _caching.makeWeakCacheSync)((file) => {
      let babel = file.options.babel;
      if (babel === void 0) return null;
      if (typeof babel != "object" || Array.isArray(babel) || babel === null)
        throw new _configError.default(".babel property must be an object", file.filepath);
      return {
        filepath: file.filepath,
        dirname: file.dirname,
        options: babel
      };
    }), readConfigJSON5 = (0, _utils.makeStaticFileCache)((filepath, content) => {
      let options;
      try {
        options = _json().parse(content);
      } catch (err) {
        throw new _configError.default(`Error while parsing config - ${err.message}`, filepath);
      }
      if (!options) throw new _configError.default("No config detected", filepath);
      if (typeof options != "object")
        throw new _configError.default(`Config returned typeof ${typeof options}`, filepath);
      if (Array.isArray(options))
        throw new _configError.default("Expected config object but found array", filepath);
      return delete options.$schema, {
        filepath,
        dirname: _path().dirname(filepath),
        options
      };
    }), readIgnoreConfig = (0, _utils.makeStaticFileCache)((filepath, content) => {
      let ignoreDir = _path().dirname(filepath), ignorePatterns = content.split(`
`).map((line) => line.replace(/#.*$/, "").trim()).filter(Boolean);
      for (let pattern of ignorePatterns)
        if (pattern[0] === "!")
          throw new _configError.default("Negation of file paths is not supported.", filepath);
      return {
        filepath,
        dirname: _path().dirname(filepath),
        ignore: ignorePatterns.map((pattern) => (0, _patternToRegex.default)(pattern, ignoreDir))
      };
    });
    function findConfigUpwards(rootDir) {
      let dirname = rootDir;
      for (; ; ) {
        for (let filename of ROOT_CONFIG_FILENAMES)
          if (_fs().existsSync(_path().join(dirname, filename)))
            return dirname;
        let nextDir = _path().dirname(dirname);
        if (dirname === nextDir) break;
        dirname = nextDir;
      }
      return null;
    }
    function* findRelativeConfig(packageData, envName, caller) {
      let config = null, ignore = null, dirname = _path().dirname(packageData.filepath);
      for (let loc of packageData.directories) {
        if (!config) {
          var _packageData$pkg;
          config = yield* loadOneConfig(RELATIVE_CONFIG_FILENAMES, loc, envName, caller, ((_packageData$pkg = packageData.pkg) == null ? void 0 : _packageData$pkg.dirname) === loc ? packageToBabelConfig(packageData.pkg) : null);
        }
        if (!ignore) {
          let ignoreLoc = _path().join(loc, BABELIGNORE_FILENAME);
          ignore = yield* readIgnoreConfig(ignoreLoc), ignore && debug("Found ignore %o from %o.", ignore.filepath, dirname);
        }
      }
      return {
        config,
        ignore
      };
    }
    function findRootConfig(dirname, envName, caller) {
      return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname, envName, caller);
    }
    function* loadOneConfig(names, dirname, envName, caller, previousConfig = null) {
      let config = (yield* _gensync().all(names.map((filename) => readConfig(_path().join(dirname, filename), envName, caller)))).reduce((previousConfig2, config2) => {
        if (config2 && previousConfig2)
          throw new _configError.default(`Multiple configuration files found. Please remove one:
 - ${_path().basename(previousConfig2.filepath)}
 - ${config2.filepath}
from ${dirname}`);
        return config2 || previousConfig2;
      }, previousConfig);
      return config && debug("Found configuration %o from %o.", config.filepath, dirname), config;
    }
    function* loadConfig(name, dirname, envName, caller) {
      let filepath = (((v, w) => (v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, "8.9") ? __require.resolve : (r, {
        paths: [b]
      }, M = __require("module")) => {
        let f = M._findPath(r, M._nodeModulePaths(b).concat(b));
        if (f) return f;
        throw f = new Error(`Cannot resolve module '${r}'`), f.code = "MODULE_NOT_FOUND", f;
      })(name, {
        paths: [dirname]
      }), conf = yield* readConfig(filepath, envName, caller);
      if (!conf)
        throw new _configError.default("Config file contains no configuration data", filepath);
      return debug("Loaded config %o from %o.", name, dirname), conf;
    }
    function readConfig(filepath, envName, caller) {
      switch (_path().extname(filepath)) {
        case ".js":
        case ".cjs":
        case ".mjs":
        case ".ts":
        case ".cts":
        case ".mts":
          return readConfigCode(filepath, {
            envName,
            caller
          });
        default:
          return readConfigJSON5(filepath);
      }
    }
    function* resolveShowConfigPath(dirname) {
      let targetPath = process.env.BABEL_SHOW_CONFIG_FOR;
      if (targetPath != null) {
        let absolutePath = _path().resolve(dirname, targetPath);
        if (!(yield* fs.stat(absolutePath)).isFile())
          throw new Error(`${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
        return absolutePath;
      }
      return null;
    }
    function throwConfigError(filepath) {
      throw new _configError.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, filepath);
    }
  }
});

// ../node_modules/@babel/core/lib/vendor/import-meta-resolve.js
var require_import_meta_resolve = __commonJS({
  "../node_modules/@babel/core/lib/vendor/import-meta-resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.moduleResolve = moduleResolve;
    exports.resolve = resolve;
    function _assert() {
      let data = __require("assert");
      return _assert = function() {
        return data;
      }, data;
    }
    function _fs() {
      let data = _interopRequireWildcard(__require("fs"), !0);
      return _fs = function() {
        return data;
      }, data;
    }
    function _process() {
      let data = __require("process");
      return _process = function() {
        return data;
      }, data;
    }
    function _url() {
      let data = __require("url");
      return _url = function() {
        return data;
      }, data;
    }
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    function _module() {
      let data = __require("module");
      return _module = function() {
        return data;
      }, data;
    }
    function _v() {
      let data = __require("v8");
      return _v = function() {
        return data;
      }, data;
    }
    function _util() {
      let data = __require("util");
      return _util = function() {
        return data;
      }, data;
    }
    function _interopRequireWildcard(e, t) {
      if (typeof WeakMap == "function") var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
      return (_interopRequireWildcard = function(e2, t2) {
        if (!t2 && e2 && e2.__esModule) return e2;
        var o, i, f = { __proto__: null, default: e2 };
        if (e2 === null || typeof e2 != "object" && typeof e2 != "function") return f;
        if (o = t2 ? n : r) {
          if (o.has(e2)) return o.get(e2);
          o.set(e2, f);
        }
        for (let t3 in e2) t3 !== "default" && {}.hasOwnProperty.call(e2, t3) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, t3)) && (i.get || i.set) ? o(f, t3, i) : f[t3] = e2[t3]);
        return f;
      })(e, t);
    }
    var own$1 = {}.hasOwnProperty, classRegExp = /^([A-Z][a-z\d]*)+$/, kTypes = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), codes = {};
    function formatList(array, type = "and") {
      return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
    }
    var messages = /* @__PURE__ */ new Map(), nodeInternalPrefix = "__node_internal_", userStackTraceLimit;
    codes.ERR_INVALID_ARG_TYPE = createError("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
      _assert()(typeof name == "string", "'name' must be a string"), Array.isArray(expected) || (expected = [expected]);
      let message = "The ";
      if (name.endsWith(" argument"))
        message += `${name} `;
      else {
        let type = name.includes(".") ? "property" : "argument";
        message += `"${name}" ${type} `;
      }
      message += "must be ";
      let types2 = [], instances = [], other = [];
      for (let value2 of expected)
        _assert()(typeof value2 == "string", "All expected entries have to be of type string"), kTypes.has(value2) ? types2.push(value2.toLowerCase()) : classRegExp.exec(value2) === null ? (_assert()(value2 !== "object", 'The value "object" should be written as "Object"'), other.push(value2)) : instances.push(value2);
      if (instances.length > 0) {
        let pos = types2.indexOf("object");
        pos !== -1 && (types2.slice(pos, 1), instances.push("Object"));
      }
      return types2.length > 0 && (message += `${types2.length > 1 ? "one of type" : "of type"} ${formatList(types2, "or")}`, (instances.length > 0 || other.length > 0) && (message += " or ")), instances.length > 0 && (message += `an instance of ${formatList(instances, "or")}`, other.length > 0 && (message += " or ")), other.length > 0 && (other.length > 1 ? message += `one of ${formatList(other, "or")}` : (other[0].toLowerCase() !== other[0] && (message += "an "), message += `${other[0]}`)), message += `. Received ${determineSpecificType(actual)}`, message;
    }, TypeError);
    codes.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", (request, reason, base = void 0) => `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`, TypeError);
    codes.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (path, base, message) => `Invalid package config ${path}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`, Error);
    codes.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", (packagePath, key, target, isImport = !1, base = void 0) => {
      let relatedError = typeof target == "string" && !isImport && target.length > 0 && !target.startsWith("./");
      return key === "." ? (_assert()(isImport === !1), `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`) : `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
    }, Error);
    codes.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", (path, base, exactUrl = !1) => `Cannot find ${exactUrl ? "module" : "package"} '${path}' imported from ${base}`, Error);
    codes.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
    codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (specifier, packagePath, base) => `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`, TypeError);
    codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", (packagePath, subpath, base = void 0) => subpath === "." ? `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}` : `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`, Error);
    codes.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error);
    codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError);
    codes.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", (extension, path) => `Unknown file extension "${extension}" for ${path}`, TypeError);
    codes.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", (name, value2, reason = "is invalid") => {
      let inspected = (0, _util().inspect)(value2);
      return inspected.length > 128 && (inspected = `${inspected.slice(0, 128)}...`), `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
    }, TypeError);
    function createError(sym, value2, constructor) {
      return messages.set(sym, value2), makeNodeErrorWithCode(constructor, sym);
    }
    function makeNodeErrorWithCode(Base, key) {
      return NodeError;
      function NodeError(...parameters) {
        let limit = Error.stackTraceLimit;
        isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = 0);
        let error = new Base();
        isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = limit);
        let message = getMessage(key, parameters, error);
        return Object.defineProperties(error, {
          message: {
            value: message,
            enumerable: !1,
            writable: !0,
            configurable: !0
          },
          toString: {
            value() {
              return `${this.name} [${key}]: ${this.message}`;
            },
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), captureLargerStackTrace(error), error.code = key, error;
      }
    }
    function isErrorStackTraceLimitWritable() {
      try {
        if (_v().startupSnapshot.isBuildingSnapshot())
          return !1;
      } catch {
      }
      let desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
      return desc === void 0 ? Object.isExtensible(Error) : own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
    }
    function hideStackFrames(wrappedFunction) {
      let hidden = nodeInternalPrefix + wrappedFunction.name;
      return Object.defineProperty(wrappedFunction, "name", {
        value: hidden
      }), wrappedFunction;
    }
    var captureLargerStackTrace = hideStackFrames(function(error) {
      let stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
      return stackTraceLimitIsWritable && (userStackTraceLimit = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(error), stackTraceLimitIsWritable && (Error.stackTraceLimit = userStackTraceLimit), error;
    });
    function getMessage(key, parameters, self2) {
      let message = messages.get(key);
      if (_assert()(message !== void 0, "expected `message` to be found"), typeof message == "function")
        return _assert()(message.length <= parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`), Reflect.apply(message, self2, parameters);
      let regex = /%[dfijoOs]/g, expectedLength = 0;
      for (; regex.exec(message) !== null; ) expectedLength++;
      return _assert()(expectedLength === parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`), parameters.length === 0 ? message : (parameters.unshift(message), Reflect.apply(_util().format, null, parameters));
    }
    function determineSpecificType(value2) {
      if (value2 == null)
        return String(value2);
      if (typeof value2 == "function" && value2.name)
        return `function ${value2.name}`;
      if (typeof value2 == "object")
        return value2.constructor && value2.constructor.name ? `an instance of ${value2.constructor.name}` : `${(0, _util().inspect)(value2, {
          depth: -1
        })}`;
      let inspected = (0, _util().inspect)(value2, {
        colors: !1
      });
      return inspected.length > 28 && (inspected = `${inspected.slice(0, 25)}...`), `type ${typeof value2} (${inspected})`;
    }
    var hasOwnProperty$1 = {}.hasOwnProperty, {
      ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1
    } = codes, cache = /* @__PURE__ */ new Map();
    function read(jsonPath, {
      base,
      specifier
    }) {
      let existing = cache.get(jsonPath);
      if (existing)
        return existing;
      let string;
      try {
        string = _fs().default.readFileSync(_path().toNamespacedPath(jsonPath), "utf8");
      } catch (error) {
        let exception = error;
        if (exception.code !== "ENOENT")
          throw exception;
      }
      let result = {
        exists: !1,
        pjsonPath: jsonPath,
        main: void 0,
        name: void 0,
        type: "none",
        exports: void 0,
        imports: void 0
      };
      if (string !== void 0) {
        let parsed;
        try {
          parsed = JSON.parse(string);
        } catch (error_) {
          let cause = error_, error = new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath, (base ? `"${specifier}" from ` : "") + (0, _url().fileURLToPath)(base || specifier), cause.message);
          throw error.cause = cause, error;
        }
        result.exists = !0, hasOwnProperty$1.call(parsed, "name") && typeof parsed.name == "string" && (result.name = parsed.name), hasOwnProperty$1.call(parsed, "main") && typeof parsed.main == "string" && (result.main = parsed.main), hasOwnProperty$1.call(parsed, "exports") && (result.exports = parsed.exports), hasOwnProperty$1.call(parsed, "imports") && (result.imports = parsed.imports), hasOwnProperty$1.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module") && (result.type = parsed.type);
      }
      return cache.set(jsonPath, result), result;
    }
    function getPackageScopeConfig(resolved) {
      let packageJSONUrl = new URL("package.json", resolved);
      for (; !packageJSONUrl.pathname.endsWith("node_modules/package.json"); ) {
        let packageConfig = read((0, _url().fileURLToPath)(packageJSONUrl), {
          specifier: resolved
        });
        if (packageConfig.exists)
          return packageConfig;
        let lastPackageJSONUrl = packageJSONUrl;
        if (packageJSONUrl = new URL("../package.json", packageJSONUrl), packageJSONUrl.pathname === lastPackageJSONUrl.pathname)
          break;
      }
      return {
        pjsonPath: (0, _url().fileURLToPath)(packageJSONUrl),
        exists: !1,
        type: "none"
      };
    }
    function getPackageType(url) {
      return getPackageScopeConfig(url).type;
    }
    var {
      ERR_UNKNOWN_FILE_EXTENSION
    } = codes, hasOwnProperty2 = {}.hasOwnProperty, extensionFormatMap = {
      __proto__: null,
      ".cjs": "commonjs",
      ".js": "module",
      ".json": "json",
      ".mjs": "module"
    };
    function mimeToFormat(mime) {
      return mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime) ? "module" : mime === "application/json" ? "json" : null;
    }
    var protocolHandlers = {
      __proto__: null,
      "data:": getDataProtocolModuleFormat,
      "file:": getFileProtocolModuleFormat,
      "http:": getHttpProtocolModuleFormat,
      "https:": getHttpProtocolModuleFormat,
      "node:"() {
        return "builtin";
      }
    };
    function getDataProtocolModuleFormat(parsed) {
      let {
        1: mime
      } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null, null];
      return mimeToFormat(mime);
    }
    function extname(url) {
      let pathname = url.pathname, index = pathname.length;
      for (; index--; ) {
        let code = pathname.codePointAt(index);
        if (code === 47)
          return "";
        if (code === 46)
          return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
      }
      return "";
    }
    function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
      let value2 = extname(url);
      if (value2 === ".js") {
        let packageType = getPackageType(url);
        return packageType !== "none" ? packageType : "commonjs";
      }
      if (value2 === "") {
        let packageType = getPackageType(url);
        return packageType === "none" || packageType === "commonjs" ? "commonjs" : "module";
      }
      let format = extensionFormatMap[value2];
      if (format) return format;
      if (ignoreErrors)
        return;
      let filepath = (0, _url().fileURLToPath)(url);
      throw new ERR_UNKNOWN_FILE_EXTENSION(value2, filepath);
    }
    function getHttpProtocolModuleFormat() {
    }
    function defaultGetFormatWithoutErrors(url, context) {
      let protocol = url.protocol;
      return hasOwnProperty2.call(protocolHandlers, protocol) && protocolHandlers[protocol](url, context, !0) || null;
    }
    var {
      ERR_INVALID_ARG_VALUE
    } = codes, DEFAULT_CONDITIONS = Object.freeze(["node", "import"]), DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
    function getDefaultConditions() {
      return DEFAULT_CONDITIONS;
    }
    function getDefaultConditionsSet() {
      return DEFAULT_CONDITIONS_SET;
    }
    function getConditionsSet(conditions) {
      if (conditions !== void 0 && conditions !== getDefaultConditions()) {
        if (!Array.isArray(conditions))
          throw new ERR_INVALID_ARG_VALUE("conditions", conditions, "expected an array");
        return new Set(conditions);
      }
      return getDefaultConditionsSet();
    }
    var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace], {
      ERR_NETWORK_IMPORT_DISALLOWED,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_PACKAGE_CONFIG,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_MODULE_NOT_FOUND,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_RESOLVE_REQUEST
    } = codes, own = {}.hasOwnProperty, invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, invalidPackageNameRegEx = /^\.|%|\\/, patternRegEx = /\*/g, encodedSeparatorRegEx = /%2f|%5c/i, emittedPackageWarnings = /* @__PURE__ */ new Set(), doubleSlashRegEx = /[/\\]{2}/;
    function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
      if (_process().noDeprecation)
        return;
      let pjsonPath = (0, _url().fileURLToPath)(packageJsonUrl), double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
      _process().emitWarning(`Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ""}.`, "DeprecationWarning", "DEP0166");
    }
    function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
      if (_process().noDeprecation || defaultGetFormatWithoutErrors(url, {
        parentURL: base.href
      }) !== "module") return;
      let urlPath = (0, _url().fileURLToPath)(url.href), packagePath = (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), basePath = (0, _url().fileURLToPath)(base);
      main ? _path().resolve(packagePath, main) !== urlPath && _process().emitWarning(`Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(packagePath.length)}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : _process().emitWarning(`No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(packagePath.length)}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
    }
    function tryStatSync(path) {
      try {
        return (0, _fs().statSync)(path);
      } catch {
      }
    }
    function fileExists(url) {
      let stats = (0, _fs().statSync)(url, {
        throwIfNoEntry: !1
      }), isFile = stats ? stats.isFile() : void 0;
      return isFile ?? !1;
    }
    function legacyMainResolve(packageJsonUrl, packageConfig, base) {
      let guess;
      if (packageConfig.main !== void 0) {
        if (guess = new (_url()).URL(packageConfig.main, packageJsonUrl), fileExists(guess)) return guess;
        let tries2 = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`], i2 = -1;
        for (; ++i2 < tries2.length && (guess = new (_url()).URL(tries2[i2], packageJsonUrl), !fileExists(guess)); )
          guess = void 0;
        if (guess)
          return emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main), guess;
      }
      let tries = ["./index.js", "./index.json", "./index.node"], i = -1;
      for (; ++i < tries.length && (guess = new (_url()).URL(tries[i], packageJsonUrl), !fileExists(guess)); )
        guess = void 0;
      if (guess)
        return emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main), guess;
      throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), (0, _url().fileURLToPath)(base));
    }
    function finalizeResolution(resolved, base, preserveSymlinks) {
      if (encodedSeparatorRegEx.exec(resolved.pathname) !== null)
        throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(base));
      let filePath;
      try {
        filePath = (0, _url().fileURLToPath)(resolved);
      } catch (error) {
        let cause = error;
        throw Object.defineProperty(cause, "input", {
          value: String(resolved)
        }), Object.defineProperty(cause, "module", {
          value: String(base)
        }), cause;
      }
      let stats = tryStatSync(filePath.endsWith("/") ? filePath.slice(-1) : filePath);
      if (stats && stats.isDirectory()) {
        let error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, _url().fileURLToPath)(base));
        throw error.url = String(resolved), error;
      }
      if (!stats || !stats.isFile()) {
        let error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && (0, _url().fileURLToPath)(base), !0);
        throw error.url = String(resolved), error;
      }
      if (!preserveSymlinks) {
        let real = (0, _fs().realpathSync)(filePath), {
          search,
          hash
        } = resolved;
        resolved = (0, _url().pathToFileURL)(real + (filePath.endsWith(_path().sep) ? "/" : "")), resolved.search = search, resolved.hash = hash;
      }
      return resolved;
    }
    function importNotDefined(specifier, packageJsonUrl, base) {
      return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), (0, _url().fileURLToPath)(base));
    }
    function exportsNotFound(subpath, packageJsonUrl, base) {
      return new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, base && (0, _url().fileURLToPath)(base));
    }
    function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
      let reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${(0, _url().fileURLToPath)(packageJsonUrl)}`;
      throw new ERR_INVALID_MODULE_SPECIFIER(request, reason, base && (0, _url().fileURLToPath)(base));
    }
    function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
      return target = typeof target == "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`, new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, target, internal, base && (0, _url().fileURLToPath)(base));
    }
    function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
      if (subpath !== "" && !pattern && target[target.length - 1] !== "/") throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
      if (!target.startsWith("./")) {
        if (internal && !target.startsWith("../") && !target.startsWith("/")) {
          let isURL2 = !1;
          try {
            new (_url()).URL(target), isURL2 = !0;
          } catch {
          }
          if (!isURL2) {
            let exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target + subpath;
            return packageResolve(exportTarget, packageJsonUrl, conditions);
          }
        }
        throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
      }
      if (invalidSegmentRegEx.exec(target.slice(2)) !== null)
        if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
          if (!isPathMap) {
            let request = pattern ? match.replace("*", () => subpath) : match + subpath, resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target;
            emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, !0);
          }
        } else
          throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
      let resolved = new (_url()).URL(target, packageJsonUrl), resolvedPath = resolved.pathname, packagePath = new (_url()).URL(".", packageJsonUrl).pathname;
      if (!resolvedPath.startsWith(packagePath)) throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
      if (subpath === "") return resolved;
      if (invalidSegmentRegEx.exec(subpath) !== null) {
        let request = pattern ? match.replace("*", () => subpath) : match + subpath;
        if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
          if (!isPathMap) {
            let resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target;
            emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, !1);
          }
        } else
          throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
      }
      return pattern ? new (_url()).URL(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () => subpath)) : new (_url()).URL(subpath, resolved);
    }
    function isArrayIndex(key) {
      let keyNumber = Number(key);
      return `${keyNumber}` !== key ? !1 : keyNumber >= 0 && keyNumber < 4294967295;
    }
    function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
      if (typeof target == "string")
        return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);
      if (Array.isArray(target)) {
        let targetList = target;
        if (targetList.length === 0) return null;
        let lastException, i = -1;
        for (; ++i < targetList.length; ) {
          let targetItem = targetList[i], resolveResult;
          try {
            resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
          } catch (error) {
            let exception = error;
            if (lastException = exception, exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
            throw error;
          }
          if (resolveResult !== void 0) {
            if (resolveResult === null) {
              lastException = null;
              continue;
            }
            return resolveResult;
          }
        }
        if (lastException == null)
          return null;
        throw lastException;
      }
      if (typeof target == "object" && target !== null) {
        let keys = Object.getOwnPropertyNames(target), i = -1;
        for (; ++i < keys.length; ) {
          let key = keys[i];
          if (isArrayIndex(key))
            throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
        }
        for (i = -1; ++i < keys.length; ) {
          let key = keys[i];
          if (key === "default" || conditions && conditions.has(key)) {
            let conditionalTarget = target[key], resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
            if (resolveResult === void 0) continue;
            return resolveResult;
          }
        }
        return null;
      }
      if (target === null)
        return null;
      throw invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
    }
    function isConditionalExportsMainSugar(exports2, packageJsonUrl, base) {
      if (typeof exports2 == "string" || Array.isArray(exports2)) return !0;
      if (typeof exports2 != "object" || exports2 === null) return !1;
      let keys = Object.getOwnPropertyNames(exports2), isConditionalSugar = !1, i = 0, keyIndex = -1;
      for (; ++keyIndex < keys.length; ) {
        let key = keys[keyIndex], currentIsConditionalSugar = key === "" || key[0] !== ".";
        if (i++ === 0)
          isConditionalSugar = currentIsConditionalSugar;
        else if (isConditionalSugar !== currentIsConditionalSugar)
          throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
      }
      return isConditionalSugar;
    }
    function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
      if (_process().noDeprecation)
        return;
      let pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);
      emittedPackageWarnings.has(pjsonPath + "|" + match) || (emittedPackageWarnings.add(pjsonPath + "|" + match), _process().emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
    }
    function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
      let exports2 = packageConfig.exports;
      if (isConditionalExportsMainSugar(exports2, packageJsonUrl, base) && (exports2 = {
        ".": exports2
      }), own.call(exports2, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
        let target = exports2[packageSubpath], resolveResult = resolvePackageTarget(packageJsonUrl, target, "", packageSubpath, base, !1, !1, !1, conditions);
        if (resolveResult == null)
          throw exportsNotFound(packageSubpath, packageJsonUrl, base);
        return resolveResult;
      }
      let bestMatch = "", bestMatchSubpath = "", keys = Object.getOwnPropertyNames(exports2), i = -1;
      for (; ++i < keys.length; ) {
        let key = keys[i], patternIndex = key.indexOf("*");
        if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
          packageSubpath.endsWith("/") && emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
          let patternTrailer = key.slice(patternIndex + 1);
          packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex && (bestMatch = key, bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length));
        }
      }
      if (bestMatch) {
        let target = exports2[bestMatch], resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, !0, !1, packageSubpath.endsWith("/"), conditions);
        if (resolveResult == null)
          throw exportsNotFound(packageSubpath, packageJsonUrl, base);
        return resolveResult;
      }
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    function patternKeyCompare(a, b) {
      let aPatternIndex = a.indexOf("*"), bPatternIndex = b.indexOf("*"), baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1, baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
      return baseLengthA > baseLengthB ? -1 : baseLengthB > baseLengthA || aPatternIndex === -1 ? 1 : bPatternIndex === -1 || a.length > b.length ? -1 : b.length > a.length ? 1 : 0;
    }
    function packageImportsResolve(name, base, conditions) {
      if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
        let reason = "is not a valid internal imports specifier name";
        throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, _url().fileURLToPath)(base));
      }
      let packageJsonUrl, packageConfig = getPackageScopeConfig(base);
      if (packageConfig.exists) {
        packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
        let imports = packageConfig.imports;
        if (imports)
          if (own.call(imports, name) && !name.includes("*")) {
            let resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], "", name, base, !1, !0, !1, conditions);
            if (resolveResult != null)
              return resolveResult;
          } else {
            let bestMatch = "", bestMatchSubpath = "", keys = Object.getOwnPropertyNames(imports), i = -1;
            for (; ++i < keys.length; ) {
              let key = keys[i], patternIndex = key.indexOf("*");
              if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
                let patternTrailer = key.slice(patternIndex + 1);
                name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex && (bestMatch = key, bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length));
              }
            }
            if (bestMatch) {
              let target = imports[bestMatch], resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, !0, !0, !1, conditions);
              if (resolveResult != null)
                return resolveResult;
            }
          }
      }
      throw importNotDefined(name, packageJsonUrl, base);
    }
    function parsePackageName(specifier, base) {
      let separatorIndex = specifier.indexOf("/"), validPackageName = !0, isScoped = !1;
      specifier[0] === "@" && (isScoped = !0, separatorIndex === -1 || specifier.length === 0 ? validPackageName = !1 : separatorIndex = specifier.indexOf("/", separatorIndex + 1));
      let packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
      if (invalidPackageNameRegEx.exec(packageName) !== null && (validPackageName = !1), !validPackageName)
        throw new ERR_INVALID_MODULE_SPECIFIER(specifier, "is not a valid package name", (0, _url().fileURLToPath)(base));
      let packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
      return {
        packageName,
        packageSubpath,
        isScoped
      };
    }
    function packageResolve(specifier, base, conditions) {
      if (_module().builtinModules.includes(specifier))
        return new (_url()).URL("node:" + specifier);
      let {
        packageName,
        packageSubpath,
        isScoped
      } = parsePackageName(specifier, base), packageConfig = getPackageScopeConfig(base);
      if (packageConfig.exists) {
        let packageJsonUrl2 = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
        if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null)
          return packageExportsResolve(packageJsonUrl2, packageSubpath, packageConfig, base, conditions);
      }
      let packageJsonUrl = new (_url()).URL("./node_modules/" + packageName + "/package.json", base), packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl), lastPath;
      do {
        let stat = tryStatSync(packageJsonPath.slice(0, -13));
        if (!stat || !stat.isDirectory()) {
          lastPath = packageJsonPath, packageJsonUrl = new (_url()).URL((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl), packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
          continue;
        }
        let packageConfig2 = read(packageJsonPath, {
          base,
          specifier
        });
        return packageConfig2.exports !== void 0 && packageConfig2.exports !== null ? packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig2, base, conditions) : packageSubpath === "." ? legacyMainResolve(packageJsonUrl, packageConfig2, base) : new (_url()).URL(packageSubpath, packageJsonUrl);
      } while (packageJsonPath.length !== lastPath.length);
      throw new ERR_MODULE_NOT_FOUND(packageName, (0, _url().fileURLToPath)(base), !1);
    }
    function isRelativeSpecifier(specifier) {
      return specifier[0] === "." && (specifier.length === 1 || specifier[1] === "/" || specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/"));
    }
    function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
      return specifier === "" ? !1 : specifier[0] === "/" ? !0 : isRelativeSpecifier(specifier);
    }
    function moduleResolve(specifier, base, conditions, preserveSymlinks) {
      let protocol = base.protocol, isRemote = protocol === "data:" || protocol === "http:" || protocol === "https:", resolved;
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier))
        try {
          resolved = new (_url()).URL(specifier, base);
        } catch (error_) {
          let error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
          throw error.cause = error_, error;
        }
      else if (protocol === "file:" && specifier[0] === "#")
        resolved = packageImportsResolve(specifier, base, conditions);
      else
        try {
          resolved = new (_url()).URL(specifier);
        } catch (error_) {
          if (isRemote && !_module().builtinModules.includes(specifier)) {
            let error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
            throw error.cause = error_, error;
          }
          resolved = packageResolve(specifier, base, conditions);
        }
      return _assert()(resolved !== void 0, "expected to be defined"), resolved.protocol !== "file:" ? resolved : finalizeResolution(resolved, base, preserveSymlinks);
    }
    function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
      if (parsedParentURL) {
        let parentProtocol = parsedParentURL.protocol;
        if (parentProtocol === "http:" || parentProtocol === "https:") {
          if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
            let parsedProtocol = parsed?.protocol;
            if (parsedProtocol && parsedProtocol !== "https:" && parsedProtocol !== "http:")
              throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "remote imports cannot import from a local location.");
            return {
              url: parsed?.href || ""
            };
          }
          throw _module().builtinModules.includes(specifier) ? new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "remote imports cannot import from a local location.") : new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "only relative and absolute specifiers are supported.");
        }
      }
    }
    function isURL(self2) {
      return !!(self2 && typeof self2 == "object" && "href" in self2 && typeof self2.href == "string" && "protocol" in self2 && typeof self2.protocol == "string" && self2.href && self2.protocol);
    }
    function throwIfInvalidParentURL(parentURL) {
      if (parentURL !== void 0 && typeof parentURL != "string" && !isURL(parentURL))
        throw new codes.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], parentURL);
    }
    function defaultResolve(specifier, context = {}) {
      let {
        parentURL
      } = context;
      _assert()(parentURL !== void 0, "expected `parentURL` to be defined"), throwIfInvalidParentURL(parentURL);
      let parsedParentURL;
      if (parentURL)
        try {
          parsedParentURL = new (_url()).URL(parentURL);
        } catch {
        }
      let parsed, protocol;
      try {
        if (parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new (_url()).URL(specifier, parsedParentURL) : new (_url()).URL(specifier), protocol = parsed.protocol, protocol === "data:")
          return {
            url: parsed.href,
            format: null
          };
      } catch {
      }
      let maybeReturn = checkIfDisallowedImport(specifier, parsed, parsedParentURL);
      if (maybeReturn) return maybeReturn;
      if (protocol === void 0 && parsed && (protocol = parsed.protocol), protocol === "node:")
        return {
          url: specifier
        };
      if (parsed && parsed.protocol === "node:") return {
        url: specifier
      };
      let conditions = getConditionsSet(context.conditions), url = moduleResolve(specifier, new (_url()).URL(parentURL), conditions, !1);
      return {
        url: url.href,
        format: defaultGetFormatWithoutErrors(url, {
          parentURL
        })
      };
    }
    function resolve(specifier, parent) {
      if (!parent)
        throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
      try {
        return defaultResolve(specifier, {
          parentURL: parent
        }).url;
      } catch (error) {
        let exception = error;
        if ((exception.code === "ERR_UNSUPPORTED_DIR_IMPORT" || exception.code === "ERR_MODULE_NOT_FOUND") && typeof exception.url == "string")
          return exception.url;
        throw error;
      }
    }
  }
});

// ../node_modules/@babel/core/lib/config/files/plugins.js
var require_plugins4 = __commonJS({
  "../node_modules/@babel/core/lib/config/files/plugins.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.loadPlugin = loadPlugin;
    exports.loadPreset = loadPreset;
    exports.resolvePreset = exports.resolvePlugin = void 0;
    function _debug() {
      let data = require_src();
      return _debug = function() {
        return data;
      }, data;
    }
    function _path() {
      let data = __require("path");
      return _path = function() {
        return data;
      }, data;
    }
    var _async = require_async(), _moduleTypes = require_module_types();
    function _url() {
      let data = __require("url");
      return _url = function() {
        return data;
      }, data;
    }
    var _importMetaResolve = require_import_meta_resolve();
    __require("module");
    function _fs() {
      let data = __require("fs");
      return _fs = function() {
        return data;
      }, data;
    }
    var debug = _debug()("babel:config:loading:files:plugins"), EXACT_RE = /^module:/, BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/, BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/, BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/, BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/, OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/, OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/, resolvePlugin = exports.resolvePlugin = resolveStandardizedName.bind(null, "plugin"), resolvePreset = exports.resolvePreset = resolveStandardizedName.bind(null, "preset");
    function* loadPlugin(name, dirname) {
      let {
        filepath,
        loader
      } = resolvePlugin(name, dirname, yield* (0, _async.isAsync)()), value2 = yield* requireModule("plugin", loader, filepath);
      return debug("Loaded plugin %o from %o.", name, dirname), {
        filepath,
        value: value2
      };
    }
    function* loadPreset(name, dirname) {
      let {
        filepath,
        loader
      } = resolvePreset(name, dirname, yield* (0, _async.isAsync)()), value2 = yield* requireModule("preset", loader, filepath);
      return debug("Loaded preset %o from %o.", name, dirname), {
        filepath,
        value: value2
      };
    }
    function standardizeName(type, name) {
      if (_path().isAbsolute(name)) return name;
      let isPreset = type === "preset";
      return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `$1${type}-`).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`).replace(EXACT_RE, "");
    }
    function* resolveAlternativesHelper(type, name) {
      let standardizedName = standardizeName(type, name), {
        error,
        value: value2
      } = yield standardizedName;
      if (!error) return value2;
      if (error.code !== "MODULE_NOT_FOUND") throw error;
      standardizedName !== name && !(yield name).error && (error.message += `
- If you want to resolve "${name}", use "module:${name}"`), (yield standardizeName(type, "@babel/" + name)).error || (error.message += `
- Did you mean "@babel/${name}"?`);
      let oppositeType = type === "preset" ? "plugin" : "preset";
      if ((yield standardizeName(oppositeType, name)).error || (error.message += `
- Did you accidentally pass a ${oppositeType} as a ${type}?`), type === "plugin") {
        let transformName = standardizedName.replace("-proposal-", "-transform-");
        transformName !== standardizedName && !(yield transformName).error && (error.message += `
- Did you mean "${transformName}"?`);
      }
      throw error.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`, error;
    }
    function tryRequireResolve(id, dirname) {
      try {
        return dirname ? {
          error: null,
          value: (((v, w) => (v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, "8.9") ? __require.resolve : (r, {
            paths: [b]
          }, M = __require("module")) => {
            let f = M._findPath(r, M._nodeModulePaths(b).concat(b));
            if (f) return f;
            throw f = new Error(`Cannot resolve module '${r}'`), f.code = "MODULE_NOT_FOUND", f;
          })(id, {
            paths: [dirname]
          })
        } : {
          error: null,
          value: __require.resolve(id)
        };
      } catch (error) {
        return {
          error,
          value: null
        };
      }
    }
    function tryImportMetaResolve(id, options) {
      try {
        return {
          error: null,
          value: (0, _importMetaResolve.resolve)(id, options)
        };
      } catch (error) {
        return {
          error,
          value: null
        };
      }
    }
    function resolveStandardizedNameForRequire(type, name, dirname) {
      let it = resolveAlternativesHelper(type, name), res = it.next();
      for (; !res.done; )
        res = it.next(tryRequireResolve(res.value, dirname));
      return {
        loader: "require",
        filepath: res.value
      };
    }
    function resolveStandardizedNameForImport(type, name, dirname) {
      let parentUrl = (0, _url().pathToFileURL)(_path().join(dirname, "./babel-virtual-resolve-base.js")).href, it = resolveAlternativesHelper(type, name), res = it.next();
      for (; !res.done; )
        res = it.next(tryImportMetaResolve(res.value, parentUrl));
      return {
        loader: "auto",
        filepath: (0, _url().fileURLToPath)(res.value)
      };
    }
    function resolveStandardizedName(type, name, dirname, allowAsync) {
      if (!_moduleTypes.supportsESM || !allowAsync)
        return resolveStandardizedNameForRequire(type, name, dirname);
      try {
        let resolved = resolveStandardizedNameForImport(type, name, dirname);
        if (!(0, _fs().existsSync)(resolved.filepath))
          throw Object.assign(new Error(`Could not resolve "${name}" in file ${dirname}.`), {
            type: "MODULE_NOT_FOUND"
          });
        return resolved;
      } catch (e) {
        try {
          return resolveStandardizedNameForRequire(type, name, dirname);
        } catch (e2) {
          throw e.type === "MODULE_NOT_FOUND" ? e : e2.type === "MODULE_NOT_FOUND" ? e2 : e;
        }
      }
    }
    LOADING_MODULES = /* @__PURE__ */ new Set();
    var LOADING_MODULES;
    function* requireModule(type, loader, name) {
      if (!(yield* (0, _async.isAsync)()) && LOADING_MODULES.has(name))
        throw new Error(`Reentrant ${type} detected trying to load "${name}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
      try {
        return LOADING_MODULES.add(name), yield* (0, _moduleTypes.default)(name, loader, `You appear to be using a native ECMAScript module ${type}, which is only supported when running Babel asynchronously or when using the Node.js \`--experimental-require-module\` flag.`, `You appear to be using a ${type} that contains top-level await, which is only supported when running Babel asynchronously.`, !0);
      } catch (err) {
        throw err.message = `[BABEL]: ${err.message} (While processing: ${name})`, err;
      } finally {
        LOADING_MODULES.delete(name);
      }
    }
  }
});

// ../node_modules/@babel/core/lib/config/files/index.js
var require_files = __commonJS({
  "../node_modules/@babel/core/lib/config/files/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "ROOT_CONFIG_FILENAMES", {
      enumerable: !0,
      get: function() {
        return _configuration.ROOT_CONFIG_FILENAMES;
      }
    });
    Object.defineProperty(exports, "findConfigUpwards", {
      enumerable: !0,
      get: function() {
        return _configuration.findConfigUpwards;
      }
    });
    Object.defineProperty(exports, "findPackageData", {
      enumerable: !0,
      get: function() {
        return _package.findPackageData;
      }
    });
    Object.defineProperty(exports, "findRelativeConfig", {
      enumerable: !0,
      get: function() {
        return _configuration.findRelativeConfig;
      }
    });
    Object.defineProperty(exports, "findRootConfig", {
      enumerable: !0,
      get: function() {
        return _configuration.findRootConfig;
      }
    });
    Object.defineProperty(exports, "loadConfig", {
      enumerable: !0,
      get: function() {
        return _configuration.loadConfig;
      }
    });
    Object.defineProperty(exports, "loadPlugin", {
      enumerable: !0,
      get: function() {
        return _plugins.loadPlugin;
      }
    });
    Object.defineProperty(exports, "loadPreset", {
      enumerable: !0,
      get: function() {
        return _plugins.loadPreset;
      }
    });
    Object.defineProperty(exports, "resolvePlugin", {
      enumerable: !0,
      get: function() {
        return _plugins.resolvePlugin;
      }
    });
    Object.defineProperty(exports, "resolvePreset", {
      enumerable: !0,
      get: function() {
        return _plugins.resolvePreset;
      }
    });
    Object.defineProperty(exports, "resolveShowConfigPath", {
      enumerable: !0,
      get: function() {
        return _configuration.resolveShowConfigPath;
      }
    });
    var _package = require_package(), _configuration = require_configuration(), _plugins = require_plugins4();
  }
});

// ../node_modules/@babel/core/lib/transform.js
var require_transform = __commonJS({
  "../node_modules/@babel/core/lib/transform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.transform = void 0;
    exports.transformAsync = transformAsync;
    exports.transformSync = transformSync2;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var _index = require_config(), _index2 = require_transformation(), _rewriteStackTrace = require_rewrite_stack_trace(), transformRunner = _gensync()(function* (code, opts) {
      let config = yield* (0, _index.default)(opts);
      return config === null ? null : yield* (0, _index2.run)(config, code);
    }), transform = exports.transform = function(code, optsOrCallback, maybeCallback) {
      let opts, callback;
      if (typeof optsOrCallback == "function" ? (callback = optsOrCallback, opts = void 0) : (opts = optsOrCallback, callback = maybeCallback), callback === void 0)
        return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(code, opts);
      (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.errback)(code, opts, callback);
    };
    function transformSync2(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(...args);
    }
    function transformAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.async)(...args);
    }
  }
});

// ../node_modules/@babel/core/lib/transform-ast.js
var require_transform_ast = __commonJS({
  "../node_modules/@babel/core/lib/transform-ast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.transformFromAst = void 0;
    exports.transformFromAstAsync = transformFromAstAsync;
    exports.transformFromAstSync = transformFromAstSync;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var _index = require_config(), _index2 = require_transformation(), _rewriteStackTrace = require_rewrite_stack_trace(), transformFromAstRunner = _gensync()(function* (ast, code, opts) {
      let config = yield* (0, _index.default)(opts);
      if (config === null) return null;
      if (!ast) throw new Error("No AST given");
      return yield* (0, _index2.run)(config, code, ast);
    }), transformFromAst = exports.transformFromAst = function(ast, code, optsOrCallback, maybeCallback) {
      let opts, callback;
      if (typeof optsOrCallback == "function" ? (callback = optsOrCallback, opts = void 0) : (opts = optsOrCallback, callback = maybeCallback), callback === void 0)
        return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(ast, code, opts);
      (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.errback)(ast, code, opts, callback);
    };
    function transformFromAstSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(...args);
    }
    function transformFromAstAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.async)(...args);
    }
  }
});

// ../node_modules/@babel/core/lib/parse.js
var require_parse3 = __commonJS({
  "../node_modules/@babel/core/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.parse = void 0;
    exports.parseAsync = parseAsync;
    exports.parseSync = parseSync;
    function _gensync() {
      let data = require_gensync();
      return _gensync = function() {
        return data;
      }, data;
    }
    var _index = require_config(), _index2 = require_parser(), _normalizeOpts = require_normalize_opts(), _rewriteStackTrace = require_rewrite_stack_trace(), parseRunner = _gensync()(function* (code, opts) {
      let config = yield* (0, _index.default)(opts);
      return config === null ? null : yield* (0, _index2.default)(config.passes, (0, _normalizeOpts.default)(config), code);
    }), parse3 = exports.parse = function(code, opts, callback) {
      if (typeof opts == "function" && (callback = opts, opts = void 0), callback === void 0)
        return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(code, opts);
      (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.errback)(code, opts, callback);
    };
    function parseSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(...args);
    }
    function parseAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.async)(...args);
    }
  }
});

// ../node_modules/@babel/core/lib/index.js
var require_lib27 = __commonJS({
  "../node_modules/@babel/core/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.DEFAULT_EXTENSIONS = void 0;
    Object.defineProperty(exports, "File", {
      enumerable: !0,
      get: function() {
        return _file.default;
      }
    });
    Object.defineProperty(exports, "buildExternalHelpers", {
      enumerable: !0,
      get: function() {
        return _buildExternalHelpers.default;
      }
    });
    Object.defineProperty(exports, "createConfigItem", {
      enumerable: !0,
      get: function() {
        return _index2.createConfigItem;
      }
    });
    Object.defineProperty(exports, "createConfigItemAsync", {
      enumerable: !0,
      get: function() {
        return _index2.createConfigItemAsync;
      }
    });
    Object.defineProperty(exports, "createConfigItemSync", {
      enumerable: !0,
      get: function() {
        return _index2.createConfigItemSync;
      }
    });
    Object.defineProperty(exports, "getEnv", {
      enumerable: !0,
      get: function() {
        return _environment.getEnv;
      }
    });
    Object.defineProperty(exports, "loadOptions", {
      enumerable: !0,
      get: function() {
        return _index2.loadOptions;
      }
    });
    Object.defineProperty(exports, "loadOptionsAsync", {
      enumerable: !0,
      get: function() {
        return _index2.loadOptionsAsync;
      }
    });
    Object.defineProperty(exports, "loadOptionsSync", {
      enumerable: !0,
      get: function() {
        return _index2.loadOptionsSync;
      }
    });
    Object.defineProperty(exports, "loadPartialConfig", {
      enumerable: !0,
      get: function() {
        return _index2.loadPartialConfig;
      }
    });
    Object.defineProperty(exports, "loadPartialConfigAsync", {
      enumerable: !0,
      get: function() {
        return _index2.loadPartialConfigAsync;
      }
    });
    Object.defineProperty(exports, "loadPartialConfigSync", {
      enumerable: !0,
      get: function() {
        return _index2.loadPartialConfigSync;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: !0,
      get: function() {
        return _parse.parse;
      }
    });
    Object.defineProperty(exports, "parseAsync", {
      enumerable: !0,
      get: function() {
        return _parse.parseAsync;
      }
    });
    Object.defineProperty(exports, "parseSync", {
      enumerable: !0,
      get: function() {
        return _parse.parseSync;
      }
    });
    exports.resolvePreset = exports.resolvePlugin = void 0;
    Object.defineProperty(exports, "template", {
      enumerable: !0,
      get: function() {
        return _template().default;
      }
    });
    Object.defineProperty(exports, "tokTypes", {
      enumerable: !0,
      get: function() {
        return _parser().tokTypes;
      }
    });
    Object.defineProperty(exports, "transform", {
      enumerable: !0,
      get: function() {
        return _transform.transform;
      }
    });
    Object.defineProperty(exports, "transformAsync", {
      enumerable: !0,
      get: function() {
        return _transform.transformAsync;
      }
    });
    Object.defineProperty(exports, "transformFile", {
      enumerable: !0,
      get: function() {
        return _transformFile.transformFile;
      }
    });
    Object.defineProperty(exports, "transformFileAsync", {
      enumerable: !0,
      get: function() {
        return _transformFile.transformFileAsync;
      }
    });
    Object.defineProperty(exports, "transformFileSync", {
      enumerable: !0,
      get: function() {
        return _transformFile.transformFileSync;
      }
    });
    Object.defineProperty(exports, "transformFromAst", {
      enumerable: !0,
      get: function() {
        return _transformAst.transformFromAst;
      }
    });
    Object.defineProperty(exports, "transformFromAstAsync", {
      enumerable: !0,
      get: function() {
        return _transformAst.transformFromAstAsync;
      }
    });
    Object.defineProperty(exports, "transformFromAstSync", {
      enumerable: !0,
      get: function() {
        return _transformAst.transformFromAstSync;
      }
    });
    Object.defineProperty(exports, "transformSync", {
      enumerable: !0,
      get: function() {
        return _transform.transformSync;
      }
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: !0,
      get: function() {
        return _traverse().default;
      }
    });
    exports.version = exports.types = void 0;
    var _file = require_file(), _buildExternalHelpers = require_build_external_helpers(), resolvers = require_files(), _environment = require_environment();
    function _types() {
      let data = require_lib4();
      return _types = function() {
        return data;
      }, data;
    }
    Object.defineProperty(exports, "types", {
      enumerable: !0,
      get: function() {
        return _types();
      }
    });
    function _parser() {
      let data = require_lib5();
      return _parser = function() {
        return data;
      }, data;
    }
    function _traverse() {
      let data = require_lib10();
      return _traverse = function() {
        return data;
      }, data;
    }
    function _template() {
      let data = require_lib7();
      return _template = function() {
        return data;
      }, data;
    }
    var _index2 = require_config(), _transform = require_transform(), _transformFile = require_transform_file(), _transformAst = require_transform_ast(), _parse = require_parse3(), version = exports.version = "7.28.5", resolvePlugin = (name, dirname) => resolvers.resolvePlugin(name, dirname, !1).filepath;
    exports.resolvePlugin = resolvePlugin;
    var resolvePreset = (name, dirname) => resolvers.resolvePreset(name, dirname, !1).filepath;
    exports.resolvePreset = resolvePreset;
    var DEFAULT_EXTENSIONS = exports.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
    exports.OptionManager = class {
      init(opts) {
        return (0, _index2.loadOptionsSync)(opts);
      }
    }, exports.Plugin = function(alias) {
      throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`);
    };
  }
});

// src/babel/index.ts
var import_core = __toESM(require_lib27(), 1), core = __toESM(require_lib27(), 1), import_core2 = __toESM(require_lib27(), 1), import_generator = __toESM(require_lib9(), 1), parser2 = __toESM(require_lib5(), 1), import_traverse = __toESM(require_lib10(), 1), types = __toESM(require_lib4(), 1);
import * as recast2 from "recast";

// src/babel/babelParse.ts
var parser = __toESM(require_lib5(), 1);
import * as recast from "recast";
function parseWithFlowOrTypescript(source, parserOptions2) {
  let parserPlugins = /^\s*\/\/\s*@flow/.test(source) ? ["flow"] : ["typescript"], mergedParserOptions = {
    ...parserOptions2,
    plugins: [...parserOptions2.plugins ?? [], ...parserPlugins]
  };
  return parser.parse(source, mergedParserOptions);
}
var parserOptions = {
  sourceType: "module",
  // FIXME: we should get this from the project config somehow?
  plugins: ["jsx", "decorators-legacy", "classProperties"],
  tokens: !0
}, babelParse = (code) => recast.parse(code, {
  parser: {
    parse(source) {
      return parseWithFlowOrTypescript(source, parserOptions);
    }
  }
}), babelPrint = (ast) => recast.print(ast, {
  quote: "single",
  trailingComma: !0,
  tabWidth: 2,
  wrapColumn: 80,
  arrowParensAlways: !0
}).code, babelParseExpression = (code) => parser.parseExpression(code, parserOptions);

// src/babel/index.ts
var traverse = import_traverse.default.default || import_traverse.default, generate = import_generator.default.default || import_generator.default, BabelFileClass = import_core2.File;

export {
  parserOptions,
  babelParse,
  babelPrint,
  babelParseExpression,
  import_core,
  core,
  parser2 as parser,
  types,
  recast2 as recast,
  traverse,
  generate,
  BabelFileClass
};
